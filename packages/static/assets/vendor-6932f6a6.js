var commonjsGlobal$2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f2, args);
        return new Ctor();
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var browser$1 = { exports: {} };
var process$1 = browser$1.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e3) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e3) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e3) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e4) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e3) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e4) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue$1 = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue$1 = currentQueue.concat(queue$1);
  } else {
    queueIndex = -1;
  }
  if (queue$1.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue$1.length;
  while (len) {
    currentQueue = queue$1;
    queue$1 = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue$1.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process$1.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue$1.push(new Item$1(fun, args));
  if (queue$1.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item$1(fun, array3) {
  this.fun = fun;
  this.array = array3;
}
Item$1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process$1.title = "browser";
process$1.browser = true;
process$1.env = {};
process$1.argv = [];
process$1.version = "";
process$1.versions = {};
function noop$7() {
}
process$1.on = noop$7;
process$1.addListener = noop$7;
process$1.once = noop$7;
process$1.off = noop$7;
process$1.removeListener = noop$7;
process$1.removeAllListeners = noop$7;
process$1.emit = noop$7;
process$1.prependListener = noop$7;
process$1.prependOnceListener = noop$7;
process$1.listeners = function(name) {
  return [];
};
process$1.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process$1.cwd = function() {
  return "/";
};
process$1.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process$1.umask = function() {
  return 0;
};
var browserExports = browser$1.exports;
const process$2 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var events$2 = { exports: {} };
var R$4 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R$4 && typeof R$4.apply === "function" ? R$4.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R$4 && typeof R$4.ownKeys === "function") {
  ReflectOwnKeys = R$4.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning2) {
  if (console && console.warn)
    console.warn(warning2);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events$2.exports = EventEmitter$1;
events$2.exports.once = once$3;
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter$1.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
  }
  this._maxListeners = n2;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$1.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter$1.prototype.emit = function emit(type3) {
  var args = [];
  for (var i = 1; i < arguments.length; i++)
    args.push(arguments[i]);
  var doError = type3 === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type3];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners2[i], this, args);
  }
  return true;
};
function _addListener(target, type3, listener, prepend3) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type3,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type3];
  }
  if (existing === void 0) {
    existing = events2[type3] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type3] = prepend3 ? [listener, existing] : [existing, listener];
    } else if (prepend3) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type3;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter$1.prototype.addListener = function addListener(type3, listener) {
  return _addListener(this, type3, listener, false);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function prependListener(type3, listener) {
  return _addListener(this, type3, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type3, listener) {
  var state = { fired: false, wrapFn: void 0, target, type: type3, listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter$1.prototype.once = function once(type3, listener) {
  checkListener(listener);
  this.on(type3, _onceWrap(this, type3, listener));
  return this;
};
EventEmitter$1.prototype.prependOnceListener = function prependOnceListener(type3, listener) {
  checkListener(listener);
  this.prependListener(type3, _onceWrap(this, type3, listener));
  return this;
};
EventEmitter$1.prototype.removeListener = function removeListener(type3, listener) {
  var list, events2, position, i, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type3];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type3];
      if (events2.removeListener)
        this.emit("removeListener", type3, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne$1(list, position);
    }
    if (list.length === 1)
      events2[type3] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type3, originalListener || listener);
  }
  return this;
};
EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
EventEmitter$1.prototype.removeAllListeners = function removeAllListeners(type3) {
  var listeners2, events2, i;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type3] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type3];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys4 = Object.keys(events2);
    var key;
    for (i = 0; i < keys4.length; ++i) {
      key = keys4[i];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type3];
  if (typeof listeners2 === "function") {
    this.removeListener(type3, listeners2);
  } else if (listeners2 !== void 0) {
    for (i = listeners2.length - 1; i >= 0; i--) {
      this.removeListener(type3, listeners2[i]);
    }
  }
  return this;
};
function _listeners(target, type3, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type3];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter$1.prototype.listeners = function listeners(type3) {
  return _listeners(this, type3, true);
};
EventEmitter$1.prototype.rawListeners = function rawListeners(type3) {
  return _listeners(this, type3, false);
};
EventEmitter$1.listenerCount = function(emitter, type3) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type3);
  } else {
    return listenerCount.call(emitter, type3);
  }
};
EventEmitter$1.prototype.listenerCount = listenerCount;
function listenerCount(type3) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type3];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n2) {
  var copy2 = new Array(n2);
  for (var i = 0; i < n2; ++i)
    copy2[i] = arr[i];
  return copy2;
}
function spliceOne$1(list, index3) {
  for (; index3 + 1 < list.length; index3++)
    list[index3] = list[index3 + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once$3(emitter, name) {
  return new Promise(function(resolve, reject3) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject3(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags2) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags2);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags2) {
  if (typeof emitter.on === "function") {
    if (flags2.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags2.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var eventsExports = events$2.exports;
const EventEmitter$2 = /* @__PURE__ */ getDefaultExportFromCjs(eventsExports);
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1) {
  lookup[i$1] = code[i$1];
  revLookup[code.charCodeAt(i$1)] = i$1;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens3 = getLens(b64);
  var validLen = lens3[0];
  var placeHoldersLen = lens3[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens3 = getLens(b64);
  var validLen = lens3[0];
  var placeHoldersLen = lens3[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset2, isLE, mLen, nBytes) {
  var e3, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset2 + i];
  i += d2;
  e3 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e3 = e3 * 256 + buffer2[offset2 + i], i += d2, nBits -= 8) {
  }
  m2 = e3 & (1 << -nBits) - 1;
  e3 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i], i += d2, nBits -= 8) {
  }
  if (e3 === 0) {
    e3 = 1 - eBias;
  } else if (e3 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e3 = e3 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
};
ieee754.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {
  var e3, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e3 = eMax;
  } else {
    e3 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e3)) < 1) {
      e3--;
      c2 *= 2;
    }
    if (e3 + eBias >= 1) {
      value += rt2 / c2;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e3++;
      c2 /= 2;
    }
    if (e3 + eBias >= eMax) {
      m2 = 0;
      e3 = eMax;
    } else if (e3 + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e3 = e3 + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e3 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
  }
  e3 = e3 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i] = e3 & 255, i += d2, e3 /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto2 = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto2, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto2);
      return arr.foo() === 42;
    } catch (e3) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length3) {
    if (length3 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length3 + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length3);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length3) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from2(arg, encodingOrOffset, length3);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length3) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length3);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length3);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf2 = value.valueOf && value.valueOf();
    if (valueOf2 != null && valueOf2 !== value) {
      return Buffer2.from(valueOf2, encodingOrOffset, length3);
    }
    const b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length3);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length3) {
    return from2(value, encodingOrOffset, length3);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string4, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length3 = byteLength2(string4, encoding) | 0;
    let buf = createBuffer(length3);
    const actual = buf.write(string4, encoding);
    if (actual !== length3) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array3) {
    const length3 = array3.length < 0 ? 0 : checked(array3.length) | 0;
    const buf = createBuffer(length3);
    for (let i = 0; i < length3; i += 1) {
      buf[i] = array3[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array3, byteOffset, length3) {
    if (byteOffset < 0 || array3.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array3.byteLength < byteOffset + (length3 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length3 === void 0) {
      buf = new Uint8Array(array3);
    } else if (length3 === void 0) {
      buf = new Uint8Array(array3, byteOffset);
    } else {
      buf = new Uint8Array(array3, byteOffset, length3);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length3) {
    if (length3 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length3 | 0;
  }
  function SlowBuffer(length3) {
    if (+length3 != length3) {
      length3 = 0;
    }
    return Buffer2.alloc(+length3);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a2, b2) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b2)
      return 0;
    let x2 = a2.length;
    let y2 = b2.length;
    for (let i = 0, len = Math.min(x2, y2); i < len; ++i) {
      if (a2[i] !== b2[i]) {
        x2 = a2[i];
        y2 = b2[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat3(list, length3) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length3 === void 0) {
      length3 = 0;
      for (i = 0; i < list.length; ++i) {
        length3 += list[i].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length3);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string4, encoding) {
    if (Buffer2.isBuffer(string4)) {
      return string4.length;
    }
    if (ArrayBuffer.isView(string4) || isInstance(string4, ArrayBuffer)) {
      return string4.byteLength;
    }
    if (typeof string4 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string4
      );
    }
    const len = string4.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string4).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string4).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string4).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap2(b2, n2, m2) {
    const i = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap2(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap2(this, i, i + 3);
      swap2(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap2(this, i, i + 7);
      swap2(this, i + 1, i + 6);
      swap2(this, i + 2, i + 5);
      swap2(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString4() {
    const length3 = this.length;
    if (length3 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length3);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals3(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect2() {
    let str = "";
    const max3 = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max3).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max3)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf3(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf3(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string4, offset2, length3) {
    offset2 = Number(offset2) || 0;
    const remaining = buf.length - offset2;
    if (!length3) {
      length3 = remaining;
    } else {
      length3 = Number(length3);
      if (length3 > remaining) {
        length3 = remaining;
      }
    }
    const strLen = string4.length;
    if (length3 > strLen / 2) {
      length3 = strLen / 2;
    }
    let i;
    for (i = 0; i < length3; ++i) {
      const parsed = parseInt(string4.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset2 + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string4, offset2, length3) {
    return blitBuffer(utf8ToBytes(string4, buf.length - offset2), buf, offset2, length3);
  }
  function asciiWrite(buf, string4, offset2, length3) {
    return blitBuffer(asciiToBytes(string4), buf, offset2, length3);
  }
  function base64Write(buf, string4, offset2, length3) {
    return blitBuffer(base64ToBytes(string4), buf, offset2, length3);
  }
  function ucs2Write(buf, string4, offset2, length3) {
    return blitBuffer(utf16leToBytes(string4, buf.length - offset2), buf, offset2, length3);
  }
  Buffer2.prototype.write = function write(string4, offset2, length3, encoding) {
    if (offset2 === void 0) {
      encoding = "utf8";
      length3 = this.length;
      offset2 = 0;
    } else if (length3 === void 0 && typeof offset2 === "string") {
      encoding = offset2;
      length3 = this.length;
      offset2 = 0;
    } else if (isFinite(offset2)) {
      offset2 = offset2 >>> 0;
      if (isFinite(length3)) {
        length3 = length3 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length3;
        length3 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset2;
    if (length3 === void 0 || length3 > remaining)
      length3 = remaining;
    if (string4.length > 0 && (length3 < 0 || offset2 < 0) || offset2 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string4, offset2, length3);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string4, offset2, length3);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string4, offset2, length3);
        case "base64":
          return base64Write(this, string4, offset2, length3);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string4, offset2, length3);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON3() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice3(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset2, ext, length3) {
    if (offset2 % 1 !== 0 || offset2 < 0)
      throw new RangeError("offset is not uint");
    if (offset2 + ext > length3)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset2, byteLength3, this.length);
    }
    let val = this[offset2 + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset2 + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 1, this.length);
    return this[offset2];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    return this[offset2] | this[offset2 + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    return this[offset2] << 8 | this[offset2 + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last2 = this[offset2 + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
    const hi2 = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last2 * 2 ** 24;
    return BigInt(lo) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last2 = this[offset2 + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last2;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset2, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset2 + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset2 + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 1, this.length);
    if (!(this[offset2] & 128))
      return this[offset2];
    return (255 - this[offset2] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    const val = this[offset2] | this[offset2 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 2, this.length);
    const val = this[offset2 + 1] | this[offset2] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last2 = this[offset2 + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last2 << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first = this[offset2];
    const last2 = this[offset2 + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last2);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, false, 52, 8);
  };
  function checkInt(buf, value, offset2, ext, max3, min3) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max3 || value < min3)
      throw new RangeError('"value" argument is out of bounds');
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset2] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset2 + i] = value / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset2 + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset2 + i] = value / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 1, 255, 0);
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2 + 3] = value >>> 24;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 1] = value >>> 8;
    this[offset2] = value & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  function wrtBigUInt64LE(buf, value, offset2, min3, max3) {
    checkIntBI(value, min3, max3, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2++] = hi2;
    return offset2;
  }
  function wrtBigUInt64BE(buf, value, offset2, min3, max3) {
    checkIntBI(value, min3, max3, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2 + 7] = lo;
    lo = lo >> 8;
    buf[offset2 + 6] = lo;
    lo = lo >> 8;
    buf[offset2 + 5] = lo;
    lo = lo >> 8;
    buf[offset2 + 4] = lo;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2 + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2 + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2 + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset2] = hi2;
    return offset2 + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset2] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i - 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value / mul >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset2 + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i + 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value / mul >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 3] = value >>> 24;
    return offset2 + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert)
      checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset2, ext, max3, min3) {
    if (offset2 + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset2 < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 4);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 23, 4);
    return offset2 + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, false, noAssert);
  };
  function writeDouble(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 8);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 52, 8);
    return offset2 + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range4, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range4}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset2, byteLength3) {
    validateNumber(offset2, "offset");
    if (buf[offset2] === void 0 || buf[offset2 + byteLength3] === void 0) {
      boundsError(offset2, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min3, max3, buf, offset2, byteLength3) {
    if (value > max3 || value < min3) {
      const n2 = typeof min3 === "bigint" ? "n" : "";
      let range4;
      if (byteLength3 > 3) {
        if (min3 === 0 || min3 === BigInt(0)) {
          range4 = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range4 = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      } else {
        range4 = `>= ${min3}${n2} and <= ${max3}${n2}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range4, value);
    }
    checkBounds(buf, offset2, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length3, type3) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type3);
      throw new errors.ERR_OUT_OF_RANGE(type3 || "offset", "an integer", value);
    }
    if (length3 < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      type3 || "offset",
      `>= ${type3 ? 1 : 0} and <= ${length3}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string4, units) {
    units = units || Infinity;
    let codePoint;
    const length3 = string4.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length3; ++i) {
      codePoint = string4.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length3) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi2, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i);
      hi2 = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset2, length3) {
    let i;
    for (i = 0; i < length3; ++i) {
      if (i + offset2 >= dst.length || i >= src.length)
        break;
      dst[i + offset2] = src[i];
    }
    return i;
  }
  function isInstance(obj, type3) {
    return obj instanceof type3 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type3.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i] + alphabet[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn2) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$6 = Symbol.for("react.element"), n$6 = Symbol.for("react.portal"), p$6 = Symbol.for("react.fragment"), q$6 = Symbol.for("react.strict_mode"), r$3 = Symbol.for("react.profiler"), t$4 = Symbol.for("react.provider"), u$4 = Symbol.for("react.context"), v$5 = Symbol.for("react.forward_ref"), w$3 = Symbol.for("react.suspense"), x$3 = Symbol.for("react.memo"), y$3 = Symbol.for("react.lazy"), z$3 = Symbol.iterator;
function A$2(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$3 && a2[z$3] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$2 = Object.assign, D$2 = {};
function E$2(a2, b2, e3) {
  this.props = a2;
  this.context = b2;
  this.refs = D$2;
  this.updater = e3 || B$1;
}
E$2.prototype.isReactComponent = {};
E$2.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$2.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$3() {
}
F$3.prototype = E$2.prototype;
function G$2(a2, b2, e3) {
  this.props = a2;
  this.context = b2;
  this.refs = D$2;
  this.updater = e3 || B$1;
}
var H$4 = G$2.prototype = new F$3();
H$4.constructor = G$2;
C$2(H$4, E$2.prototype);
H$4.isPureReactComponent = true;
var I$2 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$2 = { key: true, ref: true, __self: true, __source: true };
function M$2(a2, b2, e3) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$1.call(b2, d2) && !L$2.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e3;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$6, type: a2, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
function N$2(a2, b2) {
  return { $$typeof: l$6, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$1(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$6;
}
function escape(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$3 = /\/+/g;
function Q$2(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
}
function R$3(a2, b2, e3, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$6:
          case n$6:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$2(h2, 0) : d2, I$2(c2) ? (e3 = "", null != a2 && (e3 = a2.replace(P$3, "$&/") + "/"), R$3(c2, b2, e3, "", function(a3) {
      return a3;
    })) : null != c2 && (O$1(c2) && (c2 = N$2(c2, e3 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$3, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$2(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$2(k2, g2);
      h2 += R$3(k2, b2, e3, f2, c2);
    }
  else if (f2 = A$2(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$2(k2, g2++), h2 += R$3(k2, b2, e3, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a2, b2, e3) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$3(a2, d2, "", "", function(a3) {
    return b2.call(e3, a3, c2++);
  });
  return d2;
}
function T$4(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$1 = { current: null }, V$2 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$1, forEach: function(a2, b2, e3) {
  S$1(a2, function() {
    b2.apply(this, arguments);
  }, e3);
}, count: function(a2) {
  var b2 = 0;
  S$1(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$1(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$1(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$2;
react_production_min.Fragment = p$6;
react_production_min.Profiler = r$3;
react_production_min.PureComponent = G$2;
react_production_min.StrictMode = q$6;
react_production_min.Suspense = w$3;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a2, b2, e3) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$2({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$2.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$1.call(b2, f2) && !L$2.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e3;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$6, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$4, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$4, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a2) {
  var b2 = M$2.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$5, render: a2 };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$3, _payload: { _status: -1, _result: a2 }, _init: T$4 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$3, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$2.transition;
  V$2.transition = {};
  try {
    a2();
  } finally {
    V$2.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$1.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$1.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$1.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$1.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e3) {
  return U$1.current.useImperativeHandle(a2, b2, e3);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$1.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$1.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$1.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e3) {
  return U$1.current.useReducer(a2, b2, e3);
};
react_production_min.useRef = function(a2) {
  return U$1.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$1.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e3) {
  return U$1.current.useSyncExternalStore(a2, b2, e3);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
var F$1 = function() {
  return false;
};
const F$2 = F$1;
var T$2 = function() {
  return true;
};
const T$3 = T$2;
const __ = {
  "@@functional/placeholder": true
};
function _isPlaceholder(a2) {
  return a2 != null && typeof a2 === "object" && a2["@@functional/placeholder"] === true;
}
function _curry1(fn2) {
  return function f1(a2) {
    if (arguments.length === 0 || _isPlaceholder(a2)) {
      return f1;
    } else {
      return fn2.apply(this, arguments);
    }
  };
}
function _curry2(fn2) {
  return function f2(a2, b2) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a2) ? f2 : _curry1(function(_b) {
          return fn2(a2, _b);
        });
      default:
        return _isPlaceholder(a2) && _isPlaceholder(b2) ? f2 : _isPlaceholder(a2) ? _curry1(function(_a2) {
          return fn2(_a2, b2);
        }) : _isPlaceholder(b2) ? _curry1(function(_b) {
          return fn2(a2, _b);
        }) : fn2(a2, b2);
    }
  };
}
var add$2 = /* @__PURE__ */ _curry2(function add(a2, b2) {
  return Number(a2) + Number(b2);
});
const add$3 = add$2;
function _concat(set1, set22) {
  set1 = set1 || [];
  set22 = set22 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set22.length;
  var result = [];
  idx = 0;
  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }
  idx = 0;
  while (idx < len2) {
    result[result.length] = set22[idx];
    idx += 1;
  }
  return result;
}
function _arity(n2, fn2) {
  switch (n2) {
    case 0:
      return function() {
        return fn2.apply(this, arguments);
      };
    case 1:
      return function(a0) {
        return fn2.apply(this, arguments);
      };
    case 2:
      return function(a0, a1) {
        return fn2.apply(this, arguments);
      };
    case 3:
      return function(a0, a1, a2) {
        return fn2.apply(this, arguments);
      };
    case 4:
      return function(a0, a1, a2, a3) {
        return fn2.apply(this, arguments);
      };
    case 5:
      return function(a0, a1, a2, a3, a4) {
        return fn2.apply(this, arguments);
      };
    case 6:
      return function(a0, a1, a2, a3, a4, a5) {
        return fn2.apply(this, arguments);
      };
    case 7:
      return function(a0, a1, a2, a3, a4, a5, a6) {
        return fn2.apply(this, arguments);
      };
    case 8:
      return function(a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn2.apply(this, arguments);
      };
    case 9:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn2.apply(this, arguments);
      };
    case 10:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn2.apply(this, arguments);
      };
    default:
      throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
  }
}
function _curryN(length3, received, fn2) {
  return function() {
    var combined = [];
    var argsIdx = 0;
    var left = length3;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn2.apply(this, combined) : _arity(left, _curryN(length3, combined, fn2));
  };
}
var curryN$1 = /* @__PURE__ */ _curry2(function curryN(length3, fn2) {
  if (length3 === 1) {
    return _curry1(fn2);
  }
  return _arity(length3, _curryN(length3, [], fn2));
});
const curryN$2 = curryN$1;
var addIndex = /* @__PURE__ */ _curry1(function addIndex2(fn2) {
  return curryN$2(fn2.length, function() {
    var idx = 0;
    var origFn = arguments[0];
    var list = arguments[arguments.length - 1];
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = function() {
      var result = origFn.apply(this, _concat(arguments, [idx, list]));
      idx += 1;
      return result;
    };
    return fn2.apply(this, args);
  });
});
const addIndex$1 = addIndex;
var addIndexRight = /* @__PURE__ */ _curry1(function addIndex3(fn2) {
  return curryN$2(fn2.length, function() {
    var origFn = arguments[0];
    var list = arguments[arguments.length - 1];
    var idx = list.length - 1;
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = function() {
      var result = origFn.apply(this, _concat(arguments, [idx, list]));
      idx -= 1;
      return result;
    };
    return fn2.apply(this, args);
  });
});
const addIndexRight$1 = addIndexRight;
function _curry3(fn2) {
  return function f3(a2, b2, c2) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return _isPlaceholder(a2) ? f3 : _curry2(function(_b, _c) {
          return fn2(a2, _b, _c);
        });
      case 2:
        return _isPlaceholder(a2) && _isPlaceholder(b2) ? f3 : _isPlaceholder(a2) ? _curry2(function(_a2, _c) {
          return fn2(_a2, b2, _c);
        }) : _isPlaceholder(b2) ? _curry2(function(_b, _c) {
          return fn2(a2, _b, _c);
        }) : _curry1(function(_c) {
          return fn2(a2, b2, _c);
        });
      default:
        return _isPlaceholder(a2) && _isPlaceholder(b2) && _isPlaceholder(c2) ? f3 : _isPlaceholder(a2) && _isPlaceholder(b2) ? _curry2(function(_a2, _b) {
          return fn2(_a2, _b, c2);
        }) : _isPlaceholder(a2) && _isPlaceholder(c2) ? _curry2(function(_a2, _c) {
          return fn2(_a2, b2, _c);
        }) : _isPlaceholder(b2) && _isPlaceholder(c2) ? _curry2(function(_b, _c) {
          return fn2(a2, _b, _c);
        }) : _isPlaceholder(a2) ? _curry1(function(_a2) {
          return fn2(_a2, b2, c2);
        }) : _isPlaceholder(b2) ? _curry1(function(_b) {
          return fn2(a2, _b, c2);
        }) : _isPlaceholder(c2) ? _curry1(function(_c) {
          return fn2(a2, b2, _c);
        }) : fn2(a2, b2, c2);
    }
  };
}
var adjust = /* @__PURE__ */ _curry3(function adjust2(idx, fn2, list) {
  var len = list.length;
  if (idx >= len || idx < -len) {
    return list;
  }
  var _idx = (len + idx) % len;
  var _list = _concat(list);
  _list[_idx] = fn2(list[_idx]);
  return _list;
});
const adjust$1 = adjust;
const _isArray$1 = Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
};
function _isTransformer(obj) {
  return obj != null && typeof obj["@@transducer/step"] === "function";
}
function _dispatchable(methodNames, transducerCreator, fn2) {
  return function() {
    if (arguments.length === 0) {
      return fn2();
    }
    var obj = arguments[arguments.length - 1];
    if (!_isArray$1(obj)) {
      var idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === "function") {
          return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
        }
        idx += 1;
      }
      if (_isTransformer(obj)) {
        var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
        return transducer(obj);
      }
    }
    return fn2.apply(this, arguments);
  };
}
function _reduced(x2) {
  return x2 && x2["@@transducer/reduced"] ? x2 : {
    "@@transducer/value": x2,
    "@@transducer/reduced": true
  };
}
const _xfBase = {
  init: function() {
    return this.xf["@@transducer/init"]();
  },
  result: function(result) {
    return this.xf["@@transducer/result"](result);
  }
};
var XAll = /* @__PURE__ */ function() {
  function XAll2(f2, xf2) {
    this.xf = xf2;
    this.f = f2;
    this.all = true;
  }
  XAll2.prototype["@@transducer/init"] = _xfBase.init;
  XAll2.prototype["@@transducer/result"] = function(result) {
    if (this.all) {
      result = this.xf["@@transducer/step"](result, true);
    }
    return this.xf["@@transducer/result"](result);
  };
  XAll2.prototype["@@transducer/step"] = function(result, input) {
    if (!this.f(input)) {
      this.all = false;
      result = _reduced(this.xf["@@transducer/step"](result, false));
    }
    return result;
  };
  return XAll2;
}();
function _xall(f2) {
  return function(xf2) {
    return new XAll(f2, xf2);
  };
}
var all = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable(["all"], _xall, function all2(fn2, list) {
    var idx = 0;
    while (idx < list.length) {
      if (!fn2(list[idx])) {
        return false;
      }
      idx += 1;
    }
    return true;
  })
);
const all$1 = all;
function _arrayFromIterator(iter) {
  var list = [];
  var next;
  while (!(next = iter.next()).done) {
    list.push(next.value);
  }
  return list;
}
function _includesWith(pred, x2, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (pred(x2, list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}
function _functionName(f2) {
  var match5 = String(f2).match(/^function (\w*)/);
  return match5 == null ? "" : match5[1];
}
function _has(prop3, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop3);
}
function _objectIs(a2, b2) {
  if (a2 === b2) {
    return a2 !== 0 || 1 / a2 === 1 / b2;
  } else {
    return a2 !== a2 && b2 !== b2;
  }
}
const _objectIs$1 = typeof Object.is === "function" ? Object.is : _objectIs;
var toString$a = Object.prototype.toString;
var _isArguments = /* @__PURE__ */ function() {
  return toString$a.call(arguments) === "[object Arguments]" ? function _isArguments2(x2) {
    return toString$a.call(x2) === "[object Arguments]";
  } : function _isArguments2(x2) {
    return _has("callee", x2);
  };
}();
var hasEnumBug = !/* @__PURE__ */ {
  toString: null
}.propertyIsEnumerable("toString");
var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
var hasArgsEnumBug = /* @__PURE__ */ function() {
  return arguments.propertyIsEnumerable("length");
}();
var contains = function contains2(list, item) {
  var idx = 0;
  while (idx < list.length) {
    if (list[idx] === item) {
      return true;
    }
    idx += 1;
  }
  return false;
};
var keys$6 = typeof Object.keys === "function" && !hasArgsEnumBug ? /* @__PURE__ */ _curry1(function keys(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
}) : /* @__PURE__ */ _curry1(function keys2(obj) {
  if (Object(obj) !== obj) {
    return [];
  }
  var prop3, nIdx;
  var ks2 = [];
  var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
  for (prop3 in obj) {
    if (_has(prop3, obj) && (!checkArgsLength || prop3 !== "length")) {
      ks2[ks2.length] = prop3;
    }
  }
  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;
    while (nIdx >= 0) {
      prop3 = nonEnumerableProps[nIdx];
      if (_has(prop3, obj) && !contains(ks2, prop3)) {
        ks2[ks2.length] = prop3;
      }
      nIdx -= 1;
    }
  }
  return ks2;
});
const keys$7 = keys$6;
var type = /* @__PURE__ */ _curry1(function type2(val) {
  return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
});
const type$1 = type;
function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a2 = _arrayFromIterator(aIterator);
  var b2 = _arrayFromIterator(bIterator);
  function eq2(_a2, _b) {
    return _equals(_a2, _b, stackA.slice(), stackB.slice());
  }
  return !_includesWith(function(b3, aItem) {
    return !_includesWith(eq2, aItem, b3);
  }, b2, a2);
}
function _equals(a2, b2, stackA, stackB) {
  if (_objectIs$1(a2, b2)) {
    return true;
  }
  var typeA = type$1(a2);
  if (typeA !== type$1(b2)) {
    return false;
  }
  if (typeof a2["fantasy-land/equals"] === "function" || typeof b2["fantasy-land/equals"] === "function") {
    return typeof a2["fantasy-land/equals"] === "function" && a2["fantasy-land/equals"](b2) && typeof b2["fantasy-land/equals"] === "function" && b2["fantasy-land/equals"](a2);
  }
  if (typeof a2.equals === "function" || typeof b2.equals === "function") {
    return typeof a2.equals === "function" && a2.equals(b2) && typeof b2.equals === "function" && b2.equals(a2);
  }
  switch (typeA) {
    case "Arguments":
    case "Array":
    case "Object":
      if (typeof a2.constructor === "function" && _functionName(a2.constructor) === "Promise") {
        return a2 === b2;
      }
      break;
    case "Boolean":
    case "Number":
    case "String":
      if (!(typeof a2 === typeof b2 && _objectIs$1(a2.valueOf(), b2.valueOf()))) {
        return false;
      }
      break;
    case "Date":
      if (!_objectIs$1(a2.valueOf(), b2.valueOf())) {
        return false;
      }
      break;
    case "Error":
      return a2.name === b2.name && a2.message === b2.message;
    case "RegExp":
      if (!(a2.source === b2.source && a2.global === b2.global && a2.ignoreCase === b2.ignoreCase && a2.multiline === b2.multiline && a2.sticky === b2.sticky && a2.unicode === b2.unicode)) {
        return false;
      }
      break;
  }
  var idx = stackA.length - 1;
  while (idx >= 0) {
    if (stackA[idx] === a2) {
      return stackB[idx] === b2;
    }
    idx -= 1;
  }
  switch (typeA) {
    case "Map":
      if (a2.size !== b2.size) {
        return false;
      }
      return _uniqContentEquals(a2.entries(), b2.entries(), stackA.concat([a2]), stackB.concat([b2]));
    case "Set":
      if (a2.size !== b2.size) {
        return false;
      }
      return _uniqContentEquals(a2.values(), b2.values(), stackA.concat([a2]), stackB.concat([b2]));
    case "Arguments":
    case "Array":
    case "Object":
    case "Boolean":
    case "Number":
    case "String":
    case "Date":
    case "Error":
    case "RegExp":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "ArrayBuffer":
      break;
    default:
      return false;
  }
  var keysA = keys$7(a2);
  if (keysA.length !== keys$7(b2).length) {
    return false;
  }
  var extendedStackA = stackA.concat([a2]);
  var extendedStackB = stackB.concat([b2]);
  idx = keysA.length - 1;
  while (idx >= 0) {
    var key = keysA[idx];
    if (!(_has(key, b2) && _equals(b2[key], a2[key], extendedStackA, extendedStackB))) {
      return false;
    }
    idx -= 1;
  }
  return true;
}
var equals = /* @__PURE__ */ _curry2(function equals2(a2, b2) {
  return _equals(a2, b2, [], []);
});
const equals$1 = equals;
function _indexOf(list, a2, idx) {
  var inf, item;
  if (typeof list.indexOf === "function") {
    switch (typeof a2) {
      case "number":
        if (a2 === 0) {
          inf = 1 / a2;
          while (idx < list.length) {
            item = list[idx];
            if (item === 0 && 1 / item === inf) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        } else if (a2 !== a2) {
          while (idx < list.length) {
            item = list[idx];
            if (typeof item === "number" && item !== item) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        }
        return list.indexOf(a2, idx);
      case "string":
      case "boolean":
      case "function":
      case "undefined":
        return list.indexOf(a2, idx);
      case "object":
        if (a2 === null) {
          return list.indexOf(a2, idx);
        }
    }
  }
  while (idx < list.length) {
    if (equals$1(list[idx], a2)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}
function _includes(a2, list) {
  return _indexOf(list, a2, 0) >= 0;
}
function _map(fn2, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn2(functor[idx]);
    idx += 1;
  }
  return result;
}
function _quote(s2) {
  var escaped = s2.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\f/g, "\\f").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/\v/g, "\\v").replace(/\0/g, "\\0");
  return '"' + escaped.replace(/"/g, '\\"') + '"';
}
var pad$1 = function pad(n2) {
  return (n2 < 10 ? "0" : "") + n2;
};
var _toISOString = typeof Date.prototype.toISOString === "function" ? function _toISOString2(d2) {
  return d2.toISOString();
} : function _toISOString3(d2) {
  return d2.getUTCFullYear() + "-" + pad$1(d2.getUTCMonth() + 1) + "-" + pad$1(d2.getUTCDate()) + "T" + pad$1(d2.getUTCHours()) + ":" + pad$1(d2.getUTCMinutes()) + ":" + pad$1(d2.getUTCSeconds()) + "." + (d2.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
};
function _complement(f2) {
  return function() {
    return !f2.apply(this, arguments);
  };
}
function _arrayReduce(reducer2, acc, list) {
  var index3 = 0;
  var length3 = list.length;
  while (index3 < length3) {
    acc = reducer2(acc, list[index3]);
    index3 += 1;
  }
  return acc;
}
function _filter(fn2, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  while (idx < len) {
    if (fn2(list[idx])) {
      result[result.length] = list[idx];
    }
    idx += 1;
  }
  return result;
}
function _isObject$1(x2) {
  return Object.prototype.toString.call(x2) === "[object Object]";
}
var XFilter = /* @__PURE__ */ function() {
  function XFilter2(f2, xf2) {
    this.xf = xf2;
    this.f = f2;
  }
  XFilter2.prototype["@@transducer/init"] = _xfBase.init;
  XFilter2.prototype["@@transducer/result"] = _xfBase.result;
  XFilter2.prototype["@@transducer/step"] = function(result, input) {
    return this.f(input) ? this.xf["@@transducer/step"](result, input) : result;
  };
  return XFilter2;
}();
function _xfilter(f2) {
  return function(xf2) {
    return new XFilter(f2, xf2);
  };
}
var filter = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable(["fantasy-land/filter", "filter"], _xfilter, function(pred, filterable) {
    return _isObject$1(filterable) ? _arrayReduce(function(acc, key) {
      if (pred(filterable[key])) {
        acc[key] = filterable[key];
      }
      return acc;
    }, {}, keys$7(filterable)) : (
      // else
      _filter(pred, filterable)
    );
  })
);
const filter$1 = filter;
var reject = /* @__PURE__ */ _curry2(function reject2(pred, filterable) {
  return filter$1(_complement(pred), filterable);
});
const reject$1 = reject;
function _toString(x2, seen2) {
  var recur = function recur2(y2) {
    var xs2 = seen2.concat([x2]);
    return _includes(y2, xs2) ? "<Circular>" : _toString(y2, xs2);
  };
  var mapPairs = function(obj, keys4) {
    return _map(function(k2) {
      return _quote(k2) + ": " + recur(obj[k2]);
    }, keys4.slice().sort());
  };
  switch (Object.prototype.toString.call(x2)) {
    case "[object Arguments]":
      return "(function() { return arguments; }(" + _map(recur, x2).join(", ") + "))";
    case "[object Array]":
      return "[" + _map(recur, x2).concat(mapPairs(x2, reject$1(function(k2) {
        return /^\d+$/.test(k2);
      }, keys$7(x2)))).join(", ") + "]";
    case "[object Boolean]":
      return typeof x2 === "object" ? "new Boolean(" + recur(x2.valueOf()) + ")" : x2.toString();
    case "[object Date]":
      return "new Date(" + (isNaN(x2.valueOf()) ? recur(NaN) : _quote(_toISOString(x2))) + ")";
    case "[object Map]":
      return "new Map(" + recur(Array.from(x2)) + ")";
    case "[object Null]":
      return "null";
    case "[object Number]":
      return typeof x2 === "object" ? "new Number(" + recur(x2.valueOf()) + ")" : 1 / x2 === -Infinity ? "-0" : x2.toString(10);
    case "[object Set]":
      return "new Set(" + recur(Array.from(x2).sort()) + ")";
    case "[object String]":
      return typeof x2 === "object" ? "new String(" + recur(x2.valueOf()) + ")" : _quote(x2);
    case "[object Undefined]":
      return "undefined";
    default:
      if (typeof x2.toString === "function") {
        var repr = x2.toString();
        if (repr !== "[object Object]") {
          return repr;
        }
      }
      return "{" + mapPairs(x2, keys$7(x2)).join(", ") + "}";
  }
}
var toString$8 = /* @__PURE__ */ _curry1(function toString(val) {
  return _toString(val, []);
});
const toString$9 = toString$8;
var max$3 = /* @__PURE__ */ _curry2(function max(a2, b2) {
  if (a2 === b2) {
    return b2;
  }
  function safeMax(x2, y2) {
    if (x2 > y2 !== y2 > x2) {
      return y2 > x2 ? y2 : x2;
    }
    return void 0;
  }
  var maxByValue = safeMax(a2, b2);
  if (maxByValue !== void 0) {
    return maxByValue;
  }
  var maxByType = safeMax(typeof a2, typeof b2);
  if (maxByType !== void 0) {
    return maxByType === typeof a2 ? a2 : b2;
  }
  var stringA = toString$9(a2);
  var maxByStringValue = safeMax(stringA, toString$9(b2));
  if (maxByStringValue !== void 0) {
    return maxByStringValue === stringA ? a2 : b2;
  }
  return b2;
});
const max$4 = max$3;
var XMap = /* @__PURE__ */ function() {
  function XMap2(f2, xf2) {
    this.xf = xf2;
    this.f = f2;
  }
  XMap2.prototype["@@transducer/init"] = _xfBase.init;
  XMap2.prototype["@@transducer/result"] = _xfBase.result;
  XMap2.prototype["@@transducer/step"] = function(result, input) {
    return this.xf["@@transducer/step"](result, this.f(input));
  };
  return XMap2;
}();
var _xmap = function _xmap2(f2) {
  return function(xf2) {
    return new XMap(f2, xf2);
  };
};
var map$5 = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable(["fantasy-land/map", "map"], _xmap, function map(fn2, functor) {
    switch (Object.prototype.toString.call(functor)) {
      case "[object Function]":
        return curryN$2(functor.length, function() {
          return fn2.call(this, functor.apply(this, arguments));
        });
      case "[object Object]":
        return _arrayReduce(function(acc, key) {
          acc[key] = fn2(functor[key]);
          return acc;
        }, {}, keys$7(functor));
      default:
        return _map(fn2, functor);
    }
  })
);
const map$6 = map$5;
const _isInteger = Number.isInteger || function _isInteger2(n2) {
  return n2 << 0 === n2;
};
function _isString$1(x2) {
  return Object.prototype.toString.call(x2) === "[object String]";
}
var nth = /* @__PURE__ */ _curry2(function nth2(offset2, list) {
  var idx = offset2 < 0 ? list.length + offset2 : offset2;
  return _isString$1(list) ? list.charAt(idx) : list[idx];
});
const nth$1 = nth;
var prop = /* @__PURE__ */ _curry2(function prop2(p2, obj) {
  if (obj == null) {
    return;
  }
  return _isInteger(p2) ? nth$1(p2, obj) : obj[p2];
});
const prop$1 = prop;
var pluck = /* @__PURE__ */ _curry2(function pluck2(p2, list) {
  return map$6(prop$1(p2), list);
});
const pluck$1 = pluck;
var _isArrayLike = /* @__PURE__ */ _curry1(function isArrayLike(x2) {
  if (_isArray$1(x2)) {
    return true;
  }
  if (!x2) {
    return false;
  }
  if (typeof x2 !== "object") {
    return false;
  }
  if (_isString$1(x2)) {
    return false;
  }
  if (x2.length === 0) {
    return true;
  }
  if (x2.length > 0) {
    return x2.hasOwnProperty(0) && x2.hasOwnProperty(x2.length - 1);
  }
  return false;
});
var symIterator = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
function _createReduce(arrayReduce, methodReduce, iterableReduce) {
  return function _reduce2(xf2, acc, list) {
    if (_isArrayLike(list)) {
      return arrayReduce(xf2, acc, list);
    }
    if (list == null) {
      return acc;
    }
    if (typeof list["fantasy-land/reduce"] === "function") {
      return methodReduce(xf2, acc, list, "fantasy-land/reduce");
    }
    if (list[symIterator] != null) {
      return iterableReduce(xf2, acc, list[symIterator]());
    }
    if (typeof list.next === "function") {
      return iterableReduce(xf2, acc, list);
    }
    if (typeof list.reduce === "function") {
      return methodReduce(xf2, acc, list, "reduce");
    }
    throw new TypeError("reduce: list must be array or iterable");
  };
}
function _xArrayReduce(xf2, acc, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    acc = xf2["@@transducer/step"](acc, list[idx]);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    idx += 1;
  }
  return xf2["@@transducer/result"](acc);
}
var bind$3 = /* @__PURE__ */ _curry2(function bind(fn2, thisObj) {
  return _arity(fn2.length, function() {
    return fn2.apply(thisObj, arguments);
  });
});
const bind$4 = bind$3;
function _xIterableReduce(xf2, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = xf2["@@transducer/step"](acc, step.value);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    step = iter.next();
  }
  return xf2["@@transducer/result"](acc);
}
function _xMethodReduce(xf2, acc, obj, methodName) {
  return xf2["@@transducer/result"](obj[methodName](bind$4(xf2["@@transducer/step"], xf2), acc));
}
var _xReduce = /* @__PURE__ */ _createReduce(_xArrayReduce, _xMethodReduce, _xIterableReduce);
var XWrap = /* @__PURE__ */ function() {
  function XWrap2(fn2) {
    this.f = fn2;
  }
  XWrap2.prototype["@@transducer/init"] = function() {
    throw new Error("init not implemented on XWrap");
  };
  XWrap2.prototype["@@transducer/result"] = function(acc) {
    return acc;
  };
  XWrap2.prototype["@@transducer/step"] = function(acc, x2) {
    return this.f(acc, x2);
  };
  return XWrap2;
}();
function _xwrap(fn2) {
  return new XWrap(fn2);
}
var reduce$1 = /* @__PURE__ */ _curry3(function(xf2, acc, list) {
  return _xReduce(typeof xf2 === "function" ? _xwrap(xf2) : xf2, acc, list);
});
const reduce$2 = reduce$1;
var allPass = /* @__PURE__ */ _curry1(function allPass2(preds) {
  return curryN$2(reduce$2(max$4, 0, pluck$1("length", preds)), function() {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (!preds[idx].apply(this, arguments)) {
        return false;
      }
      idx += 1;
    }
    return true;
  });
});
const allPass$1 = allPass;
var always = /* @__PURE__ */ _curry1(function always2(val) {
  return function() {
    return val;
  };
});
const always$1 = always;
var and = /* @__PURE__ */ _curry2(function and2(a2, b2) {
  return a2 && b2;
});
const and$1 = and;
var XAny = /* @__PURE__ */ function() {
  function XAny2(f2, xf2) {
    this.xf = xf2;
    this.f = f2;
    this.any = false;
  }
  XAny2.prototype["@@transducer/init"] = _xfBase.init;
  XAny2.prototype["@@transducer/result"] = function(result) {
    if (!this.any) {
      result = this.xf["@@transducer/step"](result, false);
    }
    return this.xf["@@transducer/result"](result);
  };
  XAny2.prototype["@@transducer/step"] = function(result, input) {
    if (this.f(input)) {
      this.any = true;
      result = _reduced(this.xf["@@transducer/step"](result, true));
    }
    return result;
  };
  return XAny2;
}();
function _xany(f2) {
  return function(xf2) {
    return new XAny(f2, xf2);
  };
}
var any = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable(["any"], _xany, function any2(fn2, list) {
    var idx = 0;
    while (idx < list.length) {
      if (fn2(list[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  })
);
const any$1 = any;
var anyPass = /* @__PURE__ */ _curry1(function anyPass2(preds) {
  return curryN$2(reduce$2(max$4, 0, pluck$1("length", preds)), function() {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (preds[idx].apply(this, arguments)) {
        return true;
      }
      idx += 1;
    }
    return false;
  });
});
const anyPass$1 = anyPass;
function _iterableReduce(reducer2, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = reducer2(acc, step.value);
    step = iter.next();
  }
  return acc;
}
function _methodReduce(reducer2, acc, obj, methodName) {
  return obj[methodName](reducer2, acc);
}
var _reduce = /* @__PURE__ */ _createReduce(_arrayReduce, _methodReduce, _iterableReduce);
var ap = /* @__PURE__ */ _curry2(function ap2(applyF, applyX) {
  return typeof applyX["fantasy-land/ap"] === "function" ? applyX["fantasy-land/ap"](applyF) : typeof applyF.ap === "function" ? applyF.ap(applyX) : typeof applyF === "function" ? function(x2) {
    return applyF(x2)(applyX(x2));
  } : _reduce(function(acc, f2) {
    return _concat(acc, map$6(f2, applyX));
  }, [], applyF);
});
const ap$1 = ap;
function _aperture(n2, list) {
  var idx = 0;
  var limit = list.length - (n2 - 1);
  var acc = new Array(limit >= 0 ? limit : 0);
  while (idx < limit) {
    acc[idx] = Array.prototype.slice.call(list, idx, idx + n2);
    idx += 1;
  }
  return acc;
}
var XAperture = /* @__PURE__ */ function() {
  function XAperture2(n2, xf2) {
    this.xf = xf2;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n2);
  }
  XAperture2.prototype["@@transducer/init"] = _xfBase.init;
  XAperture2.prototype["@@transducer/result"] = function(result) {
    this.acc = null;
    return this.xf["@@transducer/result"](result);
  };
  XAperture2.prototype["@@transducer/step"] = function(result, input) {
    this.store(input);
    return this.full ? this.xf["@@transducer/step"](result, this.getCopy()) : result;
  };
  XAperture2.prototype.store = function(input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };
  XAperture2.prototype.getCopy = function() {
    return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
  };
  return XAperture2;
}();
function _xaperture(n2) {
  return function(xf2) {
    return new XAperture(n2, xf2);
  };
}
var aperture = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable([], _xaperture, _aperture)
);
const aperture$1 = aperture;
var append$1 = /* @__PURE__ */ _curry2(function append(el2, list) {
  return _concat(list, [el2]);
});
const append$2 = append$1;
var apply$2 = /* @__PURE__ */ _curry2(function apply(fn2, args) {
  return fn2.apply(this, args);
});
const apply$3 = apply$2;
var values = /* @__PURE__ */ _curry1(function values2(obj) {
  var props3 = keys$7(obj);
  var len = props3.length;
  var vals = [];
  var idx = 0;
  while (idx < len) {
    vals[idx] = obj[props3[idx]];
    idx += 1;
  }
  return vals;
});
const values$1 = values;
function mapValues$1(fn2, obj) {
  return _isArray$1(obj) ? obj.map(fn2) : keys$7(obj).reduce(function(acc, key) {
    acc[key] = fn2(obj[key]);
    return acc;
  }, {});
}
var applySpec = /* @__PURE__ */ _curry1(function applySpec2(spec) {
  spec = mapValues$1(function(v2) {
    return typeof v2 == "function" ? v2 : applySpec2(v2);
  }, spec);
  return curryN$2(reduce$2(max$4, 0, pluck$1("length", values$1(spec))), function() {
    var args = arguments;
    return mapValues$1(function(f2) {
      return apply$3(f2, args);
    }, spec);
  });
});
const applySpec$1 = applySpec;
var applyTo = /* @__PURE__ */ _curry2(function applyTo2(x2, f2) {
  return f2(x2);
});
const applyTo$1 = applyTo;
var ascend = /* @__PURE__ */ _curry3(function ascend2(fn2, a2, b2) {
  var aa2 = fn2(a2);
  var bb2 = fn2(b2);
  return aa2 < bb2 ? -1 : aa2 > bb2 ? 1 : 0;
});
const ascend$1 = ascend;
function _assoc(prop3, val, obj) {
  if (_isInteger(prop3) && _isArray$1(obj)) {
    var arr = [].concat(obj);
    arr[prop3] = val;
    return arr;
  }
  var result = {};
  for (var p2 in obj) {
    result[p2] = obj[p2];
  }
  result[prop3] = val;
  return result;
}
var isNil$1 = /* @__PURE__ */ _curry1(function isNil(x2) {
  return x2 == null;
});
const isNil$2 = isNil$1;
var assocPath = /* @__PURE__ */ _curry3(function assocPath2(path3, val, obj) {
  if (path3.length === 0) {
    return val;
  }
  var idx = path3[0];
  if (path3.length > 1) {
    var nextObj = !isNil$2(obj) && _has(idx, obj) && typeof obj[idx] === "object" ? obj[idx] : _isInteger(path3[1]) ? [] : {};
    val = assocPath2(Array.prototype.slice.call(path3, 1), val, nextObj);
  }
  return _assoc(idx, val, obj);
});
const assocPath$1 = assocPath;
var assoc = /* @__PURE__ */ _curry3(function assoc2(prop3, val, obj) {
  return assocPath$1([prop3], val, obj);
});
const assoc$1 = assoc;
var nAry = /* @__PURE__ */ _curry2(function nAry2(n2, fn2) {
  switch (n2) {
    case 0:
      return function() {
        return fn2.call(this);
      };
    case 1:
      return function(a0) {
        return fn2.call(this, a0);
      };
    case 2:
      return function(a0, a1) {
        return fn2.call(this, a0, a1);
      };
    case 3:
      return function(a0, a1, a2) {
        return fn2.call(this, a0, a1, a2);
      };
    case 4:
      return function(a0, a1, a2, a3) {
        return fn2.call(this, a0, a1, a2, a3);
      };
    case 5:
      return function(a0, a1, a2, a3, a4) {
        return fn2.call(this, a0, a1, a2, a3, a4);
      };
    case 6:
      return function(a0, a1, a2, a3, a4, a5) {
        return fn2.call(this, a0, a1, a2, a3, a4, a5);
      };
    case 7:
      return function(a0, a1, a2, a3, a4, a5, a6) {
        return fn2.call(this, a0, a1, a2, a3, a4, a5, a6);
      };
    case 8:
      return function(a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn2.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
      };
    case 9:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn2.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
      };
    case 10:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn2.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
      };
    default:
      throw new Error("First argument to nAry must be a non-negative integer no greater than ten");
  }
});
const nAry$1 = nAry;
var binary = /* @__PURE__ */ _curry1(function binary2(fn2) {
  return nAry$1(2, fn2);
});
const binary$1 = binary;
function _isFunction$1(x2) {
  var type3 = Object.prototype.toString.call(x2);
  return type3 === "[object Function]" || type3 === "[object AsyncFunction]" || type3 === "[object GeneratorFunction]" || type3 === "[object AsyncGeneratorFunction]";
}
var liftN = /* @__PURE__ */ _curry2(function liftN2(arity, fn2) {
  var lifted = curryN$2(arity, fn2);
  return curryN$2(arity, function() {
    return _arrayReduce(ap$1, map$6(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
  });
});
const liftN$1 = liftN;
var lift = /* @__PURE__ */ _curry1(function lift2(fn2) {
  return liftN$1(fn2.length, fn2);
});
const lift$1 = lift;
var both = /* @__PURE__ */ _curry2(function both2(f2, g2) {
  return _isFunction$1(f2) ? function _both() {
    return f2.apply(this, arguments) && g2.apply(this, arguments);
  } : lift$1(and$1)(f2, g2);
});
const both$1 = both;
var call$2 = /* @__PURE__ */ _curry1(function call(fn2) {
  return fn2.apply(this, Array.prototype.slice.call(arguments, 1));
});
const call$3 = call$2;
function _makeFlat(recursive) {
  return function flatt(list) {
    var value, jlen, j2;
    var result = [];
    var idx = 0;
    var ilen = list.length;
    while (idx < ilen) {
      if (_isArrayLike(list[idx])) {
        value = recursive ? flatt(list[idx]) : list[idx];
        j2 = 0;
        jlen = value.length;
        while (j2 < jlen) {
          result[result.length] = value[j2];
          j2 += 1;
        }
      } else {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
    return result;
  };
}
function _forceReduced(x2) {
  return {
    "@@transducer/value": x2,
    "@@transducer/reduced": true
  };
}
var tInit$1 = "@@transducer/init";
var tStep$1 = "@@transducer/step";
var tResult = "@@transducer/result";
var XPreservingReduced = /* @__PURE__ */ function() {
  function XPreservingReduced2(xf2) {
    this.xf = xf2;
  }
  XPreservingReduced2.prototype[tInit$1] = _xfBase.init;
  XPreservingReduced2.prototype[tResult] = _xfBase.result;
  XPreservingReduced2.prototype[tStep$1] = function(result, input) {
    var ret = this.xf[tStep$1](result, input);
    return ret["@@transducer/reduced"] ? _forceReduced(ret) : ret;
  };
  return XPreservingReduced2;
}();
var XFlatCat = /* @__PURE__ */ function() {
  function XFlatCat2(xf2) {
    this.xf = new XPreservingReduced(xf2);
  }
  XFlatCat2.prototype[tInit$1] = _xfBase.init;
  XFlatCat2.prototype[tResult] = _xfBase.result;
  XFlatCat2.prototype[tStep$1] = function(result, input) {
    return !_isArrayLike(input) ? _xArrayReduce(this.xf, result, [input]) : _xReduce(this.xf, result, input);
  };
  return XFlatCat2;
}();
var _flatCat = function _xcat(xf2) {
  return new XFlatCat(xf2);
};
function _xchain(f2) {
  return function(xf2) {
    return _xmap(f2)(_flatCat(xf2));
  };
}
var chain = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable(["fantasy-land/chain", "chain"], _xchain, function chain2(fn2, monad) {
    if (typeof monad === "function") {
      return function(x2) {
        return fn2(monad(x2))(x2);
      };
    }
    return _makeFlat(false)(map$6(fn2, monad));
  })
);
const chain$1 = chain;
var clamp$2 = /* @__PURE__ */ _curry3(function clamp(min3, max3, value) {
  if (min3 > max3) {
    throw new Error("min must not be greater than max in clamp(min, max, value)");
  }
  return value < min3 ? min3 : value > max3 ? max3 : value;
});
const clamp$3 = clamp$2;
function _cloneRegExp(pattern3) {
  return new RegExp(pattern3.source, pattern3.flags ? pattern3.flags : (pattern3.global ? "g" : "") + (pattern3.ignoreCase ? "i" : "") + (pattern3.multiline ? "m" : "") + (pattern3.sticky ? "y" : "") + (pattern3.unicode ? "u" : "") + (pattern3.dotAll ? "s" : ""));
}
function _clone(value, deep, map3) {
  map3 || (map3 = new _ObjectMap());
  if (_isPrimitive(value)) {
    return value;
  }
  var copy2 = function copy3(copiedValue) {
    var cachedCopy = map3.get(value);
    if (cachedCopy) {
      return cachedCopy;
    }
    map3.set(value, copiedValue);
    for (var key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        copiedValue[key] = deep ? _clone(value[key], true, map3) : value[key];
      }
    }
    return copiedValue;
  };
  switch (type$1(value)) {
    case "Object":
      return copy2(Object.create(Object.getPrototypeOf(value)));
    case "Array":
      return copy2([]);
    case "Date":
      return new Date(value.valueOf());
    case "RegExp":
      return _cloneRegExp(value);
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "BigInt64Array":
    case "BigUint64Array":
      return value.slice();
    default:
      return value;
  }
}
function _isPrimitive(param) {
  var type3 = typeof param;
  return param == null || type3 != "object" && type3 != "function";
}
var _ObjectMap = /* @__PURE__ */ function() {
  function _ObjectMap2() {
    this.map = {};
    this.length = 0;
  }
  _ObjectMap2.prototype.set = function(key, value) {
    const hashedKey = this.hash(key);
    let bucket = this.map[hashedKey];
    if (!bucket) {
      this.map[hashedKey] = bucket = [];
    }
    bucket.push([key, value]);
    this.length += 1;
  };
  _ObjectMap2.prototype.hash = function(key) {
    let hashedKey = [];
    for (var value in key) {
      hashedKey.push(Object.prototype.toString.call(key[value]));
    }
    return hashedKey.join();
  };
  _ObjectMap2.prototype.get = function(key) {
    if (this.length <= 180) {
      for (const p2 in this.map) {
        const bucket2 = this.map[p2];
        for (let i = 0; i < bucket2.length; i += 1) {
          const element = bucket2[i];
          if (element[0] === key) {
            return element[1];
          }
        }
      }
      return;
    }
    const hashedKey = this.hash(key);
    const bucket = this.map[hashedKey];
    if (!bucket) {
      return;
    }
    for (let i = 0; i < bucket.length; i += 1) {
      const element = bucket[i];
      if (element[0] === key) {
        return element[1];
      }
    }
  };
  return _ObjectMap2;
}();
var clone$4 = /* @__PURE__ */ _curry1(function clone(value) {
  return value != null && typeof value.clone === "function" ? value.clone() : _clone(value, true);
});
const clone$5 = clone$4;
var collectBy = /* @__PURE__ */ _curry2(function collectBy2(fn2, list) {
  var group = _reduce(function(o3, x2) {
    var tag2 = fn2(x2);
    if (o3[tag2] === void 0) {
      o3[tag2] = [];
    }
    o3[tag2].push(x2);
    return o3;
  }, {}, list);
  var newList = [];
  for (var tag in group) {
    newList.push(group[tag]);
  }
  return newList;
});
const collectBy$1 = collectBy;
var comparator = /* @__PURE__ */ _curry1(function comparator2(pred) {
  return function(a2, b2) {
    return pred(a2, b2) ? -1 : pred(b2, a2) ? 1 : 0;
  };
});
const comparator$1 = comparator;
var not = /* @__PURE__ */ _curry1(function not2(a2) {
  return !a2;
});
const not$1 = not;
var complement = /* @__PURE__ */ lift$1(not$1);
const complement$1 = complement;
function _pipe(f2, g2) {
  return function() {
    return g2.call(this, f2.apply(this, arguments));
  };
}
function _checkForMethod(methodname, fn2) {
  return function() {
    var length3 = arguments.length;
    if (length3 === 0) {
      return fn2();
    }
    var obj = arguments[length3 - 1];
    return _isArray$1(obj) || typeof obj[methodname] !== "function" ? fn2.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length3 - 1));
  };
}
var slice = /* @__PURE__ */ _curry3(
  /* @__PURE__ */ _checkForMethod("slice", function slice2(fromIndex, toIndex, list) {
    return Array.prototype.slice.call(list, fromIndex, toIndex);
  })
);
const slice$1 = slice;
var tail = /* @__PURE__ */ _curry1(
  /* @__PURE__ */ _checkForMethod(
    "tail",
    /* @__PURE__ */ slice$1(1, Infinity)
  )
);
const tail$1 = tail;
function pipe() {
  if (arguments.length === 0) {
    throw new Error("pipe requires at least one argument");
  }
  return _arity(arguments[0].length, reduce$2(_pipe, arguments[0], tail$1(arguments)));
}
var reverse$1 = /* @__PURE__ */ _curry1(function reverse(list) {
  return _isString$1(list) ? list.split("").reverse().join("") : Array.prototype.slice.call(list, 0).reverse();
});
const reverse$2 = reverse$1;
function compose$3() {
  if (arguments.length === 0) {
    throw new Error("compose requires at least one argument");
  }
  return pipe.apply(this, reverse$2(arguments));
}
var head = /* @__PURE__ */ nth$1(0);
const head$1 = head;
function _identity(x2) {
  return x2;
}
var identity$d = /* @__PURE__ */ _curry1(_identity);
const identity$e = identity$d;
var pipeWith = /* @__PURE__ */ _curry2(function pipeWith2(xf2, list) {
  if (list.length <= 0) {
    return identity$e;
  }
  var headList = head$1(list);
  var tailList = tail$1(list);
  return _arity(headList.length, function() {
    return _reduce(function(result, f2) {
      return xf2.call(this, f2, result);
    }, headList.apply(this, arguments), tailList);
  });
});
const pipeWith$1 = pipeWith;
var composeWith = /* @__PURE__ */ _curry2(function composeWith2(xf2, list) {
  return pipeWith$1.apply(this, [xf2, reverse$2(list)]);
});
const composeWith$1 = composeWith;
var concat = /* @__PURE__ */ _curry2(function concat2(a2, b2) {
  if (_isArray$1(a2)) {
    if (_isArray$1(b2)) {
      return a2.concat(b2);
    }
    throw new TypeError(toString$9(b2) + " is not an array");
  }
  if (_isString$1(a2)) {
    if (_isString$1(b2)) {
      return a2 + b2;
    }
    throw new TypeError(toString$9(b2) + " is not a string");
  }
  if (a2 != null && _isFunction$1(a2["fantasy-land/concat"])) {
    return a2["fantasy-land/concat"](b2);
  }
  if (a2 != null && _isFunction$1(a2.concat)) {
    return a2.concat(b2);
  }
  throw new TypeError(toString$9(a2) + ' does not have a method named "concat" or "fantasy-land/concat"');
});
const concat$1 = concat;
var cond = /* @__PURE__ */ _curry1(function cond2(pairs) {
  var arity = reduce$2(max$4, 0, map$6(function(pair3) {
    return pair3[0].length;
  }, pairs));
  return _arity(arity, function() {
    var idx = 0;
    while (idx < pairs.length) {
      if (pairs[idx][0].apply(this, arguments)) {
        return pairs[idx][1].apply(this, arguments);
      }
      idx += 1;
    }
  });
});
const cond$1 = cond;
var curry$1 = /* @__PURE__ */ _curry1(function curry(fn2) {
  return curryN$2(fn2.length, fn2);
});
const curry$2 = curry$1;
var constructN = /* @__PURE__ */ _curry2(function constructN2(n2, Fn2) {
  if (n2 > 10) {
    throw new Error("Constructor with greater than ten arguments");
  }
  if (n2 === 0) {
    return function() {
      return new Fn2();
    };
  }
  return curry$2(nAry$1(n2, function($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
    switch (n2) {
      case 1:
        return new Fn2($0);
      case 2:
        return new Fn2($0, $1);
      case 3:
        return new Fn2($0, $1, $2);
      case 4:
        return new Fn2($0, $1, $2, $3);
      case 5:
        return new Fn2($0, $1, $2, $3, $4);
      case 6:
        return new Fn2($0, $1, $2, $3, $4, $5);
      case 7:
        return new Fn2($0, $1, $2, $3, $4, $5, $6);
      case 8:
        return new Fn2($0, $1, $2, $3, $4, $5, $6, $7);
      case 9:
        return new Fn2($0, $1, $2, $3, $4, $5, $6, $7, $8);
      case 10:
        return new Fn2($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
    }
  }));
});
const constructN$1 = constructN;
var construct = /* @__PURE__ */ _curry1(function construct2(Fn2) {
  return constructN$1(Fn2.length, Fn2);
});
const construct$1 = construct;
var converge = /* @__PURE__ */ _curry2(function converge2(after, fns) {
  return curryN$2(reduce$2(max$4, 0, pluck$1("length", fns)), function() {
    var args = arguments;
    var context2 = this;
    return after.apply(context2, _map(function(fn2) {
      return fn2.apply(context2, args);
    }, fns));
  });
});
const converge$1 = converge;
var count = /* @__PURE__ */ curry$2(function(pred, list) {
  return _reduce(function(a2, e3) {
    return pred(e3) ? a2 + 1 : a2;
  }, 0, list);
});
const count$1 = count;
var XReduceBy = /* @__PURE__ */ function() {
  function XReduceBy2(valueFn, valueAcc, keyFn, xf2) {
    this.valueFn = valueFn;
    this.valueAcc = valueAcc;
    this.keyFn = keyFn;
    this.xf = xf2;
    this.inputs = {};
  }
  XReduceBy2.prototype["@@transducer/init"] = _xfBase.init;
  XReduceBy2.prototype["@@transducer/result"] = function(result) {
    var key;
    for (key in this.inputs) {
      if (_has(key, this.inputs)) {
        result = this.xf["@@transducer/step"](result, this.inputs[key]);
        if (result["@@transducer/reduced"]) {
          result = result["@@transducer/value"];
          break;
        }
      }
    }
    this.inputs = null;
    return this.xf["@@transducer/result"](result);
  };
  XReduceBy2.prototype["@@transducer/step"] = function(result, input) {
    var key = this.keyFn(input);
    this.inputs[key] = this.inputs[key] || [key, _clone(this.valueAcc, false)];
    this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
    return result;
  };
  return XReduceBy2;
}();
function _xreduceBy(valueFn, valueAcc, keyFn) {
  return function(xf2) {
    return new XReduceBy(valueFn, valueAcc, keyFn, xf2);
  };
}
var reduceBy = /* @__PURE__ */ _curryN(
  4,
  [],
  /* @__PURE__ */ _dispatchable([], _xreduceBy, function reduceBy2(valueFn, valueAcc, keyFn, list) {
    var xf2 = _xwrap(function(acc, elt) {
      var key = keyFn(elt);
      var value = valueFn(_has(key, acc) ? acc[key] : _clone(valueAcc, false), elt);
      if (value && value["@@transducer/reduced"]) {
        return _reduced(acc);
      }
      acc[key] = value;
      return acc;
    });
    return _xReduce(xf2, {}, list);
  })
);
const reduceBy$1 = reduceBy;
var countBy = /* @__PURE__ */ reduceBy$1(function(acc, elem) {
  return acc + 1;
}, 0);
const countBy$1 = countBy;
var dec = /* @__PURE__ */ add$3(-1);
const dec$1 = dec;
var defaultTo = /* @__PURE__ */ _curry2(function defaultTo2(d2, v2) {
  return v2 == null || v2 !== v2 ? d2 : v2;
});
const defaultTo$1 = defaultTo;
var descend = /* @__PURE__ */ _curry3(function descend2(fn2, a2, b2) {
  var aa2 = fn2(a2);
  var bb2 = fn2(b2);
  return aa2 > bb2 ? -1 : aa2 < bb2 ? 1 : 0;
});
const descend$1 = descend;
var _Set$1 = /* @__PURE__ */ function() {
  function _Set2() {
    this._nativeSet = typeof Set === "function" ? /* @__PURE__ */ new Set() : null;
    this._items = {};
  }
  _Set2.prototype.add = function(item) {
    return !hasOrAdd(item, true, this);
  };
  _Set2.prototype.has = function(item) {
    return hasOrAdd(item, false, this);
  };
  return _Set2;
}();
function hasOrAdd(item, shouldAdd, set4) {
  var type3 = typeof item;
  var prevSize, newSize;
  switch (type3) {
    case "string":
    case "number":
      if (item === 0 && 1 / item === -Infinity) {
        if (set4._items["-0"]) {
          return true;
        } else {
          if (shouldAdd) {
            set4._items["-0"] = true;
          }
          return false;
        }
      }
      if (set4._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set4._nativeSet.size;
          set4._nativeSet.add(item);
          newSize = set4._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set4._nativeSet.has(item);
        }
      } else {
        if (!(type3 in set4._items)) {
          if (shouldAdd) {
            set4._items[type3] = {};
            set4._items[type3][item] = true;
          }
          return false;
        } else if (item in set4._items[type3]) {
          return true;
        } else {
          if (shouldAdd) {
            set4._items[type3][item] = true;
          }
          return false;
        }
      }
    case "boolean":
      if (type3 in set4._items) {
        var bIdx = item ? 1 : 0;
        if (set4._items[type3][bIdx]) {
          return true;
        } else {
          if (shouldAdd) {
            set4._items[type3][bIdx] = true;
          }
          return false;
        }
      } else {
        if (shouldAdd) {
          set4._items[type3] = item ? [false, true] : [true, false];
        }
        return false;
      }
    case "function":
      if (set4._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set4._nativeSet.size;
          set4._nativeSet.add(item);
          newSize = set4._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set4._nativeSet.has(item);
        }
      } else {
        if (!(type3 in set4._items)) {
          if (shouldAdd) {
            set4._items[type3] = [item];
          }
          return false;
        }
        if (!_includes(item, set4._items[type3])) {
          if (shouldAdd) {
            set4._items[type3].push(item);
          }
          return false;
        }
        return true;
      }
    case "undefined":
      if (set4._items[type3]) {
        return true;
      } else {
        if (shouldAdd) {
          set4._items[type3] = true;
        }
        return false;
      }
    case "object":
      if (item === null) {
        if (!set4._items["null"]) {
          if (shouldAdd) {
            set4._items["null"] = true;
          }
          return false;
        }
        return true;
      }
    default:
      type3 = Object.prototype.toString.call(item);
      if (!(type3 in set4._items)) {
        if (shouldAdd) {
          set4._items[type3] = [item];
        }
        return false;
      }
      if (!_includes(item, set4._items[type3])) {
        if (shouldAdd) {
          set4._items[type3].push(item);
        }
        return false;
      }
      return true;
  }
}
var difference = /* @__PURE__ */ _curry2(function difference2(first, second2) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  var secondLen = second2.length;
  var toFilterOut = new _Set$1();
  for (var i = 0; i < secondLen; i += 1) {
    toFilterOut.add(second2[i]);
  }
  while (idx < firstLen) {
    if (toFilterOut.add(first[idx])) {
      out[out.length] = first[idx];
    }
    idx += 1;
  }
  return out;
});
const difference$1 = difference;
var differenceWith = /* @__PURE__ */ _curry3(function differenceWith2(pred, first, second2) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  while (idx < firstLen) {
    if (!_includesWith(pred, first[idx], second2) && !_includesWith(pred, first[idx], out)) {
      out.push(first[idx]);
    }
    idx += 1;
  }
  return out;
});
const differenceWith$1 = differenceWith;
var remove$1 = /* @__PURE__ */ _curry3(function remove(start, count2, list) {
  var result = Array.prototype.slice.call(list, 0);
  result.splice(start, count2);
  return result;
});
const remove$2 = remove$1;
function _dissoc(prop3, obj) {
  if (obj == null) {
    return obj;
  }
  if (_isInteger(prop3) && _isArray$1(obj)) {
    return remove$2(prop3, 1, obj);
  }
  var result = {};
  for (var p2 in obj) {
    result[p2] = obj[p2];
  }
  delete result[prop3];
  return result;
}
function _shallowCloneObject(prop3, obj) {
  if (_isInteger(prop3) && _isArray$1(obj)) {
    return [].concat(obj);
  }
  var result = {};
  for (var p2 in obj) {
    result[p2] = obj[p2];
  }
  return result;
}
var dissocPath = /* @__PURE__ */ _curry2(function dissocPath2(path3, obj) {
  if (obj == null) {
    return obj;
  }
  switch (path3.length) {
    case 0:
      return obj;
    case 1:
      return _dissoc(path3[0], obj);
    default:
      var head2 = path3[0];
      var tail2 = Array.prototype.slice.call(path3, 1);
      if (obj[head2] == null) {
        return _shallowCloneObject(head2, obj);
      } else {
        return assoc$1(head2, dissocPath2(tail2, obj[head2]), obj);
      }
  }
});
const dissocPath$1 = dissocPath;
var dissoc = /* @__PURE__ */ _curry2(function dissoc2(prop3, obj) {
  return dissocPath$1([prop3], obj);
});
const dissoc$1 = dissoc;
var divide$1 = /* @__PURE__ */ _curry2(function divide(a2, b2) {
  return a2 / b2;
});
const divide$2 = divide$1;
var XDrop = /* @__PURE__ */ function() {
  function XDrop2(n2, xf2) {
    this.xf = xf2;
    this.n = n2;
  }
  XDrop2.prototype["@@transducer/init"] = _xfBase.init;
  XDrop2.prototype["@@transducer/result"] = _xfBase.result;
  XDrop2.prototype["@@transducer/step"] = function(result, input) {
    if (this.n > 0) {
      this.n -= 1;
      return result;
    }
    return this.xf["@@transducer/step"](result, input);
  };
  return XDrop2;
}();
function _xdrop(n2) {
  return function(xf2) {
    return new XDrop(n2, xf2);
  };
}
var drop = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable(["drop"], _xdrop, function drop2(n2, xs2) {
    return slice$1(Math.max(0, n2), Infinity, xs2);
  })
);
const drop$1 = drop;
var XTake = /* @__PURE__ */ function() {
  function XTake2(n2, xf2) {
    this.xf = xf2;
    this.n = n2;
    this.i = 0;
  }
  XTake2.prototype["@@transducer/init"] = _xfBase.init;
  XTake2.prototype["@@transducer/result"] = _xfBase.result;
  XTake2.prototype["@@transducer/step"] = function(result, input) {
    this.i += 1;
    var ret = this.n === 0 ? result : this.xf["@@transducer/step"](result, input);
    return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
  };
  return XTake2;
}();
function _xtake(n2) {
  return function(xf2) {
    return new XTake(n2, xf2);
  };
}
var take$2 = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable(["take"], _xtake, function take(n2, xs2) {
    return slice$1(0, n2 < 0 ? Infinity : n2, xs2);
  })
);
const take$3 = take$2;
function dropLast$2(n2, xs2) {
  return take$3(n2 < xs2.length ? xs2.length - n2 : 0, xs2);
}
var XDropLast = /* @__PURE__ */ function() {
  function XDropLast2(n2, xf2) {
    if (n2 <= 0) {
      return xf2;
    }
    this.xf = xf2;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n2);
  }
  XDropLast2.prototype["@@transducer/init"] = _xfBase.init;
  XDropLast2.prototype["@@transducer/result"] = function(result) {
    this.acc = null;
    return this.xf["@@transducer/result"](result);
  };
  XDropLast2.prototype["@@transducer/step"] = function(result, input) {
    if (this.full) {
      result = this.xf["@@transducer/step"](result, this.acc[this.pos]);
    }
    this.store(input);
    return result;
  };
  XDropLast2.prototype.store = function(input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };
  return XDropLast2;
}();
function _xdropLast(n2) {
  return function(xf2) {
    return new XDropLast(n2, xf2);
  };
}
var dropLast = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable([], _xdropLast, dropLast$2)
);
const dropLast$1 = dropLast;
function dropLastWhile$2(pred, xs2) {
  var idx = xs2.length - 1;
  while (idx >= 0 && pred(xs2[idx])) {
    idx -= 1;
  }
  return slice$1(0, idx + 1, xs2);
}
var XDropLastWhile = /* @__PURE__ */ function() {
  function XDropLastWhile2(fn2, xf2) {
    this.f = fn2;
    this.retained = [];
    this.xf = xf2;
  }
  XDropLastWhile2.prototype["@@transducer/init"] = _xfBase.init;
  XDropLastWhile2.prototype["@@transducer/result"] = function(result) {
    this.retained = null;
    return this.xf["@@transducer/result"](result);
  };
  XDropLastWhile2.prototype["@@transducer/step"] = function(result, input) {
    return this.f(input) ? this.retain(result, input) : this.flush(result, input);
  };
  XDropLastWhile2.prototype.flush = function(result, input) {
    result = _xReduce(this.xf, result, this.retained);
    this.retained = [];
    return this.xf["@@transducer/step"](result, input);
  };
  XDropLastWhile2.prototype.retain = function(result, input) {
    this.retained.push(input);
    return result;
  };
  return XDropLastWhile2;
}();
function _xdropLastWhile(fn2) {
  return function(xf2) {
    return new XDropLastWhile(fn2, xf2);
  };
}
var dropLastWhile = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable([], _xdropLastWhile, dropLastWhile$2)
);
const dropLastWhile$1 = dropLastWhile;
var XDropRepeatsWith = /* @__PURE__ */ function() {
  function XDropRepeatsWith2(pred, xf2) {
    this.xf = xf2;
    this.pred = pred;
    this.lastValue = void 0;
    this.seenFirstValue = false;
  }
  XDropRepeatsWith2.prototype["@@transducer/init"] = _xfBase.init;
  XDropRepeatsWith2.prototype["@@transducer/result"] = _xfBase.result;
  XDropRepeatsWith2.prototype["@@transducer/step"] = function(result, input) {
    var sameAsLast = false;
    if (!this.seenFirstValue) {
      this.seenFirstValue = true;
    } else if (this.pred(this.lastValue, input)) {
      sameAsLast = true;
    }
    this.lastValue = input;
    return sameAsLast ? result : this.xf["@@transducer/step"](result, input);
  };
  return XDropRepeatsWith2;
}();
function _xdropRepeatsWith(pred) {
  return function(xf2) {
    return new XDropRepeatsWith(pred, xf2);
  };
}
var last$1 = /* @__PURE__ */ nth$1(-1);
const last$2 = last$1;
var dropRepeatsWith = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable([], _xdropRepeatsWith, function dropRepeatsWith2(pred, list) {
    var result = [];
    var idx = 1;
    var len = list.length;
    if (len !== 0) {
      result[0] = list[0];
      while (idx < len) {
        if (!pred(last$2(result), list[idx])) {
          result[result.length] = list[idx];
        }
        idx += 1;
      }
    }
    return result;
  })
);
const dropRepeatsWith$1 = dropRepeatsWith;
var dropRepeats = /* @__PURE__ */ _curry1(
  /* @__PURE__ */ _dispatchable(
    [],
    function() {
      return _xdropRepeatsWith(equals$1);
    },
    /* @__PURE__ */ dropRepeatsWith$1(equals$1)
  )
);
const dropRepeats$1 = dropRepeats;
var eqBy = /* @__PURE__ */ _curry3(function eqBy2(f2, x2, y2) {
  return equals$1(f2(x2), f2(y2));
});
const eqBy$1 = eqBy;
var dropRepeatsBy = /* @__PURE__ */ _curry2(function(fn2, list) {
  return _dispatchable([], function() {
    return _xdropRepeatsWith(eqBy$1(fn2));
  }, dropRepeatsWith$1(eqBy$1(fn2)))(list);
});
const dropRepeatsBy$1 = dropRepeatsBy;
var XDropWhile = /* @__PURE__ */ function() {
  function XDropWhile2(f2, xf2) {
    this.xf = xf2;
    this.f = f2;
  }
  XDropWhile2.prototype["@@transducer/init"] = _xfBase.init;
  XDropWhile2.prototype["@@transducer/result"] = _xfBase.result;
  XDropWhile2.prototype["@@transducer/step"] = function(result, input) {
    if (this.f) {
      if (this.f(input)) {
        return result;
      }
      this.f = null;
    }
    return this.xf["@@transducer/step"](result, input);
  };
  return XDropWhile2;
}();
function _xdropWhile(f2) {
  return function(xf2) {
    return new XDropWhile(f2, xf2);
  };
}
var dropWhile = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable(["dropWhile"], _xdropWhile, function dropWhile2(pred, xs2) {
    var idx = 0;
    var len = xs2.length;
    while (idx < len && pred(xs2[idx])) {
      idx += 1;
    }
    return slice$1(idx, Infinity, xs2);
  })
);
const dropWhile$1 = dropWhile;
var or = /* @__PURE__ */ _curry2(function or2(a2, b2) {
  return a2 || b2;
});
const or$1 = or;
var either = /* @__PURE__ */ _curry2(function either2(f2, g2) {
  return _isFunction$1(f2) ? function _either() {
    return f2.apply(this, arguments) || g2.apply(this, arguments);
  } : lift$1(or$1)(f2, g2);
});
const either$1 = either;
function _isTypedArray(val) {
  var type3 = Object.prototype.toString.call(val);
  return type3 === "[object Uint8ClampedArray]" || type3 === "[object Int8Array]" || type3 === "[object Uint8Array]" || type3 === "[object Int16Array]" || type3 === "[object Uint16Array]" || type3 === "[object Int32Array]" || type3 === "[object Uint32Array]" || type3 === "[object Float32Array]" || type3 === "[object Float64Array]" || type3 === "[object BigInt64Array]" || type3 === "[object BigUint64Array]";
}
var empty = /* @__PURE__ */ _curry1(function empty2(x2) {
  return x2 != null && typeof x2["fantasy-land/empty"] === "function" ? x2["fantasy-land/empty"]() : x2 != null && x2.constructor != null && typeof x2.constructor["fantasy-land/empty"] === "function" ? x2.constructor["fantasy-land/empty"]() : x2 != null && typeof x2.empty === "function" ? x2.empty() : x2 != null && x2.constructor != null && typeof x2.constructor.empty === "function" ? x2.constructor.empty() : _isArray$1(x2) ? [] : _isString$1(x2) ? "" : _isObject$1(x2) ? {} : _isArguments(x2) ? function() {
    return arguments;
  }() : _isTypedArray(x2) ? x2.constructor.from("") : void 0;
});
const empty$1 = empty;
var takeLast = /* @__PURE__ */ _curry2(function takeLast2(n2, xs2) {
  return drop$1(n2 >= 0 ? xs2.length - n2 : 0, xs2);
});
const takeLast$1 = takeLast;
var endsWith$1 = /* @__PURE__ */ _curry2(function(suffix, list) {
  return equals$1(takeLast$1(suffix.length, list), suffix);
});
const endsWith$2 = endsWith$1;
var eqProps = /* @__PURE__ */ _curry3(function eqProps2(prop3, obj1, obj2) {
  return equals$1(obj1[prop3], obj2[prop3]);
});
const eqProps$1 = eqProps;
var evolve = /* @__PURE__ */ _curry2(function evolve2(transformations, object2) {
  if (!_isObject$1(object2) && !_isArray$1(object2)) {
    return object2;
  }
  var result = object2 instanceof Array ? [] : {};
  var transformation, key, type3;
  for (key in object2) {
    transformation = transformations[key];
    type3 = typeof transformation;
    result[key] = type3 === "function" ? transformation(object2[key]) : transformation && type3 === "object" ? evolve2(transformation, object2[key]) : object2[key];
  }
  return result;
});
const evolve$1 = evolve;
var XFind = /* @__PURE__ */ function() {
  function XFind2(f2, xf2) {
    this.xf = xf2;
    this.f = f2;
    this.found = false;
  }
  XFind2.prototype["@@transducer/init"] = _xfBase.init;
  XFind2.prototype["@@transducer/result"] = function(result) {
    if (!this.found) {
      result = this.xf["@@transducer/step"](result, void 0);
    }
    return this.xf["@@transducer/result"](result);
  };
  XFind2.prototype["@@transducer/step"] = function(result, input) {
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf["@@transducer/step"](result, input));
    }
    return result;
  };
  return XFind2;
}();
function _xfind(f2) {
  return function(xf2) {
    return new XFind(f2, xf2);
  };
}
var find$1 = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable(["find"], _xfind, function find(fn2, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (fn2(list[idx])) {
        return list[idx];
      }
      idx += 1;
    }
  })
);
const find$2 = find$1;
var XFindIndex = /* @__PURE__ */ function() {
  function XFindIndex2(f2, xf2) {
    this.xf = xf2;
    this.f = f2;
    this.idx = -1;
    this.found = false;
  }
  XFindIndex2.prototype["@@transducer/init"] = _xfBase.init;
  XFindIndex2.prototype["@@transducer/result"] = function(result) {
    if (!this.found) {
      result = this.xf["@@transducer/step"](result, -1);
    }
    return this.xf["@@transducer/result"](result);
  };
  XFindIndex2.prototype["@@transducer/step"] = function(result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf["@@transducer/step"](result, this.idx));
    }
    return result;
  };
  return XFindIndex2;
}();
function _xfindIndex(f2) {
  return function(xf2) {
    return new XFindIndex(f2, xf2);
  };
}
var findIndex$2 = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable([], _xfindIndex, function findIndex(fn2, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (fn2(list[idx])) {
        return idx;
      }
      idx += 1;
    }
    return -1;
  })
);
const findIndex$3 = findIndex$2;
var XFindLast = /* @__PURE__ */ function() {
  function XFindLast2(f2, xf2) {
    this.xf = xf2;
    this.f = f2;
  }
  XFindLast2.prototype["@@transducer/init"] = _xfBase.init;
  XFindLast2.prototype["@@transducer/result"] = function(result) {
    return this.xf["@@transducer/result"](this.xf["@@transducer/step"](result, this.last));
  };
  XFindLast2.prototype["@@transducer/step"] = function(result, input) {
    if (this.f(input)) {
      this.last = input;
    }
    return result;
  };
  return XFindLast2;
}();
function _xfindLast(f2) {
  return function(xf2) {
    return new XFindLast(f2, xf2);
  };
}
var findLast = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable([], _xfindLast, function findLast2(fn2, list) {
    var idx = list.length - 1;
    while (idx >= 0) {
      if (fn2(list[idx])) {
        return list[idx];
      }
      idx -= 1;
    }
  })
);
const findLast$1 = findLast;
var XFindLastIndex = /* @__PURE__ */ function() {
  function XFindLastIndex2(f2, xf2) {
    this.xf = xf2;
    this.f = f2;
    this.idx = -1;
    this.lastIdx = -1;
  }
  XFindLastIndex2.prototype["@@transducer/init"] = _xfBase.init;
  XFindLastIndex2.prototype["@@transducer/result"] = function(result) {
    return this.xf["@@transducer/result"](this.xf["@@transducer/step"](result, this.lastIdx));
  };
  XFindLastIndex2.prototype["@@transducer/step"] = function(result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.lastIdx = this.idx;
    }
    return result;
  };
  return XFindLastIndex2;
}();
function _xfindLastIndex(f2) {
  return function(xf2) {
    return new XFindLastIndex(f2, xf2);
  };
}
var findLastIndex = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable([], _xfindLastIndex, function findLastIndex2(fn2, list) {
    var idx = list.length - 1;
    while (idx >= 0) {
      if (fn2(list[idx])) {
        return idx;
      }
      idx -= 1;
    }
    return -1;
  })
);
const findLastIndex$1 = findLastIndex;
var flatten = /* @__PURE__ */ _curry1(
  /* @__PURE__ */ _makeFlat(true)
);
const flatten$1 = flatten;
var flip$1 = /* @__PURE__ */ _curry1(function flip(fn2) {
  return curryN$2(fn2.length, function(a2, b2) {
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = b2;
    args[1] = a2;
    return fn2.apply(this, args);
  });
});
const flip$2 = flip$1;
var forEach$1 = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _checkForMethod("forEach", function forEach(fn2, list) {
    var len = list.length;
    var idx = 0;
    while (idx < len) {
      fn2(list[idx]);
      idx += 1;
    }
    return list;
  })
);
const forEach$2 = forEach$1;
var forEachObjIndexed = /* @__PURE__ */ _curry2(function forEachObjIndexed2(fn2, obj) {
  var keyList = keys$7(obj);
  var idx = 0;
  while (idx < keyList.length) {
    var key = keyList[idx];
    fn2(obj[key], key, obj);
    idx += 1;
  }
  return obj;
});
const forEachObjIndexed$1 = forEachObjIndexed;
var fromPairs = /* @__PURE__ */ _curry1(function fromPairs2(pairs) {
  var result = {};
  var idx = 0;
  while (idx < pairs.length) {
    result[pairs[idx][0]] = pairs[idx][1];
    idx += 1;
  }
  return result;
});
const fromPairs$1 = fromPairs;
var groupBy = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _checkForMethod(
    "groupBy",
    /* @__PURE__ */ reduceBy$1(function(acc, item) {
      acc.push(item);
      return acc;
    }, [])
  )
);
const groupBy$1 = groupBy;
var groupWith = /* @__PURE__ */ _curry2(function(fn2, list) {
  var res = [];
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    var nextidx = idx + 1;
    while (nextidx < len && fn2(list[nextidx - 1], list[nextidx])) {
      nextidx += 1;
    }
    res.push(list.slice(idx, nextidx));
    idx = nextidx;
  }
  return res;
});
const groupWith$1 = groupWith;
var gt$1 = /* @__PURE__ */ _curry2(function gt(a2, b2) {
  return a2 > b2;
});
const gt$2 = gt$1;
var gte = /* @__PURE__ */ _curry2(function gte2(a2, b2) {
  return a2 >= b2;
});
const gte$1 = gte;
var hasPath$2 = /* @__PURE__ */ _curry2(function hasPath(_path, obj) {
  if (_path.length === 0 || isNil$2(obj)) {
    return false;
  }
  var val = obj;
  var idx = 0;
  while (idx < _path.length) {
    if (!isNil$2(val) && _has(_path[idx], val)) {
      val = val[_path[idx]];
      idx += 1;
    } else {
      return false;
    }
  }
  return true;
});
const hasPath$3 = hasPath$2;
var has = /* @__PURE__ */ _curry2(function has2(prop3, obj) {
  return hasPath$3([prop3], obj);
});
const has$1 = has;
var hasIn$2 = /* @__PURE__ */ _curry2(function hasIn(prop3, obj) {
  if (isNil$2(obj)) {
    return false;
  }
  return prop3 in obj;
});
const hasIn$3 = hasIn$2;
var identical = function(a2, b2) {
  switch (arguments.length) {
    case 0:
      return identical;
    case 1:
      return function() {
        return function unaryIdentical(_b) {
          switch (arguments.length) {
            case 0:
              return unaryIdentical;
            default:
              return _objectIs$1(a2, _b);
          }
        };
      }();
    default:
      return _objectIs$1(a2, b2);
  }
};
const identical$1 = identical;
var ifElse = /* @__PURE__ */ _curry3(function ifElse2(condition, onTrue, onFalse) {
  return curryN$2(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
    return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
  });
});
const ifElse$1 = ifElse;
var inc = /* @__PURE__ */ add$3(1);
const inc$1 = inc;
var includes = /* @__PURE__ */ _curry2(_includes);
const includes$1 = includes;
var indexBy = /* @__PURE__ */ reduceBy$1(function(acc, elem) {
  return elem;
}, null);
const indexBy$1 = indexBy;
var indexOf$1 = /* @__PURE__ */ _curry2(function indexOf(target, xs2) {
  return typeof xs2.indexOf === "function" && !_isArray$1(xs2) ? xs2.indexOf(target) : _indexOf(xs2, target, 0);
});
const indexOf$2 = indexOf$1;
var init = /* @__PURE__ */ slice$1(0, -1);
const init$1 = init;
var innerJoin = /* @__PURE__ */ _curry3(function innerJoin2(pred, xs2, ys2) {
  return _filter(function(x2) {
    return _includesWith(pred, x2, ys2);
  }, xs2);
});
const innerJoin$1 = innerJoin;
var insert = /* @__PURE__ */ _curry3(function insert2(idx, elt, list) {
  idx = idx < list.length && idx >= 0 ? idx : list.length;
  var result = Array.prototype.slice.call(list, 0);
  result.splice(idx, 0, elt);
  return result;
});
const insert$1 = insert;
var insertAll = /* @__PURE__ */ _curry3(function insertAll2(idx, elts, list) {
  idx = idx < list.length && idx >= 0 ? idx : list.length;
  return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
});
const insertAll$1 = insertAll;
var XUniqBy = /* @__PURE__ */ function() {
  function XUniqBy2(f2, xf2) {
    this.xf = xf2;
    this.f = f2;
    this.set = new _Set$1();
  }
  XUniqBy2.prototype["@@transducer/init"] = _xfBase.init;
  XUniqBy2.prototype["@@transducer/result"] = _xfBase.result;
  XUniqBy2.prototype["@@transducer/step"] = function(result, input) {
    return this.set.add(this.f(input)) ? this.xf["@@transducer/step"](result, input) : result;
  };
  return XUniqBy2;
}();
function _xuniqBy(f2) {
  return function(xf2) {
    return new XUniqBy(f2, xf2);
  };
}
var uniqBy$1 = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable([], _xuniqBy, function(fn2, list) {
    var set4 = new _Set$1();
    var result = [];
    var idx = 0;
    var appliedItem, item;
    while (idx < list.length) {
      item = list[idx];
      appliedItem = fn2(item);
      if (set4.add(appliedItem)) {
        result.push(item);
      }
      idx += 1;
    }
    return result;
  })
);
const uniqBy$2 = uniqBy$1;
var uniq = /* @__PURE__ */ uniqBy$2(identity$e);
const uniq$1 = uniq;
var intersection = /* @__PURE__ */ _curry2(function intersection2(list1, list2) {
  var toKeep = new _Set$1();
  for (var i = 0; i < list1.length; i += 1) {
    toKeep.add(list1[i]);
  }
  return uniq$1(_filter(toKeep.has.bind(toKeep), list2));
});
const intersection$1 = intersection;
var intersperse = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _checkForMethod("intersperse", function intersperse2(separator, list) {
    var out = [];
    var idx = 0;
    var length3 = list.length;
    while (idx < length3) {
      if (idx === length3 - 1) {
        out.push(list[idx]);
      } else {
        out.push(list[idx], separator);
      }
      idx += 1;
    }
    return out;
  })
);
const intersperse$1 = intersperse;
function _objectAssign(target) {
  if (target == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  var output = Object(target);
  var idx = 1;
  var length3 = arguments.length;
  while (idx < length3) {
    var source = arguments[idx];
    if (source != null) {
      for (var nextKey in source) {
        if (_has(nextKey, source)) {
          output[nextKey] = source[nextKey];
        }
      }
    }
    idx += 1;
  }
  return output;
}
const _objectAssign$1 = typeof Object.assign === "function" ? Object.assign : _objectAssign;
var objOf = /* @__PURE__ */ _curry2(function objOf2(key, val) {
  var obj = {};
  obj[key] = val;
  return obj;
});
const objOf$1 = objOf;
var _stepCatArray = {
  "@@transducer/init": Array,
  "@@transducer/step": function(xs2, x2) {
    xs2.push(x2);
    return xs2;
  },
  "@@transducer/result": _identity
};
var _stepCatString = {
  "@@transducer/init": String,
  "@@transducer/step": function(a2, b2) {
    return a2 + b2;
  },
  "@@transducer/result": _identity
};
var _stepCatObject = {
  "@@transducer/init": Object,
  "@@transducer/step": function(result, input) {
    return _objectAssign$1(result, _isArrayLike(input) ? objOf$1(input[0], input[1]) : input);
  },
  "@@transducer/result": _identity
};
function _stepCat(obj) {
  if (_isTransformer(obj)) {
    return obj;
  }
  if (_isArrayLike(obj)) {
    return _stepCatArray;
  }
  if (typeof obj === "string") {
    return _stepCatString;
  }
  if (typeof obj === "object") {
    return _stepCatObject;
  }
  throw new Error("Cannot create transformer for " + obj);
}
var into = /* @__PURE__ */ _curry3(function into2(acc, transducer, list) {
  var xf2 = transducer(_isTransformer(acc) ? acc : _stepCat(acc));
  return _xReduce(xf2, xf2["@@transducer/init"](), list);
});
const into$1 = into;
var invert = /* @__PURE__ */ _curry1(function invert2(obj) {
  var props3 = keys$7(obj);
  var len = props3.length;
  var idx = 0;
  var out = {};
  while (idx < len) {
    var key = props3[idx];
    var val = obj[key];
    var list = _has(val, out) ? out[val] : out[val] = [];
    list[list.length] = key;
    idx += 1;
  }
  return out;
});
const invert$1 = invert;
var invertObj = /* @__PURE__ */ _curry1(function invertObj2(obj) {
  var props3 = keys$7(obj);
  var len = props3.length;
  var idx = 0;
  var out = {};
  while (idx < len) {
    var key = props3[idx];
    out[obj[key]] = key;
    idx += 1;
  }
  return out;
});
const invertObj$1 = invertObj;
var invoker = /* @__PURE__ */ _curry2(function invoker2(arity, method) {
  return curryN$2(arity + 1, function() {
    var target = arguments[arity];
    if (target != null && _isFunction$1(target[method])) {
      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
    }
    throw new TypeError(toString$9(target) + ' does not have a method named "' + method + '"');
  });
});
const invoker$1 = invoker;
var is$2 = /* @__PURE__ */ _curry2(function is(Ctor, val) {
  return val instanceof Ctor || val != null && (val.constructor === Ctor || Ctor.name === "Object" && typeof val === "object");
});
const is$3 = is$2;
var isEmpty = /* @__PURE__ */ _curry1(function isEmpty2(x2) {
  return x2 != null && equals$1(x2, empty$1(x2));
});
const isEmpty$1 = isEmpty;
var isNotNil = /* @__PURE__ */ _curry1(function isNotNil2(x2) {
  return !isNil$2(x2);
});
const isNotNil$1 = isNotNil;
var join = /* @__PURE__ */ invoker$1(1, "join");
const join$1 = join;
var juxt = /* @__PURE__ */ _curry1(function juxt2(fns) {
  return converge$1(function() {
    return Array.prototype.slice.call(arguments, 0);
  }, fns);
});
const juxt$1 = juxt;
var keysIn = /* @__PURE__ */ _curry1(function keysIn2(obj) {
  var prop3;
  var ks2 = [];
  for (prop3 in obj) {
    ks2[ks2.length] = prop3;
  }
  return ks2;
});
const keysIn$1 = keysIn;
var lastIndexOf = /* @__PURE__ */ _curry2(function lastIndexOf2(target, xs2) {
  if (typeof xs2.lastIndexOf === "function" && !_isArray$1(xs2)) {
    return xs2.lastIndexOf(target);
  } else {
    var idx = xs2.length - 1;
    while (idx >= 0) {
      if (equals$1(xs2[idx], target)) {
        return idx;
      }
      idx -= 1;
    }
    return -1;
  }
});
const lastIndexOf$1 = lastIndexOf;
function _isNumber$1(x2) {
  return Object.prototype.toString.call(x2) === "[object Number]";
}
var length = /* @__PURE__ */ _curry1(function length2(list) {
  return list != null && _isNumber$1(list.length) ? list.length : NaN;
});
const length$1 = length;
var lens = /* @__PURE__ */ _curry2(function lens2(getter, setter) {
  return function(toFunctorFn) {
    return function(target) {
      return map$6(function(focus) {
        return setter(focus, target);
      }, toFunctorFn(getter(target)));
    };
  };
});
const lens$1 = lens;
var update$1 = /* @__PURE__ */ _curry3(function update(idx, x2, list) {
  return adjust$1(idx, always$1(x2), list);
});
const update$2 = update$1;
var lensIndex = /* @__PURE__ */ _curry1(function lensIndex2(n2) {
  return lens$1(nth$1(n2), update$2(n2));
});
const lensIndex$1 = lensIndex;
var paths = /* @__PURE__ */ _curry2(function paths2(pathsArray, obj) {
  return pathsArray.map(function(paths3) {
    var val = obj;
    var idx = 0;
    var p2;
    while (idx < paths3.length) {
      if (val == null) {
        return;
      }
      p2 = paths3[idx];
      val = _isInteger(p2) ? nth$1(p2, val) : val[p2];
      idx += 1;
    }
    return val;
  });
});
const paths$1 = paths;
var path = /* @__PURE__ */ _curry2(function path2(pathAr, obj) {
  return paths$1([pathAr], obj)[0];
});
const path$1 = path;
var lensPath = /* @__PURE__ */ _curry1(function lensPath2(p2) {
  return lens$1(path$1(p2), assocPath$1(p2));
});
const lensPath$1 = lensPath;
var lensProp = /* @__PURE__ */ _curry1(function lensProp2(k2) {
  return lens$1(prop$1(k2), assoc$1(k2));
});
const lensProp$1 = lensProp;
var lt$1 = /* @__PURE__ */ _curry2(function lt(a2, b2) {
  return a2 < b2;
});
const lt$2 = lt$1;
var lte = /* @__PURE__ */ _curry2(function lte2(a2, b2) {
  return a2 <= b2;
});
const lte$1 = lte;
var mapAccum = /* @__PURE__ */ _curry3(function mapAccum2(fn2, acc, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  var tuple = [acc];
  while (idx < len) {
    tuple = fn2(tuple[0], list[idx]);
    result[idx] = tuple[1];
    idx += 1;
  }
  return [tuple[0], result];
});
const mapAccum$1 = mapAccum;
var mapAccumRight = /* @__PURE__ */ _curry3(function mapAccumRight2(fn2, acc, list) {
  var idx = list.length - 1;
  var result = [];
  var tuple = [acc];
  while (idx >= 0) {
    tuple = fn2(tuple[0], list[idx]);
    result[idx] = tuple[1];
    idx -= 1;
  }
  return [tuple[0], result];
});
const mapAccumRight$1 = mapAccumRight;
var mapObjIndexed = /* @__PURE__ */ _curry2(function mapObjIndexed2(fn2, obj) {
  return _arrayReduce(function(acc, key) {
    acc[key] = fn2(obj[key], key, obj);
    return acc;
  }, {}, keys$7(obj));
});
const mapObjIndexed$1 = mapObjIndexed;
var match$1 = /* @__PURE__ */ _curry2(function match(rx, str) {
  return str.match(rx) || [];
});
const match$2 = match$1;
var mathMod = /* @__PURE__ */ _curry2(function mathMod2(m2, p2) {
  if (!_isInteger(m2)) {
    return NaN;
  }
  if (!_isInteger(p2) || p2 < 1) {
    return NaN;
  }
  return (m2 % p2 + p2) % p2;
});
const mathMod$1 = mathMod;
var maxBy = /* @__PURE__ */ _curry3(function maxBy2(f2, a2, b2) {
  var resultB = f2(b2);
  return max$4(f2(a2), resultB) === resultB ? b2 : a2;
});
const maxBy$1 = maxBy;
var sum = /* @__PURE__ */ reduce$2(add$3, 0);
const sum$1 = sum;
var mean = /* @__PURE__ */ _curry1(function mean2(list) {
  return sum$1(list) / list.length;
});
const mean$1 = mean;
var median = /* @__PURE__ */ _curry1(function median2(list) {
  var len = list.length;
  if (len === 0) {
    return NaN;
  }
  var width = 2 - len % 2;
  var idx = (len - width) / 2;
  return mean$1(Array.prototype.slice.call(list, 0).sort(function(a2, b2) {
    return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
  }).slice(idx, idx + width));
});
const median$1 = median;
var memoizeWith = /* @__PURE__ */ _curry2(function memoizeWith2(keyGen, fn2) {
  var cache2 = {};
  return _arity(fn2.length, function() {
    var key = keyGen.apply(this, arguments);
    if (!_has(key, cache2)) {
      cache2[key] = fn2.apply(this, arguments);
    }
    return cache2[key];
  });
});
const memoizeWith$1 = memoizeWith;
var mergeAll = /* @__PURE__ */ _curry1(function mergeAll2(list) {
  return _objectAssign$1.apply(null, [{}].concat(list));
});
const mergeAll$1 = mergeAll;
var mergeWithKey = /* @__PURE__ */ _curry3(function mergeWithKey2(fn2, l2, r2) {
  var result = {};
  var k2;
  l2 = l2 || {};
  r2 = r2 || {};
  for (k2 in l2) {
    if (_has(k2, l2)) {
      result[k2] = _has(k2, r2) ? fn2(k2, l2[k2], r2[k2]) : l2[k2];
    }
  }
  for (k2 in r2) {
    if (_has(k2, r2) && !_has(k2, result)) {
      result[k2] = r2[k2];
    }
  }
  return result;
});
const mergeWithKey$1 = mergeWithKey;
var mergeDeepWithKey = /* @__PURE__ */ _curry3(function mergeDeepWithKey2(fn2, lObj, rObj) {
  return mergeWithKey$1(function(k2, lVal, rVal) {
    if (_isObject$1(lVal) && _isObject$1(rVal)) {
      return mergeDeepWithKey2(fn2, lVal, rVal);
    } else {
      return fn2(k2, lVal, rVal);
    }
  }, lObj, rObj);
});
const mergeDeepWithKey$1 = mergeDeepWithKey;
var mergeDeepLeft = /* @__PURE__ */ _curry2(function mergeDeepLeft2(lObj, rObj) {
  return mergeDeepWithKey$1(function(k2, lVal, rVal) {
    return lVal;
  }, lObj, rObj);
});
const mergeDeepLeft$1 = mergeDeepLeft;
var mergeDeepRight = /* @__PURE__ */ _curry2(function mergeDeepRight2(lObj, rObj) {
  return mergeDeepWithKey$1(function(k2, lVal, rVal) {
    return rVal;
  }, lObj, rObj);
});
const mergeDeepRight$1 = mergeDeepRight;
var mergeDeepWith = /* @__PURE__ */ _curry3(function mergeDeepWith2(fn2, lObj, rObj) {
  return mergeDeepWithKey$1(function(k2, lVal, rVal) {
    return fn2(lVal, rVal);
  }, lObj, rObj);
});
const mergeDeepWith$1 = mergeDeepWith;
var mergeLeft = /* @__PURE__ */ _curry2(function mergeLeft2(l2, r2) {
  return _objectAssign$1({}, r2, l2);
});
const mergeLeft$1 = mergeLeft;
var mergeRight = /* @__PURE__ */ _curry2(function mergeRight2(l2, r2) {
  return _objectAssign$1({}, l2, r2);
});
const mergeRight$1 = mergeRight;
var mergeWith = /* @__PURE__ */ _curry3(function mergeWith2(fn2, l2, r2) {
  return mergeWithKey$1(function(_2, _l, _r) {
    return fn2(_l, _r);
  }, l2, r2);
});
const mergeWith$1 = mergeWith;
var min$3 = /* @__PURE__ */ _curry2(function min(a2, b2) {
  if (a2 === b2) {
    return a2;
  }
  function safeMin(x2, y2) {
    if (x2 < y2 !== y2 < x2) {
      return y2 < x2 ? y2 : x2;
    }
    return void 0;
  }
  var minByValue = safeMin(a2, b2);
  if (minByValue !== void 0) {
    return minByValue;
  }
  var minByType = safeMin(typeof a2, typeof b2);
  if (minByType !== void 0) {
    return minByType === typeof a2 ? a2 : b2;
  }
  var stringA = toString$9(a2);
  var minByStringValue = safeMin(stringA, toString$9(b2));
  if (minByStringValue !== void 0) {
    return minByStringValue === stringA ? a2 : b2;
  }
  return a2;
});
const min$4 = min$3;
var minBy = /* @__PURE__ */ _curry3(function minBy2(f2, a2, b2) {
  var resultB = f2(b2);
  return min$4(f2(a2), resultB) === resultB ? b2 : a2;
});
const minBy$1 = minBy;
function _modify(prop3, fn2, obj) {
  if (_isInteger(prop3) && _isArray$1(obj)) {
    var arr = [].concat(obj);
    arr[prop3] = fn2(arr[prop3]);
    return arr;
  }
  var result = {};
  for (var p2 in obj) {
    result[p2] = obj[p2];
  }
  result[prop3] = fn2(result[prop3]);
  return result;
}
var modifyPath = /* @__PURE__ */ _curry3(function modifyPath2(path3, fn2, object2) {
  if (!_isObject$1(object2) && !_isArray$1(object2) || path3.length === 0) {
    return object2;
  }
  var idx = path3[0];
  if (!_has(idx, object2)) {
    return object2;
  }
  if (path3.length === 1) {
    return _modify(idx, fn2, object2);
  }
  var val = modifyPath2(Array.prototype.slice.call(path3, 1), fn2, object2[idx]);
  if (val === object2[idx]) {
    return object2;
  }
  return _assoc(idx, val, object2);
});
const modifyPath$1 = modifyPath;
var modify = /* @__PURE__ */ _curry3(function modify2(prop3, fn2, object2) {
  return modifyPath$1([prop3], fn2, object2);
});
const modify$1 = modify;
var modulo = /* @__PURE__ */ _curry2(function modulo2(a2, b2) {
  return a2 % b2;
});
const modulo$1 = modulo;
var move = /* @__PURE__ */ _curry3(function(from2, to2, list) {
  var length3 = list.length;
  var result = list.slice();
  var positiveFrom = from2 < 0 ? length3 + from2 : from2;
  var positiveTo = to2 < 0 ? length3 + to2 : to2;
  var item = result.splice(positiveFrom, 1);
  return positiveFrom < 0 || positiveFrom >= list.length || positiveTo < 0 || positiveTo >= list.length ? list : [].concat(result.slice(0, positiveTo)).concat(item).concat(result.slice(positiveTo, list.length));
});
const move$1 = move;
var multiply = /* @__PURE__ */ _curry2(function multiply2(a2, b2) {
  return a2 * b2;
});
const multiply$1 = multiply;
var partialObject = /* @__PURE__ */ _curry2((f2, o3) => (props3) => f2.call(globalThis, mergeDeepRight$1(o3, props3)));
const partialObject$1 = partialObject;
var negate = /* @__PURE__ */ _curry1(function negate2(n2) {
  return -n2;
});
const negate$1 = negate;
var none$1 = /* @__PURE__ */ _curry2(function none(fn2, input) {
  return all$1(_complement(fn2), input);
});
const none$2 = none$1;
var nthArg = /* @__PURE__ */ _curry1(function nthArg2(n2) {
  var arity = n2 < 0 ? 1 : n2 + 1;
  return curryN$2(arity, function() {
    return nth$1(n2, arguments);
  });
});
const nthArg$1 = nthArg;
var o = /* @__PURE__ */ _curry3(function o2(f2, g2, x2) {
  return f2(g2(x2));
});
const o$1 = o;
var of$1 = /* @__PURE__ */ _curry2(function of(Ctor, val) {
  return typeof Ctor["fantasy-land/of"] === "function" ? Ctor["fantasy-land/of"](val) : typeof Ctor.of === "function" ? Ctor.of(val) : [val];
});
const of$2 = of$1;
var omit = /* @__PURE__ */ _curry2(function omit2(names, obj) {
  var result = {};
  var index3 = {};
  var idx = 0;
  var len = names.length;
  while (idx < len) {
    index3[names[idx]] = 1;
    idx += 1;
  }
  for (var prop3 in obj) {
    if (!index3.hasOwnProperty(prop3)) {
      result[prop3] = obj[prop3];
    }
  }
  return result;
});
const omit$1 = omit;
var on$1 = /* @__PURE__ */ _curryN(4, [], function on(f2, g2, a2, b2) {
  return f2(g2(a2), g2(b2));
});
const on$2 = on$1;
var once$1 = /* @__PURE__ */ _curry1(function once2(fn2) {
  var called = false;
  var result;
  return _arity(fn2.length, function() {
    if (called) {
      return result;
    }
    called = true;
    result = fn2.apply(this, arguments);
    return result;
  });
});
const once$2 = once$1;
function _assertPromise(name, p2) {
  if (p2 == null || !_isFunction$1(p2.then)) {
    throw new TypeError("`" + name + "` expected a Promise, received " + _toString(p2, []));
  }
}
var otherwise = /* @__PURE__ */ _curry2(function otherwise2(f2, p2) {
  _assertPromise("otherwise", p2);
  return p2.then(null, f2);
});
const otherwise$1 = otherwise;
var Identity = function(x2) {
  return {
    value: x2,
    map: function(f2) {
      return Identity(f2(x2));
    }
  };
};
var over = /* @__PURE__ */ _curry3(function over2(lens3, f2, x2) {
  return lens3(function(y2) {
    return Identity(f2(y2));
  })(x2).value;
});
const over$1 = over;
var pair = /* @__PURE__ */ _curry2(function pair2(fst, snd) {
  return [fst, snd];
});
const pair$1 = pair;
function _createPartialApplicator(concat3) {
  return _curry2(function(fn2, args) {
    return _arity(Math.max(0, fn2.length - args.length), function() {
      return fn2.apply(this, concat3(args, arguments));
    });
  });
}
var partial = /* @__PURE__ */ _createPartialApplicator(_concat);
const partial$1 = partial;
var partialRight = /* @__PURE__ */ _createPartialApplicator(
  /* @__PURE__ */ flip$2(_concat)
);
const partialRight$1 = partialRight;
var partition = /* @__PURE__ */ juxt$1([filter$1, reject$1]);
const partition$1 = partition;
var pathEq = /* @__PURE__ */ _curry3(function pathEq2(val, _path, obj) {
  return equals$1(path$1(_path, obj), val);
});
const pathEq$1 = pathEq;
var pathOr = /* @__PURE__ */ _curry3(function pathOr2(d2, p2, obj) {
  return defaultTo$1(d2, path$1(p2, obj));
});
const pathOr$1 = pathOr;
var pathSatisfies = /* @__PURE__ */ _curry3(function pathSatisfies2(pred, propPath, obj) {
  return pred(path$1(propPath, obj));
});
const pathSatisfies$1 = pathSatisfies;
var pick$1 = /* @__PURE__ */ _curry2(function pick(names, obj) {
  var result = {};
  var idx = 0;
  while (idx < names.length) {
    if (names[idx] in obj) {
      result[names[idx]] = obj[names[idx]];
    }
    idx += 1;
  }
  return result;
});
const pick$2 = pick$1;
var pickAll = /* @__PURE__ */ _curry2(function pickAll2(names, obj) {
  var result = {};
  var idx = 0;
  var len = names.length;
  while (idx < len) {
    var name = names[idx];
    result[name] = obj[name];
    idx += 1;
  }
  return result;
});
const pickAll$1 = pickAll;
var pickBy$1 = /* @__PURE__ */ _curry2(function pickBy(test3, obj) {
  var result = {};
  for (var prop3 in obj) {
    if (test3(obj[prop3], prop3, obj)) {
      result[prop3] = obj[prop3];
    }
  }
  return result;
});
const pickBy$2 = pickBy$1;
var prepend = /* @__PURE__ */ _curry2(function prepend2(el2, list) {
  return _concat([el2], list);
});
const prepend$1 = prepend;
var product = /* @__PURE__ */ reduce$2(multiply$1, 1);
const product$1 = product;
var useWith = /* @__PURE__ */ _curry2(function useWith2(fn2, transformers) {
  return curryN$2(transformers.length, function() {
    var args = [];
    var idx = 0;
    while (idx < transformers.length) {
      args.push(transformers[idx].call(this, arguments[idx]));
      idx += 1;
    }
    return fn2.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
  });
});
const useWith$1 = useWith;
var project = /* @__PURE__ */ useWith$1(_map, [pickAll$1, identity$e]);
const project$1 = project;
function _promap(f2, g2, profunctor) {
  return function(x2) {
    return g2(profunctor(f2(x2)));
  };
}
var XPromap = /* @__PURE__ */ function() {
  function XPromap2(f2, g2, xf2) {
    this.xf = xf2;
    this.f = f2;
    this.g = g2;
  }
  XPromap2.prototype["@@transducer/init"] = _xfBase.init;
  XPromap2.prototype["@@transducer/result"] = _xfBase.result;
  XPromap2.prototype["@@transducer/step"] = function(result, input) {
    return this.xf["@@transducer/step"](result, _promap(this.f, this.g, input));
  };
  return XPromap2;
}();
function _xpromap(f2, g2) {
  return function(xf2) {
    return new XPromap(f2, g2, xf2);
  };
}
var promap = /* @__PURE__ */ _curry3(
  /* @__PURE__ */ _dispatchable(["fantasy-land/promap", "promap"], _xpromap, _promap)
);
const promap$1 = promap;
var propEq = /* @__PURE__ */ _curry3(function propEq2(val, name, obj) {
  return equals$1(val, prop$1(name, obj));
});
const propEq$1 = propEq;
var propIs = /* @__PURE__ */ _curry3(function propIs2(type3, name, obj) {
  return is$3(type3, prop$1(name, obj));
});
const propIs$1 = propIs;
var propOr = /* @__PURE__ */ _curry3(function propOr2(val, p2, obj) {
  return defaultTo$1(val, prop$1(p2, obj));
});
const propOr$1 = propOr;
var propSatisfies = /* @__PURE__ */ _curry3(function propSatisfies2(pred, name, obj) {
  return pred(prop$1(name, obj));
});
const propSatisfies$1 = propSatisfies;
var props = /* @__PURE__ */ _curry2(function props2(ps2, obj) {
  return ps2.map(function(p2) {
    return path$1([p2], obj);
  });
});
const props$1 = props;
var range$3 = /* @__PURE__ */ _curry2(function range(from2, to2) {
  if (!(_isNumber$1(from2) && _isNumber$1(to2))) {
    throw new TypeError("Both arguments to range must be numbers");
  }
  var result = [];
  var n2 = from2;
  while (n2 < to2) {
    result.push(n2);
    n2 += 1;
  }
  return result;
});
const range$4 = range$3;
var reduceRight = /* @__PURE__ */ _curry3(function reduceRight2(fn2, acc, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    acc = fn2(list[idx], acc);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    idx -= 1;
  }
  return acc;
});
const reduceRight$1 = reduceRight;
var reduceWhile = /* @__PURE__ */ _curryN(4, [], function _reduceWhile(pred, fn2, a2, list) {
  var xf2 = _xwrap(function(acc, x2) {
    return pred(acc, x2) ? fn2(acc, x2) : _reduced(acc);
  });
  return _xReduce(xf2, a2, list);
});
const reduceWhile$1 = reduceWhile;
var reduced = /* @__PURE__ */ _curry1(_reduced);
const reduced$1 = reduced;
var times = /* @__PURE__ */ _curry2(function times2(fn2, n2) {
  var len = Number(n2);
  var idx = 0;
  var list;
  if (len < 0 || isNaN(len)) {
    throw new RangeError("n must be a non-negative number");
  }
  list = [];
  while (idx < len) {
    list.push(fn2(idx));
    idx += 1;
  }
  return list;
});
const times$1 = times;
var repeat = /* @__PURE__ */ _curry2(function repeat2(value, n2) {
  return times$1(always$1(value), n2);
});
const repeat$1 = repeat;
var replace$1 = /* @__PURE__ */ _curry3(function replace(regex, replacement, str) {
  return str.replace(regex, replacement);
});
const replace$2 = replace$1;
var tInit = "@@transducer/init";
var tStep = "@@transducer/step";
var XScan = /* @__PURE__ */ function() {
  function XScan2(reducer2, acc, xf2) {
    this.xf = xf2;
    this.f = reducer2;
    this.acc = acc;
  }
  XScan2.prototype[tInit] = function() {
    return this.xf[tStep](this.xf[tInit](), this.acc);
  };
  XScan2.prototype["@@transducer/result"] = _xfBase.result;
  XScan2.prototype[tStep] = function(result, input) {
    if (result["@@transducer/reduced"]) {
      return result;
    }
    this.acc = this.f(this.acc, input);
    return this.xf[tStep](result, this.acc);
  };
  return XScan2;
}();
var _xscan = /* @__PURE__ */ _curry3(function _xscan2(reducer2, acc, xf2) {
  return new XScan(reducer2, acc, xf2);
});
var scan = /* @__PURE__ */ _curry3(
  /* @__PURE__ */ _dispatchable([], _xscan, function scan2(fn2, acc, list) {
    var idx = 0;
    var len = list.length;
    var result = [acc];
    while (idx < len) {
      acc = fn2(acc, list[idx]);
      result[idx + 1] = acc;
      idx += 1;
    }
    return result;
  })
);
const scan$1 = scan;
var sequence = /* @__PURE__ */ _curry2(function sequence2(F2, traversable) {
  var of3 = typeof F2["fantasy-land/of"] === "function" ? F2["fantasy-land/of"] : typeof F2.of === "function" ? F2.of : F2;
  var TypeRep = {
    "fantasy-land/of": of3
  };
  return typeof traversable["fantasy-land/traverse"] === "function" ? traversable["fantasy-land/traverse"](TypeRep, _identity) : typeof traversable.traverse === "function" ? traversable.traverse(TypeRep, _identity) : reduceRight$1(function(x2, acc) {
    return ap$1(map$6(prepend$1, x2), acc);
  }, of3([]), traversable);
});
const sequence$1 = sequence;
var set$2 = /* @__PURE__ */ _curry3(function set(lens3, v2, x2) {
  return over$1(lens3, always$1(v2), x2);
});
const set$3 = set$2;
var sort = /* @__PURE__ */ _curry2(function sort2(comparator3, list) {
  return Array.prototype.slice.call(list, 0).sort(comparator3);
});
const sort$1 = sort;
var sortBy$1 = /* @__PURE__ */ _curry2(function sortBy(fn2, list) {
  return Array.prototype.slice.call(list, 0).sort(function(a2, b2) {
    var aa2 = fn2(a2);
    var bb2 = fn2(b2);
    return aa2 < bb2 ? -1 : aa2 > bb2 ? 1 : 0;
  });
});
const sortBy$2 = sortBy$1;
var sortWith = /* @__PURE__ */ _curry2(function sortWith2(fns, list) {
  return Array.prototype.slice.call(list, 0).sort(function(a2, b2) {
    var result = 0;
    var i = 0;
    while (result === 0 && i < fns.length) {
      result = fns[i](a2, b2);
      i += 1;
    }
    return result;
  });
});
const sortWith$1 = sortWith;
var split = /* @__PURE__ */ invoker$1(1, "split");
const split$1 = split;
var splitAt = /* @__PURE__ */ _curry2(function splitAt2(index3, array3) {
  return [slice$1(0, index3, array3), slice$1(index3, length$1(array3), array3)];
});
const splitAt$1 = splitAt;
var splitEvery = /* @__PURE__ */ _curry2(function splitEvery2(n2, list) {
  if (n2 <= 0) {
    throw new Error("First argument to splitEvery must be a positive integer");
  }
  var result = [];
  var idx = 0;
  while (idx < list.length) {
    result.push(slice$1(idx, idx += n2, list));
  }
  return result;
});
const splitEvery$1 = splitEvery;
var splitWhen = /* @__PURE__ */ _curry2(function splitWhen2(pred, list) {
  var idx = 0;
  var len = list.length;
  var prefix2 = [];
  while (idx < len && !pred(list[idx])) {
    prefix2.push(list[idx]);
    idx += 1;
  }
  return [prefix2, Array.prototype.slice.call(list, idx)];
});
const splitWhen$1 = splitWhen;
var splitWhenever = /* @__PURE__ */ _curryN(2, [], function splitWhenever2(pred, list) {
  var acc = [];
  var curr = [];
  for (var i = 0; i < list.length; i = i + 1) {
    if (!pred(list[i])) {
      curr.push(list[i]);
    }
    if ((i < list.length - 1 && pred(list[i + 1]) || i === list.length - 1) && curr.length > 0) {
      acc.push(curr);
      curr = [];
    }
  }
  return acc;
});
const splitWhenever$1 = splitWhenever;
var startsWith$1 = /* @__PURE__ */ _curry2(function(prefix2, list) {
  return equals$1(take$3(prefix2.length, list), prefix2);
});
const startsWith$2 = startsWith$1;
var subtract$2 = /* @__PURE__ */ _curry2(function subtract(a2, b2) {
  return Number(a2) - Number(b2);
});
const subtract$3 = subtract$2;
var swapObject = function(indexA, indexB, o3) {
  var copy2 = clone$5(o3);
  var properties = Object.getOwnPropertyNames(copy2);
  if (properties.includes(indexA) && properties.includes(indexB)) {
    var tmp = copy2[indexA];
    copy2[indexA] = copy2[indexB];
    copy2[indexB] = tmp;
  }
  return copy2;
};
var swapList = function(indexA, indexB, list) {
  var length3 = list.length;
  var result = list.slice();
  var positiveIndexA = indexA < 0 ? length3 + indexA : indexA;
  var positiveIndexB = indexB < 0 ? length3 + indexB : indexB;
  var positiveMin = Math.min(positiveIndexA, positiveIndexB);
  var positiveMax = Math.max(positiveIndexA, positiveIndexB);
  if (positiveIndexA < 0 || positiveIndexA > length3) {
    return result;
  }
  if (positiveIndexB < 0 || positiveIndexB > length3) {
    return result;
  }
  if (positiveIndexA === positiveIndexB) {
    return result;
  }
  result = [].concat(result.slice(0, positiveMin)).concat(result[positiveMax]).concat(result.slice(positiveMin + 1, positiveMax)).concat(result[positiveMin]).concat(result.slice(positiveMax + 1, length3));
  return result;
};
var swapString = function(indexA, indexB, s2) {
  var result = swapList(indexA, indexB, s2);
  return _isArray$1(result) ? result.join("") : result;
};
var swap$1 = /* @__PURE__ */ _curry3(function(indexA, indexB, o3) {
  if (_isArray$1(o3)) {
    return swapList(indexA, indexB, o3);
  } else if (_isString$1(o3)) {
    return swapString(indexA, indexB, o3);
  } else {
    return swapObject(indexA, indexB, o3);
  }
});
const swap$2 = swap$1;
var symmetricDifference = /* @__PURE__ */ _curry2(function symmetricDifference2(list1, list2) {
  return concat$1(difference$1(list1, list2), difference$1(list2, list1));
});
const symmetricDifference$1 = symmetricDifference;
var symmetricDifferenceWith = /* @__PURE__ */ _curry3(function symmetricDifferenceWith2(pred, list1, list2) {
  return concat$1(differenceWith$1(pred, list1, list2), differenceWith$1(pred, list2, list1));
});
const symmetricDifferenceWith$1 = symmetricDifferenceWith;
var takeLastWhile = /* @__PURE__ */ _curry2(function takeLastWhile2(fn2, xs2) {
  var idx = xs2.length - 1;
  while (idx >= 0 && fn2(xs2[idx])) {
    idx -= 1;
  }
  return slice$1(idx + 1, Infinity, xs2);
});
const takeLastWhile$1 = takeLastWhile;
var XTakeWhile = /* @__PURE__ */ function() {
  function XTakeWhile2(f2, xf2) {
    this.xf = xf2;
    this.f = f2;
  }
  XTakeWhile2.prototype["@@transducer/init"] = _xfBase.init;
  XTakeWhile2.prototype["@@transducer/result"] = _xfBase.result;
  XTakeWhile2.prototype["@@transducer/step"] = function(result, input) {
    return this.f(input) ? this.xf["@@transducer/step"](result, input) : _reduced(result);
  };
  return XTakeWhile2;
}();
function _xtakeWhile(f2) {
  return function(xf2) {
    return new XTakeWhile(f2, xf2);
  };
}
var takeWhile = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable(["takeWhile"], _xtakeWhile, function takeWhile2(fn2, xs2) {
    var idx = 0;
    var len = xs2.length;
    while (idx < len && fn2(xs2[idx])) {
      idx += 1;
    }
    return slice$1(0, idx, xs2);
  })
);
const takeWhile$1 = takeWhile;
var XTap = /* @__PURE__ */ function() {
  function XTap2(f2, xf2) {
    this.xf = xf2;
    this.f = f2;
  }
  XTap2.prototype["@@transducer/init"] = _xfBase.init;
  XTap2.prototype["@@transducer/result"] = _xfBase.result;
  XTap2.prototype["@@transducer/step"] = function(result, input) {
    this.f(input);
    return this.xf["@@transducer/step"](result, input);
  };
  return XTap2;
}();
function _xtap(f2) {
  return function(xf2) {
    return new XTap(f2, xf2);
  };
}
var tap = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable([], _xtap, function tap2(fn2, x2) {
    fn2(x2);
    return x2;
  })
);
const tap$1 = tap;
function _isRegExp(x2) {
  return Object.prototype.toString.call(x2) === "[object RegExp]";
}
var test = /* @__PURE__ */ _curry2(function test2(pattern3, str) {
  if (!_isRegExp(pattern3)) {
    throw new TypeError("test requires a value of type RegExp as its first argument; received " + toString$9(pattern3));
  }
  return _cloneRegExp(pattern3).test(str);
});
const test$1 = test;
var andThen = /* @__PURE__ */ _curry2(function andThen2(f2, p2) {
  _assertPromise("andThen", p2);
  return p2.then(f2);
});
const andThen$1 = andThen;
var toLower$2 = /* @__PURE__ */ invoker$1(0, "toLowerCase");
const toLower$3 = toLower$2;
var toPairs = /* @__PURE__ */ _curry1(function toPairs2(obj) {
  var pairs = [];
  for (var prop3 in obj) {
    if (_has(prop3, obj)) {
      pairs[pairs.length] = [prop3, obj[prop3]];
    }
  }
  return pairs;
});
const toPairs$1 = toPairs;
var toPairsIn = /* @__PURE__ */ _curry1(function toPairsIn2(obj) {
  var pairs = [];
  for (var prop3 in obj) {
    pairs[pairs.length] = [prop3, obj[prop3]];
  }
  return pairs;
});
const toPairsIn$1 = toPairsIn;
var toUpper = /* @__PURE__ */ invoker$1(0, "toUpperCase");
const toUpper$1 = toUpper;
var transduce = /* @__PURE__ */ curryN$2(4, function transduce2(xf2, fn2, acc, list) {
  return _xReduce(xf2(typeof fn2 === "function" ? _xwrap(fn2) : fn2), acc, list);
});
const transduce$1 = transduce;
var transpose = /* @__PURE__ */ _curry1(function transpose2(outerlist) {
  var i = 0;
  var result = [];
  while (i < outerlist.length) {
    var innerlist = outerlist[i];
    var j2 = 0;
    while (j2 < innerlist.length) {
      if (typeof result[j2] === "undefined") {
        result[j2] = [];
      }
      result[j2].push(innerlist[j2]);
      j2 += 1;
    }
    i += 1;
  }
  return result;
});
const transpose$1 = transpose;
var traverse = /* @__PURE__ */ _curry3(function traverse2(F2, f2, traversable) {
  var of3 = typeof F2["fantasy-land/of"] === "function" ? F2["fantasy-land/of"] : typeof F2.of === "function" ? F2.of : F2;
  var TypeRep = {
    "fantasy-land/of": of3
  };
  return typeof traversable["fantasy-land/traverse"] === "function" ? traversable["fantasy-land/traverse"](TypeRep, f2) : typeof traversable.traverse === "function" ? traversable.traverse(TypeRep, f2) : sequence$1(TypeRep, map$6(f2, traversable));
});
const traverse$1 = traverse;
var ws$1 = "	\n\v\f\r \u2028\u2029\uFEFF";
var zeroWidth = "";
var hasProtoTrim = typeof String.prototype.trim === "function";
var trim$1 = !hasProtoTrim || /* @__PURE__ */ ws$1.trim() || !/* @__PURE__ */ zeroWidth.trim() ? /* @__PURE__ */ _curry1(function trim(str) {
  var beginRx = new RegExp("^[" + ws$1 + "][" + ws$1 + "]*");
  var endRx = new RegExp("[" + ws$1 + "][" + ws$1 + "]*$");
  return str.replace(beginRx, "").replace(endRx, "");
}) : /* @__PURE__ */ _curry1(function trim2(str) {
  return str.trim();
});
const trim$2 = trim$1;
var tryCatch = /* @__PURE__ */ _curry2(function _tryCatch(tryer, catcher) {
  return _arity(tryer.length, function() {
    try {
      return tryer.apply(this, arguments);
    } catch (e3) {
      return catcher.apply(this, _concat([e3], arguments));
    }
  });
});
const tryCatch$1 = tryCatch;
var unapply = /* @__PURE__ */ _curry1(function unapply2(fn2) {
  return function() {
    return fn2(Array.prototype.slice.call(arguments, 0));
  };
});
const unapply$1 = unapply;
var unary = /* @__PURE__ */ _curry1(function unary2(fn2) {
  return nAry$1(1, fn2);
});
const unary$1 = unary;
var uncurryN = /* @__PURE__ */ _curry2(function uncurryN2(depth, fn2) {
  return curryN$2(depth, function() {
    var currentDepth = 1;
    var value = fn2;
    var idx = 0;
    var endIdx;
    while (currentDepth <= depth && typeof value === "function") {
      endIdx = currentDepth === depth ? arguments.length : idx + value.length;
      value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
      currentDepth += 1;
      idx = endIdx;
    }
    return value;
  });
});
const uncurryN$1 = uncurryN;
var unfold = /* @__PURE__ */ _curry2(function unfold2(fn2, seed) {
  var pair3 = fn2(seed);
  var result = [];
  while (pair3 && pair3.length) {
    result[result.length] = pair3[0];
    pair3 = fn2(pair3[1]);
  }
  return result;
});
const unfold$1 = unfold;
var union = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ compose$3(uniq$1, _concat)
);
const union$1 = union;
var XUniqWith = /* @__PURE__ */ function() {
  function XUniqWith2(pred, xf2) {
    this.xf = xf2;
    this.pred = pred;
    this.items = [];
  }
  XUniqWith2.prototype["@@transducer/init"] = _xfBase.init;
  XUniqWith2.prototype["@@transducer/result"] = _xfBase.result;
  XUniqWith2.prototype["@@transducer/step"] = function(result, input) {
    if (_includesWith(this.pred, input, this.items)) {
      return result;
    } else {
      this.items.push(input);
      return this.xf["@@transducer/step"](result, input);
    }
  };
  return XUniqWith2;
}();
function _xuniqWith(pred) {
  return function(xf2) {
    return new XUniqWith(pred, xf2);
  };
}
var uniqWith = /* @__PURE__ */ _curry2(
  /* @__PURE__ */ _dispatchable([], _xuniqWith, function(pred, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    var item;
    while (idx < len) {
      item = list[idx];
      if (!_includesWith(pred, item, result)) {
        result[result.length] = item;
      }
      idx += 1;
    }
    return result;
  })
);
const uniqWith$1 = uniqWith;
var unionWith = /* @__PURE__ */ _curry3(function unionWith2(pred, list1, list2) {
  return uniqWith$1(pred, _concat(list1, list2));
});
const unionWith$1 = unionWith;
var unless = /* @__PURE__ */ _curry3(function unless2(pred, whenFalseFn, x2) {
  return pred(x2) ? x2 : whenFalseFn(x2);
});
const unless$1 = unless;
var unnest = /* @__PURE__ */ chain$1(_identity);
const unnest$1 = unnest;
var until = /* @__PURE__ */ _curry3(function until2(pred, fn2, init2) {
  var val = init2;
  while (!pred(val)) {
    val = fn2(val);
  }
  return val;
});
const until$1 = until;
var unwind = /* @__PURE__ */ _curry2(function(key, object2) {
  if (!(key in object2 && _isArray$1(object2[key]))) {
    return [object2];
  }
  return _map(function(item) {
    return _assoc(key, item, object2);
  }, object2[key]);
});
const unwind$1 = unwind;
var valuesIn = /* @__PURE__ */ _curry1(function valuesIn2(obj) {
  var prop3;
  var vs2 = [];
  for (prop3 in obj) {
    vs2[vs2.length] = obj[prop3];
  }
  return vs2;
});
const valuesIn$1 = valuesIn;
var Const = function(x2) {
  return {
    value: x2,
    "fantasy-land/map": function() {
      return this;
    }
  };
};
var view = /* @__PURE__ */ _curry2(function view2(lens3, x2) {
  return lens3(Const)(x2).value;
});
const view$1 = view;
var when = /* @__PURE__ */ _curry3(function when2(pred, whenTrueFn, x2) {
  return pred(x2) ? whenTrueFn(x2) : x2;
});
const when$1 = when;
var where = /* @__PURE__ */ _curry2(function where2(spec, testObj) {
  for (var prop3 in spec) {
    if (_has(prop3, spec) && !spec[prop3](testObj[prop3])) {
      return false;
    }
  }
  return true;
});
const where$1 = where;
var whereAny = /* @__PURE__ */ _curry2(function whereAny2(spec, testObj) {
  for (var prop3 in spec) {
    if (_has(prop3, spec) && spec[prop3](testObj[prop3])) {
      return true;
    }
  }
  return false;
});
const whereAny$1 = whereAny;
var whereEq = /* @__PURE__ */ _curry2(function whereEq2(spec, testObj) {
  return where$1(map$6(equals$1, spec), testObj);
});
const whereEq$1 = whereEq;
var without = /* @__PURE__ */ _curry2(function without2(xs2, list) {
  var toRemove = new _Set$1();
  for (var i = 0; i < xs2.length; i += 1) {
    toRemove.add(xs2[i]);
  }
  return reject$1(toRemove.has.bind(toRemove), list);
});
const without$1 = without;
var xor = /* @__PURE__ */ _curry2(function xor2(a2, b2) {
  return Boolean(!a2 ^ !b2);
});
const xor$1 = xor;
var xprod = /* @__PURE__ */ _curry2(function xprod2(a2, b2) {
  var idx = 0;
  var ilen = a2.length;
  var j2;
  var jlen = b2.length;
  var result = [];
  while (idx < ilen) {
    j2 = 0;
    while (j2 < jlen) {
      result[result.length] = [a2[idx], b2[j2]];
      j2 += 1;
    }
    idx += 1;
  }
  return result;
});
const xprod$1 = xprod;
var zip = /* @__PURE__ */ _curry2(function zip2(a2, b2) {
  var rv = [];
  var idx = 0;
  var len = Math.min(a2.length, b2.length);
  while (idx < len) {
    rv[idx] = [a2[idx], b2[idx]];
    idx += 1;
  }
  return rv;
});
const zip$1 = zip;
var zipObj = /* @__PURE__ */ _curry2(function zipObj2(keys4, values3) {
  var idx = 0;
  var len = Math.min(keys4.length, values3.length);
  var out = {};
  while (idx < len) {
    out[keys4[idx]] = values3[idx];
    idx += 1;
  }
  return out;
});
const zipObj$1 = zipObj;
var zipWith = /* @__PURE__ */ _curry3(function zipWith2(fn2, a2, b2) {
  var rv = [];
  var idx = 0;
  var len = Math.min(a2.length, b2.length);
  while (idx < len) {
    rv[idx] = fn2(a2[idx], b2[idx]);
    idx += 1;
  }
  return rv;
});
const zipWith$1 = zipWith;
var thunkify = /* @__PURE__ */ _curry1(function thunkify2(fn2) {
  return curryN$2(fn2.length, function createThunk() {
    var fnArgs = arguments;
    return function invokeThunk() {
      return fn2.apply(this, fnArgs);
    };
  });
});
const thunkify$1 = thunkify;
const R$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  F: F$2,
  T: T$3,
  __,
  add: add$3,
  addIndex: addIndex$1,
  addIndexRight: addIndexRight$1,
  adjust: adjust$1,
  all: all$1,
  allPass: allPass$1,
  always: always$1,
  and: and$1,
  andThen: andThen$1,
  any: any$1,
  anyPass: anyPass$1,
  ap: ap$1,
  aperture: aperture$1,
  append: append$2,
  apply: apply$3,
  applySpec: applySpec$1,
  applyTo: applyTo$1,
  ascend: ascend$1,
  assoc: assoc$1,
  assocPath: assocPath$1,
  binary: binary$1,
  bind: bind$4,
  both: both$1,
  call: call$3,
  chain: chain$1,
  clamp: clamp$3,
  clone: clone$5,
  collectBy: collectBy$1,
  comparator: comparator$1,
  complement: complement$1,
  compose: compose$3,
  composeWith: composeWith$1,
  concat: concat$1,
  cond: cond$1,
  construct: construct$1,
  constructN: constructN$1,
  converge: converge$1,
  count: count$1,
  countBy: countBy$1,
  curry: curry$2,
  curryN: curryN$2,
  dec: dec$1,
  defaultTo: defaultTo$1,
  descend: descend$1,
  difference: difference$1,
  differenceWith: differenceWith$1,
  dissoc: dissoc$1,
  dissocPath: dissocPath$1,
  divide: divide$2,
  drop: drop$1,
  dropLast: dropLast$1,
  dropLastWhile: dropLastWhile$1,
  dropRepeats: dropRepeats$1,
  dropRepeatsBy: dropRepeatsBy$1,
  dropRepeatsWith: dropRepeatsWith$1,
  dropWhile: dropWhile$1,
  either: either$1,
  empty: empty$1,
  endsWith: endsWith$2,
  eqBy: eqBy$1,
  eqProps: eqProps$1,
  equals: equals$1,
  evolve: evolve$1,
  filter: filter$1,
  find: find$2,
  findIndex: findIndex$3,
  findLast: findLast$1,
  findLastIndex: findLastIndex$1,
  flatten: flatten$1,
  flip: flip$2,
  forEach: forEach$2,
  forEachObjIndexed: forEachObjIndexed$1,
  fromPairs: fromPairs$1,
  groupBy: groupBy$1,
  groupWith: groupWith$1,
  gt: gt$2,
  gte: gte$1,
  has: has$1,
  hasIn: hasIn$3,
  hasPath: hasPath$3,
  head: head$1,
  identical: identical$1,
  identity: identity$e,
  ifElse: ifElse$1,
  inc: inc$1,
  includes: includes$1,
  indexBy: indexBy$1,
  indexOf: indexOf$2,
  init: init$1,
  innerJoin: innerJoin$1,
  insert: insert$1,
  insertAll: insertAll$1,
  intersection: intersection$1,
  intersperse: intersperse$1,
  into: into$1,
  invert: invert$1,
  invertObj: invertObj$1,
  invoker: invoker$1,
  is: is$3,
  isEmpty: isEmpty$1,
  isNil: isNil$2,
  isNotNil: isNotNil$1,
  join: join$1,
  juxt: juxt$1,
  keys: keys$7,
  keysIn: keysIn$1,
  last: last$2,
  lastIndexOf: lastIndexOf$1,
  length: length$1,
  lens: lens$1,
  lensIndex: lensIndex$1,
  lensPath: lensPath$1,
  lensProp: lensProp$1,
  lift: lift$1,
  liftN: liftN$1,
  lt: lt$2,
  lte: lte$1,
  map: map$6,
  mapAccum: mapAccum$1,
  mapAccumRight: mapAccumRight$1,
  mapObjIndexed: mapObjIndexed$1,
  match: match$2,
  mathMod: mathMod$1,
  max: max$4,
  maxBy: maxBy$1,
  mean: mean$1,
  median: median$1,
  memoizeWith: memoizeWith$1,
  mergeAll: mergeAll$1,
  mergeDeepLeft: mergeDeepLeft$1,
  mergeDeepRight: mergeDeepRight$1,
  mergeDeepWith: mergeDeepWith$1,
  mergeDeepWithKey: mergeDeepWithKey$1,
  mergeLeft: mergeLeft$1,
  mergeRight: mergeRight$1,
  mergeWith: mergeWith$1,
  mergeWithKey: mergeWithKey$1,
  min: min$4,
  minBy: minBy$1,
  modify: modify$1,
  modifyPath: modifyPath$1,
  modulo: modulo$1,
  move: move$1,
  multiply: multiply$1,
  nAry: nAry$1,
  negate: negate$1,
  none: none$2,
  not: not$1,
  nth: nth$1,
  nthArg: nthArg$1,
  o: o$1,
  objOf: objOf$1,
  of: of$2,
  omit: omit$1,
  on: on$2,
  once: once$2,
  or: or$1,
  otherwise: otherwise$1,
  over: over$1,
  pair: pair$1,
  partial: partial$1,
  partialObject: partialObject$1,
  partialRight: partialRight$1,
  partition: partition$1,
  path: path$1,
  pathEq: pathEq$1,
  pathOr: pathOr$1,
  pathSatisfies: pathSatisfies$1,
  paths: paths$1,
  pick: pick$2,
  pickAll: pickAll$1,
  pickBy: pickBy$2,
  pipe,
  pipeWith: pipeWith$1,
  pluck: pluck$1,
  prepend: prepend$1,
  product: product$1,
  project: project$1,
  promap: promap$1,
  prop: prop$1,
  propEq: propEq$1,
  propIs: propIs$1,
  propOr: propOr$1,
  propSatisfies: propSatisfies$1,
  props: props$1,
  range: range$4,
  reduce: reduce$2,
  reduceBy: reduceBy$1,
  reduceRight: reduceRight$1,
  reduceWhile: reduceWhile$1,
  reduced: reduced$1,
  reject: reject$1,
  remove: remove$2,
  repeat: repeat$1,
  replace: replace$2,
  reverse: reverse$2,
  scan: scan$1,
  sequence: sequence$1,
  set: set$3,
  slice: slice$1,
  sort: sort$1,
  sortBy: sortBy$2,
  sortWith: sortWith$1,
  split: split$1,
  splitAt: splitAt$1,
  splitEvery: splitEvery$1,
  splitWhen: splitWhen$1,
  splitWhenever: splitWhenever$1,
  startsWith: startsWith$2,
  subtract: subtract$3,
  sum: sum$1,
  swap: swap$2,
  symmetricDifference: symmetricDifference$1,
  symmetricDifferenceWith: symmetricDifferenceWith$1,
  tail: tail$1,
  take: take$3,
  takeLast: takeLast$1,
  takeLastWhile: takeLastWhile$1,
  takeWhile: takeWhile$1,
  tap: tap$1,
  test: test$1,
  thunkify: thunkify$1,
  times: times$1,
  toLower: toLower$3,
  toPairs: toPairs$1,
  toPairsIn: toPairsIn$1,
  toString: toString$9,
  toUpper: toUpper$1,
  transduce: transduce$1,
  transpose: transpose$1,
  traverse: traverse$1,
  trim: trim$2,
  tryCatch: tryCatch$1,
  type: type$1,
  unapply: unapply$1,
  unary: unary$1,
  uncurryN: uncurryN$1,
  unfold: unfold$1,
  union: union$1,
  unionWith: unionWith$1,
  uniq: uniq$1,
  uniqBy: uniqBy$2,
  uniqWith: uniqWith$1,
  unless: unless$1,
  unnest: unnest$1,
  until: until$1,
  unwind: unwind$1,
  update: update$2,
  useWith: useWith$1,
  values: values$1,
  valuesIn: valuesIn$1,
  view: view$1,
  when: when$1,
  where: where$1,
  whereAny: whereAny$1,
  whereEq: whereEq$1,
  without: without$1,
  xor: xor$1,
  xprod: xprod$1,
  zip: zip$1,
  zipObj: zipObj$1,
  zipWith: zipWith$1
}, Symbol.toStringTag, { value: "Module" }));
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e3 = a2[d2];
        if (0 < g2(e3, b2))
          a2[d2] = b2, a2[c2] = e3, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e3 = a2.length, w2 = e3 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e3 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e3 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e3 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e3 ? v2.callback = e3 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e3 = -1;
        break;
      case 2:
        e3 = 250;
        break;
      case 5:
        e3 = 1073741823;
        break;
      case 4:
        e3 = 1e4;
        break;
      default:
        e3 = 5e3;
    }
    e3 = c2 + e3;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e3, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e3, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa$1 = reactExports, ca$1 = schedulerExports;
function p$5(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da$1 = /* @__PURE__ */ new Set(), ea$1 = {};
function fa$1(a2, b2) {
  ha$1(a2, b2);
  ha$1(a2 + "Capture", b2);
}
function ha$1(a2, b2) {
  ea$1[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da$1.add(b2[a2]);
}
var ia$1 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka$2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la$1 = {}, ma$1 = {};
function oa$1(a2) {
  if (ja.call(ma$1, a2))
    return true;
  if (ja.call(la$1, a2))
    return false;
  if (ka$2.test(a2))
    return ma$1[a2] = true;
  la$1[a2] = true;
  return false;
}
function pa$1(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa$1(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$4(a2, b2, c2, d2, e3, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e3;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$2 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$2[a2] = new v$4(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$2[b2] = new v$4(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$2[a2] = new v$4(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$2[a2] = new v$4(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$2[a2] = new v$4(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$2[a2] = new v$4(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$2[a2] = new v$4(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$2[a2] = new v$4(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$2[a2] = new v$4(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra$1 = /[\-:]([a-z])/g;
function sa$1(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra$1,
    sa$1
  );
  z$2[b2] = new v$4(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra$1, sa$1);
  z$2[b2] = new v$4(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra$1, sa$1);
  z$2[b2] = new v$4(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$2[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$2.xlinkHref = new v$4("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$2[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta$1(a2, b2, c2, d2) {
  var e3 = z$2.hasOwnProperty(b2) ? z$2[b2] : null;
  if (null !== e3 ? 0 !== e3.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e3, d2) && (c2 = null), d2 || null === e3 ? oa$1(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e3.mustUseProperty ? a2[e3.propertyName] = null === c2 ? 3 === e3.type ? false : "" : c2 : (b2 = e3.attributeName, d2 = e3.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e3 = e3.type, c2 = 3 === e3 || 4 === e3 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua$1 = aa$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va$1 = Symbol.for("react.element"), wa$1 = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za$1 = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca$1 = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea$1 = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$1 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa$1(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e3 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e3.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e3[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e3[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e3[g2] !== f2[h2]) {
                var k2 = "\n" + e3[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa$1(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa$1(a2.type, false), a2;
    case 11:
      return a2 = Oa$1(a2.type.render, false), a2;
    case 1:
      return a2 = Oa$1(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa$1:
      return "Portal";
    case Aa:
      return "Profiler";
    case za$1:
      return "StrictMode";
    case Ea$1:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca$1:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra$1(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za$1 ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa$1(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta$1(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua$1(a2) {
  var b2 = Ta$1(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e3 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e3.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua$1(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta$1(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa$1(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta$1(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa$1(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa$1(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e3 = 0; e3 < c2.length; e3++)
      b2["$" + c2[e3]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e3 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e3 && (a2[c2].selected = e3), e3 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa$1(c2);
    b2 = null;
    for (e3 = 0; e3 < a2.length; e3++) {
      if (a2[e3].value === c2) {
        a2[e3].selected = true;
        d2 && (a2[e3].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e3].disabled || (b2 = a2[e3]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$5(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$5(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$5(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa$1(c2) };
}
function ib(a2, b2) {
  var c2 = Sa$1(b2.value), d2 = Sa$1(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e3) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e3);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e3 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e3) : a2[c2] = e3;
    }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$5(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$5(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$5(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$5(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$5(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$5(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia$1)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$5(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$5(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$5(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e3 = c2.return;
    if (null === e3)
      break;
    var f2 = e3.alternate;
    if (null === f2) {
      d2 = e3.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e3.child === f2.child) {
      for (f2 = e3.child; f2; ) {
        if (f2 === c2)
          return Xb(e3), a2;
        if (f2 === d2)
          return Xb(e3), b2;
        f2 = f2.sibling;
      }
      throw Error(p$5(188));
    }
    if (c2.return !== d2.return)
      c2 = e3, d2 = f2;
    else {
      for (var g2 = false, h2 = e3.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e3;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e3;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e3;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e3;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$5(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$5(190));
  }
  if (3 !== c2.tag)
    throw Error(p$5(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca$1.unstable_scheduleCallback, bc = ca$1.unstable_cancelCallback, cc = ca$1.unstable_shouldYield, dc = ca$1.unstable_requestPaint, B = ca$1.unstable_now, ec = ca$1.unstable_getCurrentPriorityLevel, fc = ca$1.unstable_ImmediatePriority, gc = ca$1.unstable_UserBlockingPriority, hc = ca$1.unstable_NormalPriority, ic = ca$1.unstable_LowPriority, jc = ca$1.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e3 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e3;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e3, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e3) && (e3 = d2 & -d2, f2 = b2 & -b2, e3 >= f2 || 16 === e3 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e3 = 1 << c2, d2 |= a2[c2], b2 &= ~e3;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e3 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e3[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e3[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e3 = 31 - oc(c2), f2 = 1 << e3;
    b2[e3] = 0;
    d2[e3] = -1;
    a2[e3] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e3 = 1 << d2;
    e3 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e3;
  }
}
var C$1 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e3, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e3] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e3 && -1 === b2.indexOf(e3) && b2.push(e3);
  return a2;
}
function Uc(a2, b2, c2, d2, e3) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e3), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e3), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e3), true;
    case "pointerover":
      var f2 = e3.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e3));
      return true;
    case "gotpointercapture":
      return f2 = e3.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e3)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca$1.unstable_scheduleCallback(ca$1.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua$1.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e3 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$1 = e3, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e3 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$1 = e3, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e3 = Yc(a2, b2, c2, d2);
    if (null === e3)
      hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e3, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e3; ) {
        var f2 = Cb(e3);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id, c2);
        if (f2 === e3)
          break;
        e3 = f2;
      }
      null !== e3 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d2) {
  id = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e3 = "value" in kd ? kd.value : kd.textContent, f2 = e3.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e3[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e3[f2 - d2]; d2++)
    ;
  return md = e3.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e3, f2, g2) {
    this._reactName = b3;
    this._targetInst = e3;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia$1 && "CompositionEvent" in window, be = null;
ia$1 && "documentMode" in document && (be = document.documentMode);
var ce$1 = ia$1 && "TextEvent" in window && !be, de$1 = ia$1 && (!ae$1 || be && 8 < be && 11 >= be), ee$1 = String.fromCharCode(32), fe$1 = false;
function ge$1(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$1(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie$1 = false;
function je$1(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$1 = true;
      return ee$1;
    case "textInput":
      return a2 = b2.data, a2 === ee$1 && fe$1 ? null : a2;
    default:
      return null;
  }
}
function ke$1(a2, b2) {
  if (ie$1)
    return "compositionend" === a2 || !ae$1 && ge$1(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$1 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$1[a2.type] : "textarea" === b2 ? true : false;
}
function ne$1(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe$1(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe$1 = null, qe = null;
function re$2(a2) {
  se$1(a2, 0);
}
function te$1(a2) {
  var b2 = ue(a2);
  if (Wa(b2))
    return a2;
}
function ve$1(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we = false;
if (ia$1) {
  var xe;
  if (ia$1) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;");
      ye = "function" === typeof ze$1.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be$1), qe = pe$1 = null);
}
function Be$1(a2) {
  if ("value" === a2.propertyName && te$1(qe)) {
    var b2 = [];
    ne$1(b2, qe, a2, xb(a2));
    Jb(re$2, b2);
  }
}
function Ce(a2, b2, c2) {
  "focusin" === a2 ? (Ae$1(), pe$1 = b2, qe = c2, pe$1.attachEvent("onpropertychange", Be$1)) : "focusout" === a2 && Ae$1();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$1(qe);
}
function Ee$1(a2, b2) {
  if ("click" === a2)
    return te$1(b2);
}
function Fe$1(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te$1(b2);
}
function Ge$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He$1 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie$1(a2, b2) {
  if (He$1(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e3 = c2[d2];
    if (!ja.call(b2, e3) || !He$1(a2[e3], b2[e3]))
      return false;
  }
  return true;
}
function Je$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke$1(a2, b2) {
  var c2 = Je$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
function Le$1(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le$1(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$1() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe$1(a2) {
  var b2 = Me$1(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le$1(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne$1(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e3 = c2.textContent.length, f2 = Math.min(d2.start, e3);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e3);
        !a2.extend && f2 > d2 && (e3 = d2, d2 = f2, f2 = e3);
        e3 = Ke$1(c2, f2);
        var g2 = Ke$1(
          c2,
          d2
        );
        e3 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e3.node || a2.anchorOffset !== e3.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e3.node, e3.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe$1 = ia$1 && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re$1 = null, Se$1 = null, Te$1 = false;
function Ue$1(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$1 || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne$1(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Ie$1(Se$1, d2) || (Se$1 = d2, d2 = oe$1(Re$1, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve$1(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia$1 && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a2) {
  if (Xe$1[a2])
    return Xe$1[a2];
  if (!We$1[a2])
    return a2;
  var b2 = We$1[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$1)
      return Xe$1[a2] = b2[c2];
  return a2;
}
var $e$1 = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa$1(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$1, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha$1("onMouseEnter", ["mouseout", "mouseover"]);
ha$1("onMouseLeave", ["mouseout", "mouseover"]);
ha$1("onPointerEnter", ["pointerout", "pointerover"]);
ha$1("onPointerLeave", ["pointerout", "pointerover"]);
fa$1("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa$1("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa$1("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa$1("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa$1("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa$1("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$1(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e3 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped())
            break a;
          nf(e3, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped())
            break a;
          nf(e3, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$1(a2, b2) {
  var c2 = b2[of2];
  void 0 === c2 && (c2 = b2[of2] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da$1.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e3 = ed;
      break;
    case 4:
      e3 = gd;
      break;
    default:
      e3 = fd;
  }
  c2 = e3.bind(null, b2, c2, a2);
  e3 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e3 = true);
  d2 ? void 0 !== e3 ? a2.addEventListener(b2, c2, { capture: true, passive: e3 }) : a2.addEventListener(b2, c2, true) : void 0 !== e3 ? a2.addEventListener(b2, c2, { passive: e3 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e3) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e3 || 8 === h2.nodeType && h2.parentNode === e3)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e3 || 8 === k2.nodeType && k2.parentNode === e3)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e4 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e$1:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e4), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e4.window === e4 ? e4 : (h3 = e4.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e4);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e4) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e4), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na2 = ve$1;
        else if (me$1(h3))
          if (we)
            na2 = Fe$1;
          else {
            na2 = De;
            var xa2 = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na2 = Ee$1);
        if (na2 && (na2 = na2(a2, d3))) {
          ne$1(g3, na2, c2, e4);
          break a;
        }
        xa2 && xa2(a2, h3, d3);
        "focusout" === a2 && (xa2 = h3._wrapperState) && xa2.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa2 = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me$1(xa2) || "true" === xa2.contentEditable)
            Qe = xa2, Re$1 = d3, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re$1 = Qe = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue$1(g3, c2, e4);
          break;
        case "selectionchange":
          if (Pe$1)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c2, e4);
      }
      var $a;
      if (ae$1)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$1 ? ge$1(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$1 && "ko" !== c2.locale && (ie$1 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$1 && ($a = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = true)), xa2 = oe$1(d3, ba), 0 < xa2.length && (ba = new Ld(ba, a2, null, c2, e4), g3.push({ event: ba, listeners: xa2 }), $a ? ba.data = $a : ($a = he$1(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$1 ? je$1(a2, c2) : ke$1(a2, c2))
        d3 = oe$1(d3, "onBeforeInput"), 0 < d3.length && (e4 = new Ld("onBeforeInput", "beforeinput", null, c2, e4), g3.push({ event: e4, listeners: d3 }), e4.data = $a);
    }
    se$1(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$1(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e3 = a2, f2 = e3.stateNode;
    5 === e3.tag && null !== f2 && (e3 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e3)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e3)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e3) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e3 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e3 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$5(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e3 = c2.nextSibling;
    a2.removeChild(c2);
    if (e3 && 8 === e3.nodeType)
      if (c2 = e3.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e3);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e3;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of2 = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$5(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$1(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$1(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$3 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e3 = {}, f2;
  for (f2 in c2)
    e3[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e3);
  return e3;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$1(Wf);
  E$1(H$3);
}
function ag(a2, b2, c2) {
  if (H$3.current !== Vf)
    throw Error(p$5(168));
  G$1(H$3, b2);
  G$1(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e3 in d2)
    if (!(e3 in b2))
      throw Error(p$5(108, Ra$1(a2) || "Unknown", e3));
  return A$1({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$3.current;
  G$1(H$3, a2);
  G$1(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$5(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$1(Wf), E$1(H$3), G$1(H$3, a2)) : E$1(Wf);
  G$1(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$1;
    try {
      var c2 = eg;
      for (C$1 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e3) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e3;
    } finally {
      C$1 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e3 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e3);
  c2 += 1;
  var f2 = 32 - oc(b2) + e3;
  if (30 < f2) {
    var g2 = e3 - e3 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e3 -= g2;
    rg = 1 << 32 - oc(b2) + e3 | c2 << e3 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e3 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$1 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$1) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$5(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$1 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$5(418));
      a2.flags = a2.flags & -4097 | 2;
      I$1 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$1)
    return Fg(a2), I$1 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$5(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$5(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$1 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua$1.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$1({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$1(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$5(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e3 = b2.interleaved;
  null === e3 ? (c2.next = c2, Xg(b2)) : (c2.next = e3.next, e3.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$1 & 2)) {
    var e3 = d2.pending;
    null === e3 ? b2.next = b2 : (b2.next = e3.next, e3.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e3 = d2.interleaved;
  null === e3 ? (b2.next = b2, Xg(d2)) : (b2.next = e3.next, e3.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e3 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e3 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e3 = f2 = b2 : f2 = f2.next = b2;
    } else
      e3 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e3, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e3 = a2.updateQueue;
  $g = false;
  var f2 = e3.firstBaseUpdate, g2 = e3.lastBaseUpdate, h2 = e3.shared.pending;
  if (null !== h2) {
    e3.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e3.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e3.effects, null === r2 ? e3.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e3.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e3.lastBaseUpdate = r2, e3.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e3.baseState = k2;
    e3.firstBaseUpdate = l2;
    e3.lastBaseUpdate = m2;
    b2 = e3.shared.interleaved;
    if (null !== b2) {
      e3 = b2;
      do
        g2 |= e3.lane, e3 = e3.next;
      while (e3 !== b2);
    } else
      null === f2 && (e3.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e3 = d2.callback;
      if (null !== e3) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e3)
          throw Error(p$5(191, e3));
        e3.call(d2);
      }
    }
}
var jh = new aa$1.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$1(), e3 = lh(a2), f2 = ch(d2, e3);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e3);
  null !== b2 && (mh(b2, a2, e3, d2), eh(b2, a2, e3));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$1(), e3 = lh(a2), f2 = ch(d2, e3);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e3);
  null !== b2 && (mh(b2, a2, e3, d2), eh(b2, a2, e3));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$1(), d2 = lh(a2), e3 = ch(c2, d2);
  e3.tag = 2;
  void 0 !== b2 && null !== b2 && (e3.callback = b2);
  b2 = dh(a2, e3, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e3, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$1(c2, d2) || !Ie$1(e3, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e3 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e3 = Zf(b2) ? Xf : H$3.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e3) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e3, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e3 = a2.stateNode;
  e3.props = c2;
  e3.state = a2.memoizedState;
  e3.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e3.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$3.current, e3.context = Yf(a2, f2));
  e3.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e3.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e3.getSnapshotBeforeUpdate || "function" !== typeof e3.UNSAFE_componentWillMount && "function" !== typeof e3.componentWillMount || (b2 = e3.state, "function" === typeof e3.componentWillMount && e3.componentWillMount(), "function" === typeof e3.UNSAFE_componentWillMount && e3.UNSAFE_componentWillMount(), b2 !== e3.state && nh.enqueueReplaceState(e3, e3.state, null), gh(a2, c2, e3, d2), e3.state = a2.memoizedState);
  "function" === typeof e3.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$5(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$5(147, a2));
      var e3 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e3.refs;
        b3 === jh && (b3 = e3.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$5(284));
    if (!c2._owner)
      throw Error(p$5(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$5(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e3(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e3(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e3(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e3(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e3(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va$1:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa$1:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e4 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e4 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va$1:
          return c3.key === e4 ? k2(a3, b3, c3, d3) : null;
        case wa$1:
          return c3.key === e4 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e4 = c3._init, r2(
            a3,
            b3,
            e4(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e4 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e4) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e4);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va$1:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e4);
        case wa$1:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e4);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e4);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e4, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e4, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e4, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e4, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e4, u2), I$1 && tg(e4, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e4, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$1 && tg(e4, w2);
      return l3;
    }
    for (u2 = d2(e4, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e4, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e4, a3);
    });
    I$1 && tg(e4, w2);
    return l3;
  }
  function t2(e4, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$5(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$5(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e4, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e4, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e4,
        m3
      ), I$1 && tg(e4, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e4, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$1 && tg(e4, w2);
      return l3;
    }
    for (m3 = d2(e4, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e4, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e4, a3);
    });
    I$1 && tg(e4, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va$1:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e3(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e3(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa$1:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e3(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e3(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$5(174));
  return a2;
}
function Ih(a2, b2) {
  G$1(Gh, b2);
  G$1(Fh, a2);
  G$1(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$1(Eh);
  G$1(Eh, b2);
}
function Jh() {
  E$1(Eh);
  E$1(Fh);
  E$1(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$1(Fh, a2), G$1(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$1(Eh), E$1(Fh));
}
var M$1 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua$1.ReactCurrentDispatcher, Qh = ua$1.ReactCurrentBatchConfig, Rh = 0, N$1 = null, O = null, P$2 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$1() {
  throw Error(p$5(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He$1(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e3, f2) {
  Rh = f2;
  N$1 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e3);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$5(301));
      f2 += 1;
      P$2 = O = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e3);
    } while (Th);
  }
  Ph.current = ai$1;
  b2 = null !== O && null !== O.next;
  Rh = 0;
  P$2 = O = N$1 = null;
  Sh = false;
  if (b2)
    throw Error(p$5(300));
  return a2;
}
function bi$1() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci$1() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$2 ? N$1.memoizedState = P$2 = a2 : P$2 = P$2.next = a2;
  return P$2;
}
function di$1() {
  if (null === O) {
    var a2 = N$1.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O.next;
  var b2 = null === P$2 ? N$1.memoizedState : P$2.next;
  if (null !== b2)
    P$2 = b2, O = a2;
  else {
    if (null === a2)
      throw Error(p$5(310));
    O = a2;
    a2 = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
    null === P$2 ? N$1.memoizedState = P$2 = a2 : P$2 = P$2.next = a2;
  }
  return P$2;
}
function ei$1(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$5(311));
  c2.lastRenderedReducer = a2;
  var d2 = O, e3 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e3) {
      var g2 = e3.next;
      e3.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e3 = f2;
    c2.pending = null;
  }
  if (null !== e3) {
    f2 = e3.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N$1.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He$1(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e3 = a2;
    do
      f2 = e3.lane, N$1.lanes |= f2, hh |= f2, e3 = e3.next;
    while (e3 !== a2);
  } else
    null === e3 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$5(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e3 = c2.pending, f2 = b2.memoizedState;
  if (null !== e3) {
    c2.pending = null;
    var g2 = e3 = e3.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e3);
    He$1(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi$1() {
}
function ii$1(a2, b2) {
  var c2 = N$1, d2 = di$1(), e3 = b2(), f2 = !He$1(d2.memoizedState, e3);
  f2 && (d2.memoizedState = e3, Ug = true);
  d2 = d2.queue;
  ji$1(ki$1.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$2 && P$2.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li$1(9, mi$1.bind(null, c2, d2, e3, b2), void 0, null);
    if (null === R$1)
      throw Error(p$5(349));
    0 !== (Rh & 30) || ni$1(c2, b2, e3);
  }
  return e3;
}
function ni$1(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi$1(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi$1(b2) && pi$3(a2);
}
function ki$1(a2, b2, c2) {
  return c2(function() {
    oi$1(b2) && pi$3(a2);
  });
}
function oi$1(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$1(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi$3(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi$1(a2) {
  var b2 = ci$1();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei$1, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri$1.bind(null, N$1, a2);
  return [b2.memoizedState, a2];
}
function li$1(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si$1() {
  return di$1().memoizedState;
}
function ti$1(a2, b2, c2, d2) {
  var e3 = ci$1();
  N$1.flags |= a2;
  e3.memoizedState = li$1(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui$1(a2, b2, c2, d2) {
  var e3 = di$1();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O) {
    var g2 = O.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e3.memoizedState = li$1(b2, c2, f2, d2);
      return;
    }
  }
  N$1.flags |= a2;
  e3.memoizedState = li$1(1 | b2, c2, f2, d2);
}
function vi$1(a2, b2) {
  return ti$1(8390656, 8, a2, b2);
}
function ji$1(a2, b2) {
  return ui$1(2048, 8, a2, b2);
}
function wi$1(a2, b2) {
  return ui$1(4, 2, a2, b2);
}
function xi$1(a2, b2) {
  return ui$1(4, 4, a2, b2);
}
function yi$1(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui$1(4, 4, yi$1.bind(null, b2, a2), c2);
}
function Ai$1() {
}
function Bi(a2, b2) {
  var c2 = di$1();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci$1(a2, b2) {
  var c2 = di$1();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di$1(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He$1(c2, b2) || (c2 = yc(), N$1.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei$1(a2, b2) {
  var c2 = C$1;
  C$1 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$1 = c2, Qh.transition = d2;
  }
}
function Fi$1() {
  return di$1().memoizedState;
}
function Gi$1(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii$1(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e3 = L$1();
    mh(c2, a2, d2, e3);
    Ji$1(c2, b2, d2);
  }
}
function ri$1(a2, b2, c2) {
  var d2 = lh(a2), e3 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii$1(b2, e3);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e3.hasEagerState = true;
        e3.eagerState = h2;
        if (He$1(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e3.next = e3, Xg(b2)) : (e3.next = k2.next, k2.next = e3);
          b2.interleaved = e3;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e3, d2);
    null !== c2 && (e3 = L$1(), mh(c2, a2, d2, e3), Ji$1(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N$1 || null !== b2 && b2 === N$1;
}
function Ii$1(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji$1(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai$1 = { readContext: Vg, useCallback: Q$1, useContext: Q$1, useEffect: Q$1, useImperativeHandle: Q$1, useInsertionEffect: Q$1, useLayoutEffect: Q$1, useMemo: Q$1, useReducer: Q$1, useRef: Q$1, useState: Q$1, useDebugValue: Q$1, useDeferredValue: Q$1, useTransition: Q$1, useMutableSource: Q$1, useSyncExternalStore: Q$1, useId: Q$1, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci$1().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi$1, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti$1(
    4194308,
    4,
    yi$1.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti$1(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti$1(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci$1();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci$1();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi$1.bind(null, N$1, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci$1();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi$1, useDebugValue: Ai$1, useDeferredValue: function(a2) {
  return ci$1().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi$1(false), b2 = a2[0];
  a2 = Ei$1.bind(null, a2[1]);
  ci$1().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$1, e3 = ci$1();
  if (I$1) {
    if (void 0 === c2)
      throw Error(p$5(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R$1)
      throw Error(p$5(349));
    0 !== (Rh & 30) || ni$1(d2, b2, c2);
  }
  e3.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e3.queue = f2;
  vi$1(ki$1.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li$1(9, mi$1.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci$1(), b2 = R$1.identifierPrefix;
  if (I$1) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji$1,
  useImperativeHandle: zi,
  useInsertionEffect: wi$1,
  useLayoutEffect: xi$1,
  useMemo: Ci$1,
  useReducer: fi$1,
  useRef: si$1,
  useState: function() {
    return fi$1(ei$1);
  },
  useDebugValue: Ai$1,
  useDeferredValue: function(a2) {
    var b2 = di$1();
    return Di$1(b2, O.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi$1(ei$1)[0], b2 = di$1().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi$1,
  useSyncExternalStore: ii$1,
  useId: Fi$1,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji$1, useImperativeHandle: zi, useInsertionEffect: wi$1, useLayoutEffect: xi$1, useMemo: Ci$1, useReducer: gi$1, useRef: si$1, useState: function() {
  return gi$1(ei$1);
}, useDebugValue: Ai$1, useDeferredValue: function(a2) {
  var b2 = di$1();
  return null === O ? b2.memoizedState = a2 : Di$1(b2, O.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi$1(ei$1)[0], b2 = di$1().memoizedState;
  return [a2, b2];
}, useMutableSource: hi$1, useSyncExternalStore: ii$1, useId: Fi$1, unstable_isNewReconciler: false };
function Ki$1(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa$1(d2), d2 = d2.return;
    while (d2);
    var e3 = c2;
  } catch (f2) {
    e3 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e3, digest: null };
}
function Li$1(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi$1(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni$1 = "function" === typeof WeakMap ? WeakMap : Map;
function Oi$1(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi$1 = d2);
    Mi$1(a2, b2);
  };
  return c2;
}
function Ri$1(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e3 = b2.value;
    c2.payload = function() {
      return d2(e3);
    };
    c2.callback = function() {
      Mi$1(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi$1(a2, b2);
    "function" !== typeof d2 && (null === Si$1 ? Si$1 = /* @__PURE__ */ new Set([this]) : Si$1.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti$1(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni$1();
    var e3 = /* @__PURE__ */ new Set();
    d2.set(b2, e3);
  } else
    e3 = d2.get(b2), void 0 === e3 && (e3 = /* @__PURE__ */ new Set(), d2.set(b2, e3));
  e3.has(c2) || (e3.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi$1(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi$1(a2, b2, c2, d2, e3) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e3;
  return a2;
}
var Xi$1 = ua$1.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi$1(a2, b2, c2, d2, e3) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e3);
  d2 = Xh(a2, b2, c2, d2, f2, e3);
  c2 = bi$1();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e3, $i$1(a2, b2, e3);
  I$1 && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e3);
  return b2.child;
}
function aj(a2, b2, c2, d2, e3) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e3);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e3);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e3)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$1;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i$1(a2, b2, e3);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e3) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie$1(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e3))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i$1(a2, b2, e3);
  }
  return dj(a2, b2, c2, d2, e3);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e3 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$1(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$1(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$1(fj, gj), gj |= d2;
  Yi(a2, b2, e3, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e3) {
  var f2 = Zf(c2) ? Xf : H$3.current;
  f2 = Yf(b2, f2);
  Tg(b2, e3);
  c2 = Xh(a2, b2, c2, d2, f2, e3);
  d2 = bi$1();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e3, $i$1(a2, b2, e3);
  I$1 && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e3);
  return b2.child;
}
function ij(a2, b2, c2, d2, e3) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e3);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e3), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$3.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e3);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$3.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e3);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e3);
}
function kj(a2, b2, c2, d2, e3, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e3 && dg(b2, c2, false), $i$1(a2, b2, f2);
  d2 = b2.stateNode;
  Xi$1.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e3 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e3) {
  Ig();
  Jg(e3);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e3 = M$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e3 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e3 |= 1;
  G$1(M$1, e3 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e3 = a2.memoizedState;
  if (null !== e3 && (h2 = e3.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e3, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e3 = a2.child;
    h2 = e3.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e3 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e3, k2), d2.subtreeFlags = e3.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e3, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li$1(Error(p$5(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e3 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e3, 0, null);
    f2 = Ah(f2, e3, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e3.data) {
    d2 = e3.nextSibling && e3.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$5(419));
    d2 = Li$1(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R$1;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e3 = 2;
          break;
        case 16:
          e3 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e3 = 32;
          break;
        case 536870912:
          e3 = 268435456;
          break;
        default:
          e3 = 0;
      }
      e3 = 0 !== (e3 & (d2.suspendedLanes | g2)) ? 0 : e3;
      0 !== e3 && e3 !== f2.retryLane && (f2.retryLane = e3, Zg(a2, e3), mh(d2, a2, e3, -1));
    }
    uj();
    d2 = Li$1(Error(p$5(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e3.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e3._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e3.nextSibling);
  xg = b2;
  I$1 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e3) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e3 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e3);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e3 = d2.revealOrder, f2 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M$1.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$1(M$1, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e3) {
      case "forwards":
        c2 = b2.child;
        for (e3 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e3 = c2), c2 = c2.sibling;
        c2 = e3;
        null === c2 ? (e3 = b2.child, b2.child = null) : (e3 = c2.sibling, c2.sibling = null);
        xj(b2, false, e3, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e3 = b2.child;
        for (b2.child = null; null !== e3; ) {
          a2 = e3.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e3;
            break;
          }
          a2 = e3.sibling;
          e3.sibling = c2;
          c2 = e3;
          e3 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i$1(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$5(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e3 = b2.memoizedProps.value;
      G$1(Mg, d2._currentValue);
      d2._currentValue = e3;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$1(M$1, M$1.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$1(M$1, M$1.current & 1);
        a2 = $i$1(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$1(M$1, M$1.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e3 = b2.memoizedState;
      null !== e3 && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
      G$1(M$1, M$1.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i$1(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e3 = a2.memoizedProps;
  if (e3 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e3 = Ya(a2, e3);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e3 = A$1({}, e3, { value: void 0 });
        d2 = A$1({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e3 = gb(a2, e3);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e3.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e3)
      if (!d2.hasOwnProperty(l2) && e3.hasOwnProperty(l2) && null != e3[l2])
        if ("style" === l2) {
          var h2 = e3[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea$1.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e3 ? e3[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea$1.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$1("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$1)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e3 = a2.child; null !== e3; )
      c2 |= e3.lanes | e3.childLanes, d2 |= e3.subtreeFlags & 14680064, d2 |= e3.flags & 14680064, e3.return = a2, e3 = e3.sibling;
  else
    for (e3 = a2.child; null !== e3; )
      c2 |= e3.lanes | e3.childLanes, d2 |= e3.subtreeFlags, d2 |= e3.flags, e3.return = a2, e3 = e3.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$1(Wf);
      E$1(H$3);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S(b2);
      return null;
    case 5:
      Lh(b2);
      var e3 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e3), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$5(166));
          S(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$1("cancel", d2);
              D$1("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$1("load", d2);
              break;
            case "video":
            case "audio":
              for (e3 = 0; e3 < lf.length; e3++)
                D$1(lf[e3], d2);
              break;
            case "source":
              D$1("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$1(
                "error",
                d2
              );
              D$1("load", d2);
              break;
            case "details":
              D$1("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$1("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$1("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$1("invalid", d2);
          }
          ub(c2, f2);
          e3 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e3 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e3 = ["children", "" + h2]) : ea$1.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$1("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e3;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e3.nodeType ? e3 : e3.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$1("cancel", a2);
                D$1("close", a2);
                e3 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$1("load", a2);
                e3 = d2;
                break;
              case "video":
              case "audio":
                for (e3 = 0; e3 < lf.length; e3++)
                  D$1(lf[e3], a2);
                e3 = d2;
                break;
              case "source":
                D$1("error", a2);
                e3 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$1(
                  "error",
                  a2
                );
                D$1("load", a2);
                e3 = d2;
                break;
              case "details":
                D$1("toggle", a2);
                e3 = d2;
                break;
              case "input":
                Za(a2, d2);
                e3 = Ya(a2, d2);
                D$1("invalid", a2);
                break;
              case "option":
                e3 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e3 = A$1({}, d2, { value: void 0 });
                D$1("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e3 = gb(a2, d2);
                D$1("invalid", a2);
                break;
              default:
                e3 = d2;
            }
            ub(c2, e3);
            h2 = e3;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea$1.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$1("scroll", a2) : null != k2 && ta$1(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa$1(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e3.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$5(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S(b2);
      return null;
    case 13:
      E$1(M$1);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$1 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$5(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$5(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$1.current & 1) ? 0 === T$1 && (T$1 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return Rg(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E$1(M$1);
      f2 = b2.memoizedState;
      if (null === f2)
        return S(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$1 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$1(M$1, M$1.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$1)
              return S(b2), null;
          } else
            2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = M$1.current, G$1(M$1, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$5(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$1(Wf), E$1(H$3), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$1(M$1);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$5(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$1(M$1), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me$1();
  if (Ne$1(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e3 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e3 && 3 !== q2.nodeType || (h2 = g2 + e3);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e3 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$1 = b2; null !== V$1; )
    if (b2 = V$1, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$1 = a2;
    else
      for (; null !== V$1; ) {
        b2 = V$1;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$5(163));
            }
        } catch (F2) {
          W$1(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$1 = a2;
          break;
        }
        V$1 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e3 = d2 = d2.next;
    do {
      if ((e3.tag & a2) === a2) {
        var f2 = e3.destroy;
        e3.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e3 = e3.next;
    } while (e3 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of2], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$1 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U || Mj(c2, b2);
    case 6:
      var d2 = X$1, e3 = Yj;
      X$1 = null;
      Zj(a2, b2, c2);
      X$1 = d2;
      Yj = e3;
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
      break;
    case 4:
      d2 = X$1;
      e3 = Yj;
      X$1 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$1 = d2;
      Yj = e3;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e3 = d2 = d2.next;
        do {
          var f2 = e3, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e3 = e3.next;
        } while (e3 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Zj(a2, b2, c2), U = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e3 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$1 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$1)
          throw Error(p$5(160));
        ak(f2, g2, e3);
        X$1 = null;
        Yj = false;
        var k2 = e3.alternate;
        null !== k2 && (k2.return = null);
        e3.return = null;
      } catch (l2) {
        W$1(e3, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e3 = a2.stateNode;
        try {
          ob(e3, "");
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e3 = a2.stateNode, null != e3)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e3, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e3, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e3, q2) : "children" === m2 ? ob(e3, q2) : ta$1(e3, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e3, f2);
                break;
              case "textarea":
                ib(e3, f2);
                break;
              case "select":
                var r2 = e3._wrapperState.wasMultiple;
                e3._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e3, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e3,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e3, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e3[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$5(162));
        e3 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e3.nodeValue = f2;
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e3 = a2.child;
      e3.flags & 8192 && (f2 = null !== e3.memoizedState, e3.stateNode.isHidden = f2, !f2 || null !== e3.alternate && null !== e3.alternate.memoizedState || (gk = B()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U = (l2 = U) || m2, dk(b2, a2), U = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$1 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$1 = m2; null !== V$1; ) {
              r2 = V$1;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$1 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e3 = q2.stateNode, l2 ? (f2 = e3.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$5(160));
      }
      switch (d2.tag) {
        case 5:
          var e3 = d2.stateNode;
          d2.flags & 32 && (ob(e3, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e3);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$5(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$1 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$1; ) {
    var e3 = V$1, f2 = e3.child;
    if (22 === e3.tag && d2) {
      var g2 = null !== e3.memoizedState || Kj;
      if (!g2) {
        var h2 = e3.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Kj;
        var l2 = U;
        Kj = g2;
        if ((U = k2) && !l2)
          for (V$1 = e3; null !== V$1; )
            g2 = V$1, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e3) : null !== k2 ? (k2.return = g2, V$1 = k2) : kk(e3);
        for (; null !== f2; )
          V$1 = f2, jk(f2), f2 = f2.sibling;
        V$1 = e3;
        Kj = h2;
        U = l2;
      }
      lk(a2);
    } else
      0 !== (e3.subtreeFlags & 8772) && null !== f2 ? (f2.return = e3, V$1 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e3 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e3, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$5(163));
          }
        U || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e3 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e3, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$1 = h2;
      break;
    }
    V$1 = b2.return;
  }
}
var mk = Math.ceil, nk = ua$1.ReactCurrentDispatcher, ok = ua$1.ReactCurrentOwner, pk = ua$1.ReactCurrentBatchConfig, K$1 = 0, R$1 = null, Y$1 = null, Z$1 = 0, gj = 0, fj = Uf(0), T$1 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi$1 = null, Si$1 = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$1() {
  return 0 !== (K$1 & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z$1)
    return Z$1 & -Z$1;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$1;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$5(185));
  Ac(a2, c2, d2);
  if (0 === (K$1 & 2) || a2 !== R$1)
    a2 === R$1 && (0 === (K$1 & 2) && (rk |= c2), 4 === T$1 && Dk(a2, Z$1)), Ek(a2, d2), 1 === c2 && 0 === K$1 && 0 === (b2.mode & 1) && (Hj = B() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R$1 ? Z$1 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$1 & 6))
    throw Error(p$5(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$1 ? Z$1 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e3 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    if (R$1 !== a2 || Z$1 !== b2)
      vk = null, Hj = B() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$1 = e3;
    null !== Y$1 ? b2 = 0 : (R$1 = null, Z$1 = 0, b2 = T$1);
  }
  if (0 !== b2) {
    2 === b2 && (e3 = xc(a2), 0 !== e3 && (d2 = e3, b2 = Ok(a2, e3)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e3 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e3) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B()), c2;
      a2.finishedWork = e3;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$5(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e3 = a2.suspendedLanes;
            if ((e3 & d2) !== d2) {
              L$1();
              a2.pingedLanes |= a2.suspendedLanes & e3;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e3 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e3 && (e3 = g2);
            d2 &= ~f2;
          }
          d2 = e3;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$5(329));
      }
    }
  }
  Ek(a2, B());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e3 = c2[d2], f2 = e3.getSnapshot;
          e3 = e3.value;
          try {
            if (!He$1(f2(), e3))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$1 & 6))
    throw Error(p$5(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B()), c2;
  if (6 === c2)
    throw Error(p$5(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, 0 === K$1 && (Hj = B() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$1 & 6) && Ik();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = pk.transition, d2 = C$1;
  try {
    if (pk.transition = null, C$1 = 1, a2)
      return a2();
  } finally {
    C$1 = d2, pk.transition = c2, K$1 = b2, 0 === (K$1 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$1(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y$1)
    for (c2 = Y$1.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$1(Wf);
          E$1(H$3);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$1(M$1);
          break;
        case 19:
          E$1(M$1);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$1 = a2;
  Y$1 = a2 = wh(a2.current, null);
  Z$1 = gj = b2;
  T$1 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e3 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e3;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y$1;
    try {
      Qg();
      Ph.current = ai$1;
      if (Sh) {
        for (var d2 = N$1.memoizedState; null !== d2; ) {
          var e3 = d2.queue;
          null !== e3 && (e3.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$2 = O = N$1 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$1 = 1;
        qk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$1;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi$1(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi$1(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti$1(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti$1(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$5(426));
          }
        } else if (I$1 && h2.mode & 1) {
          var J2 = Vi$1(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi$1(J2, g2, h2, f2, b2);
            Jg(Ki$1(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki$1(k2, h2);
        4 !== T$1 && (T$1 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi$1(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si$1 || !Si$1.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri$1(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na2) {
      b2 = na2;
      Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai$1;
  return null === a2 ? ai$1 : a2;
}
function uj() {
  if (0 === T$1 || 3 === T$1 || 2 === T$1)
    T$1 = 4;
  null === R$1 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$1, Z$1);
}
function Jk(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = Kk();
  if (R$1 !== a2 || Z$1 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e3) {
      Nk(a2, e3);
    }
  while (1);
  Qg();
  K$1 = c2;
  nk.current = d2;
  if (null !== Y$1)
    throw Error(p$5(261));
  R$1 = null;
  Z$1 = 0;
  return T$1;
}
function Uk() {
  for (; null !== Y$1; )
    Vk(Y$1);
}
function Mk() {
  for (; null !== Y$1 && !cc(); )
    Vk(Y$1);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y$1 = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$1 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$1 = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$1 = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a2;
  } while (null !== b2);
  0 === T$1 && (T$1 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C$1, e3 = pk.transition;
  try {
    pk.transition = null, C$1 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e3, C$1 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$1 & 6))
    throw Error(p$5(327));
  c2 = a2.finishedWork;
  var e3 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$5(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R$1 && (Y$1 = R$1 = null, Z$1 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$1;
    C$1 = 1;
    var h2 = K$1;
    K$1 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe$1(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$1 = h2;
    C$1 = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e3);
  f2 = a2.pendingLanes;
  0 === f2 && (Si$1 = null);
  mc(c2.stateNode);
  Ek(a2, B());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e3 = b2[c2], d2(e3.value, { componentStack: e3.stack, digest: e3.digest });
  if (Pi)
    throw Pi = false, a2 = Qi$1, Qi$1 = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$1;
    try {
      pk.transition = null;
      C$1 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p$5(331));
        var e3 = K$1;
        K$1 |= 4;
        for (V$1 = a2.current; null !== V$1; ) {
          var f2 = V$1, g2 = f2.child;
          if (0 !== (V$1.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$1 = l2; null !== V$1; ) {
                  var m2 = V$1;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$1 = q2;
                  else
                    for (; null !== V$1; ) {
                      m2 = V$1;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$1 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$1 = r2;
                        break;
                      }
                      V$1 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$1 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$1 = g2;
          else
            b:
              for (; null !== V$1; ) {
                f2 = V$1;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V$1 = x2;
                  break b;
                }
                V$1 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$1 = w2; null !== V$1; ) {
          g2 = V$1;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$1 = u2;
          else
            b:
              for (g2 = w2; null !== V$1; ) {
                h2 = V$1;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na2) {
                    W$1(h2, h2.return, na2);
                  }
                if (h2 === g2) {
                  V$1 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V$1 = F2;
                  break b;
                }
                V$1 = h2.return;
              }
        }
        K$1 = e3;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na2) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$1 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki$1(c2, b2);
  b2 = Oi$1(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$1();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$1(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si$1 || !Si$1.has(d2))) {
          a2 = Ki$1(c2, a2);
          a2 = Ri$1(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$1();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$1();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R$1 === a2 && (Z$1 & c2) === c2 && (4 === T$1 || 3 === T$1 && (Z$1 & 130023424) === Z$1 && 500 > B() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$1();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e3 = a2.memoizedState;
      null !== e3 && (c2 = e3.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$5(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$1 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e3 = Yf(b2, H$3.current);
      Tg(b2, c2);
      e3 = Xh(null, b2, d2, a2, e3, c2);
      var f2 = bi$1();
      b2.flags |= 1;
      "object" === typeof e3 && null !== e3 && "function" === typeof e3.render && void 0 === e3.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e3.state && void 0 !== e3.state ? e3.state : null, ah(b2), e3.updater = nh, b2.stateNode = e3, e3._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$1 && f2 && vg(b2), Yi(null, b2, e3, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e3 = d2._init;
        d2 = e3(d2._payload);
        b2.type = d2;
        e3 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e3) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi$1(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$5(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), dj(a2, b2, d2, e3, c2);
    case 1:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), ij(a2, b2, d2, e3, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$5(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e3 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e3 = Ki$1(Error(p$5(423)), b2);
            b2 = mj(a2, b2, d2, c2, e3);
            break a;
          } else if (d2 !== e3) {
            e3 = Ki$1(Error(p$5(424)), b2);
            b2 = mj(a2, b2, d2, c2, e3);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e3) {
            b2 = $i$1(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e3 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e3.children, Ef(d2, e3) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), Zi$1(a2, b2, d2, e3, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e3 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e3.value;
        G$1(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He$1(f2.value, g2)) {
            if (f2.children === e3.children && !Wf.current) {
              b2 = $i$1(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$5(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a2, b2, e3.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e3 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e3 = Vg(e3), d2 = d2(e3), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e3 = Lg(d2, b2.pendingProps), e3 = Lg(d2.type, e3), aj(a2, b2, d2, e3, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e3), rh(b2, d2, e3, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$5(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e3, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e3, f2, b2);
        case za$1:
          g2 = 8;
          e3 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e3 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea$1:
          return a2 = Bg(13, c2, b2, e3), a2.elementType = Ea$1, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e3), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e3, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca$1:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$5(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e3);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e3) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e3;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa$1, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$5(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$5(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  a2 = cl(c2, d2, true, a2, e3, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$1();
  e3 = lh(c2);
  f2 = ch(d2, e3);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e3);
  a2.current.lanes = e3;
  Ac(a2, e3, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e3 = b2.current, f2 = L$1(), g2 = lh(e3);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e3, b2, g2);
  null !== a2 && (mh(a2, e3, g2, f2), eh(a2, e3, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$5(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e3) {
  if (e3) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e3 = a2.lastChild; )
    a2.removeChild(e3);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e3) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e3) {
      var h2 = e3;
      e3 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e3);
  } else
    g2 = rl(c2, b2, a2, e3, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B()), 0 === (K$1 & 6) && (Hj = B() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L$1();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L$1();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L$1();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C$1;
};
Ic = function(a2, b2) {
  var c2 = C$1;
  try {
    return C$1 = a2, b2();
  } finally {
    C$1 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e3 = Db(d2);
            if (!e3)
              throw Error(p$5(90));
            Wa(d2);
            bb(d2, e3);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua$1.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$5(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$5(299));
  var c2 = false, d2 = "", e3 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e3 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e3);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$5(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$5(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$5(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$5(405));
  var d2 = null != c2 && c2.hydratedSources || null, e3 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e3 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e3, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e3 = c2._getVersion, e3 = e3(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e3] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e3
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$5(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$5(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$5(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$5(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var l$5 = function(e3, t2) {
  return l$5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t3) {
    e4.__proto__ = t3;
  } || function(e4, t3) {
    for (var n2 in t3)
      t3.hasOwnProperty(n2) && (e4[n2] = t3[n2]);
  }, l$5(e3, t2);
};
function c$3(e3, t2) {
  function n2() {
    this.constructor = e3;
  }
  l$5(e3, t2), e3.prototype = null === t2 ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
}
var d$2 = function() {
  return d$2 = Object.assign || function(e3) {
    for (var t2, n2 = 1, s2 = arguments.length; n2 < s2; n2++)
      for (var i in t2 = arguments[n2])
        Object.prototype.hasOwnProperty.call(t2, i) && (e3[i] = t2[i]);
    return e3;
  }, d$2.apply(this, arguments);
};
function h$6(e3, t2) {
  var n2 = {};
  for (var s2 in e3)
    Object.prototype.hasOwnProperty.call(e3, s2) && t2.indexOf(s2) < 0 && (n2[s2] = e3[s2]);
  if (null != e3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (s2 = Object.getOwnPropertySymbols(e3); i < s2.length; i++)
      t2.indexOf(s2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e3, s2[i]) && (n2[s2[i]] = e3[s2[i]]);
  }
  return n2;
}
var u$3, _, m$5, v$3 = /* @__PURE__ */ function() {
  function e3() {
    this.nr = 0, this.keys = 1, this.subscribers = {};
  }
  return e3.prototype.subscribe = function(e4) {
    var t2 = this.keys++;
    return this.subscribers[t2] = e4, this.nr++, t2;
  }, e3.prototype.unsubscribe = function(e4) {
    this.nr--, delete this.subscribers[e4];
  }, e3.prototype.next = function(e4) {
    var t2 = this.subscribers;
    for (var n2 in t2)
      t2.hasOwnProperty(n2) && t2[n2](e4);
  }, e3;
}(), f$3 = [], g$2 = false, y$2 = "undefined" != typeof window, b$2 = y$2 && window.matchMedia && window.matchMedia("(prefers-color-scheme:dark)"), D = y$2 ? navigator.userAgent : "", x$2 = y$2 ? navigator.platform : "", C = y$2 ? navigator.maxTouchPoints : 0, w$2 = D && D.match(/Android|iPhone|iPad|iPod|Windows Phone|Windows|MSIE/i), T = D && /Safari/.test(D);
/Android/i.test(w$2) ? (u$3 = "android", _ = D.match(/Android\s+([\d.]+)/i), g$2 = true, _ && (f$3 = _[0].replace("Android ", "").split("."))) : /iPhone|iPad|iPod/i.test(w$2) || /iPhone|iPad|iPod/i.test(x$2) || "MacIntel" === x$2 && C > 1 ? (u$3 = "ios", _ = D.match(/OS\s+([\d_]+)/i), g$2 = true, _ && (f$3 = _[0].replace(/_/g, ".").replace("OS ", "").split("."))) : /Windows Phone/i.test(w$2) ? (u$3 = "wp", g$2 = true) : /Windows|MSIE/i.test(w$2) && (u$3 = "windows"), m$5 = +f$3[0], +f$3[1];
var k$5 = {}, E = {}, M = {}, I = new v$3();
function N() {
  var e3 = "", t2 = "", n2 = "";
  for (var s2 in t2 = "android" === u$3 ? "material" : "wp" === u$3 || "windows" === u$3 ? "windows" : "ios", E) {
    if (E[s2].baseTheme === t2 && false !== E[s2].auto && s2 !== t2 + "-dark") {
      e3 = s2;
      break;
    }
    s2 === t2 ? e3 = s2 : n2 || (n2 = s2);
  }
  return e3 || n2;
}
function L(e3) {
  for (var t2 in e3)
    e3.hasOwnProperty(t2) && (k$5[t2] = e3[t2]);
  I.next(k$5);
}
function H$2(e3, t2, n2) {
  var s2 = E[t2];
  E[e3] = d$2({}, s2, { auto: n2, baseTheme: t2 }), M.theme = N();
}
var R = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M217.9 256L345 129c9.4-9.4 9.4-24.6 0-33.9-9.4-9.4-24.6-9.3-34 0L167 239c-9.1 9.1-9.3 23.7-.7 33.1L310.9 417c4.7 4.7 10.9 7 17 7s12.3-2.3 17-7c9.4-9.4 9.4-24.6 0-33.9L217.9 256z"/></svg>', V = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 294.1L383 167c9.4-9.4 24.6-9.4 33.9 0s9.3 24.6 0 34L273 345c-9.1 9.1-23.7 9.3-33.1.7L95 201.1c-4.7-4.7-7-10.9-7-17s2.3-12.3 7-17c9.4-9.4 24.6-9.4 33.9 0l127.1 127z"/></svg>', P$1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M294.1 256L167 129c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.3 34 0L345 239c9.1 9.1 9.3 23.7.7 33.1L201.1 417c-4.7 4.7-10.9 7-17 7s-12.3-2.3-17-7c-9.4-9.4-9.4-24.6 0-33.9l127-127.1z"/></svg>', z$1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 217.9L383 345c9.4 9.4 24.6 9.4 33.9 0 9.4-9.4 9.3-24.6 0-34L273 167c-9.1-9.1-23.7-9.3-33.1-.7L95 310.9c-4.7 4.7-7 10.9-7 17s2.3 12.3 7 17c9.4 9.4 24.6 9.4 33.9 0l127.1-127z"/></svg>', Y = '<svg xmlns="http://www.w3.org/2000/svg" height="17" viewBox="0 0 17 17" width="17"><path d="M8.5 0a8.5 8.5 0 110 17 8.5 8.5 0 010-17zm3.364 5.005a.7.7 0 00-.99 0l-2.44 2.44-2.439-2.44-.087-.074a.7.7 0 00-.903 1.064l2.44 2.439-2.44 2.44-.074.087a.7.7 0 001.064.903l2.439-2.441 2.44 2.441.087.074a.7.7 0 00.903-1.064l-2.441-2.44 2.441-2.439.074-.087a.7.7 0 00-.074-.903z" fill="currentColor" fill-rule="evenodd"/></svg>', W = { clearIcon: Y, labelStyle: "inline" };
E.ios = { Calendar: { nextIconH: P$1, nextIconV: V, prevIconH: R, prevIconV: z$1 }, Checkbox: { position: "end" }, Datepicker: { clearIcon: Y, display: "bottom" }, Dropdown: W, Eventcalendar: { chevronIconDown: V, nextIconH: P$1, nextIconV: V, prevIconH: R, prevIconV: z$1 }, Input: W, Radio: { position: "end" }, Scroller: { display: "bottom", itemHeight: 34, minWheelWidth: 55, rows: 5, scroll3d: true }, SegmentedGroup: { drag: true }, Select: { clearIcon: Y }, Textarea: W }, H$2("ios-dark", "ios"), M.theme = N();
var F = { setText: "", cancelText: "", clearText: "", closeText: "", selectedText: "{count} ", dateFormat: "DD.MM.YYYY", dateFormatLong: "DDD, D MMM YYYY", dateWheelFormat: "|DDD D MMM|", dayNames: ["", "", "", "", "", "", ""], dayNamesShort: ["", "", "", "", "", "", ""], dayNamesMin: ["", "", "", "", "", "", ""], fromText: "", monthNames: ["", "", "", "", "", "", "", "", "", "", "", ""], monthNamesShort: ["", "", "", "", "", "", "", "", "", "", "", ""], timeFormat: "HH:mm", toText: "", nowText: "", amText: "am", pmText: "pm", todayText: "C", firstDay: 1, dateText: "", timeText: "", allDayText: " ", noEventsText: " ", eventText: "", eventsText: "", moreEventsText: " {count}", weekText: " {count}", rangeStartLabel: "", rangeEndLabel: "", rangeStartHelp: "", rangeEndHelp: "", filterEmptyText: " ", filterPlaceholderText: "" };
var X = se(3), K = se(4), q$5 = se(7);
function G(e3, t2, n2) {
  return Math.max(t2, Math.min(e3, n2));
}
function j(e3) {
  return Array.isArray(e3);
}
function J(e3) {
  return e3 - parseFloat(e3) >= 0;
}
function Z(e3) {
  return "number" == typeof e3;
}
function $(e3) {
  return "string" == typeof e3;
}
function Q(e3) {
  return null == e3 || "" === e3;
}
function ee(e3) {
  return void 0 === e3;
}
function te(e3) {
  return "object" == typeof e3;
}
function ne(e3) {
  return null != e3 && "" + e3 != "false";
}
function se(e3) {
  return Array.apply(0, Array(Math.max(0, e3)));
}
function ie(e3) {
  return void 0 !== e3 ? e3 + (J(e3) ? "px" : "") : "";
}
function ae() {
}
function re$1(e3, t2) {
  void 0 === t2 && (t2 = 2);
  for (var n2 = e3 + ""; n2.length < t2; )
    n2 = "0" + n2;
  return n2;
}
function oe(e3) {
  return Math.round(e3);
}
function le(e3, t2) {
  return ce(e3 / t2) * t2;
}
function ce(e3) {
  return Math.floor(e3);
}
function de(e3, t2) {
  var n2, s2;
  return void 0 === t2 && (t2 = 100), function() {
    for (var i = [], a2 = 0; a2 < arguments.length; a2++)
      i[a2] = arguments[a2];
    var r2 = +/* @__PURE__ */ new Date();
    n2 && r2 < n2 + t2 ? (clearTimeout(s2), s2 = setTimeout(function() {
      n2 = r2, e3.apply(void 0, i);
    }, t2)) : (n2 = r2, e3.apply(void 0, i));
  };
}
function he(e3, t2) {
  var n2;
  return void 0 === t2 && (t2 = 100), function() {
    for (var s2 = [], i = 0; i < arguments.length; i++)
      s2[i] = arguments[i];
    clearTimeout(n2), n2 = setTimeout(function() {
      e3.apply(void 0, s2);
    }, t2);
  };
}
function _e(e3, t2) {
  e3._cdr ? setTimeout(t2) : t2();
}
function me(e3, t2) {
  return ve(e3, t2);
}
function pe(e3, t2) {
  return ve(e3, t2, true);
}
function ve(e3, t2, n2) {
  for (var s2 = e3.length, i = 0; i < s2; i++) {
    var a2 = e3[i];
    if (t2(a2, i))
      return n2 ? i : a2;
  }
  return n2 ? -1 : void 0;
}
function fe(e3, t2) {
  return j(e3) ? e3.map(t2) : t2(e3, 0, [e3]);
}
function ge(e3) {
  var t2 = [];
  if (e3)
    for (var n2 = 0, s2 = Object.keys(e3); n2 < s2.length; n2++) {
      var i = s2[n2];
      t2.push(e3[i]);
    }
  return t2;
}
se(24);
var Te = new Date(1970, 0, 1);
function ke(e3) {
  return !!e3._mbsc;
}
function Se(e3, t2) {
  var n2 = t2.dataTimezone || t2.displayTimezone, s2 = t2.timezonePlugin;
  if (n2 && s2 && ke(e3)) {
    var i = e3.clone();
    return i.setTimezone(n2), i.toISOString();
  }
  return e3;
}
var Ee = { amText: "am", dateFormat: "MM/DD/YYYY", dateFormatLong: "D DDD MMM YYYY", dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], dayNamesMin: ["S", "M", "T", "W", "T", "F", "S"], dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], daySuffix: "", firstDay: 0, fromText: "Start", getDate: Xe, monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], monthSuffix: "", pmText: "pm", separator: " ", shortYearCutoff: "+10", timeFormat: "h:mm A", toText: "End", todayText: "Today", weekText: "Week {count}", yearSuffix: "", getMonth: function(e3) {
  return e3.getMonth();
}, getDay: function(e3) {
  return e3.getDate();
}, getYear: function(e3) {
  return e3.getFullYear();
}, getMaxDayOfMonth: function(e3, t2) {
  return 32 - new Date(e3, t2, 32, 12).getDate();
}, getWeekNumber: function(e3) {
  var t2 = /* @__PURE__ */ new Date(+e3);
  t2.setHours(0, 0, 0), t2.setDate(t2.getDate() + 4 - (t2.getDay() || 7));
  var n2 = new Date(t2.getFullYear(), 0, 1);
  return Math.ceil(((t2 - n2) / 864e5 + 1) / 7);
} }, Me = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[T\s](\d{2}):?(\d{2})(?::?(\d{2})(?:\.(\d{3}))?)?((Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/, Ie = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
function Ne(e3, t2, n2) {
  var s2, i, a2 = { y: 1, m: 2, d: 3, h: 4, i: 5, s: 6, u: 7, tz: 8 };
  if (n2)
    for (s2 in a2)
      a2.hasOwnProperty(s2) && (i = e3[a2[s2] - t2]) && (n2[s2] = "tz" === s2 ? i : 1);
}
function Le(e3) {
  return +new Date(1970, 0, 1, e3.getHours(), e3.getMinutes(), e3.getSeconds(), e3.getMilliseconds()) - +Te;
}
function He(e3, t2, n2, s2, i) {
  var a2 = +e3, r2 = +n2;
  return a2 < (i && r2 === +s2 ? +s2 + 1 : +s2) && (i && a2 === +t2 ? +t2 + 1 : +t2) > r2;
}
function Oe(e3, t2) {
  var n2 = Je(e3, t2);
  return n2.setHours(0, 0, 0, 0), n2;
}
function Re(e3, t2) {
  var n2 = Je(e3, t2);
  return n2.setHours(23, 59, 59, 999), n2;
}
function Ve(e3, t2, n2, s2, i) {
  return (!t2 && !i || e3.exclusiveEndDates) && n2 && s2 && n2 < s2 ? Je(t2 ? void 0 : e3, +s2 - 1) : s2;
}
function Pe(e3) {
  return e3.getFullYear() + "-" + re$1(e3.getMonth() + 1) + "-" + re$1(e3.getDate());
}
function ze(e3, t2) {
  return ke(e3) && !t2 ? e3.createDate(e3.getFullYear(), e3.getMonth(), e3.getDate()) : Xe(e3.getFullYear(), e3.getMonth(), e3.getDate());
}
function Ye(e3) {
  return Date.UTC(e3.getFullYear(), e3.getMonth(), e3.getDate());
}
function We(e3, t2) {
  return oe((Ye(t2) - Ye(e3)) / 864e5);
}
function Fe(e3, t2, n2, s2) {
  for (var i = -1, a2 = ze(e3); a2 <= ze(t2); a2.setDate(a2.getDate() + 1))
    at(a2.getDay(), n2, s2) && i++;
  return i;
}
function Ae(e3, t2, n2) {
  var s2 = e3.getFullYear(), i = e3.getMonth(), a2 = e3.getDay(), r2 = void 0 === n2 ? t2.firstDay : n2;
  return new Date(s2, i, r2 - (r2 - a2 > 0 ? 7 : 0) - a2 + e3.getDate());
}
function Ue(e3, t2) {
  return e3.getFullYear() === t2.getFullYear() && e3.getMonth() === t2.getMonth() && e3.getDate() === t2.getDate();
}
function Be(e3, t2, n2) {
  return n2.getYear(e3) === n2.getYear(t2) && n2.getMonth(e3) === n2.getMonth(t2);
}
function Xe(e3, t2, n2, s2, i, a2, r2) {
  var o3 = new Date(e3, t2, n2, s2 || 0, i || 0, a2 || 0, r2 || 0);
  return 23 === o3.getHours() && 0 === (s2 || 0) && o3.setHours(o3.getHours() + 2), o3;
}
function Ke(e3) {
  return e3.getTime;
}
function Ge(e3, t2) {
  return Je(e3, t2.getFullYear(), t2.getMonth(), t2.getDate(), t2.getHours(), t2.getMinutes(), t2.getSeconds(), t2.getMilliseconds());
}
function je(e3) {
  return e3 ? new Date(e3.getFullYear(), e3.getMonth(), e3.getDate(), e3.getHours(), e3.getMinutes(), e3.getSeconds(), e3.getMilliseconds()) : e3;
}
function Je(e3, t2, n2, s2, i, a2, r2, o3) {
  return null === t2 ? null : t2 && (Z(t2) || $(t2)) && ee(n2) ? Ze(t2, e3) : e3 && e3.timezonePlugin ? e3.timezonePlugin.createDate(e3, t2, n2, s2, i, a2, r2, o3) : te(t2) ? new Date(t2) : ee(t2) ? /* @__PURE__ */ new Date() : new Date(t2, n2 || 0, s2 || 1, i || 0, a2 || 0, r2 || 0, o3 || 0);
}
function Ze(e3, t2, n2, s2, i) {
  var a2;
  if ($(e3) && (e3 = e3.trim()), !e3)
    return null;
  var r2 = t2 && t2.timezonePlugin;
  if (r2 && !i) {
    var o3 = ke(e3) ? e3 : r2.parse(e3, t2);
    return o3.setTimezone(t2.displayTimezone), o3;
  }
  return Ke(e3) ? e3 : e3._isAMomentObject ? e3.toDate() : Z(e3) ? new Date(e3) : (a2 = Ie.exec(e3)) ? (Ne(a2, 2, s2), new Date(1970, 0, 1, a2[2] ? +a2[2] : 0, a2[3] ? +a2[3] : 0, a2[4] ? +a2[4] : 0, a2[5] ? +a2[5] : 0)) : (a2 = Me.exec(e3)) ? (Ne(a2, 0, s2), new Date(a2[1] ? +a2[1] : 1970, a2[2] ? a2[2] - 1 : 0, a2[3] ? +a2[3] : 1, a2[4] ? +a2[4] : 0, a2[5] ? +a2[5] : 0, a2[6] ? +a2[6] : 0, a2[7] ? +a2[7] : 0)) : tt(n2, e3, t2);
}
function $e(e3, t2, n2, s2, i) {
  var a2 = y$2 && window.moment || t2.moment, r2 = t2.timezonePlugin && (t2.dataTimezone || t2.displayTimezone), o3 = r2 ? "iso8601" : t2.returnFormat;
  if (r2 && i)
    return Se(e3, t2);
  if (e3) {
    if ("moment" === o3 && a2)
      return a2(e3);
    if ("locale" === o3)
      return et(n2, e3, t2);
    if ("iso8601" === o3)
      return function(e4, t3) {
        var n3 = "", s3 = "";
        return e4 && (t3.h && (s3 += re$1(e4.getHours()) + ":" + re$1(e4.getMinutes()), t3.s && (s3 += ":" + re$1(e4.getSeconds())), t3.u && (s3 += "." + re$1(e4.getMilliseconds(), 3)), t3.tz && (s3 += t3.tz)), t3.y ? (n3 += e4.getFullYear(), t3.m && (n3 += "-" + re$1(e4.getMonth() + 1), t3.d && (n3 += "-" + re$1(e4.getDate())), t3.h && (n3 += "T" + s3))) : t3.h && (n3 = s3)), n3;
      }(e3, s2);
  }
  return e3;
}
function et(e3, t2, n2) {
  var s2, i, a2 = "", r2 = false, o3 = function(t3) {
    for (var n3 = 0, i2 = s2; i2 + 1 < e3.length && e3.charAt(i2 + 1) === t3; )
      n3++, i2++;
    return n3;
  }, l2 = function(e4) {
    var t3 = o3(e4);
    return s2 += t3, t3;
  }, c2 = function(e4, t3, n3) {
    var s3 = "" + t3;
    if (l2(e4))
      for (; s3.length < n3; )
        s3 = "0" + s3;
    return s3;
  }, d2 = function(e4, t3, n3, s3) {
    return 3 === l2(e4) ? s3[t3] : n3[t3];
  };
  for (s2 = 0; s2 < e3.length; s2++)
    if (r2)
      "'" !== e3.charAt(s2) || l2("'") ? a2 += e3.charAt(s2) : r2 = false;
    else
      switch (e3.charAt(s2)) {
        case "D":
          a2 += o3("D") > 1 ? d2("D", t2.getDay(), n2.dayNamesShort, n2.dayNames) : c2("D", n2.getDay(t2), 2);
          break;
        case "M":
          a2 += o3("M") > 1 ? d2("M", n2.getMonth(t2), n2.monthNamesShort, n2.monthNames) : c2("M", n2.getMonth(t2) + 1, 2);
          break;
        case "Y":
          i = n2.getYear(t2), a2 += 3 === l2("Y") ? i : (i % 100 < 10 ? "0" : "") + i % 100;
          break;
        case "h":
          var h2 = t2.getHours();
          a2 += c2("h", h2 > 12 ? h2 - 12 : 0 === h2 ? 12 : h2, 2);
          break;
        case "H":
          a2 += c2("H", t2.getHours(), 2);
          break;
        case "m":
          a2 += c2("m", t2.getMinutes(), 2);
          break;
        case "s":
          a2 += c2("s", t2.getSeconds(), 2);
          break;
        case "a":
          a2 += t2.getHours() > 11 ? n2.pmText : n2.amText;
          break;
        case "A":
          a2 += t2.getHours() > 11 ? n2.pmText.toUpperCase() : n2.amText.toUpperCase();
          break;
        case "'":
          l2("'") ? a2 += "'" : r2 = true;
          break;
        default:
          a2 += e3.charAt(s2);
      }
  return a2;
}
function tt(e3, t2, n2) {
  var s2 = d$2({}, Ee, n2), i = Ze(s2.defaultValue || /* @__PURE__ */ new Date());
  if (!t2)
    return i;
  e3 || (e3 = s2.dateFormat + s2.separator + s2.timeFormat);
  var a2, r2 = s2.shortYearCutoff, o3 = s2.getYear(i), l2 = s2.getMonth(i) + 1, c2 = s2.getDay(i), h2 = i.getHours(), u2 = i.getMinutes(), _2 = 0, m2 = -1, p2 = false, v2 = 0, f2 = function(t3) {
    for (var n3 = 0, s3 = a2; s3 + 1 < e3.length && e3.charAt(s3 + 1) === t3; )
      n3++, s3++;
    return n3;
  }, g2 = function(e4) {
    var t3 = f2(e4);
    return a2 += t3, t3;
  }, y2 = function(e4) {
    var n3 = g2(e4), s3 = new RegExp("^\\d{1," + (n3 >= 2 ? 4 : 2) + "}"), i2 = t2.substr(v2).match(s3);
    return i2 ? (v2 += i2[0].length, parseInt(i2[0], 10)) : 0;
  }, b2 = function(e4, n3, s3) {
    for (var i2 = 3 === g2(e4) ? s3 : n3, a3 = 0; a3 < i2.length; a3++)
      if (t2.substr(v2, i2[a3].length).toLowerCase() === i2[a3].toLowerCase())
        return v2 += i2[a3].length, a3 + 1;
    return 0;
  }, D2 = function() {
    v2++;
  };
  for (a2 = 0; a2 < e3.length; a2++)
    if (p2)
      "'" !== e3.charAt(a2) || g2("'") ? D2() : p2 = false;
    else
      switch (e3.charAt(a2)) {
        case "Y":
          o3 = y2("Y");
          break;
        case "M":
          l2 = f2("M") < 2 ? y2("M") : b2("M", s2.monthNamesShort, s2.monthNames);
          break;
        case "D":
          f2("D") < 2 ? c2 = y2("D") : b2("D", s2.dayNamesShort, s2.dayNames);
          break;
        case "H":
          h2 = y2("H");
          break;
        case "h":
          h2 = y2("h");
          break;
        case "m":
          u2 = y2("m");
          break;
        case "s":
          _2 = y2("s");
          break;
        case "a":
          m2 = b2("a", [s2.amText, s2.pmText], [s2.amText, s2.pmText]) - 1;
          break;
        case "A":
          m2 = b2("A", [s2.amText, s2.pmText], [s2.amText, s2.pmText]) - 1;
          break;
        case "'":
          g2("'") ? D2() : p2 = true;
          break;
        default:
          D2();
      }
  if (o3 < 100) {
    var x2 = void 0;
    x2 = o3 <= ($(r2) ? (/* @__PURE__ */ new Date()).getFullYear() % 100 + parseInt(r2, 10) : +r2) ? 0 : -100, o3 += (/* @__PURE__ */ new Date()).getFullYear() - (/* @__PURE__ */ new Date()).getFullYear() % 100 + x2;
  }
  h2 = -1 === m2 ? h2 : m2 && h2 < 12 ? h2 + 12 : m2 || 12 !== h2 ? h2 : 0;
  var C2 = s2.getDate(o3, l2 - 1, c2, h2, u2, _2);
  return s2.getYear(C2) !== o3 || s2.getMonth(C2) + 1 !== l2 || s2.getDay(C2) !== c2 ? i : C2;
}
function nt(e3, t2, n2) {
  if (e3 === t2)
    return true;
  if (j(e3) && !e3.length && null === t2 || j(t2) && !t2.length && null === e3)
    return true;
  if (null === e3 || null === t2 || void 0 === e3 || void 0 === t2)
    return false;
  if ($(e3) && $(t2))
    return e3 === t2;
  var s2 = n2 && n2.dateFormat;
  if (j(e3) || j(t2)) {
    if (e3.length !== t2.length)
      return false;
    for (var i = 0; i < e3.length; i++) {
      var a2 = e3[i], r2 = t2[i];
      if (!($(a2) && $(r2) ? a2 === r2 : +Ze(a2, n2, s2) == +Ze(r2, n2, s2)))
        return false;
    }
    return true;
  }
  return +Ze(e3, n2, s2) == +Ze(t2, n2, s2);
}
function st(e3) {
  return ke(e3) ? e3.clone() : new Date(e3);
}
function it(e3, t2) {
  var n2 = st(e3);
  return n2.setDate(n2.getDate() + t2), n2;
}
function at(e3, t2, n2) {
  return t2 > n2 ? e3 <= n2 || e3 >= t2 : e3 >= t2 && e3 <= n2;
}
function rt(e3, t2) {
  var n2 = 6e4 * t2, s2 = st(e3).setHours(0, 0, 0, 0), i = s2 + Math.round((+e3 - +s2) / n2) * n2;
  return ke(e3) ? e3.createDate(i) : new Date(i);
}
function ot(e3, t2, n2) {
  return t2 && e3 < t2 ? new Date(t2) : n2 && e3 > n2 ? new Date(n2) : e3;
}
y$2 && "undefined" == typeof Symbol && (window.Symbol = { toPrimitive: "toPrimitive" });
var lt2 = 1, ct = d$2({}, Ee, { dateText: "Date", eventText: "event", eventsText: "events", moreEventsText: "{count} more", nextPageText: "Next page", prevPageText: "Previous page", showEventTooltip: true, showToday: true, timeText: "Time" });
function dt(e3, t2) {
  var n2 = t2.refDate ? Ze(t2.refDate) : Te, s2 = t2.showCalendar ? t2.calendarType : t2.eventRange, i = (t2.showCalendar ? "year" === s2 ? 1 : "week" === s2 ? t2.weeks : t2.size : t2.eventRangeSize) || 1, a2 = t2.getDate, r2 = "week" === s2 ? Ae(n2, t2) : n2, o3 = t2.getYear(r2), l2 = t2.getMonth(r2), c2 = t2.getDay(r2);
  switch (s2) {
    case "year":
      return a2(o3 + e3 * i, 0, 1);
    case "week":
      return a2(o3, l2, c2 + 7 * i * e3);
    case "day":
      return a2(o3, l2, c2 + i * e3);
    default:
      return a2(o3, l2 + e3 * i, 1);
  }
}
function ht(e3, t2) {
  var n2, s2 = t2.refDate ? Ze(t2.refDate) : Te, i = t2.getYear, a2 = t2.getMonth, r2 = t2.showCalendar ? t2.calendarType : t2.eventRange, o3 = (t2.showCalendar ? "year" === r2 ? 1 : "week" === r2 ? t2.weeks : t2.size : t2.eventRangeSize) || 1;
  switch (r2) {
    case "year":
      n2 = i(e3) - i(s2);
      break;
    case "week":
      n2 = We(Ae(s2, t2), Ae(e3, t2)) / 7;
      break;
    case "day":
      n2 = We(s2, e3);
      break;
    case "month":
      n2 = a2(e3) - a2(s2) + 12 * (i(e3) - i(s2));
      break;
    default:
      return;
  }
  return ce(n2 / o3);
}
function ut(e3, t2) {
  var n2 = t2.refDate ? Ze(t2.refDate) : Te;
  return ce((t2.getYear(e3) - t2.getYear(n2)) / 12);
}
function _t(e3, t2) {
  var n2 = t2.refDate ? Ze(t2.refDate) : Te;
  return t2.getYear(e3) - t2.getYear(n2);
}
function mt(e3, t2) {
  var n2 = Ze(e3.start || e3.date), s2 = Ze(t2.start || e3.date), i = e3.title || e3.text, a2 = t2.title || t2.text, r2 = n2 ? +n2 * (e3.allDay ? 1 : 10) : 0, o3 = s2 ? +s2 * (t2.allDay ? 1 : 10) : 0;
  return r2 === o3 ? i > a2 ? 1 : -1 : r2 - o3;
}
function pt(e3, t2) {
  return "auto" === e3 ? Math.max(1, Math.min(3, Math.floor(t2 ? t2 / 296 : 1))) : e3 ? +e3 : 1;
}
function vt(e3, t2, n2, s2, i, a2, r2, o3, l2, c2, d2, h2, u2, _2) {
  t2 = t2 || {};
  for (var m2 = {}, p2 = {}, v2 = n2, f2 = 0, g2 = i, y2 = s2; v2 < s2; ) {
    var b2 = Pe(v2), D2 = v2.getDay(), x2 = e3.getDay(v2), C2 = d2 && e3.getDate(e3.getYear(v2), e3.getMonth(v2) + 1, 0), w2 = l2 && (D2 === o3 || 1 === x2 && d2) || +v2 == +n2, T2 = Ae(v2, e3), k2 = ft(t2[b2] || [], c2), S2 = void 0, E2 = void 0, M2 = 0, I2 = 0, N2 = 0;
    w2 && (p2 = {}, y2 = l2 ? it(T2, a2) : s2), r2 && (k2 = k2.filter(function(e4) {
      return e4.allDay;
    })), -1 === i && (g2 = k2.length + 1);
    var L2 = k2.length, H2 = [];
    for (h2 && (H2.push({ id: "count_" + +v2, count: L2, placeholder: 0 === L2 }), M2 = g2); L2 && M2 < g2; ) {
      S2 = null;
      for (var O2 = 0; O2 < k2.length; O2++)
        p2[M2] === k2[O2] && (S2 = k2[O2], E2 = O2);
      if (M2 === g2 - 1 && (I2 < L2 - 1 || N2 === L2 && !S2) && -1 !== i) {
        var R2 = L2 - I2, V2 = u2 || "", P2 = (R2 > 1 && _2 || V2).replace(/{count}/, R2);
        if (R2 && H2.push({ id: "more_" + ++f2, more: P2, label: P2 }), S2) {
          p2[M2] = null;
          for (var z2 = 0, Y2 = S2._days; z2 < Y2.length; z2++) {
            var W2 = Y2[z2], F2 = V2.replace(/{count}/, "1");
            m2[Pe(W2)].data[M2] = { id: "more_" + ++f2, more: F2, label: F2 };
          }
        }
        I2++, M2++;
      } else if (S2)
        E2 === N2 && N2++, Ue(v2, Ze(S2.end, S2.allDay ? void 0 : e3)) && (p2[M2] = null), H2.push({ id: S2.occurrenceId || S2.id, event: S2 }), M2++, I2++, S2._days.push(v2);
      else if (N2 < L2) {
        var A2 = k2[N2], U2 = A2.allDay, B2 = A2.start && Ze(A2.start, U2 ? void 0 : e3);
        if (!B2 || Ue(v2, B2) || w2) {
          var X2 = Ve(e3, U2, B2, A2.end && Ze(A2.end, U2 ? void 0 : e3), true), K2 = X2 && !Ue(B2, X2), q2 = C2 && C2 < X2 ? C2 : X2, G2 = B2 ? ", " + e3.fromText + ": " + et("DDDD, MMMM D, YYYY", B2, e3) : "", j2 = X2 ? ", " + e3.toText + ": " + et("DDDD, MMMM D, YYYY", X2, e3) : "";
          void 0 === A2.id && (A2.id = "mbsc_" + lt2++), K2 && (p2[M2] = A2), A2._days = [v2], H2.push({ event: A2, id: A2.occurrenceId || A2.id, label: (A2.title || A2.text || "") + G2 + j2, lastDay: C2 ? it(C2, 1) : void 0, multiDay: K2, showText: true, width: K2 ? 100 * Math.min(We(v2, q2) + 1, We(v2, y2)) : 100 }), M2++, I2++;
        }
        N2++;
      } else
        I2 < L2 && H2.push({ id: "ph_" + ++f2, placeholder: true }), M2++;
    }
    m2[b2] = { data: H2, events: k2 }, v2 = ze(it(v2, 1));
  }
  return m2;
}
function ft(e3, t2) {
  return e3 && e3.slice(0).sort(t2 || mt);
}
var gt2, yt = reactExports.createContext({}), Dt = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._setEl = function(e4) {
      t3._el = e4 ? e4._el || e4 : null;
    }, t3;
  }
  return c$3(t2, e3), Object.defineProperty(t2.prototype, "value", { get: function() {
    return this.__value;
  }, set: function(e4) {
    this.__value = e4;
  }, enumerable: true, configurable: true }), t2.prototype.componentDidMount = function() {
    this.__init(), this._init(), this._mounted(), this._updated();
  }, t2.prototype.componentDidUpdate = function() {
    this._updated();
  }, t2.prototype.componentWillUnmount = function() {
    this._destroy(), this.__destroy();
  }, t2.prototype.render = function() {
    return this._opt = this.context, this._willUpdate(), this._template(this.s, this.state);
  }, t2.prototype._safeHtml = function(e4) {
    return { __html: e4 };
  }, t2.prototype._init = function() {
  }, t2.prototype.__init = function() {
  }, t2.prototype._emit = function(e4, t3) {
  }, t2.prototype._mounted = function() {
  }, t2.prototype._updated = function() {
  }, t2.prototype._destroy = function() {
  }, t2.prototype.__destroy = function() {
  }, t2.prototype._willUpdate = function() {
  }, t2.prototype._template = function(e4, t3) {
  }, t2.contextType = yt, t2;
}(reactExports.PureComponent), xt = 0, Ct = { large: 992, medium: 768, small: 576, xlarge: 1200, xsmall: 0 };
b$2 && (gt2 = b$2.matches, b$2.addListener(function(e3) {
  gt2 = e3.matches, I.next();
}));
var wt = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3.s = {}, t3.state = {}, t3._mbsc = true, t3._v = { version: "5.20.1" }, t3._uid = ++xt, t3;
  }
  return c$3(t2, e3), Object.defineProperty(t2.prototype, "nativeElement", { get: function() {
    return this._el;
  }, enumerable: true, configurable: true }), t2.prototype.destroy = function() {
  }, t2.prototype._hook = function(e4, t3) {
    var n2 = this.s;
    if (t3.inst = this, t3.type = e4, this._emit(e4, t3), n2[e4])
      return n2[e4](t3, this);
  }, t2.prototype.__init = function() {
    var e4 = this;
    if (this.constructor.defaults) {
      this._optChange = I.subscribe(function() {
        e4.forceUpdate();
      });
      var t3 = this.props.modules;
      if (t3)
        for (var n2 = 0, s2 = t3; n2 < s2.length; n2++) {
          var i = s2[n2];
          i.init && i.init(this);
        }
    }
    this._hook("onInit", {});
  }, t2.prototype.__destroy = function() {
    void 0 !== this._optChange && I.unsubscribe(this._optChange), this._hook("onDestroy", {});
  }, t2.prototype._render = function(e4, t3) {
  }, t2.prototype._willUpdate = function() {
    this._merge(), this._render(this.s, this.state);
  }, t2.prototype._resp = function(e4) {
    var t3, n2 = e4.responsive, s2 = -1, i = this.state.width;
    if (void 0 === i && (i = 375), n2 && i) {
      for (var a2 in n2)
        if (n2.hasOwnProperty(a2)) {
          var r2 = n2[a2], o3 = r2.breakpoint || Ct[a2];
          i >= o3 && o3 > s2 && (t3 = r2, s2 = o3);
        }
    }
    return t3;
  }, t2.prototype._merge = function() {
    var e4, t3, n2, s2 = this.constructor, i = s2.defaults, a2 = this._opt || {}, r2 = {};
    if (this._prevS = this.s || {}, i) {
      for (var o3 in this.props)
        void 0 !== this.props[o3] && (r2[o3] = this.props[o3]);
      var l2 = r2.locale || a2.locale || k$5.locale || {}, c2 = r2.calendarSystem || l2.calendarSystem || a2.calendarSystem || k$5.calendarSystem, h2 = r2.theme || a2.theme || k$5.theme, _2 = r2.themeVariant || a2.themeVariant || k$5.themeVariant;
      "auto" !== h2 && h2 || (h2 = M.theme), "dark" !== _2 && (!gt2 || "auto" !== _2 && _2) || !E[h2 + "-dark"] || (h2 += "-dark"), r2.theme = h2;
      var m2 = (n2 = E[h2]) && E[h2][s2._name];
      t3 = d$2({}, i, m2, l2, k$5, a2, c2, r2);
      var p2 = this._resp(t3);
      this._respProps = p2, p2 && (t3 = d$2({}, t3, p2));
    } else
      t3 = d$2({}, this.props), n2 = E[t3.theme];
    e4 = n2 && n2.baseTheme, t3.baseTheme = e4, this.s = t3, this._className = t3.cssClass || t3.class || t3.className || "", this._rtl = " mbsc-" + (t3.rtl ? "rtl" : "ltr"), this._theme = " mbsc-" + t3.theme + (e4 ? " mbsc-" + e4 : ""), this._touchUi = "auto" === t3.touchUi || void 0 === t3.touchUi ? g$2 : t3.touchUi, this._hb = "ios" !== u$3 || "ios" !== t3.theme && "ios" !== e4 ? "" : " mbsc-hb";
  }, t2.defaults = void 0, t2._name = "", t2;
}(Dt), Tt = y$2 ? document : void 0, kt = y$2 ? window : void 0, St = ["Webkit", "Moz"], Et = Tt && Tt.createElement("div").style, Mt = Tt && Tt.createElement("canvas"), It = Mt && Mt.getContext && Mt.getContext("2d", { willReadFrequently: true }), Nt = kt && kt.CSS, Lt = Nt && Nt.supports, Ht = {}, Ot = kt && kt.requestAnimationFrame || function(e3) {
  return setTimeout(e3, 20);
}, Rt = kt && kt.cancelAnimationFrame || function(e3) {
  clearTimeout(e3);
}, Vt = Et && void 0 !== Et.animationName, Pt = "ios" === u$3 && !T, zt = Pt && kt && kt.webkit && kt.webkit.messageHandlers, Yt = Et && void 0 === Et.touchAction || Pt && !zt, Wt = function() {
  if (!Et || void 0 !== Et.transform)
    return "";
  for (var e3 = 0, t2 = St; e3 < t2.length; e3++) {
    var n2 = t2[e3];
    if (void 0 !== Et[n2 + "Transform"])
      return n2;
  }
  return "";
}(), Ft = Wt ? "-" + Wt.toLowerCase() + "-" : "", At = Lt && Lt("(transform-style: preserve-3d)"), Ut = Lt && (Lt("position", "sticky") || Lt("position", "-webkit-sticky"));
function Bt(e3, t2, n2, s2) {
  e3 && e3.addEventListener(t2, n2, s2);
}
function Xt(e3, t2, n2, s2) {
  e3 && e3.removeEventListener(t2, n2, s2);
}
function Kt(e3) {
  if (y$2)
    return e3 && e3.ownerDocument ? e3.ownerDocument : Tt;
}
function qt(e3, t2) {
  return parseFloat(getComputedStyle(e3)[t2] || "0");
}
function Gt(e3) {
  return void 0 !== e3.scrollLeft ? e3.scrollLeft : e3.pageXOffset;
}
function jt(e3) {
  return void 0 !== e3.scrollTop ? e3.scrollTop : e3.pageYOffset;
}
function Jt(e3) {
  if (y$2)
    return e3 && e3.ownerDocument && e3.ownerDocument.defaultView ? e3.ownerDocument.defaultView : kt;
}
function Zt(e3, t2) {
  var n2 = getComputedStyle(e3), s2 = (Wt ? n2[Wt + "Transform"] : n2.transform).split(")")[0].split(", ");
  return +(t2 ? s2[13] || s2[5] : s2[12] || s2[4]) || 0;
}
function $t(e3) {
  if (Ht[e3])
    return Ht[e3];
  if (!It)
    return "#fff";
  It.fillStyle = e3, It.fillRect(0, 0, 1, 1);
  var t2 = It.getImageData(0, 0, 1, 1), n2 = t2 ? t2.data : [0, 0, 0], s2 = 0.299 * +n2[0] + 0.587 * +n2[1] + 0.114 * +n2[2] < 130 ? "#fff" : "#000";
  return Ht[e3] = s2, s2;
}
function Qt(e3, t2, n2, s2, i, a2, r2) {
  var o3, l2, c2 = Math.min(1, (+/* @__PURE__ */ new Date() - t2) / 468), d2 = 0.5 * (1 - Math.cos(Math.PI * c2));
  void 0 !== i && (o3 = oe(n2 + (i - n2) * d2), e3.scrollLeft = o3), void 0 !== a2 && (l2 = oe(s2 + (a2 - s2) * d2), e3.scrollTop = l2), o3 !== i || l2 !== a2 ? Ot(function() {
    Qt(e3, t2, n2, s2, i, a2, r2);
  }) : r2 && r2();
}
function en(e3, t2, n2, s2, i, a2) {
  void 0 !== t2 && (t2 = Math.max(0, oe(t2))), void 0 !== n2 && (n2 = Math.max(0, oe(n2))), i && void 0 !== t2 && (t2 = -t2), s2 ? Qt(e3, +/* @__PURE__ */ new Date(), e3.scrollLeft, e3.scrollTop, t2, n2, a2) : (void 0 !== t2 && (e3.scrollLeft = t2), void 0 !== n2 && (e3.scrollTop = n2), a2 && a2());
}
function tn(e3) {
  var t2 = e3.getBoundingClientRect(), n2 = { left: t2.left, top: t2.top }, s2 = Jt(e3);
  return void 0 !== s2 && (n2.top += jt(s2), n2.left += Gt(s2)), n2;
}
function nn(e3, t2) {
  var n2 = e3 && (e3.matches || e3.msMatchesSelector);
  return n2 && n2.call(e3, t2);
}
function sn(e3, t2, n2) {
  for (; e3 && !nn(e3, t2); ) {
    if (e3 === n2 || e3.nodeType === e3.DOCUMENT_NODE)
      return null;
    e3 = e3.parentNode;
  }
  return e3;
}
function an(e3, t2, n2) {
  var s2;
  try {
    s2 = new CustomEvent(t2, { bubbles: true, cancelable: true, detail: n2 });
  } catch (e4) {
    (s2 = document.createEvent("Event")).initEvent(t2, true, true), s2.detail = n2;
  }
  e3.dispatchEvent(s2);
}
function rn(e3, t2) {
  for (var n2 = 0; n2 < e3.length; n2++)
    t2(e3[n2], n2);
}
var on2, ln$1, cn = "change", dn = "click", hn = "mousedown", un = "mouseup", _n = "mouseenter", mn = 0;
function pn(e3, t2, n2) {
  var s2, i, a2, r2, o3, l2, c2, d2 = 0;
  function h2() {
    i.style.width = "100000px", i.style.height = "100000px", s2.scrollLeft = 1e5, s2.scrollTop = 1e5, l2.scrollLeft = 1e5, l2.scrollTop = 1e5;
  }
  function u2() {
    var e4 = +/* @__PURE__ */ new Date();
    r2 = 0, c2 || (e4 - d2 > 200 && !s2.scrollTop && !s2.scrollLeft && (d2 = e4, h2()), r2 || (r2 = Ot(u2)));
  }
  function _2() {
    o3 || (o3 = Ot(m2));
  }
  function m2() {
    o3 = 0, h2(), t2();
  }
  return kt && kt.ResizeObserver ? (on2 || (on2 = new kt.ResizeObserver(function(e4) {
    o3 || (o3 = Ot(function() {
      for (var t3 = 0, n3 = e4; t3 < n3.length; t3++) {
        var s3 = n3[t3];
        s3.target.__mbscResize && s3.target.__mbscResize();
      }
      o3 = 0;
    }));
  })), mn++, e3.__mbscResize = function() {
    n2 ? n2.run(t2) : t2();
  }, on2.observe(e3)) : a2 = Tt && Tt.createElement("div"), a2 && (a2.innerHTML = '<div class="mbsc-resize"><div class="mbsc-resize-i mbsc-resize-x"></div></div><div class="mbsc-resize"><div class="mbsc-resize-i mbsc-resize-y"></div></div>', a2.dir = "ltr", l2 = a2.childNodes[1], s2 = a2.childNodes[0], i = s2.childNodes[0], e3.appendChild(a2), Bt(s2, "scroll", _2), Bt(l2, "scroll", _2), n2 ? n2.runOutsideAngular(function() {
    Ot(u2);
  }) : Ot(u2)), { detach: function() {
    on2 ? (mn--, delete e3.__mbscResize, on2.unobserve(e3), mn || (on2 = void 0)) : (a2 && (Xt(s2, "scroll", _2), Xt(l2, "scroll", _2), e3.removeChild(a2), Rt(o3), a2 = void 0), c2 = true);
  } };
}
var vn = "input,select,textarea,button", fn = 'textarea,button,input[type="button"],input[type="submit"]', gn = vn + ',[tabindex="0"]', yn = { enter: 13, esc: 27, space: 32 }, bn = y$2 && /(iphone|ipod)/i.test(D) && m$5 >= 7 && m$5 < 15;
function Dn(e3, t2) {
  var n2 = e3.s, s2 = [], i = { cancel: { cssClass: "mbsc-popup-button-close", name: "cancel", text: n2.cancelText }, close: { cssClass: "mbsc-popup-button-close", name: "close", text: n2.closeText }, ok: { cssClass: "mbsc-popup-button-primary", keyCode: 13, name: "ok", text: n2.okText }, set: { cssClass: "mbsc-popup-button-primary", keyCode: 13, name: "set", text: n2.setText } };
  if (t2 && t2.length)
    return t2.forEach(function(t3) {
      var n3 = $(t3) ? i[t3] || { text: t3 } : t3;
      n3.handler && !$(n3.handler) || ($(n3.handler) && (n3.name = n3.handler), n3.handler = function(t4) {
        e3._onButtonClick({ domEvent: t4, button: n3 });
      }), s2.push(n3);
    }), s2;
}
function xn(e3, t2) {
  void 0 === t2 && (t2 = 0);
  var n2 = e3._prevModal;
  if (n2 && n2 !== e3 && t2 < 10)
    return n2.isVisible() ? n2 : xn(n2, t2 + 1);
}
var Cn = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._lastFocus = +/* @__PURE__ */ new Date(), t3._onOverlayClick = function() {
      t3._isOpen && t3.s.closeOnOverlayClick && !t3._preventClose && t3._close("overlay"), t3._preventClose = false;
    }, t3._onDocClick = function(e4) {
      t3.s.showOverlay || e4.target === t3.s.focusElm || ln$1 !== t3 || t3._onOverlayClick();
    }, t3._onMouseDown = function(e4) {
      t3.s.showOverlay || (t3._target = e4.target);
    }, t3._onMouseUp = function(e4) {
      t3._target && t3._popup && t3._popup.contains(t3._target) && !t3._popup.contains(e4.target) && (t3._preventClose = true), t3._target = false;
    }, t3._onPopupClick = function() {
      t3.s.showOverlay || (t3._preventClose = true);
    }, t3._onAnimationEnd = function(e4) {
      e4.target === t3._popup && (t3._isClosing && (t3._onClosed(), t3._isClosing = false, t3.state.isReady ? t3.setState({ isReady: false }) : t3.forceUpdate()), t3._isOpening && (t3._onOpened(), t3._isOpening = false, t3.forceUpdate()));
    }, t3._onButtonClick = function(e4) {
      var n2 = e4.domEvent, s2 = e4.button;
      t3._hook("onButtonClick", { domEvent: n2, button: s2 }), /cancel|close|ok|set/.test(s2.name) && t3._close(s2.name);
    }, t3._onFocus = function(e4) {
      var n2 = +/* @__PURE__ */ new Date();
      ln$1 === t3 && e4.target.nodeType && t3._ctx.contains(e4.target) && !t3._popup.contains(e4.target) && n2 - t3._lastFocus > 100 && e4.target !== t3.s.focusElm && (t3._lastFocus = n2, t3._active.focus());
    }, t3._onKeyDown = function(e4) {
      var n2 = t3.s, s2 = e4.keyCode, i = n2.focusElm && !n2.focusOnOpen ? n2.focusElm : void 0;
      if ((32 === s2 && !nn(e4.target, vn) || t3._lock && (38 === s2 || 40 === s2)) && e4.preventDefault(), n2.focusTrap && 9 === s2) {
        var a2 = t3._popup.querySelectorAll(gn), r2 = [], o3 = -1, l2 = 0, c2 = -1, d2 = void 0;
        rn(a2, function(e6) {
          e6.disabled || !e6.offsetHeight && !e6.offsetWidth || (r2.push(e6), o3++, e6 === t3._doc.activeElement && (c2 = o3));
        }), e4.shiftKey && (l2 = o3, o3 = 0), c2 === o3 ? d2 = i || r2[l2] : e4.target === i && (d2 = r2[l2]), d2 && (d2.focus(), e4.preventDefault());
      }
    }, t3._onContentScroll = function(e4) {
      !t3._lock || "touchmove" === e4.type && "stylus" === e4.touches[0].touchType || e4.preventDefault();
    }, t3._onScroll = function(e4) {
      var n2 = t3.s;
      n2.closeOnScroll ? t3._close("scroll") : (t3._hasContext || "anchored" === n2.display) && t3.position();
    }, t3._onWndKeyDown = function(e4) {
      var n2 = t3.s, s2 = e4.keyCode;
      if (ln$1 === t3 && void 0 !== s2) {
        if (t3._hook("onKeyDown", { keyCode: s2 }), n2.closeOnEsc && 27 === s2 && t3._close("esc"), 13 === s2 && nn(e4.target, fn) && !e4.shiftKey)
          return;
        if (t3._buttons)
          for (var i = 0, a2 = t3._buttons; i < a2.length; i++)
            for (var r2 = a2[i], o3 = 0, l2 = j(r2.keyCode) ? r2.keyCode : [r2.keyCode]; o3 < l2.length; o3++) {
              var c2 = l2[o3];
              if (!r2.disabled && void 0 !== c2 && (c2 === s2 || yn[c2] === s2))
                return void r2.handler(e4);
            }
      }
    }, t3._onResize = function() {
      var e4 = t3._wrapper, n2 = t3._hasContext;
      t3._vpWidth = Math.min(e4.clientWidth, n2 ? 1 / 0 : t3._win.innerWidth), t3._vpHeight = Math.min(e4.clientHeight, n2 ? 1 / 0 : t3._win.innerHeight), t3._maxWidth = t3._limitator.offsetWidth, t3._maxHeight = void 0 !== t3.s.maxHeight || t3._vpWidth < 768 || t3._vpHeight < 650 ? t3._limitator.offsetHeight : 600, t3._round = false === t3.s.touchUi || t3._popup.offsetWidth < t3._vpWidth && t3._vpWidth > t3._maxWidth;
      var s2 = { isLarge: t3._round, maxPopupHeight: t3._maxHeight, maxPopupWidth: t3._maxWidth, target: e4, windowHeight: t3._vpHeight, windowWidth: t3._vpWidth };
      false === t3._hook("onResize", s2) || s2.cancel || t3.position();
    }, t3;
  }
  return c$3(t2, e3), t2.prototype.open = function() {
    this._isOpen || this.setState({ isOpen: true });
  }, t2.prototype.close = function() {
    this._close();
  }, t2.prototype.isVisible = function() {
    return !!this._isOpen;
  }, t2.prototype.position = function() {
    if (this._isOpen) {
      var e4 = this.s, t3 = this.state, n2 = this._wrapper, s2 = this._popup, i = this._hasContext, a2 = e4.anchor, r2 = e4.anchorAlign, o3 = e4.rtl, l2 = jt(this._scrollCont), c2 = Gt(this._scrollCont), d2 = this._vpWidth, h2 = this._vpHeight, u2 = this._maxWidth, _2 = this._maxHeight, m2 = Math.min(s2.offsetWidth, u2), p2 = Math.min(s2.offsetHeight, _2), v2 = e4.showArrow;
      this._lock = e4.scrollLock && this._content.scrollHeight <= this._content.clientHeight, i && (n2.style.top = l2 + "px", n2.style.left = c2 + "px");
      var f2 = false === this._hook("onPosition", { isLarge: this._round, maxPopupHeight: _2, maxPopupWidth: u2, target: this._wrapper, windowHeight: h2, windowWidth: d2 });
      if ("anchored" !== e4.display || f2)
        this.setState({ height: h2, isReady: true, showArrow: v2, width: d2 });
      else {
        var g2 = 0, y2 = 0, b2 = G(t3.modalLeft || 0, 8, d2 - m2 - 8), D2 = t3.modalTop || 8, x2 = "bottom", C2 = {}, w2 = v2 ? 16 : 4, T2 = (n2.offsetWidth - d2) / 2, k2 = (n2.offsetHeight - h2) / 2;
        if (i) {
          var S2 = this._ctx.getBoundingClientRect();
          y2 = S2.top, g2 = S2.left;
        }
        if (a2 && this._ctx.contains(a2)) {
          var E2 = a2.getBoundingClientRect(), M2 = E2.top - y2, I2 = E2.left - g2, N2 = a2.offsetWidth, L2 = a2.offsetHeight;
          if (b2 = G(b2 = "start" === r2 && !o3 || "end" === r2 && o3 ? I2 : "end" === r2 && !o3 || "start" === r2 && o3 ? I2 + N2 - m2 : I2 - (m2 - N2) / 2, 8, d2 - m2 - 8), D2 = M2 + L2 + w2, C2 = { left: G(I2 + N2 / 2 - b2 - T2, 30, m2 - 30) + "px" }, D2 + p2 + w2 > h2) {
            if (M2 - p2 - w2 > 0)
              x2 = "top", D2 = M2 - p2 - w2;
            else if (!e4.disableLeftRight) {
              var H2 = I2 - m2 - 8 > 0;
              (H2 || I2 + N2 + m2 + 8 <= d2) && ((D2 = G(M2 - (p2 - L2) / 2, 8, h2 - p2 - 8)) + p2 + 8 > h2 && (D2 = Math.max(h2 - p2 - 8, 0)), C2 = { top: G(M2 + L2 / 2 - D2 - k2, 30, p2 - 30) + "px" }, x2 = H2 ? "left" : "right", b2 = H2 ? I2 - m2 : I2 + N2);
            }
          }
        }
        "top" !== x2 && "bottom" !== x2 || D2 + p2 + w2 > h2 && (D2 = Math.max(h2 - p2 - w2, 0), v2 = false), this.setState({ arrowPos: C2, bubblePos: x2, height: h2, isReady: true, modalLeft: b2, modalTop: D2, showArrow: v2, width: d2 });
      }
    }
  }, t2.prototype._render = function(e4, t3) {
    "bubble" === e4.display && (e4.display = "anchored");
    var n2 = e4.animation, s2 = e4.display, i = this._prevS, a2 = "anchored" === s2, r2 = "inline" !== s2, o3 = e4.fullScreen && r2, l2 = !!r2 && (void 0 === e4.isOpen ? t3.isOpen : e4.isOpen);
    if (l2 && (e4.windowWidth !== i.windowWidth || e4.display !== i.display || e4.showArrow !== i.showArrow || e4.anchor !== i.anchor && "anchored" === e4.display) && (this._shouldPosition = true), this._limits = { maxHeight: ie(e4.maxHeight), maxWidth: ie(e4.maxWidth) }, this._style = { height: o3 ? "100%" : ie(e4.height), left: a2 && t3.modalLeft ? t3.modalLeft + "px" : "", maxHeight: ie(this._maxHeight || e4.maxHeight), maxWidth: ie(this._maxWidth || e4.maxWidth), top: a2 && t3.modalTop ? t3.modalTop + "px" : "", width: o3 ? "100%" : ie(e4.width) }, this._hasContext = "body" !== e4.context && void 0 !== e4.context, this._needsLock = bn && !this._hasContext && "anchored" !== s2 && e4.scrollLock, this._isModal = r2, this._flexButtons = "center" === s2 || !this._touchUi && !o3 && ("top" === s2 || "bottom" === s2), void 0 !== n2 && true !== n2)
      this._animation = $(n2) ? n2 : "";
    else
      switch (s2) {
        case "bottom":
          this._animation = "slide-up";
          break;
        case "top":
          this._animation = "slide-down";
          break;
        default:
          this._animation = "pop";
      }
    e4.buttons ? e4.buttons !== i.buttons && (this._buttons = Dn(this, e4.buttons)) : this._buttons = void 0, e4.headerText !== i.headerText && (this._headerText = e4.headerText ? this._safeHtml(e4.headerText) : void 0), l2 && !this._isOpen && this._onOpen(), !l2 && this._isOpen && this._onClose(), this._isOpen = l2, this._isVisible = l2 || this._isClosing;
  }, t2.prototype._updated = function() {
    var e4 = this, t3 = this.s, n2 = this._wrapper;
    if (Tt && (t3.context !== this._prevS.context || !this._ctx) && ((s2 = $(t3.context) ? Tt.querySelector(t3.context) : t3.context) || (s2 = Tt.body), s2.__mbscLock = s2.__mbscLock || 0, s2.__mbscIOSLock = s2.__mbscIOSLock || 0, s2.__mbscModals = s2.__mbscModals || 0, this._ctx = s2, this._justOpened))
      return void _e(this, function() {
        e4.forceUpdate();
      });
    if (n2) {
      if (this._justOpened) {
        var s2 = this._ctx, i = this._hasContext, a2 = this._doc = Kt(n2), r2 = this._win = Jt(n2), o3 = a2.activeElement;
        if (!this._hasWidth && t3.responsive) {
          var l2 = Math.min(n2.clientWidth, i ? 1 / 0 : r2.innerWidth), c2 = Math.min(n2.clientHeight, i ? 1 / 0 : r2.innerHeight);
          if (this._hasWidth = true, l2 !== this.state.width || c2 !== this.state.height)
            return void _e(this, function() {
              e4.setState({ height: c2, width: l2 });
            });
        }
        if (this._scrollCont = i ? s2 : r2, this._observer = pn(n2, this._onResize, this._zone), this._prevFocus = t3.focusElm || o3, s2.__mbscModals++, t3.focusOnOpen && o3 && setTimeout(function() {
          o3.blur();
        }), this._needsLock) {
          if (!s2.__mbscIOSLock) {
            var d2 = jt(this._scrollCont), h2 = Gt(this._scrollCont);
            s2.style.left = -h2 + "px", s2.style.top = -d2 + "px", s2.__mbscScrollLeft = h2, s2.__mbscScrollTop = d2, s2.classList.add("mbsc-popup-open-ios"), s2.parentNode.classList.add("mbsc-popup-open-ios");
          }
          s2.__mbscIOSLock++;
        }
        i && s2.classList.add("mbsc-popup-ctx"), t3.focusTrap && Bt(r2, "focusin", this._onFocus), t3.focusElm && !t3.focusOnOpen && Bt(t3.focusElm, "keydown", this._onKeyDown), Bt(this._scrollCont, "touchmove", this._onContentScroll, { passive: false }), Bt(this._scrollCont, "wheel", this._onContentScroll, { passive: false }), Bt(this._scrollCont, "mousewheel", this._onContentScroll, { passive: false }), setTimeout(function() {
          Bt(a2, hn, e4._onMouseDown), Bt(a2, un, e4._onMouseUp), Bt(a2, dn, e4._onDocClick);
        }), this._hook("onOpen", { target: this._wrapper });
      }
      this._shouldPosition && _e(this, function() {
        e4._onResize();
      }), this._justOpened = false, this._justClosed = false, this._shouldPosition = false;
    }
  }, t2.prototype._destroy = function() {
    this._isOpen && (this._onClosed(), this._unlisten(), ln$1 === this && (ln$1 = xn(this)));
  }, t2.prototype._onOpen = function() {
    var e4 = this;
    Vt && this._animation ? (this._isOpening = true, this._isClosing = false) : this._onOpened(), this._justOpened = true, this._preventClose = false, ln$1 !== this && setTimeout(function() {
      e4._prevModal = ln$1, ln$1 = e4;
    });
  }, t2.prototype._onClose = function() {
    var e4 = this;
    Vt && this._animation ? (this._isClosing = true, this._isOpening = false) : setTimeout(function() {
      e4._onClosed(), e4.setState({ isReady: false });
    }), this._hasWidth = false, this._unlisten();
  }, t2.prototype._onOpened = function() {
    var e4 = this.s;
    if (e4.focusOnOpen) {
      var t3 = e4.activeElm, n2 = t3 ? $(t3) ? this._popup.querySelector(t3) || this._active : t3 : this._active;
      n2 && n2.focus && n2.focus();
    }
    Bt(this._win, "keydown", this._onWndKeyDown), Bt(this._scrollCont, "scroll", this._onScroll);
  }, t2.prototype._onClosed = function() {
    var e4, t3, n2 = this, s2 = this._ctx, i = this._prevFocus, a2 = this.s.focusOnClose && i && i.focus && i !== this._doc.activeElement;
    s2.__mbscModals--, this._justClosed = true, this._needsLock && (s2.__mbscIOSLock--, s2.__mbscIOSLock || (s2.classList.remove("mbsc-popup-open-ios"), s2.parentNode.classList.remove("mbsc-popup-open-ios"), s2.style.left = "", s2.style.top = "", e4 = this._scrollCont, t3 = s2.__mbscScrollLeft, e4.scrollTo ? e4.scrollTo(t3, e4.scrollY) : e4.scrollLeft = t3, function(e6, t4) {
      e6.scrollTo ? e6.scrollTo(e6.scrollX, t4) : e6.scrollTop = t4;
    }(this._scrollCont, s2.__mbscScrollTop))), this._hasContext && !s2.__mbscModals && s2.classList.remove("mbsc-popup-ctx"), this._hook("onClosed", { focus: a2 }), a2 && i.focus(), setTimeout(function() {
      ln$1 === n2 && (ln$1 = xn(n2));
    });
  }, t2.prototype._unlisten = function() {
    Xt(this._win, "keydown", this._onWndKeyDown), Xt(this._scrollCont, "scroll", this._onScroll), Xt(this._scrollCont, "touchmove", this._onContentScroll, { passive: false }), Xt(this._scrollCont, "wheel", this._onContentScroll, { passive: false }), Xt(this._scrollCont, "mousewheel", this._onContentScroll, { passive: false }), Xt(this._doc, hn, this._onMouseDown), Xt(this._doc, un, this._onMouseUp), Xt(this._doc, dn, this._onDocClick), this.s.focusTrap && Xt(this._win, "focusin", this._onFocus), this.s.focusElm && Xt(this.s.focusElm, "keydown", this._onKeyDown), this._observer && (this._observer.detach(), this._observer = null);
  }, t2.prototype._close = function(e4) {
    this._isOpen && (void 0 === this.s.isOpen && this.setState({ isOpen: false }), this._hook("onClose", { source: e4 }));
  }, t2.defaults = { buttonVariant: "flat", cancelText: "Cancel", closeOnEsc: true, closeOnOverlayClick: true, closeText: "Close", contentPadding: true, display: "center", focusOnClose: true, focusOnOpen: true, focusTrap: true, maxWidth: 600, okText: "Ok", scrollLock: true, setText: "Set", showArrow: true, showOverlay: true }, t2;
}(wt);
function wn(e3, t2, n2) {
  void 0 === n2 && (n2 = 0), n2 > 10 ? (delete e3.__mbscTimer, t2(e3)) : (clearTimeout(e3.__mbscTimer), e3.__mbscTimer = setTimeout(function() {
    e3.getInputElement ? e3.getInputElement().then(function(s2) {
      s2 ? (delete e3.__mbscTimer, t2(s2)) : wn(e3, t2, n2 + 1);
    }) : wn(e3, t2, n2 + 1);
  }, 10));
}
function Tn(e3, t2) {
  if (e3) {
    if ((s2 = e3).getInputElement || s2.tagName && "ion-input" === s2.tagName.toLowerCase())
      wn(e3, t2);
    else if (e3.vInput)
      t2(e3.vInput.nativeElement);
    else if (e3._el)
      t2(e3._el);
    else if (1 === e3.nodeType)
      t2(e3);
    else if ($(e3)) {
      var n2 = Tt.querySelector(e3);
      n2 && t2(n2);
    }
  }
  var s2;
}
function kn(e3, t2, n2, s2) {
  if (!e3 || 1 !== e3.nodeType)
    return ae;
  var i, a2 = function() {
    (t2.s.showOnClick || t2.s.showOnFocus) && m2 && !t2._allowTyping && (p2.readOnly = true);
  }, r2 = function(n3) {
    var i2 = t2.s;
    s2 && s2(n3), i2.showOnClick && !i2.disabled && (t2._focusElm = e3, t2._anchor = i2.anchor || e3, t2.open());
  }, o3 = function(e4) {
    t2.s.showOnClick && (t2.s.showOnFocus && (t2._preventShow = true), t2._allowTyping || e4.preventDefault());
  }, l2 = function(e4) {
    t2.s.showOnClick && (t2._isOpen ? 13 === e4.keyCode && t2._allowTyping && e4.stopPropagation() : (32 === e4.keyCode && e4.preventDefault(), 13 !== e4.keyCode && 32 !== e4.keyCode || r2(e4)));
  }, c2 = function(e4) {
    a2(), t2.s.showOnFocus && (t2._preventShow ? t2._preventShow = false : r2(e4));
  }, d2 = function() {
    m2 && (p2.readOnly = i);
  }, h2 = function(e4) {
    n2 && n2(e4);
  }, u2 = function() {
    _2.document.activeElement === e3 && (a2(), t2._preventShow = true);
  }, _2 = Jt(e3), m2 = nn(e3, "input,select"), p2 = e3;
  return m2 && (p2.autocomplete = "off", i = p2.readOnly), Bt(e3, dn, r2), Bt(e3, hn, o3), Bt(e3, "keydown", l2), Bt(e3, "focus", c2), Bt(e3, "blur", d2), Bt(e3, cn, h2), Bt(_2, "focus", u2), function() {
    m2 && (p2.readOnly = i), Xt(e3, dn, r2), Xt(e3, hn, o3), Xt(e3, "keydown", l2), Xt(e3, "focus", c2), Xt(e3, "blur", d2), Xt(e3, cn, h2), Xt(_2, "focus", u2);
  };
}
var En = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._nullSupport = true, t3._onInputChange = function(e4, n2) {
      var s2 = e4.detail || (void 0 !== n2 ? n2 : e4.target.value);
      if (s2 !== t3._tempValueText && !t3._preventChange) {
        t3._readValue(s2, true), t3._valueTextChange = s2 !== t3._tempValueText;
        var i = Q(s2) ? null : t3._get(t3._tempValueRep);
        t3.value = i, t3._change(i);
      }
      t3._preventChange = false;
    }, t3._onResize = function(e4) {
      t3._hook("onResize", e4);
    }, t3._onWrapperResize = function() {
      t3._wrapper && t3._onResize({ windowWidth: t3._wrapper.offsetWidth });
    }, t3._onPopupClose = function(e4) {
      /cancel|esc|overlay|scroll/.test(e4.source) && t3._hook("onCancel", { value: t3.value, valueText: t3._valueText }), t3.close();
    }, t3._onPopupClosed = function(e4) {
      e4.focus && (t3._preventShow = true), t3._hook("onClosed", e4), t3._onClosed();
    }, t3._onPopupKey = function(e4) {
      13 === e4.keyCode && t3._onEnterKey(e4);
    }, t3._onPopupOpen = function(e4) {
      e4.value = t3.value, e4.valueText = t3._valueText, t3._hook("onOpen", e4);
    }, t3._onButtonClick = function(e4) {
      var n2 = e4.domEvent, s2 = e4.button;
      "set" === s2.name && t3.set(), t3._popup && t3._popup._onButtonClick({ domEvent: n2, button: s2 });
    }, t3._setInput = function(e4) {
      t3._el = e4 && e4.nativeElement ? e4.nativeElement : e4;
    }, t3._setPopup = function(e4) {
      t3._popup = e4;
    }, t3._setWrapper = function(e4) {
      t3._wrapper = e4;
    }, t3;
  }
  return c$3(t2, e3), t2.prototype.open = function() {
    this._inst ? this._inst.open() : void 0 === this.s.isOpen && this.setState({ isOpen: true });
  }, t2.prototype.close = function() {
    if ("inline" !== this.s.display)
      if (this._inst)
        this._inst.close();
      else {
        var e4 = { value: this.value, valueText: this._valueText };
        void 0 === this.s.isOpen && this.setState({ isOpen: false }), this._hook("onClose", e4);
      }
  }, t2.prototype.set = function() {
    this._valueRep = this._copy(this._tempValueRep), this._valueText = this._tempValueText, this._value = this.value = this._get(this._valueRep), this._change(this.value);
  }, t2.prototype.position = function() {
    this._inst ? this._inst.position() : this._popup && this._popup.position();
  }, t2.prototype.isVisible = function() {
    return this._inst ? this._inst.isVisible() : !!this._popup && this._popup.isVisible();
  }, t2.prototype.getVal = function() {
    return this._get(this._valueRep);
  }, t2.prototype.setVal = function(e4) {
    this.value = e4, this.setState({ value: e4 });
  }, t2.prototype.getTempVal = function() {
    return this._get(this._tempValueRep);
  }, t2.prototype.setTempVal = function(e4) {
    this._tempValueSet = true, this._tempValueRep = this._parse(e4), this._setOrUpdate(true);
  }, t2.prototype._shouldValidate = function(e4, t3) {
    return false;
  }, t2.prototype._valueEquals = function(e4, t3) {
    return e4 === t3;
  }, t2.prototype._render = function(e4, t3) {
    var n2 = this, s2 = this.props || {}, i = this._respProps || {}, a2 = this._prevS;
    this._touchUi || (e4.display = i.display || s2.display || k$5.display || "anchored", e4.showArrow = i.showArrow || s2.showArrow || false), "bubble" === e4.display && (e4.display = "anchored"), this._scrollLock = e4.scrollLock;
    var r2 = void 0 !== e4.isOpen ? e4.isOpen : t3.isOpen, o3 = void 0 !== e4.value ? e4.value : void 0 === t3.value ? e4.defaultValue : t3.value;
    if (this._showInput = void 0 !== e4.showInput ? e4.showInput : "inline" !== e4.display && void 0 === e4.element, (!this._buttons || e4.buttons !== a2.buttons || e4.display !== a2.display || e4.setText !== a2.setText || e4.cancelText !== a2.cancelText || e4.closeText !== a2.closeText || e4.touchUi !== a2.touchUi) && (this._buttons = Dn(this, e4.buttons || ("inline" === e4.display || "anchored" === e4.display && !this._touchUi ? [] : ["cancel", "set"])), this._live = true, this._buttons && this._buttons.length))
      for (var l2 = 0, c2 = this._buttons; l2 < c2.length; l2++) {
        var d2 = c2[l2];
        "ok" !== d2.name && "set" !== d2.name || (this._live = false);
      }
    if (!this._valueEquals(o3, this._value) || void 0 === this._tempValueRep || this._shouldValidate(e4, a2) || e4.defaultSelection !== a2.defaultSelection || e4.invalid !== a2.invalid || e4.valid !== a2.valid) {
      this._readValue(o3);
      var h2 = this._get(this._tempValueRep), u2 = !(this._valueEquals(o3, h2) || this._nullSupport && Q(o3));
      this._setHeader(), clearTimeout(this._handler), this._handler = setTimeout(function() {
        n2.value = o3, u2 && n2._change(h2), n2._valueEquals(n2._tempValue, h2) || void 0 !== n2._inst || n2._hook("onTempChange", { value: h2 });
      });
    }
    if (e4.headerText !== a2.headerText && this._setHeader(), r2 && !this._isOpen) {
      if (!this._tempValueSet || this._live) {
        var _2 = this._get(this._tempValueRep), m2 = this._get(this._valueRep);
        this._tempValueRep = this._copy(this._valueRep), this._tempValueText = this._format(this._tempValueRep), this._tempValue = _2, this._setHeader(), this._valueEquals(_2, m2) || setTimeout(function() {
          n2._hook("onTempChange", { value: m2 });
        });
      }
      this._onOpen();
    }
    this._allowTyping = e4.inputTyping && !g$2 && !this._touchUi, this._anchorAlign = e4.anchorAlign || (this._touchUi ? "center" : "start"), this._cssClass = "mbsc-picker " + (e4.cssClass || ""), this._isOpen = r2, this._maxWidth = e4.maxWidth, this._valueTextChange = this._valueTextChange || this._oldValueText !== this._valueText, this._oldValueText = this._valueText, this._value = o3, this._shouldInitInput = this._shouldInitInput || e4.display !== a2.display || e4.element !== a2.element;
  }, t2.prototype._updated = function() {
    var e4 = this, t3 = this.s, n2 = this._input;
    this._shouldInitInput && !this._inst && (this._unlisten(), this._wrapper && "inline" === t3.display && (this._observer = pn(this._wrapper, this._onWrapperResize, this._zone)), Tn(t3.element || this._el, function(n3) {
      e4._el = n3, "inline" !== t3.display && (e4._resetEl = kn(n3, e4, e4._onInputChange)), nn(n3, "input,select") && (e4._input = n3, e4._write(n3));
    })), this._valueTextChange && n2 && this._write(n2), this._shouldInitInput = false, this._valueTextChange = false, this._anchor = t3.anchor || this._focusElm || t3.element || this._el;
  }, t2.prototype._writeValue = function(e4, t3, n2) {
    var s2 = e4.value;
    return e4.value = t3, s2 !== t3;
  }, t2.prototype._destroy = function() {
    this._unlisten(), this._shouldInitInput = true;
  }, t2.prototype._setHeader = function() {
    var e4 = this.s.headerText;
    this._headerText = e4 ? e4.replace(/\{value\}/i, this._tempValueText || "&nbsp;") : void 0;
  }, t2.prototype._setOrUpdate = function(e4) {
    var t3 = this._get(this._tempValueRep);
    this._tempValue = t3, this._tempValueText = this._format(this._tempValueRep), this._setHeader(), e4 || this._hook("onTempChange", { value: t3 }), this._live ? this.set() : this.forceUpdate();
  }, t2.prototype._copy = function(e4) {
    return e4;
  }, t2.prototype._format = function(e4) {
    return e4;
  }, t2.prototype._get = function(e4) {
    return e4;
  }, t2.prototype._parse = function(e4, t3) {
    return e4;
  }, t2.prototype._validate = function() {
  }, t2.prototype._onClosed = function() {
  }, t2.prototype._onOpen = function() {
  }, t2.prototype._onParse = function() {
  }, t2.prototype._onEnterKey = function(e4) {
    this.set(), this.close();
  }, t2.prototype._change = function(e4) {
    void 0 === this.s.value && this.setState({ value: e4 }), this._hook("onChange", { value: e4, valueText: this._tempValueText });
  }, t2.prototype._readValue = function(e4, t3) {
    this._tempValueRep = this._parse(e4, t3), this._onParse(), this._validate(), this._tempValueText = this._format(this._tempValueRep), this._valueRep = this._copy(this._tempValueRep), this._valueText = Q(e4) ? "" : this._tempValueText;
  }, t2.prototype._unlisten = function() {
    this._resetEl && (this._resetEl(), this._resetEl = void 0), this._observer && (this._observer.detach(), this._observer = void 0);
  }, t2.prototype._write = function(e4) {
    var t3 = this, n2 = this._value;
    this._writeValue(e4, this._valueText || "", n2) && setTimeout(function() {
      t3._preventChange = true, an(e4, "input"), an(e4, cn);
    });
    var s2 = e4.__mbscFormInst;
    s2 && s2.setOptions({ pickerMap: this.s.valueMap, pickerValue: n2 });
  }, t2.defaults = { cancelText: "Cancel", closeText: "Close", focusOnClose: "android" !== u$3, okText: "Ok", setText: "Set", showOnFocus: g$2 }, t2;
}(wt), Mn = { 0: "SU", 1: "MO", 2: "TU", 3: "WE", 4: "TH", 5: "FR", 6: "SA" }, In = { SU: 0, MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6 }, Nn = { byday: "weekDays", bymonth: "month", bymonthday: "day", bysetpos: "pos", dtstart: "from", freq: "repeat", wkst: "weekStart" };
function Ln(e3, t2, n2, s2) {
  var i = Ze(t2.start, t2.allDay ? void 0 : n2), a2 = Ze(t2.end, t2.allDay ? void 0 : n2), r2 = a2 - i;
  for (s2 && (t2.start = i, t2.end = a2), i = ze(i), a2 = n2.exclusiveEndDates ? a2 : ze(it(a2, 1)); i < a2 || !r2; )
    Hn(e3, i, t2), i = it(i, 1), r2 = 1;
}
function Hn(e3, t2, n2) {
  var s2 = Pe(t2);
  e3[s2] || (e3[s2] = [], e3[s2].date = ze(t2, true)), e3[s2].push(n2);
}
function On(e3, t2, n2, s2, i, a2) {
  var r2 = {};
  if (i)
    for (var o3 = 0, l2 = An(i); o3 < l2.length; o3++) {
      r2[Pe(Ze(l2[o3]))] = true;
    }
  if (a2)
    for (var c2 = 0, d2 = Un(a2, e3, t2, n2, s2); c2 < d2.length; c2++) {
      r2[Pe(d2[c2].d)] = true;
    }
  return r2;
}
function Rn(e3) {
  return $(e3) || e3.getTime || e3.toDate ? e3 : e3.start || e3.date;
}
function Vn(e3) {
  for (var t2 = {}, n2 = 0, s2 = e3.split(";"); n2 < s2.length; n2++) {
    var i = s2[n2].split("="), a2 = i[0].trim().toLowerCase(), r2 = i[1].trim();
    t2[Nn[a2] || a2] = r2;
  }
  return t2;
}
function Wn(e3, t2, n2, s2) {
  for (var i = null, a2 = 0, r2 = e3; a2 < r2.length; a2++) {
    var o3 = r2[a2];
    if (o3.recurring) {
      var l2 = Ze(o3.start || o3.date), c2 = Un(o3.recurring, l2, t2, void 0, n2, o3.reccurringException, o3.recurringExceptionRule, "first");
      (!i || c2 < i) && (i = c2);
    } else if (o3.start && o3.end) {
      var d2 = Ze(o3.start, n2, s2);
      Ze(o3.end, n2, s2) > t2 && (i = d2 <= t2 ? t2 : i && i < d2 ? i : d2);
    } else {
      var h2 = Ze(Rn(o3), n2, s2);
      h2 > t2 && (!i || h2 < i) && (i = h2);
    }
  }
  return i;
}
function Fn(e3, t2, n2, s2) {
  var i = t2;
  e3.sort(function(e4, t3) {
    return Ze(Rn(e4), n2, s2) - Ze(Rn(t3), n2, s2);
  });
  for (var a2 = 0, r2 = e3; a2 < r2.length; a2++) {
    var o3 = r2[a2];
    if (o3.recurring) {
      var l2 = Ze(o3.start || o3.date), c2 = Un(o3.recurring, l2, t2, void 0, n2, o3.reccurringException, o3.recurringExceptionRule, "last");
      c2 > i && (i = c2);
    } else if (o3.start && o3.end) {
      var d2 = Ze(o3.start, n2, s2), h2 = Ze(o3.end, n2, s2);
      h2 > i && We(i, d2) <= 1 && (i = h2);
    } else {
      var u2 = Ze(Rn(o3), n2, s2);
      u2 > i && We(i, u2) <= 1 && (i = u2);
    }
  }
  return i;
}
function An(e3) {
  return e3 ? j(e3) ? e3 : $(e3) ? e3.split(",") : [e3] : [];
}
function Un(e3, t2, n2, s2, i, a2, r2, o3) {
  $(e3) && (e3 = Vn(e3));
  for (var l2, c2, d2 = i.getYear, h2 = i.getMonth, u2 = i.getDay, _2 = i.getDate, m2 = i.getMaxDayOfMonth, p2 = (e3.repeat || "").toLowerCase(), v2 = e3.interval || 1, f2 = e3.count, g2 = e3.from ? Ze(e3.from) : t2 || (1 !== v2 || void 0 !== f2 ? /* @__PURE__ */ new Date() : n2), y2 = ze(g2), b2 = d2(g2), D2 = h2(g2), x2 = e3.until ? Ze(e3.until) : 1 / 0, C2 = g2 < n2, w2 = C2 ? n2 : ze(g2), T2 = "first" === o3, k2 = "last" === o3, S2 = T2 || k2 || !s2 || x2 < s2 ? x2 : s2, E2 = void 0 === f2 ? 1 / 0 : f2, M2 = (e3.weekDays || Mn[g2.getDay()]).split(","), I2 = In[(e3.weekStart || "MO").trim().toUpperCase()], N2 = j(e3.day) ? e3.day : ((e3.day || u2(g2)) + "").split(","), L2 = j(e3.month) ? e3.month : ((e3.month || h2(g2) + 1) + "").split(","), H2 = [], O2 = void 0 !== e3.pos, R2 = O2 ? +e3.pos : 1, V2 = [], P2 = s2 ? On(t2, n2, s2, i, a2, r2) : {}, z2 = true, Y2 = 0, W2 = 0, F2 = null, A2 = n2, U2 = 0, B2 = M2; U2 < B2.length; U2++) {
    var X2 = B2[U2];
    V2.push(In[X2.trim().toUpperCase()]);
  }
  var K2 = function() {
    if (s2 || (P2 = On(c2, c2, it(c2, 1), i, a2, r2)), !P2[Pe(c2)] && c2 >= w2)
      if (T2)
        F2 = !F2 || c2 < F2 ? c2 : F2, z2 = false;
      else if (k2) {
        var e4 = We(A2, c2);
        A2 = c2 > A2 && e4 <= 1 ? c2 : A2, z2 = e4 <= 1;
      } else
        H2.push({ d: c2, i: W2 });
    W2++;
  }, q2 = function(e4, t3) {
    for (var n3 = [], s3 = 0, i2 = V2; s3 < i2.length; s3++)
      for (var a3 = Ae(e4, { firstDay: i2[s3] }); a3 < t3; a3.setDate(a3.getDate() + 7))
        a3.getMonth() === e4.getMonth() && n3.push(+a3);
    n3.sort();
    var r3 = n3[R2 < 0 ? n3.length + R2 : R2 - 1];
    (c2 = r3 ? new Date(r3) : t3) < S2 ? r3 && K2() : z2 = false;
  };
  switch (p2) {
    case "daily":
      for (W2 = f2 && C2 ? ce(We(g2, n2) / v2) : 0; z2; )
        (c2 = _2(d2(g2), h2(g2), u2(g2) + W2 * v2)) < S2 && W2 < E2 ? K2() : z2 = false;
      break;
    case "weekly":
      var G2 = V2, J2 = Ae(g2, { firstDay: I2 }), Z2 = J2.getDay();
      for (G2.sort(function(e4, t3) {
        return (e4 = (e4 -= Z2) < 0 ? e4 + 7 : e4) - (t3 = (t3 -= Z2) < 0 ? t3 + 7 : t3);
      }); z2; ) {
        for (var Q2 = 0, ee2 = G2; Q2 < ee2.length; Q2++) {
          l2 = it(J2, (X2 = ee2[Q2]) < I2 ? X2 - I2 + 7 : X2 - I2), (c2 = _2(d2(l2), h2(l2), u2(l2) + 7 * Y2 * v2)) < S2 && W2 < E2 ? c2 >= y2 && K2() : z2 = false;
        }
        Y2++;
      }
      break;
    case "monthly":
      for (; z2; ) {
        var te2 = m2(b2, D2 + Y2 * v2);
        if (O2)
          q2(_2(b2, D2 + Y2 * v2, 1), _2(b2, D2 + Y2 * v2 + 1, 1));
        else
          for (var ne2 = 0, se2 = N2; ne2 < se2.length; ne2++) {
            var ie2 = se2[ne2];
            (c2 = _2(b2, D2 + Y2 * v2, (he2 = +ie2) < 0 ? te2 + he2 + 1 : he2)) < S2 && W2 < E2 ? te2 >= ie2 && c2 >= y2 && K2() : z2 = false;
          }
        Y2++;
      }
      break;
    case "yearly":
      for (; z2; ) {
        for (var ae2 = 0, re2 = L2; ae2 < re2.length; ae2++) {
          var oe2 = +re2[ae2];
          te2 = m2(b2 + Y2 * v2, oe2 - 1);
          if (O2)
            q2(_2(b2 + Y2 * v2, oe2 - 1, 1), _2(b2 + Y2 * v2, oe2, 1));
          else
            for (var le2 = 0, de2 = N2; le2 < de2.length; le2++) {
              var he2;
              ie2 = de2[le2];
              (c2 = _2(b2 + Y2 * v2, oe2 - 1, (he2 = +ie2) < 0 ? te2 + he2 + 1 : he2)) < S2 && W2 < E2 ? te2 >= ie2 && c2 >= y2 && K2() : z2 = false;
            }
        }
        Y2++;
      }
  }
  return T2 ? F2 : k2 ? A2 : H2;
}
function Bn(e3, t2, n2, s2, i) {
  var a2 = {}, r2 = s2.timezonePlugin, o3 = s2.dataTimezone || s2.displayTimezone, l2 = r2 ? { displayTimezone: o3, timezonePlugin: r2 } : s2;
  if (e3) {
    for (var c2 = 0, h2 = e3; c2 < h2.length; c2++) {
      var u2 = h2[c2], _2 = Rn(u2), m2 = Ze(_2, u2.allDay ? void 0 : s2);
      if (u2.recurring)
        for (var p2 = Ie.test(_2) ? null : Ze(_2), v2 = it(t2, -1), f2 = it(n2, 1), g2 = Un(u2.recurring, p2, v2, f2, s2, u2.recurringException, u2.recurringExceptionRule), y2 = Je(u2.allDay ? void 0 : l2, m2), b2 = u2.end ? Ze(u2.end, u2.allDay ? void 0 : s2) : y2, D2 = +b2 - +y2, x2 = 0, C2 = g2; x2 < C2.length; x2++) {
          var w2 = C2[x2], T2 = w2.d, k2 = d$2({}, u2);
          if (u2.start ? k2.start = Je(u2.allDay ? void 0 : l2, T2.getFullYear(), T2.getMonth(), T2.getDate(), y2.getHours(), y2.getMinutes(), y2.getSeconds()) : (k2.allDay = true, k2.start = Je(void 0, T2.getFullYear(), T2.getMonth(), T2.getDate())), u2.end) {
            if (u2.allDay) {
              var S2 = it(T2, We(y2, b2));
              k2.end = new Date(S2.getFullYear(), S2.getMonth(), S2.getDate(), b2.getHours(), b2.getMinutes(), b2.getSeconds());
            } else
              k2.end = Je(l2, +k2.start + D2);
            "00:00" === u2.end && k2.end.setHours(23, 59, 59, 999);
          }
          k2.nr = w2.i, k2.occurrenceId = k2.id + "_" + Pe(k2.start), k2.original = u2, k2.start && k2.end ? Ln(a2, k2, s2, i) : Hn(a2, T2, k2);
        }
      else
        u2.start && u2.end ? Ln(a2, u2, s2, i) : m2 && Hn(a2, m2, u2);
    }
    return a2;
  }
}
function Xn(e3, t2, n2, s2, i, a2) {
  var r2 = Pe(t2);
  if (i && +t2 < i || a2 && +t2 > a2)
    return true;
  if (s2 && s2[r2])
    return false;
  var o3 = n2 && n2[r2];
  if (o3)
    for (var l2 = 0, c2 = o3; l2 < c2.length; l2++) {
      var d2 = c2[l2], h2 = d2.start, u2 = d2.end, _2 = d2.allDay;
      if (!h2 || !u2 || _2)
        return d2;
      var m2 = Ve(e3, _2, h2, u2), p2 = Oe(e3, t2), v2 = Re(e3, m2);
      if (!Ue(h2, u2) && (+h2 == +p2 || +m2 == +v2 || !Ue(t2, h2) && !Ue(t2, u2) && t2 > h2 && t2 < u2))
        return d2;
    }
  return false;
}
function Kn(e3, t2, n2, s2, i, a2, r2) {
  var o3, l2, c2 = true, d2 = true, h2 = 0, u2 = 0;
  +e3 < n2 && (e3 = Je(t2, n2)), +e3 > s2 && (e3 = Je(t2, s2));
  var _2 = t2.getYear(e3), m2 = t2.getMonth(e3), p2 = t2.getDate(_2, m2 - 1, 1), v2 = t2.getDate(_2, m2 + 2, 1), f2 = +p2 > n2 ? +p2 : n2, g2 = +v2 < s2 ? +v2 : s2;
  if (i || (a2 = Bn(t2.valid, p2, v2, t2, true), i = Bn(t2.invalid, p2, v2, t2, true)), !Xn(t2, e3, i, a2, n2, s2))
    return e3;
  for (o3 = e3, l2 = e3; c2 && +o3 < g2 && h2 < 100; )
    c2 = Xn(t2, o3 = it(o3, 1), i, a2, n2, s2), h2++;
  for (; d2 && +l2 > f2 && u2 < 100; )
    d2 = Xn(t2, l2 = it(l2, -1), i, a2, n2, s2), u2++;
  return c2 && d2 ? e3 : 1 !== r2 || c2 ? -1 !== r2 || d2 ? Be(e3, o3, t2) ? o3 : Be(e3, l2, t2) ? l2 : u2 >= h2 && !c2 ? o3 : l2 : l2 : o3;
}
var Qn = {}, es = ["calendar"], ts = [{ recurring: { repeat: "daily" } }];
function ns(e3) {
  return "start" === e3 ? "end" : "start";
}
function ss(e3, t2) {
  var n2 = Ae(new Date(e3), t2, void 0 !== t2.firstSelectDay ? t2.firstSelectDay : t2.firstDay), s2 = new Date(n2.getFullYear(), n2.getMonth(), n2.getDate() + t2.selectSize - 1);
  return { start: n2, end: s2 };
}
var is$1, as$1, rs = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._iso = {}, t3._onActiveChange = function(e4) {
      t3._active = e4.date, t3.forceUpdate();
    }, t3._onResize = function(e4) {
      var n2 = e4.windowWidth;
      e4.cancel = t3.state.width !== n2, t3.setState({ isLarge: e4.isLarge, maxPopupWidth: e4.maxPopupWidth, width: n2, widthType: n2 > 600 ? "md" : "sm" });
    }, t3._onDayHoverIn = function(e4) {
      var n2 = e4.date, s2 = e4.hidden;
      t3.setState({ hoverDate: s2 ? void 0 : +n2 });
    }, t3._onDayHoverOut = function(e4) {
      var n2 = e4.date;
      t3.state.hoverDate === +n2 && t3.setState({ hoverDate: void 0 });
    }, t3._onCellClick = function(e4) {
      t3._lastSelected = Ge(t3.s, e4.date), e4.active = t3._activeSelect, t3._hook("onCellClick", e4);
    }, t3._onCalendarChange = function(e4) {
      t3._tempValueSet = false;
      var n2 = t3.s, s2 = t3._copy(t3._tempValueRep), i = fe(e4.value, function(e6) {
        return Ge(n2, e6);
      }), a2 = "preset-range" === n2.select, r2 = "range" === n2.select, o3 = r2 && t3._newSelection, l2 = (r2 || a2) && n2.exclusiveEndDates && !t3._hasTime;
      if (l2 && s2.end && (s2.end = +Oe(n2, Je(n2, s2.end - 1))), t3._hasTime && t3._selectedTime && !r2)
        if (t3.s.selectMultiple) {
          var c2 = i[i.length - 1];
          c2 && c2.setHours(t3._selectedTime.getHours(), t3._selectedTime.getMinutes());
        } else
          i.setHours(t3._selectedTime.getHours(), t3._selectedTime.getMinutes());
      if (r2 || a2) {
        var d2 = t3._getDate(s2), h2 = d2.filter(function(e6) {
          return null !== e6;
        }), u2 = h2.map(function(e6) {
          return +e6;
        }), _2 = h2.map(function(e6) {
          return +ze(e6);
        }), m2 = i.filter(function(e6) {
          return _2.indexOf(+e6) < 0;
        })[0];
        if (a2) {
          if (m2) {
            var p2 = ss(+m2, n2), v2 = p2.start, f2 = p2.end;
            s2.start = +v2, s2.end = +f2;
          }
        } else {
          var g2 = !t3._hasTime, y2 = t3._renderControls, b2 = t3._activeSelect, D2 = ns(b2);
          if (m2) {
            switch (t3._hasTime && t3._selectedTime && m2.setHours(t3._selectedTime.getHours(), t3._selectedTime.getMinutes(), t3._selectedTime.getSeconds(), t3._selectedTime.getMilliseconds()), u2.length) {
              case 0:
                (s2 = {})[b2] = +m2;
                break;
              case 1:
                if (y2) {
                  s2[b2] = +m2;
                  break;
                }
                u2[0] > +m2 || "start" === t3._activeSelect ? t3._hasTime ? s2[b2] = +m2 : (s2 = { start: +m2 }, g2 = false) : s2.end = +m2;
                break;
              case 2:
                if (y2) {
                  s2[b2] = +m2;
                  break;
                }
                u2[0] > +m2 || "start" === t3._activeSelect ? t3._hasTime ? s2[b2] = +m2 : (s2 = { start: +m2 }, "end" === t3._activeSelect && (g2 = false)) : "end" === t3._activeSelect && (s2.end = +m2);
            }
            y2 && s2.start && s2.end && s2.start > s2.end && (s2 = { start: +m2 }, t3._setActiveSelect("end"));
          } else {
            var x2 = void 0;
            x2 = 1 === u2.length ? Je(n2, u2[0]) : t3._lastSelected, t3._hasTime && t3._selectedTime ? x2.setHours(t3._selectedTime.getHours(), t3._selectedTime.getMinutes(), t3._selectedTime.getSeconds(), t3._selectedTime.getMilliseconds()) : !n2.exclusiveEndDates && !t3._hasTime && "end" === t3._activeSelect && d2[0] && Ue(x2, d2[0]) && x2.setHours(23, 59, 59, 999), y2 || t3._hasTime ? s2[b2] = +x2 : "start" === t3._activeSelect ? s2 = { start: +x2 } : s2.end = +x2;
          }
          if (s2.start && s2.end) {
            if (s2.start > s2.end) {
              var C2 = Je(n2, s2.start), w2 = Je(n2, s2.end);
              Ue(C2, w2) ? (w2.setHours(C2.getHours(), C2.getMinutes(), C2.getSeconds(), C2.getMilliseconds()), s2.end = +w2) : s2.end = void 0;
            }
            if (n2.minRange && s2.end) {
              var T2 = t3._hasTime ? s2.start + n2.minRange : +it(Je(n2, s2.start), n2.minRange - 1);
              s2.end < T2 && (!t3._hasTime || "start" === b2) && (s2.end = void 0);
            }
            if (n2.maxRange && s2.end) {
              T2 = t3._hasTime ? s2.start + n2.maxRange : +it(Je(n2, s2.start), n2.maxRange) - 1;
              s2.end > T2 && (!t3._hasTime || "start" === b2) && (s2.end = void 0);
            }
            if (s2.end && "start" === b2 && !n2.inRangeInvalid) {
              var k2 = n2.valid ? it(Fn(n2.valid, Je(n2, s2.start), n2), 1) : Wn(n2.invalid || [], Je(n2, s2.start), n2);
              null !== k2 && +k2 < s2.end && (s2.end = void 0);
            }
          }
          g2 && (t3._newSelection || !t3._renderControls || void 0 === t3._newSelection && "inline" === t3.s.display) && (t3._setActiveSelect(D2), t3._newSelection = false);
        }
      } else if (s2 = { date: {} }, t3.s.selectMultiple)
        for (var S2 = 0, E2 = i; S2 < E2.length; S2++) {
          var M2 = E2[S2];
          s2.date[+M2] = M2;
        }
      else {
        if (t3._hasTime) {
          var I2 = t3._selectedTime || /* @__PURE__ */ new Date();
          i.setHours(I2.getHours(), I2.getMinutes(), I2.getSeconds(), I2.getMilliseconds());
        }
        s2.date[+i] = i;
      }
      t3._tempValueRep = s2, l2 && s2.end && (s2.end = +Oe(n2, it(Je(n2, s2.end), 1))), t3._setOrUpdate(), !t3._live || t3.s.selectMultiple && !r2 || t3._hasTime || r2 && (!s2.start || !s2.end || o3) || t3.close();
    }, t3._onDatetimeChange = function(e4) {
      var n2 = t3.s, s2 = "range" === n2.select, i = Ge(n2, e4.value), a2 = t3._hasTime ? i : ze(i), r2 = +a2;
      t3._tempValueSet = false;
      var o3 = t3._copy(t3._tempValueRep), l2 = s2 && n2.exclusiveEndDates && !t3._hasTime;
      if (l2 && o3.end && (o3.end = +Oe(n2, Je(n2, o3.end - 1))), s2)
        if ("start" === t3._activeSelect) {
          if (t3._hasTime && t3._selectedTime && a2.setHours(t3._selectedTime.getHours(), t3._selectedTime.getMinutes(), t3._selectedTime.getSeconds(), t3._selectedTime.getMilliseconds()), o3.start = r2, o3.end) {
            var c2 = n2.minRange && !t3._hasTime ? 24 * (n2.minRange - 1) * 60 * 60 * 1e3 - 1 : n2.minRange || 0;
            o3.end - o3.start < c2 && (o3.end = void 0);
          }
        } else
          t3._hasTime ? t3._selectedTime && a2.setHours(t3._selectedTime.getHours(), t3._selectedTime.getMinutes(), t3._selectedTime.getSeconds(), t3._selectedTime.getMilliseconds()) : o3.start !== +ze(a2) || n2.exclusiveEndDates || a2.setHours(23, 59, 59, 999), o3.end = +a2;
      else {
        if (t3._hasTime && t3._hasDate && n2.controls.indexOf("datetime") < 0) {
          var d2 = t3._selectedTime || /* @__PURE__ */ new Date();
          a2.setHours(d2.getHours(), d2.getMinutes(), d2.getSeconds(), d2.getMilliseconds());
        } else
          t3._selectedTime = Je(n2, a2);
        (o3 = { date: {} }).date[+a2] = a2;
      }
      t3._tempValueRep = o3, l2 && o3.end && (o3.end = +Oe(n2, it(Je(n2, o3.end), 1))), t3._setOrUpdate();
    }, t3._onTimePartChange = function(e4) {
      t3._tempValueSet = false;
      var n2 = t3.s, s2 = "range" === n2.select, i = Ge(n2, e4.value);
      if (t3._selectedTime = i, s2) {
        var a2 = t3._getDate(t3._tempValueRep), r2 = "start" === t3._activeSelect ? 0 : 1;
        if (a2[r2])
          (o3 = Je(n2, a2[r2])).setHours(i.getHours(), i.getMinutes(), i.getSeconds(), i.getMilliseconds()), a2[r2] = o3, "start" === t3._activeSelect && +o3 > +a2[1] && (a2.length = 1), t3._tempValueRep = t3._parse(a2);
        else
          t3._selectedTime.setHours(i.getHours(), i.getMinutes(), i.getSeconds(), i.getMilliseconds());
      } else if (!n2.selectMultiple) {
        var o3;
        (o3 = t3._getDate(t3._tempValueRep)) ? (o3.setHours(i.getHours(), i.getMinutes(), i.getSeconds(), i.getMilliseconds()), t3._tempValueRep = { date: {} }, t3._tempValueRep.date[+o3] = o3) : (t3._selectedTime.setHours(i.getHours(), i.getMinutes(), i.getSeconds(), i.getMilliseconds()), t3._live && t3.forceUpdate());
      }
      t3._setOrUpdate();
    }, t3._changeActiveTab = function(e4) {
      t3.setState({ activeTab: e4.target.value });
    }, t3._changeActiveSelect = function(e4) {
      var n2 = e4.target.value;
      t3._setActiveSelect(n2), t3.setActiveDate(n2);
    }, t3._clearEnd = function() {
      t3._tempValueRep.end = void 0, t3._hasTimegrid && (t3._selectedTime = void 0), t3._setOrUpdate();
    }, t3._clearStart = function() {
      t3._tempValueRep = {}, t3._newSelection = true, t3._hasTimegrid && (t3._selectedTime = void 0), t3._setOrUpdate();
    }, t3._proxy = function(e4) {
      t3._hook(e4.type, e4);
    }, t3._onInputClickRange = function(e4) {
      var n2 = e4.target === t3._startInput || t3._renderControls ? "start" : "end";
      t3._setActiveSelect(n2);
    }, t3._onInputChangeRange = function(e4) {
      var n2 = t3._startInput, s2 = t3._endInput, i = (n2 ? n2.value : "") + (s2 && s2.value ? " - " + s2.value : "");
      t3._onInputChange(e4, i);
    }, t3;
  }
  return c$3(t2, e3), t2.prototype.setActiveDate = function(e4) {
    var t3 = ns(e4);
    this._activeSelect = e4;
    var n2 = this._tempValueRep[e4], s2 = this._tempValueRep[t3];
    this._tempValueRep.start && this._tempValueRep.end || !n2 && s2 ? this._newSelection = false : n2 && !s2 && (this._newSelection = true), n2 && (this._active = n2), !n2 && this._hasTimegrid && (this._selectedTime = void 0), this.forceUpdate();
  }, t2.prototype.getTempVal = function() {
    return e3.prototype.getTempVal.call(this);
  }, t2.prototype.setTempVal = function(t3) {
    e3.prototype.setTempVal.call(this, t3);
  }, t2.prototype.navigate = function(e4) {
    this._active = +Ze(e4), this.forceUpdate();
  }, t2.prototype._shouldValidate = function(e4, t3) {
    return e4.controls !== t3.controls || e4.dataTimezone !== t3.dataTimezone || e4.displayTimezone !== t3.displayTimezone || e4.dateFormat !== t3.dateFormat || e4.timeFormat !== t3.timeFormat || e4.locale !== t3.locale || e4.min !== t3.min || e4.max !== t3.max;
  }, t2.prototype._valueEquals = function(e4, t3) {
    var n2 = j(e4) && 0 === e4.length || null == e4, s2 = j(t3) && 0 === t3.length || null == t3;
    return n2 && n2 === s2 || nt(e4, t3, this.s);
  }, t2.prototype._init = function() {
    this.props.modules && this.props.modules.forEach(function(e4) {
      Qn[e4._name] = e4;
    });
  }, t2.prototype._render = function(t3, n2) {
    var s2 = this;
    t3.inRangeInvalid && (t3.rangeEndInvalid = false), "preset-range" === t3.select && (t3.controls = es), void 0 === t3.exclusiveEndDates && (t3.exclusiveEndDates = !!t3.displayTimezone);
    var i = this._hasTime, a2 = this._hasDate = !!me(t3.controls, function(e4) {
      return /date|calendar/.test(e4);
    }), r2 = this._hasTime = !!me(t3.controls, function(e4) {
      return /time/.test(e4);
    });
    r2 || (t3.timezonePlugin = t3.dataTimezone = t3.displayTimezone = void 0), !t3.valid || t3.invalid && !r2 || (t3.invalid = ts);
    var o3 = this._prevS;
    t3.buttons;
    var l2 = t3.calendarSize;
    t3.children, t3.className;
    var c2 = t3.controls;
    t3.cssClass, t3.element, t3.onDestroy, t3.onInit, t3.onTempChange, t3.responsive;
    var u2 = t3.select, _2 = t3.selectMultiple, m2 = t3.tabs, p2 = h$6(t3, ["buttons", "calendarSize", "children", "className", "controls", "cssClass", "element", "onDestroy", "onInit", "onTempChange", "responsive", "select", "selectMultiple", "tabs"]), v2 = n2.widthType || "sm", f2 = "date" !== u2;
    if (this._renderTabs = c2.length > 1 && ("auto" === m2 ? "sm" === v2 : m2), u2 !== o3.select && this._tempValueRep) {
      if (f2 && this._tempValueRep.date) {
        var g2 = Object.keys(this._tempValueRep.date).map(function(e4) {
          return +e4;
        }).sort(), y2 = g2[0], b2 = g2[1];
        this._tempValueRep.start = y2, this._tempValueRep.end = b2, this._tempValueRep.date = void 0, this._tempValueText = this._format(this._tempValueRep), setTimeout(function() {
          s2.set();
        });
      } else if (!f2 && (this._tempValueRep.start || this._tempValueRep.end)) {
        this._tempValueRep.date || (this._tempValueRep.date = {});
        var D2 = this._tempValueRep.start || this._tempValueRep.end;
        this._tempValueRep.date[D2] = new Date(D2);
        var x2 = this._tempValueRep.end || this._tempValueRep.start;
        x2 !== D2 && t3.selectMultiple && (this._tempValueRep.date[x2] = new Date(x2)), this._tempValueRep.start = void 0, this._tempValueRep.end = void 0, this._tempValueText = this._format(this._tempValueRep), setTimeout(function() {
          s2.set();
        });
      }
    }
    t3.min !== o3.min && (this._min = Q(t3.min) ? void 0 : Ze(t3.min, t3, t3.dateFormat)), t3.max !== o3.max && (this._max = Q(t3.max) ? void 0 : Ze(t3.max, t3, t3.dateFormat)), t3.minTime !== o3.minTime && (this._minTime = Q(t3.minTime) ? void 0 : Ze(t3.minTime, t3, t3.timeFormat)), t3.maxTime !== o3.maxTime && (this._maxTime = Q(t3.maxTime) ? void 0 : Ze(t3.maxTime, t3, t3.timeFormat));
    var C2, w2 = this._tempValueRep && this._tempValueRep.end, T2 = this._tempValueRep && this._tempValueRep.start, k2 = (a2 ? t3.dateFormat : "") + (r2 ? (a2 ? t3.separator : "") + t3.timeFormat : ""), S2 = c2 !== o3.controls;
    if (S2) {
      this._controls = [], this._controlsClass = "", this._hasCalendar = false, this._hasTimegrid = false;
      for (var E2 = 0, M2 = c2; E2 < M2.length; E2++) {
        "timegrid" === (X2 = M2[E2]) && (this._hasTimegrid = true), "calendar" === X2 && (this._hasCalendar = true), this._controls.push({ Component: Qn["calendar" === X2 ? "Calendar" : "timegrid" === X2 ? "Timegrid" : "Datetime"], name: X2, title: "time" === X2 || "timegrid" === X2 ? t3.timeText : t3.dateText }), this._controlsClass += " mbsc-datepicker-control-" + X2;
      }
      r2 || (this._selectedTime = void 0);
    }
    if (this._renderControls = f2 && "preset-range" !== u2 && (void 0 === t3.showRangeLabels || t3.showRangeLabels), this._nullSupport = "inline" !== t3.display || "date" !== u2 || true === t3.selectMultiple, this._valueFormat = k2, this._activeTab = n2.activeTab || c2[0], e3.prototype._render.call(this, t3, n2), S2 && f2 && t3.exclusiveEndDates && r2 !== i && w2 && setTimeout(function() {
      var e4 = +it(Je(t3, w2), i ? 1 : -1), n3 = T2 && Je(t3, T2), a3 = n3 && e4 < +n3 ? +it(Je(t3, n3), 1) : e4;
      s2._tempValueRep.end = a3, s2._tempValueRep.start = n3 && +n3, s2._valueText = s2._tempValueText = s2._format(s2._tempValueRep), s2._valueTextChange = true, s2.set(), s2.forceUpdate();
    }), t3.headerText === o3.headerText && t3.selectCounter === o3.selectCounter && t3.selectMultiple === o3.selectMultiple || this._setHeader(), this._scrollLock = void 0 !== t3.scrollLock ? t3.scrollLock : !this._hasTimegrid, this._showInput = void 0 !== t3.showInput ? t3.showInput : this._showInput && (!f2 || !t3.startInput && !t3.endInput), this._shouldInitInputs = this._shouldInitInputs || u2 !== o3.select || t3.startInput !== o3.startInput || t3.endInput !== o3.endInput, this._shouldInitInput = this._shouldInitInput || this._shouldInitInputs, S2 || t3.dateWheels !== o3.dateWheels || t3.timeWheels !== o3.timeWheels || t3.dateFormat !== o3.dateFormat || t3.timeFormat !== o3.timeFormat) {
      var I2 = t3.dateWheels || t3.dateFormat, N2 = t3.timeWheels || t3.timeFormat, L2 = this._iso = {};
      a2 && (/y/i.test(I2) && (L2.y = 1), /M/.test(I2) && (L2.y = 1, L2.m = 1), /d/i.test(I2) && (L2.y = 1, L2.m = 1, L2.d = 1)), r2 && (/h/i.test(N2) && (L2.h = 1), /m/.test(N2) && (L2.i = 1), /s/i.test(N2) && (L2.s = 1));
    }
    if (f2 ? (void 0 === this._activeSelect && this._setActiveSelect("start", true), C2 = this._selectionNotReady()) : (this._activeSelect = void 0, C2 = false), this._buttons) {
      var H2 = me(this._buttons, function(e4) {
        return "set" === e4.name;
      });
      H2 && H2.disabled !== C2 && (H2.disabled = C2, this._buttons = this._buttons.slice());
    }
    var O2 = this._activeSelect;
    this._needsWidth = ("anchored" === t3.display || "center" === t3.display || "inline" !== t3.display && n2.isLarge || c2.length > 1 && !m2) && void 0 === t3.width;
    var R2 = void 0 !== t3.max ? Ze(t3.max, t3, k2) : void 0, V2 = void 0 !== t3.min ? Ze(t3.min, t3, k2) : void 0;
    this._maxLimited = R2, this._minLimited = V2;
    var P2 = this._tempValueRep.start;
    if (P2 && (this._prevStart !== P2 || o3.valid !== t3.valid || o3.invalid !== t3.invalid)) {
      var z2 = Je(t3, P2);
      this._nextInvalid = t3.valid ? it(Fn(t3.valid, z2, t3), 1) : Wn(t3.invalid || [], z2, t3);
    }
    var Y2 = "end" === O2 && P2;
    if (Y2) {
      if (!t3.inRangeInvalid) {
        var W2 = this._nextInvalid;
        W2 && (t3.rangeEndInvalid ? this._maxLimited = Je(t3, +it(W2, 1) - 1) : this._maxLimited = Je(t3, +W2 - 1));
      }
      this._hasCalendar && !r2 || (!this._minLimited || Ze(this._minLimited, t3, k2) < Je(t3, P2)) && (this._minLimited = Je(t3, this._tempValueRep.start));
    }
    if (this._minTimeLimited = this._minLimited, Y2) {
      if (t3.minRange) {
        var F2 = r2 ? this._tempValueRep.start + t3.minRange : +it(Je(t3, this._tempValueRep.start), t3.minRange) - 1;
        (!this._minLimited || +Ze(this._minLimited, t3, k2) < F2) && (this._minLimited = Je(t3, F2), this._minTimeLimited = this._minLimited);
      }
      if (void 0 === this._minTimeLimited && this._tempValueRep.start && this._tempValueRep.end && (this._minTimeLimited = Je(t3, +this._tempValueRep.start)), void 0 !== t3.maxRange) {
        var A2 = r2 ? this._tempValueRep.start + t3.maxRange : +it(Je(t3, this._tempValueRep.start), t3.maxRange) - 1;
        (!this._maxLimited || +Ze(this._maxLimited, t3, k2) > A2) && (this._maxLimited = Je(t3, A2));
      }
    }
    for (var U2 = 0, B2 = this._controls; U2 < B2.length; U2++) {
      var X2 = B2[U2], K2 = d$2({}, p2, { display: "inline", isOpen: t3.isOpen || n2.isOpen, max: this._maxLimited, min: this._minLimited });
      if (t3.rangeEndInvalid && Y2 && this._nextInvalid && (K2.valid = (K2.valid || []).concat([this._nextInvalid])), "calendar" === X2.name) {
        K2.min = this._minLimited ? ze(this._minLimited) : void 0, K2.max = this._maxLimited ? ze(this._maxLimited) : void 0, K2.selectRange = f2, K2.width = this._needsWidth ? 296 * pt(t3.pages, n2.maxPopupWidth) : void 0, "week" === t3.calendarType && l2 ? K2.weeks = l2 : K2.size = l2;
        var q2 = "auto" === t3.pages ? 3 : t3.pages || 1;
        if (this._maxWidth = t3.maxWidth || (q2 > 2 ? 296 * q2 : void 0), f2) {
          var J2 = this._getDate(this._tempValueRep), Z2 = J2[1];
          Z2 && t3.exclusiveEndDates && !r2 && (J2[1] = Je(t3, +Z2 - 1));
          var $2 = J2.filter(function(e4) {
            return null !== e4;
          }).map(function(e4) {
            return +ze(e4);
          }).filter(function(e4, t4, n3) {
            return n3.indexOf(e4) === t4;
          }).map(function(e4) {
            return new Date(e4);
          });
          if (K2.value = $2, t3.rangeHighlight)
            if (K2.rangeStart = J2[0] && +ze(je(J2[0])), K2.rangeEnd = J2[1] && +ze(je(J2[1])), K2.onDayHoverIn = this._onDayHoverIn, K2.onDayHoverOut = this._onDayHoverOut, "preset-range" === u2) {
              if (n2.hoverDate) {
                var ee2 = ss(n2.hoverDate, t3);
                y2 = ee2.start, b2 = ee2.end;
                K2.hoverStart = +y2, K2.hoverEnd = +b2;
              }
            } else
              "end" === O2 && J2[0] && (K2.hoverStart = K2.rangeEnd || K2.rangeStart, K2.hoverEnd = n2.hoverDate), "start" === O2 && J2[1] && this._renderControls && (K2.hoverStart = n2.hoverDate, K2.hoverEnd = K2.rangeStart || K2.rangeEnd);
        } else
          K2.selectMultiple = _2, K2.value = this._getDate(this._tempValueRep);
        for (var te2 = j(K2.value) ? K2.value : [K2.value], ne2 = K2.min ? +K2.min : -1 / 0, se2 = K2.max ? +K2.max : 1 / 0, ie2 = void 0, ae2 = 0, re2 = te2; ae2 < re2.length; ae2++) {
          var oe2 = re2[ae2];
          !ie2 && oe2 >= ne2 && oe2 <= se2 && (ie2 = +oe2);
        }
        ie2 === this._selectedDate && void 0 !== this._active && t3.min === o3.min && t3.max === o3.max || (this._selectedDate = ie2, this._active = G(ie2 ? +ze(new Date(ie2)) : this._active || +ze(/* @__PURE__ */ new Date()), ne2, se2));
        var le2 = t3.dateWheels || t3.dateFormat, ce2 = /d/i.test(le2) ? "month" : /m/i.test(le2) ? "year" : /y/i.test(le2) ? "multi-year" : "month";
        K2.active = this._active, K2.onActiveChange = this._onActiveChange, K2.onChange = this._onCalendarChange, K2.onCellClick = this._onCellClick, K2.onCellHoverIn = this._proxy, K2.onCellHoverOut = this._proxy, K2.onLabelClick = this._proxy, K2.onPageChange = this._proxy, K2.onPageLoaded = this._proxy, K2.onPageLoading = this._proxy, K2.selectView = ce2;
      } else {
        var de2 = Object.keys(this._tempValueRep.date || {});
        if (K2.displayStyle = "bottom" !== t3.display && "top" !== t3.display || !this._hasCalendar && !this._renderTabs ? t3.display : "center", K2.mode = X2.name, "time" !== X2.name && "timegrid" !== X2.name || !a2)
          if (K2.onChange = this._onDatetimeChange, f2) {
            var he2 = this._tempValueRep[O2], ue2 = this._tempValueRep[ns(O2)];
            K2.value = he2 ? Je(t3, he2) : ue2 ? Je(t3, ue2) : null, "end" === O2 && t3.exclusiveEndDates && !r2 && (K2.value = Je(t3, +K2.value - 1));
          } else {
            var _e2 = this._tempValueRep.date && this._tempValueRep.date[de2[0]], pe2 = _e2;
            _e2 && (r2 || (pe2 = ze(_e2))), K2.value = pe2 || null;
          }
        else {
          if (K2.onChange = this._onTimePartChange, f2) {
            var ve2 = this._tempValueRep[O2], fe2 = void 0;
            this._selectedTime && (!this._minTimeLimited || this._selectedTime > this._minTimeLimited ? fe2 = this._selectedTime : (fe2 = Je(t3, this._minTimeLimited)).setHours(this._selectedTime.getHours(), this._selectedTime.getMinutes(), this._selectedTime.getSeconds(), this._selectedTime.getMilliseconds())), this._selectedTime = ve2 ? Je(t3, ve2) : fe2 || ("time" === X2.name ? Je(t3) : void 0), K2.value = this._selectedTime;
          } else if (!t3.selectMultiple) {
            var ge2 = this._tempValueRep.date && this._tempValueRep.date[de2[0]] || this._selectedTime;
            this._selectedTime = K2.value = ge2;
          }
          K2.min = this._minTimeLimited, K2.max = this._maxLimited;
        }
        if ("time" === X2.name || "timegrid" === X2.name) {
          var ye = K2.value || ot(/* @__PURE__ */ new Date(), K2.min, K2.max);
          if (this._minTime) {
            var be2 = this._minTime;
            ne2 = new Date(ye.getFullYear(), ye.getMonth(), ye.getDate(), be2.getHours(), be2.getMinutes(), be2.getSeconds(), be2.getMilliseconds());
            (!K2.min || ne2 > K2.min) && (K2.min = ne2);
          }
          if (this._maxTime) {
            var De2 = this._maxTime;
            se2 = new Date(ye.getFullYear(), ye.getMonth(), ye.getDate(), De2.getHours(), De2.getMinutes(), De2.getSeconds(), De2.getMilliseconds());
            (!K2.max || se2 < K2.max) && (K2.max = se2);
          }
        }
      }
      X2.options = K2;
    }
    this._prevStart = this._tempValueRep.start;
  }, t2.prototype._updated = function() {
    var t3 = this, n2 = this.s;
    if (this._shouldInitInputs) {
      if (this._resetInputs(), "range" === n2.select) {
        var s2 = n2.startInput;
        s2 && this._setupInput("start", s2);
        var i = n2.endInput;
        i && this._setupInput("end", i), !n2.element || this._startInput !== n2.element && this._endInput !== n2.element || (this._shouldInitInput = false, clearTimeout(n2.element.__mbscTimer));
      }
      this._shouldInitInputs = false;
    }
    var a2 = this._valueTextChange;
    if (e3.prototype._updated.call(this), "range" === n2.select && a2) {
      var r2 = function(e4, n3) {
        e4.value = n3, setTimeout(function() {
          t3._preventChange = true, an(e4, "input"), an(e4, cn);
        });
      };
      this._startInput && r2(this._startInput, this._getValueText("start")), this._endInput && r2(this._endInput, this._getValueText("end"));
    }
  }, t2.prototype._onEnterKey = function(t3) {
    this._selectionNotReady() || e3.prototype._onEnterKey.call(this, t3);
  }, t2.prototype._setupInput = function(e4, t3) {
    var n2 = this;
    Tn(t3, function(t4) {
      var s2 = kn(t4, n2, n2._onInputChangeRange, n2._onInputClickRange);
      "start" === e4 ? (n2._startInput = t4, n2._resetStartInput = s2) : (n2._endInput = t4, n2._resetEndInput = s2);
      var i = n2._getValueText(e4), a2 = i !== t4.value;
      t4.value = i, a2 && setTimeout(function() {
        n2._preventChange = true, an(t4, "input"), an(t4, cn);
      });
    });
  }, t2.prototype._destroy = function() {
    this._resetInputs(), e3.prototype._destroy.call(this);
  }, t2.prototype._setHeader = function() {
    var t3 = this.s;
    if (t3.selectCounter && t3.selectMultiple) {
      var n2 = Object.keys(this._tempValueRep && this._tempValueRep.date || {}).length;
      this._headerText = (n2 > 1 && t3.selectedPluralText || t3.selectedText).replace(/{count}/, "" + n2);
    } else
      e3.prototype._setHeader.call(this);
  }, t2.prototype._validate = function() {
    if (!(this._max <= this._min)) {
      var e4 = this.s, t3 = this._min ? +this._min : -1 / 0, n2 = this._max ? +this._max : 1 / 0;
      if ("date" === e4.select) {
        var s2 = this._tempValueRep.date;
        if (!e4.selectMultiple)
          for (var i = 0, a2 = Object.keys(s2); i < a2.length; i++) {
            var r2 = a2[i], o3 = s2[r2], l2 = Kn(o3, e4, t3, n2);
            +l2 != +o3 && (delete s2[r2], s2[+ze(l2)] = l2);
          }
      } else {
        var c2 = this._getDate(this._tempValueRep), d2 = c2[0], h2 = c2[1];
        d2 && (d2 = Kn(d2, e4, t3, n2), e4.inRangeInvalid || this._prevStart && this._prevStart === +d2 || (this._nextInvalid = e4.valid ? it(Fn(e4.valid, d2, e4), 1) : Wn(e4.invalid || [], d2, e4))), h2 && (h2 = !e4.inRangeInvalid && this._nextInvalid && this._nextInvalid <= h2 ? e4.rangeEndInvalid ? this._nextInvalid : it(this._nextInvalid, -1) : Kn(h2, e4, t3, n2)), d2 && h2 && d2 > h2 && ("end" === this._activeSelect ? d2 = h2 : h2 = d2), d2 && (this._prevStart = this._tempValueRep.start = +d2), h2 && (this._tempValueRep.end = +h2);
      }
    }
  }, t2.prototype._copy = function(e4) {
    var t3 = e4.date ? d$2({}, e4.date) : e4.date;
    return d$2({}, e4, { date: t3 });
  }, t2.prototype._format = function(e4) {
    var t3 = this.s, n2 = [];
    if (!t3)
      return "";
    if ("date" === t3.select) {
      var s2 = e4.date;
      for (var i in s2)
        void 0 !== s2[i] && null !== s2[i] && n2.push(et(this._valueFormat, s2[i], t3));
      return t3.selectMultiple ? n2.join(", ") : n2[0];
    }
    if (e4.start && n2.push(et(this._valueFormat, Je(t3, e4.start), t3)), e4.end) {
      n2.length || n2.push("");
      var a2 = Je(t3, e4.end - (t3.exclusiveEndDates && !this._hasTime ? 1 : 0));
      n2.push(et(this._valueFormat, a2, t3));
    }
    return this._tempStartText = n2[0] || "", this._tempEndText = n2[1] || "", n2.join(" - ");
  }, t2.prototype._parse = function(e4, t3) {
    var n2 = this.s, s2 = {}, i = "date" !== n2.select, a2 = n2.selectMultiple, r2 = [];
    if (Q(e4)) {
      var o3 = n2.defaultSelection;
      e4 = a2 || i ? o3 : null === o3 || this._live && "inline" !== n2.display ? null : o3 || /* @__PURE__ */ new Date();
    }
    if ($(e4) && (i || a2) ? r2 = e4.split(i ? " - " : ",") : j(e4) ? r2 = e4 : e4 && !j(e4) && (r2 = [e4]), i) {
      var l2 = r2[0], c2 = r2[1], d2 = Ze(l2, n2, this._valueFormat, this._iso), h2 = Ze(c2, n2, this._valueFormat, this._iso);
      s2.start = d2 ? +d2 : void 0, s2.end = h2 ? +h2 : void 0;
    } else {
      s2.date = {};
      for (var u2 = 0, _2 = r2; u2 < _2.length; u2++) {
        var m2 = _2[u2];
        if (!Q(m2)) {
          var p2 = Ze(m2, n2, this._valueFormat, this._iso, t3);
          if (p2) {
            t3 && (p2 = Ge(n2, p2));
            var v2 = +ze(p2);
            s2.date[v2] = p2, this._hasTime && (this._selectedTime = new Date(p2));
          }
        }
      }
    }
    return s2;
  }, t2.prototype._getDate = function(e4) {
    var t3 = this.s;
    if ("date" !== t3.select) {
      var n2 = e4.start ? Je(t3, e4.start) : null, s2 = e4.end ? Je(t3, e4.end) : null;
      return n2 || s2 ? [n2, s2] : [];
    }
    if (t3.selectMultiple) {
      var i = [], a2 = e4.date;
      if (a2)
        for (var r2 = 0, o3 = Object.keys(a2); r2 < o3.length; r2++) {
          var l2 = o3[r2];
          i.push(Je(t3, +l2));
        }
      return i;
    }
    var c2 = Object.keys(e4.date || {});
    return c2.length ? Je(t3, e4.date[c2[0]]) : null;
  }, t2.prototype._get = function(e4) {
    var t3 = this, n2 = this.s, s2 = this._valueFormat, i = this._iso, a2 = this._getDate(e4);
    return j(a2) ? a2.map(function(e6) {
      return e6 ? $e(e6, n2, s2, i, t3._hasTime) : null;
    }) : null === a2 ? null : $e(a2, n2, s2, i, this._hasTime);
  }, t2.prototype._onClosed = function() {
    this._active = this._activeSelect = void 0, this._hasTimegrid && (this._selectedTime = void 0);
  }, t2.prototype._onOpen = function() {
    this._newSelection = true;
  }, t2.prototype._resetInputs = function() {
    this._resetStartInput && (this._resetStartInput(), this._resetStartInput = void 0), this._resetEndInput && (this._resetEndInput(), this._resetEndInput = void 0);
  }, t2.prototype._getValueText = function(e4) {
    return this._valueText.split(" - ")["start" === e4 ? 0 : 1] || "";
  }, t2.prototype._selectionNotReady = function() {
    var e4 = false;
    if ("range" === this.s.select) {
      var t3 = (this._get(this._tempValueRep || {}) || []).filter(function(e6) {
        return e6;
      });
      (e4 = !t3.length) || (e4 = this._hasCalendar && !this._hasTime || this._renderControls ? t3.length < 2 : !this._tempValueRep[this._activeSelect]);
    }
    return e4;
  }, t2.prototype._setActiveSelect = function(e4, t3) {
    var n2 = this;
    this._activeSelect !== e4 && (t3 ? setTimeout(function() {
      return n2._hook("onActiveDateChange", { active: e4 });
    }) : this._hook("onActiveDateChange", { active: e4 })), this._activeSelect = e4;
  }, t2.defaults = d$2({}, Ee, En.defaults, { activeElm: '.mbsc-calendar-cell[tabindex="0"]', controls: es, dateText: "Date", inRangeInvalid: false, inputTyping: true, rangeEndHelp: "Please select", rangeEndLabel: "End", rangeHighlight: true, rangeStartHelp: "Please select", rangeStartLabel: "Start", select: "date", selectSize: 7, selectedText: "{count} selected", showOnClick: true, timeText: "Time" }), t2._name = "Datepicker", t2;
}(En), os = reactExports.createContext, ls = reactExports.createElement, cs = void 0, ds = reactExports.Fragment, hs = reactExports.PureComponent, us = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    return ls("span", { onClick: e4.onClick, className: this._cssClass, dangerouslySetInnerHTML: this._svg }, this._hasChildren && e4.name);
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._render = function(e4) {
    this._hasChildren = !$(e4.name), this._cssClass = this._className + " mbsc-icon" + this._theme + (e4.name && !this._hasChildren ? -1 !== e4.name.indexOf(" ") ? " " + e4.name : " mbsc-font-icon mbsc-icon-" + e4.name : ""), this._svg = e4.svg ? this._safeHtml(e4.svg) : void 0;
  }, t2;
}(wt)), _s = 0;
function ms(e3, t2, n2) {
  var s2 = (n2 ? "page" : "client") + t2;
  return e3.targetTouches && e3.targetTouches[0] ? e3.targetTouches[0][s2] : e3.changedTouches && e3.changedTouches[0] ? e3.changedTouches[0][s2] : e3[s2];
}
function ps(e3, t2) {
  if (!t2.mbscClick) {
    var n2 = (e3.originalEvent || e3).changedTouches[0], s2 = document.createEvent("MouseEvents");
    s2.initMouseEvent("click", true, true, window, 1, n2.screenX, n2.screenY, n2.clientX, n2.clientY, false, false, false, false, 0, null), s2.isMbscTap = true, s2.isIonicTap = true, is$1 = true, t2.mbscChange = true, t2.mbscClick = true, t2.dispatchEvent(s2), is$1 = false, _s++, setTimeout(function() {
      _s--;
    }, 500), setTimeout(function() {
      delete t2.mbscClick;
    });
  }
}
function vs(e3) {
  !_s || is$1 || e3.isMbscTap || "TEXTAREA" === e3.target.nodeName && e3.type === hn || (e3.stopPropagation(), e3.preventDefault());
}
function fs(e3) {
  Jt(e3.target).__mbscFocusVisible = false;
}
function gs(e3) {
  Jt(e3.target).__mbscFocusVisible = true;
}
function ys(e3) {
  Kt(e3.target).__mbscMoveObs.next(e3);
}
function bs(e3) {
  e3 && setTimeout(function() {
    e3.style.opacity = "0", e3.style.transition = "opacity linear .4s", setTimeout(function() {
      e3 && e3.parentNode && e3.parentNode.removeChild(e3);
    }, 400);
  }, 200);
}
function Ds(e3, t2) {
  var n2, s2, i, a2, r2, o3, l2, c2, d2, h2, u2, _2, m2, p2, f2, g2, y2 = {}, b2 = Jt(e3), D2 = Kt(e3);
  function x2(e4) {
    if ("touchstart" === e4.type)
      as$1 = true;
    else if (as$1)
      return e4.type === hn && (as$1 = false), true;
    return false;
  }
  function C2() {
    l2 && (bs(a2), a2 = function(e4, t3, n3) {
      var s3 = e4.getBoundingClientRect(), i2 = t3 - s3.left, a3 = n3 - s3.top, r3 = Math.max(i2, e4.offsetWidth - i2), o4 = Math.max(a3, e4.offsetHeight - a3), l3 = 2 * Math.sqrt(Math.pow(r3, 2) + Math.pow(o4, 2)), c3 = Tt.createElement("span");
      c3.classList.add("mbsc-ripple");
      var d3 = c3.style;
      return d3.backgroundColor = getComputedStyle(e4).color, d3.width = l3 + "px", d3.height = l3 + "px", d3.top = n3 - s3.top - l3 / 2 + "px", d3.left = t3 - s3.left - l3 / 2 + "px", e4.appendChild(c3), setTimeout(function() {
        d3.opacity = ".2", d3.transform = "scale(1)", d3.transition = "opacity linear .1s, transform cubic-bezier(0, 0, 0.2, 1) .4s";
      }, 30), c3;
    }(e3, _2, m2)), t2.onPress(), n2 = true;
  }
  function w2(e4, a3) {
    s2 = false, bs(e4), clearTimeout(i), i = setTimeout(function() {
      n2 && (t2.onRelease(), n2 = false);
    }, a3);
  }
  function T2(e4) {
    if (!x2(e4) && (e4.type !== hn || 0 === e4.button && !e4.ctrlKey)) {
      if (h2 = ms(e4, "X"), u2 = ms(e4, "Y"), _2 = h2, m2 = u2, n2 = false, s2 = false, c2 = false, g2 = true, y2.moved = c2, y2.startX = h2, y2.startY = u2, y2.endX = _2, y2.endY = m2, y2.deltaX = 0, y2.deltaY = 0, y2.domEvent = e4, y2.isTouch = as$1, bs(a2), t2.onStart) {
        var r3 = t2.onStart(y2);
        l2 = r3 && r3.ripple;
      }
      t2.onPress && (s2 = true, clearTimeout(i), i = setTimeout(C2, 50)), e4.type === hn && (Bt(D2, "mousemove", k2), Bt(D2, un, S2)), Bt(D2, "contextmenu", R2);
    }
  }
  function k2(e4) {
    g2 && (_2 = ms(e4, "X"), m2 = ms(e4, "Y"), p2 = _2 - h2, f2 = m2 - u2, !c2 && (Math.abs(p2) > 9 || Math.abs(f2) > 9) && (c2 = true, w2(a2)), y2.moved = c2, y2.endX = _2, y2.endY = m2, y2.deltaX = p2, y2.deltaY = f2, y2.domEvent = e4, y2.isTouch = "touchmove" === e4.type, t2.onMove && t2.onMove(y2));
  }
  function S2(e4) {
    g2 && (s2 && !n2 && (clearTimeout(i), C2()), y2.domEvent = e4, y2.isTouch = "touchend" === e4.type, t2.onEnd && t2.onEnd(y2), w2(a2, 75), g2 = false, "touchend" === e4.type && t2.click && Yt && !c2 && ps(e4, e4.target), e4.type === un && (Xt(D2, "mousemove", k2), Xt(D2, un, S2)), Xt(D2, "contextmenu", R2));
  }
  function E2(e4) {
    x2(e4) || (o3 = true, t2.onHoverIn(e4));
  }
  function M2(e4) {
    o3 && t2.onHoverOut(e4), o3 = false;
  }
  function I2(e4) {
    t2.onKeyDown(e4);
  }
  function N2(e4) {
    (t2.keepFocus || b2.__mbscFocusVisible) && (r2 = true, t2.onFocus(e4));
  }
  function L2(e4) {
    r2 && t2.onBlur(e4), r2 = false;
  }
  function H2(e4) {
    t2.onChange(e4);
  }
  function O2(e4) {
    y2.domEvent = e4, as$1 || t2.onDoubleClick(y2);
  }
  function R2(e4) {
    as$1 && e4.preventDefault();
  }
  if (Bt(e3, "touchstart", T2, { passive: true }), Bt(e3, hn, T2), Bt(e3, "touchend", S2), Bt(e3, "touchcancel", S2), D2) {
    var V2 = D2.__mbscMoveCount || 0, P2 = D2.__mbscMoveObs || new v$3();
    0 === V2 && Bt(D2, "touchmove", ys, { passive: false }), D2.__mbscMoveObs = P2, D2.__mbscMoveCount = ++V2, d2 = P2.subscribe(k2);
  }
  if (t2.onChange && Bt(e3, cn, H2), t2.onHoverIn && Bt(e3, _n, E2), t2.onHoverOut && Bt(e3, "mouseleave", M2), t2.onKeyDown && Bt(e3, "keydown", I2), t2.onFocus && b2 && (Bt(e3, "focus", N2), !t2.keepFocus)) {
    var z2 = b2.__mbscFocusCount || 0;
    0 === z2 && (Bt(b2, hn, fs, true), Bt(b2, "keydown", gs, true)), b2.__mbscFocusCount = ++z2;
  }
  return t2.onBlur && Bt(e3, "blur", L2), t2.onDoubleClick && Bt(e3, "dblclick", O2), function() {
    if (clearTimeout(i), t2.onFocus && b2 && !t2.keepFocus) {
      var n3 = b2.__mbscFocusCount || 0;
      b2.__mbscFocusCount = --n3, n3 <= 0 && (Xt(b2, hn, fs), Xt(b2, "keydown", gs));
    }
    if (D2) {
      var s3 = D2.__mbscMoveCount || 0;
      D2.__mbscMoveCount = --s3, D2.__mbscMoveObs && D2.__mbscMoveObs.unsubscribe(d2), s3 <= 0 && (delete D2.__mbscMoveCount, delete D2.__mbscMoveObs, Xt(D2, "touchmove", ys, { passive: false }));
    }
    Xt(e3, hn, T2, { passive: true }), Xt(e3, "touchend", S2), Xt(e3, "touchcancel", S2), Xt(D2, "mousemove", k2), Xt(D2, un, S2), Xt(D2, "contextmenu", R2), Xt(e3, cn, H2), Xt(e3, _n, E2), Xt(e3, "mouseleave", M2), Xt(e3, "keydown", I2), Xt(e3, "touchstart", T2), Xt(e3, "focus", N2), Xt(e3, "blur", L2), Xt(e3, "dblclick", O2);
  };
}
y$2 && (["mousedown", _n, hn, un, dn].forEach(function(e3) {
  Tt.addEventListener(e3, vs, true);
}), "android" === u$3 && m$5 < 5 && Tt.addEventListener(cn, function(e3) {
  var t2 = e3.target;
  _s && "checkbox" === t2.type && !t2.mbscChange && (e3.stopPropagation(), e3.preventDefault()), delete t2.mbscChange;
}, true));
var xs, Cs = new v$3(), ws = 0;
function Ts() {
  clearTimeout(xs), xs = setTimeout(function() {
    Cs.next();
  }, 100);
}
function ks(e3) {
  try {
    return nn(e3, "*:-webkit-autofill");
  } catch (e4) {
    return false;
  }
}
var Ss = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._tag = "input", t3._onClick = function() {
      t3._hidePass = !t3._hidePass;
    }, t3._onMouseDown = function(e4) {
      t3.s.tags && (t3._preventFocus = true);
    }, t3._onTagClear = function(e4, n2) {
      if (e4.stopPropagation(), e4.preventDefault(), !t3.s.disabled) {
        var s2 = t3.s.pickerValue.slice();
        s2.splice(n2, 1), an(t3._el, cn, s2);
      }
    }, t3._sizeTextArea = function() {
      var e4, n2, s2, i = t3._el, a2 = t3.s.rows;
      i.offsetHeight && (i.style.height = "", s2 = i.scrollHeight - i.offsetHeight, e4 = i.offsetHeight + (s2 > 0 ? s2 : 0), (n2 = Math.round(e4 / 24)) > a2 ? (e4 = 24 * a2 + (e4 - 24 * n2), i.style.overflow = "auto") : i.style.overflow = "", e4 && (i.style.height = e4 + "px"));
    }, t3._onAutoFill = function() {
      "floating" === t3.s.labelStyle && ks(t3._el) && t3.setState({ isFloatingActive: true });
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._checkFloating = function() {
    var e4 = this, t3 = this._el, n2 = this.s, s2 = ks(t3), i = this.state.hasFocus || s2 || !Q(this.value);
    if (t3 && "floating" === n2.labelStyle) {
      if ("select" === this._tag) {
        var a2 = t3, r2 = a2.options[0];
        i = !!(i || a2.multiple || a2.value || a2.selectedIndex > -1 && r2 && r2.label);
      } else if (void 0 === this.value) {
        i = !(!i && !t3.value);
      }
      this._valueChecked = true, _e(this, function() {
        e4.setState({ isFloatingActive: i });
      });
    }
  }, t2.prototype._mounted = function() {
    var e4, t3 = this, n2 = this.s, s2 = this._el;
    Bt(s2, "animationstart", this._onAutoFill), "textarea" === this._tag && (Bt(s2, "input", this._sizeTextArea), this._unsubscribe = (e4 = this._sizeTextArea, ws || Bt(kt, "resize", Ts), ws++, Cs.subscribe(e4))), this._unlisten = Ds(s2, { keepFocus: true, onBlur: function() {
      t3.setState({ hasFocus: false, isFloatingActive: !!s2.value });
    }, onChange: function(e6) {
      if ("file" === n2.type) {
        for (var s3 = [], i = 0, a2 = e6.target.files; i < a2.length; i++) {
          var r2 = a2[i];
          s3.push(r2.name);
        }
        t3.setState({ files: s3.join(", ") });
      }
      n2.tags && void 0 === n2.value && void 0 === n2.defaultValue && t3.setState({ value: e6.target.value }), t3._checkFloating(), t3._emit("onChange", e6);
    }, onFocus: function() {
      t3._preventFocus || t3.setState({ hasFocus: true, isFloatingActive: true }), t3._preventFocus = false;
    }, onHoverIn: function() {
      t3._disabled || t3.setState({ hasHover: true });
    }, onHoverOut: function() {
      t3.setState({ hasHover: false });
    } });
  }, t2.prototype._render = function(e4, t3) {
    var n2 = !(!e4.endIconSvg && !e4.endIcon), s2 = e4.pickerValue, i = !(!e4.startIconSvg && !e4.startIcon), a2 = void 0 !== e4.label || e4.hasChildren, r2 = e4.error, o3 = e4.rtl ? "right" : "left", l2 = e4.rtl ? "left" : "right", c2 = e4.inputStyle, d2 = e4.labelStyle, h2 = "floating" === d2, u2 = !(!h2 || !a2 || !t3.isFloatingActive && Q(e4.value)), _2 = void 0 === e4.disabled ? t3.disabled : e4.disabled, m2 = this._prevS, p2 = void 0 !== e4.value ? e4.value : void 0 !== t3.value ? t3.value : e4.defaultValue, v2 = this._theme + this._rtl + (r2 ? " mbsc-error" : "") + (_2 ? " mbsc-disabled" : "") + (t3.hasHover ? " mbsc-hover" : "") + (t3.hasFocus && !_2 ? " mbsc-focus" : "");
    "file" !== e4.type || n2 || (e4.endIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/></svg>', n2 = true), e4.tags && (Q(s2) && (s2 = []), j(s2) || (s2 = [s2]), this._tagsArray = e4.pickerMap ? s2.map(function(t4) {
      return e4.pickerMap.get(t4);
    }) : Q(p2) ? [] : p2.split(", ")), e4.passwordToggle && (n2 = true, this._passIconClass = v2 + " mbsc-toggle-icon mbsc-textfield-icon mbsc-textfield-icon-" + c2 + " mbsc-textfield-icon-" + l2 + " mbsc-textfield-icon-" + c2 + "-" + l2 + (a2 ? " mbsc-textfield-icon-" + d2 : ""), this._hidePass = void 0 === this._hidePass ? "password" === e4.type : this._hidePass), this._hasStartIcon = i, this._hasEndIcon = n2, this._hasError = r2, this._disabled = _2, this._cssClass = this._className + this._hb + v2 + " mbsc-form-control-wrapper mbsc-textfield-wrapper mbsc-font mbsc-textfield-wrapper-" + c2 + (_2 ? " mbsc-disabled" : "") + (a2 ? " mbsc-textfield-wrapper-" + d2 : "") + (i ? " mbsc-textfield-wrapper-has-icon-" + o3 + " " : "") + (n2 ? " mbsc-textfield-wrapper-has-icon-" + l2 + " " : ""), a2 && (this._labelClass = v2 + " mbsc-label mbsc-label-" + d2 + " mbsc-label-" + c2 + "-" + d2 + (i ? " mbsc-label-" + c2 + "-" + d2 + "-has-icon-" + o3 + " " : "") + (n2 ? " mbsc-label-" + c2 + "-" + d2 + "-has-icon-" + l2 + " " : "") + (h2 && this._animateFloating ? " mbsc-label-floating-animate" : "") + (u2 ? " mbsc-label-floating-active" : "")), this._innerClass = v2 + " mbsc-textfield-inner mbsc-textfield-inner-" + c2 + (a2 ? " mbsc-textfield-inner-" + d2 : ""), i && (this._startIconClass = v2 + " mbsc-textfield-icon mbsc-textfield-icon-" + c2 + " mbsc-textfield-icon-" + o3 + " mbsc-textfield-icon-" + c2 + "-" + o3 + (a2 ? " mbsc-textfield-icon-" + d2 : "")), n2 && (this._endIconClass = v2 + " mbsc-textfield-icon mbsc-textfield-icon-" + c2 + " mbsc-textfield-icon-" + l2 + " mbsc-textfield-icon-" + c2 + "-" + l2 + (a2 ? " mbsc-textfield-icon-" + d2 : "")), this._nativeElmClass = v2 + " " + (e4.inputClass || "") + " mbsc-textfield mbsc-textfield-" + c2 + (e4.dropdown ? " mbsc-select" : "") + (a2 ? " mbsc-textfield-" + d2 + " mbsc-textfield-" + c2 + "-" + d2 : "") + (u2 ? " mbsc-textfield-floating-active" : "") + (i ? " mbsc-textfield-has-icon-" + o3 + " mbsc-textfield-" + c2 + "-has-icon-" + o3 + (a2 ? " mbsc-textfield-" + c2 + "-" + d2 + "-has-icon-" + o3 : "") : "") + (n2 ? " mbsc-textfield-has-icon-" + l2 + " mbsc-textfield-" + c2 + "-has-icon-" + l2 + (a2 ? " mbsc-textfield-" + c2 + "-" + d2 + "-has-icon-" + l2 : "") : ""), ("select" === this._tag || e4.dropdown) && (this._selectIconClass = "mbsc-select-icon mbsc-select-icon-" + c2 + this._rtl + this._theme + (a2 ? " mbsc-select-icon-" + d2 : "") + (i ? " mbsc-select-icon-" + o3 : "") + (n2 ? " mbsc-select-icon-" + l2 : "")), ("textarea" === this._tag || e4.tags) && (this._cssClass += " mbsc-textarea-wrapper", this._innerClass += " mbsc-textarea-inner", this._nativeElmClass += " mbsc-textarea", "textarea" !== this._tag || p2 === this._prevValue && e4.inputStyle === m2.inputStyle && e4.labelStyle === m2.labelStyle && e4.rows === m2.rows && e4.theme === m2.theme || (this._shouldSize = true), this._prevValue = p2), e4.tags && (this._innerClass += " mbsc-textfield-tags-inner"), "file" === e4.type && (this._dummyElmClass = this._nativeElmClass, this._nativeElmClass += " mbsc-textfield-file"), this._errorClass = this._theme + this._rtl + " mbsc-error-message mbsc-error-message-" + c2 + (a2 ? " mbsc-error-message-" + d2 : "") + (i ? " mbsc-error-message-has-icon-" + o3 : "") + (n2 ? " mbsc-error-message-has-icon-" + l2 : ""), e4.notch && "outline" === c2 && (this._fieldSetClass = "mbsc-textfield-fieldset" + v2 + (i ? " mbsc-textfield-fieldset-has-icon-" + o3 : "") + (n2 ? " mbsc-textfield-fieldset-has-icon-" + l2 : ""), this._legendClass = "mbsc-textfield-legend" + this._theme + (u2 || a2 && "stacked" === d2 ? " mbsc-textfield-legend-active" : "")), e4.ripple && "outline" !== e4.inputStyle && (this._rippleClass = "mbsc-textfield-ripple" + this._theme + (r2 ? " mbsc-error" : "") + (t3.hasFocus ? " mbsc-textfield-ripple-active" : "")), this._valueChecked && (this._animateFloating = true);
  }, t2.prototype._updated = function() {
    var e4 = this;
    this._shouldSize && (this._shouldSize = false, _e(this, function() {
      e4._sizeTextArea();
    })), this._checkFloating();
  }, t2.prototype._destroy = function() {
    Xt(this._el, "animationstart", this._onAutoFill), Xt(this._el, "input", this._sizeTextArea), function(e4) {
      ws--, Cs.unsubscribe(e4), ws || Xt(kt, "resize", Ts);
    }(this._unsubscribe), this._unlisten();
  }, t2.defaults = { dropdown: false, dropdownIcon: V, hideIcon: "eye-blocked", inputStyle: "underline", labelStyle: "stacked", placeholder: "", ripple: false, rows: 6, showIcon: "eye", type: "text" }, t2._name = "Input", t2;
}(wt), Es = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), Object.defineProperty(t2.prototype, "value", { get: function() {
    return this._el && this._el.value;
  }, set: function(e4) {
    this._el.value = e4, this._checkFloating(), "textarea" === this._tag && this._sizeTextArea();
  }, enumerable: true, configurable: true }), t2.prototype._template = function(e4, t3) {
    var n2 = this, s2 = this.props, i = s2.children, a2 = s2.dropdown;
    s2.dropdownIcon, s2.endIcon, s2.endIconSrc, s2.endIconSvg, s2.error;
    var r2 = s2.errorMessage, o3 = s2.hasChildren;
    s2.hideIcon, s2.hideIconSvg, s2.inputClass, s2.inputStyle, s2.label, s2.labelStyle, s2.notch, s2.passwordToggle, s2.pickerMap, s2.pickerValue, s2.ripple, s2.rows, s2.rtl, s2.showIcon, s2.showIconSvg, s2.startIcon, s2.startIconSrc, s2.startIconSvg;
    var l2 = s2.tags;
    s2.theme, s2.themeVariant;
    var c2 = s2.type, u2 = h$6(s2, ["children", "dropdown", "dropdownIcon", "endIcon", "endIconSrc", "endIconSvg", "error", "errorMessage", "hasChildren", "hideIcon", "hideIconSvg", "inputClass", "inputStyle", "label", "labelStyle", "notch", "passwordToggle", "pickerMap", "pickerValue", "ripple", "rows", "rtl", "showIcon", "showIconSvg", "startIcon", "startIconSrc", "startIconSvg", "tags", "theme", "themeVariant", "type"]), _2 = e4.label;
    return ls("label", { className: this._cssClass, onMouseDown: this._onMouseDown }, (_2 || o3) && ls("span", { className: this._labelClass }, o3 ? "" : _2), ls("span", { className: this._innerClass }, "input" === this._tag && ls("input", d$2({}, u2, { ref: this._setEl, className: this._nativeElmClass + (e4.tags ? " mbsc-textfield-hidden" : ""), disabled: this._disabled, type: e4.passwordToggle ? this._hidePass ? "password" : "text" : c2 })), "file" === c2 && ls("input", { className: this._dummyElmClass, disabled: this._disabled, placeholder: e4.placeholder, readOnly: true, type: "text", value: t3.files || "" }), "select" === this._tag && ls("select", d$2({}, u2, { ref: this._setEl, className: "mbsc-select" + this._nativeElmClass, disabled: this._disabled }), i), "textarea" === this._tag && ls("textarea", d$2({}, u2, { ref: this._setEl, className: this._nativeElmClass, disabled: this._disabled })), l2 && ls("span", { className: "mbsc-textfield-tags" + this._nativeElmClass }, this._tagsArray.length ? this._tagsArray.map(function(t4, s3) {
      return t4 && ls("span", { key: s3, className: "mbsc-textfield-tag" + n2._theme + n2._rtl }, ls("span", { className: "mbsc-textfield-tag-text" + n2._theme }, t4), ls(us, { className: "mbsc-textfield-tag-clear", onClick: function(e6) {
        return n2._onTagClear(e6, s3);
      }, svg: e4.clearIcon, theme: e4.theme }));
    }) : ls("span", { className: "mbsc-textfield-tags-placeholder" + this._theme }, e4.placeholder)), ("select" === this._tag || a2) && ls(us, { className: this._selectIconClass, svg: e4.dropdownIcon, theme: e4.theme }), this._hasStartIcon && ls(us, { className: this._startIconClass, name: e4.startIcon, svg: e4.startIconSvg, theme: e4.theme }), this._hasEndIcon && !e4.passwordToggle && ls(us, { className: this._endIconClass, name: e4.endIcon, svg: e4.endIconSvg, theme: e4.theme }), e4.passwordToggle && ls(us, { onClick: this._onClick, className: this._passIconClass, name: this._hidePass ? e4.showIcon : e4.hideIcon, svg: this._hidePass ? e4.showIconSvg : e4.hideIconSvg, theme: e4.theme }), this._hasError && ls("span", { className: this._errorClass }, r2), e4.notch && "outline" === e4.inputStyle && ls("fieldset", { "aria-hidden": "true", className: this._fieldSetClass }, ls("legend", { className: this._legendClass }, _2 && "inline" !== e4.labelStyle ? _2 : "&nbsp;")), e4.ripple && "outline" !== e4.inputStyle && ls("span", { className: this._rippleClass })));
  }, t2;
}(Ss), Ms = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype.render = function() {
    var e4 = this.props.context;
    return e4 ? reactDomExports.createPortal(this.props.children, e4) : null;
  }, t2;
}(reactExports.Component), Is = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    var t3 = this.props, n2 = t3.ariaLabel, s2 = t3.children;
    t3.className, t3.color;
    var i = t3.endIcon;
    t3.endIconSrc;
    var a2 = t3.endIconSvg;
    t3.hasChildren;
    var r2 = t3.icon;
    t3.iconSrc;
    var o3 = t3.iconSvg;
    t3.ripple, t3.rtl;
    var l2 = t3.role, c2 = t3.startIcon;
    t3.startIconSrc;
    var u2 = t3.startIconSvg;
    t3.tag, t3.tabIndex, t3.theme, t3.themeVariant, t3.variant;
    var _2 = h$6(t3, ["ariaLabel", "children", "className", "color", "endIcon", "endIconSrc", "endIconSvg", "hasChildren", "icon", "iconSrc", "iconSvg", "ripple", "rtl", "role", "startIcon", "startIconSrc", "startIconSvg", "tag", "tabIndex", "theme", "themeVariant", "variant"]), m2 = d$2({ "aria-label": n2, className: this._cssClass, ref: this._setEl }, _2), p2 = ls(ds, null, this._isIconOnly && ls(us, { className: this._iconClass, name: r2, svg: o3, theme: e4.theme }), this._hasStartIcon && ls(us, { className: this._startIconClass, name: c2, svg: u2, theme: e4.theme }), s2, this._hasEndIcon && ls(us, { className: this._endIconClass, name: i, svg: a2, theme: e4.theme }));
    return "span" === e4.tag ? ls("span", d$2({ role: l2, "aria-disabled": e4.disabled, tabIndex: this._tabIndex }, m2), p2) : "a" === e4.tag ? ls("a", d$2({ "aria-disabled": e4.disabled, tabIndex: this._tabIndex }, m2), p2) : ls("button", d$2({ role: l2, tabIndex: this._tabIndex }, m2), p2);
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._mounted = function() {
    var e4 = this;
    this._unlisten = Ds(this._el, { click: true, onBlur: function() {
      e4.setState({ hasFocus: false });
    }, onFocus: function() {
      e4.setState({ hasFocus: true });
    }, onHoverIn: function() {
      e4.s.disabled || e4.setState({ hasHover: true });
    }, onHoverOut: function() {
      e4.setState({ hasHover: false });
    }, onKeyDown: function(t3) {
      switch (t3.keyCode) {
        case 13:
        case 32:
          e4._el.click(), t3.preventDefault();
      }
    }, onPress: function() {
      e4.setState({ isActive: true });
    }, onRelease: function() {
      e4.setState({ isActive: false });
    }, onStart: function() {
      return { ripple: e4.s.ripple && !e4.s.disabled };
    } });
  }, t2.prototype._render = function(e4, t3) {
    var n2 = this, s2 = e4.disabled;
    this._isIconOnly = !(!e4.icon && !e4.iconSvg), this._hasStartIcon = !(!e4.startIcon && !e4.startIconSvg), this._hasEndIcon = !(!e4.endIcon && !e4.endIconSvg), this._tabIndex = s2 ? void 0 : e4.tabIndex || 0, this._cssClass = this._className + " mbsc-reset mbsc-font mbsc-button" + this._theme + this._rtl + " mbsc-button-" + e4.variant + (this._isIconOnly ? " mbsc-icon-button" : "") + (s2 ? " mbsc-disabled" : "") + (e4.color ? " mbsc-button-" + e4.color : "") + (t3.hasFocus && !s2 ? " mbsc-focus" : "") + (t3.isActive && !s2 ? " mbsc-active" : "") + (t3.hasHover && !s2 ? " mbsc-hover" : ""), this._iconClass = "mbsc-button-icon" + this._rtl, this._startIconClass = this._iconClass + " mbsc-button-icon-start", this._endIconClass = this._iconClass + " mbsc-button-icon-end", e4.disabled && t3.hasHover && setTimeout(function() {
      n2.setState({ hasHover: false });
    });
  }, t2.prototype._destroy = function() {
    this._unlisten();
  }, t2.defaults = { ripple: false, role: "button", tag: "button", variant: "standard" }, t2._name = "Button", t2;
}(wt)), Ns = Ms, Ls = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._setActive = function(e4) {
      t3._active = e4;
    }, t3._setContent = function(e4) {
      t3._content = e4;
    }, t3._setLimitator = function(e4) {
      t3._limitator = e4;
    }, t3._setPopup = function(e4) {
      t3._popup = e4;
    }, t3._setWrapper = function(e4) {
      t3._wrapper = e4;
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4, t3) {
    var n2 = this, s2 = this._hb, i = this._rtl, a2 = this._theme, r2 = e4.display;
    return this._isModal ? this._isVisible ? ls(Ns, { context: this._ctx }, ls("div", { className: "mbsc-font mbsc-popup-wrapper mbsc-popup-wrapper-" + r2 + a2 + i + " " + this._className + (e4.fullScreen ? " mbsc-popup-wrapper-" + r2 + "-full" : "") + (this._touchUi ? "" : " mbsc-popup-pointer") + (this._round ? " mbsc-popup-round" : "") + (this._hasContext ? " mbsc-popup-wrapper-ctx" : "") + (t3.isReady ? "" : " mbsc-popup-hidden"), ref: this._setWrapper, onKeyDown: this._onKeyDown }, e4.showOverlay && ls("div", { className: "mbsc-popup-overlay mbsc-popup-overlay-" + r2 + a2 + (this._isClosing ? " mbsc-popup-overlay-out" : "") + (this._isOpening && t3.isReady ? " mbsc-popup-overlay-in" : ""), onClick: this._onOverlayClick }), ls("div", { className: "mbsc-popup-limits mbsc-popup-limits-" + r2, ref: this._setLimitator, style: this._limits }), ls("div", { className: "mbsc-popup " + a2 + s2 + " mbsc-popup-" + r2 + (e4.fullScreen ? "-full" : "") + (t3.bubblePos && t3.showArrow && "anchored" === r2 ? " mbsc-popup-anchored-" + t3.bubblePos : "") + (this._isClosing ? " mbsc-popup-" + this._animation + "-out" : "") + (this._isOpening && t3.isReady ? " mbsc-popup-" + this._animation + "-in" : ""), role: "dialog", "aria-modal": "true", ref: this._setPopup, style: this._style, onClick: this._onPopupClick, onAnimationEnd: this._onAnimationEnd }, "anchored" === r2 && t3.showArrow && ls("div", { className: "mbsc-popup-arrow-wrapper mbsc-popup-arrow-wrapper-" + t3.bubblePos + a2 }, ls("div", { className: "mbsc-popup-arrow mbsc-popup-arrow-" + t3.bubblePos + a2, style: t3.arrowPos })), ls("div", { className: "mbsc-popup-focus", tabIndex: -1, ref: this._setActive }), ls("div", { className: "mbsc-popup-body mbsc-popup-body-" + r2 + a2 + s2 + (e4.fullScreen ? " mbsc-popup-body-" + r2 + "-full" : "") + (this._round ? " mbsc-popup-body-round" : "") }, this._headerText && ls("div", { className: "mbsc-popup-header mbsc-popup-header-" + r2 + a2 + s2 + (this._buttons ? "" : " mbsc-popup-header-no-buttons"), dangerouslySetInnerHTML: this._headerText }), ls("div", { className: "mbsc-popup-content" + (e4.contentPadding ? " mbsc-popup-padding" : ""), ref: this._setContent }, e4.children), this._buttons && ls("div", { className: "mbsc-popup-buttons mbsc-popup-buttons-" + r2 + a2 + i + s2 + (this._flexButtons ? " mbsc-popup-buttons-flex" : "") + (e4.fullScreen ? " mbsc-popup-buttons-" + r2 + "-full" : "") }, this._buttons.map(function(t4, a3) {
      return ls(Is, { color: t4.color, className: "mbsc-popup-button mbsc-popup-button-" + r2 + i + s2 + (n2._flexButtons ? " mbsc-popup-button-flex" : "") + " " + (t4.cssClass || ""), icon: t4.icon, disabled: t4.disabled, key: a3, theme: e4.theme, themeVariant: e4.themeVariant, variant: t4.variant || e4.buttonVariant, onClick: t4.handler }, t4.text);
    })))))) : null : ls(ds, null, e4.children);
  }, t2;
}(Cn);
function Hs(e3, t2, n2) {
  var s2 = t2.inputComponent, i = d$2({ defaultValue: e3._value && e3._valueText || "", placeholder: t2.placeholder, ref: e3._setInput }, t2.inputProps);
  t2.inputComponent || (s2 = Es, i = d$2({ "aria-expanded": !!e3._isOpen, "aria-haspopup": "dialog", disabled: t2.disabled, dropdown: t2.dropdown, endIcon: t2.endIcon, endIconSrc: t2.endIconSrc, endIconSvg: t2.endIconSvg, error: t2.error, errorMessage: t2.errorMessage, inputStyle: t2.inputStyle, label: t2.label, labelStyle: t2.labelStyle, name: t2.name, pickerMap: t2.valueMap, pickerValue: e3._value, placeholder: t2.placeholder, rtl: t2.rtl, startIcon: t2.startIcon, startIconSrc: t2.startIconSrc, startIconSvg: t2.startIconSvg, tags: void 0 === t2.tagInput ? t2.selectMultiple : t2.tagInput, theme: t2.theme, themeVariant: t2.themeVariant }, i));
  var a2 = ls(s2, i);
  return ls(ds, null, e3._showInput && a2, ls(Ls, { activeElm: t2.activeElm, anchor: e3._anchor, anchorAlign: e3._anchorAlign, animation: t2.animation, buttons: e3._buttons, cancelText: t2.cancelText, closeOnEsc: t2.closeOnEsc, closeOnOverlayClick: t2.closeOnOverlayClick, closeOnScroll: t2.closeOnScroll, closeText: t2.closeText, contentPadding: false, context: t2.context, cssClass: e3._cssClass, disableLeftRight: true, display: t2.display, focusElm: e3._focusElm, focusOnClose: t2.focusOnClose, focusOnOpen: !e3._allowTyping, focusTrap: t2.focusTrap, fullScreen: t2.fullScreen, headerText: e3._headerText, height: t2.height, isOpen: e3._isOpen, maxHeight: t2.maxHeight, maxWidth: e3._maxWidth, onClose: e3._onPopupClose, onClosed: e3._onPopupClosed, onKeyDown: e3._onPopupKey, onOpen: e3._onPopupOpen, onResize: e3._onResize, setText: t2.setText, showArrow: t2.showArrow, showOverlay: !e3._allowTyping && t2.showOverlay, ref: e3._setPopup, rtl: t2.rtl, scrollLock: e3._scrollLock, theme: t2.theme, themeVariant: t2.themeVariant, touchUi: e3._touchUi, windowWidth: e3.state.width, width: t2.width }, n2));
}
var Os = os({}), Rs = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype.componentWillUnmount = function() {
    this._changes && this._changes.unsubscribe(this._handler);
  }, t2.prototype.render = function() {
    var e4 = this, t3 = this.props, n2 = t3.host, s2 = t3.component, i = t3.view, a2 = h$6(t3, ["host", "component", "view"]), r2 = i || n2 && n2._calendarView;
    return r2 && !this._changes && (this._changes = r2.s.instanceService.onComponentChange, this._handler = this._changes.subscribe(function() {
      e4.forceUpdate();
    })), ls(Os.Consumer, null, function(e6) {
      var t4 = e6.instance || i || n2 && n2._calendarView;
      return t4 && ls(s2, d$2({ inst: t4 }, a2));
    });
  }, t2;
}(hs), Vs = function(e3) {
  var t2 = e3.inst, n2 = e3.className;
  return ls(Is, { ariaLabel: t2.s.prevPageText, className: "mbsc-calendar-button " + (n2 || ""), disabled: t2._isPrevDisabled(), iconSvg: t2._prevIcon, onClick: t2.prevPage, theme: t2.s.theme, themeVariant: t2.s.themeVariant, type: "button", variant: "flat" });
}, Ps = function(e3) {
  var t2 = e3.inst, n2 = e3.className;
  return ls(Is, { ariaLabel: t2.s.nextPageText, disabled: t2._isNextDisabled(), className: "mbsc-calendar-button " + (n2 || ""), iconSvg: t2._nextIcon, onClick: t2.nextPage, theme: t2.s.theme, themeVariant: t2.s.themeVariant, type: "button", variant: "flat" });
}, zs = function(e3) {
  var t2 = e3.inst, n2 = e3.className;
  return ls(Is, { className: "mbsc-calendar-button mbsc-calendar-button-today " + (n2 || ""), onClick: t2._onTodayClick, theme: t2.s.theme, themeVariant: t2.s.themeVariant, type: "button", variant: "flat" }, t2.s.todayText);
}, Ys = function(e3) {
  var t2 = e3.inst, n2 = e3.className, s2 = t2.s, i = t2._theme, a2 = t2._view;
  return ls("div", { "aria-live": "polite", className: (n2 || "") + i }, t2._title.map(function(e4, n3) {
    return (1 === t2._pageNr || 0 === n3 || t2._hasPicker || "month" === a2) && ls(Is, { className: "mbsc-calendar-button", "data-index": n3, onClick: t2._onPickerBtnClick, key: n3, theme: s2.theme, themeVariant: s2.themeVariant, type: "button", variant: "flat" }, (t2._hasPicker || "month" === a2) && (e4.title ? ls("span", { className: "mbsc-calendar-title" + i }, e4.title) : ls(ds, null, t2._yearFirst && ls("span", { className: "mbsc-calendar-title mbsc-calendar-year" + i }, e4.yearTitle), ls("span", { className: "mbsc-calendar-title mbsc-calendar-month" + i }, e4.monthTitle), !t2._yearFirst && ls("span", { className: "mbsc-calendar-title mbsc-calendar-year" + i }, e4.yearTitle))), !t2._hasPicker && "month" !== a2 && ls("span", { className: "mbsc-calendar-title" + i }, t2._viewTitle), s2.downIcon && 1 === t2._pageNr ? ls(us, { svg: "month" === a2 ? s2.downIcon : s2.upIcon, theme: s2.theme }) : null);
  }));
}, Ws = function(e3) {
  var t2 = e3.calendar, n2 = e3.view, s2 = h$6(e3, ["calendar", "view"]);
  return ls(Rs, d$2({ component: Vs, host: t2, view: n2 }, s2));
};
Ws._name = "CalendarPrev";
var Fs = function(e3) {
  var t2 = e3.calendar, n2 = e3.view, s2 = h$6(e3, ["calendar", "view"]);
  return ls(Rs, d$2({ component: Ps, host: t2, view: n2 }, s2));
};
Fs._name = "CalendarNext";
var As = function(e3) {
  var t2 = e3.calendar, n2 = e3.view, s2 = h$6(e3, ["calendar", "view"]);
  return ls(Rs, d$2({ component: zs, host: t2, view: n2 }, s2));
};
As._name = "CalendarToday";
var Us = function(e3) {
  var t2 = e3.calendar, n2 = e3.view, s2 = h$6(e3, ["calendar", "view"]);
  return ls(Rs, d$2({ component: Ys, host: t2, view: n2 }, s2));
};
function Bs(e3, t2, n2, s2) {
  var i;
  if (!(t2 < n2 || t2 > s2)) {
    if (j(e3)) {
      var a2 = e3.length, r2 = t2 % a2;
      i = e3[r2 >= 0 ? r2 : r2 + a2];
    } else
      i = e3(t2);
    return i;
  }
}
Us._name = "CalendarNav";
var Xs = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._setInnerEl = function(e4) {
      t3._innerEl = e4;
    }, t3._setScrollEl = function(e4) {
      t3._scrollEl = e4;
    }, t3._setScrollEl3d = function(e4) {
      t3._scrollEl3d = e4;
    }, t3._setScrollbarEl = function(e4) {
      t3._scrollbarEl = e4;
    }, t3._setScrollbarContEl = function(e4) {
      t3._scrollbarContEl = e4;
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    var t3, n2 = this, s2 = e4.children;
    return e4.itemRenderer && (s2 = this.visibleItems.map(function(t4) {
      return e4.itemRenderer(t4, n2._offset);
    }), e4.scroll3d && (t3 = this.visible3dItems.map(function(t4) {
      return e4.itemRenderer(t4, n2._offset, true);
    }))), ls("div", { ref: this._setEl, className: this._cssClass, style: e4.styles }, ls("div", { ref: this._setInnerEl, className: e4.innerClass, style: e4.innerStyles }, ls("div", { ref: this._setScrollEl, className: "mbsc-scrollview-scroll" + this._rtl }, s2)), e4.scroll3d && ls("div", { ref: this._setScrollEl3d, style: { height: e4.itemSize + "px" }, className: "mbsc-scroller-items-3d" }, t3), ls("div", { ref: this._setScrollbarContEl, className: "mbsc-scroller-bar-cont " + this._rtl + (e4.scrollBar && this._barSize !== this._barContSize ? "" : " mbsc-scroller-bar-hidden") + (this._started ? " mbsc-scroller-bar-started" : "") }, ls("div", { className: "mbsc-scroller-bar" + this._theme, ref: this._setScrollbarEl, style: { height: this._barSize + "px" } })));
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._currPos = 0, t3._delta = 0, t3._endPos = 0, t3._lastRaf = 0, t3._maxSnapScroll = 0, t3._margin = 0, t3._scrollEnd = he(function() {
      Rt(t3._raf), t3._raf = false, t3._onEnd(), t3._hasScrolled = false;
    }, 200), t3._onStart = function(e4) {
      var n2 = t3.s;
      t3._hook("onStart", {}), n2.changeOnEnd && t3._isScrolling || !n2.mouseSwipe && !e4.isTouch || !n2.swipe || (t3._started = true, t3._hasScrolled = t3._isScrolling, t3._currX = e4.startX, t3._currY = e4.startY, t3._delta = 0, t3._velocityX = 0, t3._velocityY = 0, t3._startPos = Zt(t3._scrollEl, t3._isVertical), t3._timestamp = +/* @__PURE__ */ new Date(), t3._isScrolling && (Rt(t3._raf), t3._raf = false, t3._scroll(t3._startPos)));
    }, t3._onMove = function(e4) {
      var n2 = e4.domEvent, s2 = t3.s;
      t3._isVertical || s2.scrollLock || t3._hasScrolled ? n2.cancelable && n2.preventDefault() : "touchmove" === n2.type && (Math.abs(e4.deltaY) > 7 || !s2.swipe) && (t3._started = false), t3._started && (t3._delta = t3._isVertical ? e4.deltaY : e4.deltaX, (t3._hasScrolled || Math.abs(t3._delta) > t3._threshold) && (t3._hasScrolled || t3._hook("onGestureStart", {}), t3._hasScrolled = true, t3._isScrolling = true, t3._raf || (t3._raf = Ot(function() {
        return t3._move(e4);
      }))));
    }, t3._onEnd = function() {
      if (t3._started = false, t3._hasScrolled) {
        var e4, n2 = t3.s, s2 = 17 * (t3._isVertical ? t3._velocityY : t3._velocityX), i = t3._maxSnapScroll, a2 = t3._delta;
        a2 += s2 * s2 * 0.5 * (s2 < 0 ? -1 : 1), i && (a2 = G(a2, -t3._round * i, t3._round * i));
        var r2 = G(oe((t3._startPos + a2) / t3._round) * t3._round, t3._min, t3._max), o3 = oe(-r2 * t3._rtlNr / n2.itemSize) + t3._offset, l2 = a2 > 0 ? t3._isVertical ? 270 : 360 : t3._isVertical ? 90 : 180, c2 = o3 - n2.selectedIndex;
        e4 = n2.time || Math.max(1e3, 3 * Math.abs(r2 - t3._currPos)), t3._hook("onGestureEnd", { direction: l2, index: o3 }), t3._delta = 0, t3._scroll(r2, e4), c2 && !n2.changeOnEnd && (t3._hook("onIndexChange", { index: o3, diff: c2 }), n2.selectedIndex === t3._prevIndex && n2.selectedIndex !== o3 && t3.forceUpdate());
      }
    }, t3._onClick = function(e4) {
      t3._hasScrolled && (t3._hasScrolled = false, e4.stopPropagation(), e4.preventDefault());
    }, t3._onScroll = function(e4) {
      e4.target.scrollTop = 0, e4.target.scrollLeft = 0;
    }, t3._onMouseWheel = function(e4) {
      var n2 = t3._isVertical ? void 0 === e4.deltaY ? e4.wheelDelta || e4.detail : e4.deltaY : e4.deltaX;
      if (t3._el.contains(e4.target) && n2 && t3.s.mousewheel) {
        if (e4.preventDefault(), t3._hook("onStart", {}), t3._started || (t3._delta = 0, t3._velocityX = 0, t3._velocityY = 0, t3._startPos = t3._currPos, t3._hook("onGestureStart", {})), e4.deltaMode && 1 === e4.deltaMode && (n2 *= 15), n2 = G(-n2, -t3._scrollSnap, t3._scrollSnap), t3._delta += n2, t3._maxSnapScroll && Math.abs(t3._delta) > t3._round * t3._maxSnapScroll && (n2 = 0), t3._startPos + t3._delta < t3._min && (t3._startPos = t3._min, t3._delta = 0, n2 = 0), t3._startPos + t3._delta > t3._max && (t3._startPos = t3._max, t3._delta = 0, n2 = 0), t3._raf || (t3._raf = Ot(function() {
          return t3._move();
        })), !n2 && t3._started)
          return;
        t3._hasScrolled = true, t3._isScrolling = true, t3._started = true, t3._scrollEnd();
      }
    }, t3._onTrackStart = function(e4) {
      e4.stopPropagation();
      var n2 = { domEvent: e4, startX: ms(e4, "X", true), startY: ms(e4, "Y", true) };
      if (t3._onStart(n2), t3._trackStartX = n2.startX, t3._trackStartY = n2.startY, e4.target === t3._scrollbarEl)
        Bt(t3._doc, un, t3._onTrackEnd), Bt(t3._doc, "mousemove", t3._onTrackMove);
      else {
        var s2 = tn(t3._scrollbarContEl).top, i = (n2.startY - s2) / t3._barContSize;
        t3._startPos = t3._currPos = t3._max + (t3._min - t3._max) * i, t3._hasScrolled = true, t3._onEnd();
      }
    }, t3._onTrackMove = function(e4) {
      var n2 = t3._barContSize, s2 = ms(e4, "X", true), i = ms(e4, "Y", true), a2 = (t3._isVertical ? i - t3._trackStartY : s2 - t3._trackStartX) / n2;
      t3._isInfinite ? t3._delta = -(t3._maxSnapScroll * t3._round * 2 + n2) * a2 : t3._delta = (t3._min - t3._max - n2) * a2, (t3._hasScrolled || Math.abs(t3._delta) > t3._threshold) && (t3._hasScrolled || t3._hook("onGestureStart", {}), t3._hasScrolled = true, t3._isScrolling = true, t3._raf || (t3._raf = Ot(function() {
        return t3._move({ endX: s2, endY: i }, !t3._isInfinite);
      })));
    }, t3._onTrackEnd = function() {
      t3._delta = 0, t3._startPos = t3._currPos, t3._onEnd(), Xt(t3._doc, un, t3._onTrackEnd), Xt(t3._doc, "mousemove", t3._onTrackMove);
    }, t3._onTrackClick = function(e4) {
      e4.stopPropagation();
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._render = function(e4, t3) {
    var n2 = this._prevS, s2 = e4.batchSize, i = e4.batchSize3d, a2 = e4.itemNr || 1, r2 = e4.itemSize, o3 = e4.selectedIndex, l2 = n2.selectedIndex, c2 = void 0 === t3.index ? o3 : t3.index, d2 = [], h2 = [], u2 = o3 - l2, _2 = c2 - this._currIndex, m2 = e4.minIndex, p2 = e4.maxIndex, v2 = e4.items, f2 = e4.offset;
    this._currIndex = c2, this._isVertical = "Y" === e4.axis, this._threshold = this._isVertical ? e4.thresholdY : e4.thresholdX, this._rtlNr = !this._isVertical && e4.rtl ? -1 : 1, this._round = e4.snap ? r2 : 1;
    for (var g2 = this._round; g2 > 44; )
      g2 /= 2;
    if (this._scrollSnap = oe(44 / g2) * g2, v2) {
      for (var y2 = c2 - s2; y2 < c2 + a2 + s2; y2++)
        d2.push({ key: y2, data: Bs(v2, y2, m2, p2) });
      if (e4.scroll3d)
        for (y2 = c2 - i; y2 < c2 + a2 + i; y2++)
          h2.push({ key: y2, data: Bs(v2, y2, m2, p2) });
      this.visibleItems = d2, this.visible3dItems = h2, this._maxSnapScroll = s2, this._isInfinite = "function" == typeof v2;
    }
    void 0 === this._offset && (this._offset = o3);
    var b2 = -(o3 - this._offset) * r2 * this._rtlNr;
    if (Math.abs(u2) > s2 && b2 !== this._endPos) {
      var D2 = u2 + s2 * (u2 > 0 ? -1 : 1);
      this._offset += D2, this._margin -= D2;
    }
    if (f2 && f2 !== n2.offset && (this._offset += f2, this._margin -= f2), _2 && (this._margin += _2), this._max = void 0 !== m2 ? -(m2 - this._offset) * r2 * this._rtlNr : 1 / 0, this._min = void 0 !== p2 ? -(p2 - this._offset - (e4.spaceAround ? 0 : a2 - 1)) * r2 * this._rtlNr : -1 / 0, -1 === this._rtlNr) {
      var x2 = this._min;
      this._min = this._max, this._max = x2;
    }
    this._min > this._max && (this._min = this._max);
    var C2 = e4.visibleSize * r2;
    this._barContSize = C2, this._barSize = Math.max(20, C2 * C2 / (this._max - this._min + C2)), this._cssClass = this._className + " mbsc-ltr";
  }, t2.prototype._mounted = function() {
    this._doc = Kt(this._el), Bt(this._el, dn, this._onClick, true), Bt(this.s.scroll3d ? this._innerEl : this._el, "scroll", this._onScroll), Bt(this._doc, "mousewheel", this._onMouseWheel, { passive: false, capture: true }), Bt(this._doc, "wheel", this._onMouseWheel, { passive: false, capture: true }), Bt(this._scrollbarContEl, hn, this._onTrackStart), Bt(this._scrollbarContEl, dn, this._onTrackClick), this._unlisten = Ds(this._el, { onEnd: this._onEnd, onMove: this._onMove, onStart: this._onStart, prevDef: true });
  }, t2.prototype._updated = function() {
    var e4 = this.s, t3 = e4.batchSize, n2 = e4.itemSize, s2 = e4.selectedIndex, i = this._prevIndex, a2 = !e4.prevAnim && (void 0 !== i && i !== s2 || this._isAnimating), r2 = -(s2 - this._offset) * n2 * this._rtlNr;
    e4.margin && (this._scrollEl.style.marginTop = this._isVertical ? (this._margin - t3) * n2 + "px" : ""), this._started || this._scroll(r2, a2 ? this._isAnimating || e4.time || 1e3 : 0), this._prevIndex = s2;
  }, t2.prototype._destroy = function() {
    Xt(this._el, dn, this._onClick, true), Xt(this.s.scroll3d ? this._innerEl : this._el, "scroll", this._onScroll), Xt(this._doc, "mousewheel", this._onMouseWheel, { passive: false, capture: true }), Xt(this._doc, "wheel", this._onMouseWheel, { passive: false, capture: true }), Xt(this._scrollbarContEl, hn, this._onTrackStart), Xt(this._scrollbarContEl, dn, this._onTrackClick), Rt(this._raf), this._raf = false, this._scroll(0), this._unlisten();
  }, t2.prototype._anim = function(e4) {
    var t3 = this;
    return this._raf = Ot(function() {
      var n2 = t3.s, s2 = +/* @__PURE__ */ new Date();
      if (t3._raf) {
        if ((t3._currPos - t3._endPos) * -e4 < 4)
          return t3._currPos = t3._endPos, t3._raf = false, t3._isAnimating = 0, t3._isScrolling = false, t3._infinite(t3._currPos), t3._hook("onAnimationEnd", {}), void t3._scrollbarContEl.classList.remove("mbsc-scroller-bar-started");
        s2 - t3._lastRaf > 100 && (t3._lastRaf = s2, t3._currPos = Zt(t3._scrollEl, t3._isVertical), n2.changeOnEnd || t3._infinite(t3._currPos)), t3._raf = t3._anim(e4);
      }
    });
  }, t2.prototype._infinite = function(e4) {
    var t3 = this.s;
    if (t3.itemSize) {
      var n2 = oe(-e4 * this._rtlNr / t3.itemSize) + this._offset, s2 = n2 - this._currIndex;
      s2 && (t3.changeOnEnd ? this._hook("onIndexChange", { index: n2, diff: s2 }) : this.setState({ index: n2 }));
    }
  }, t2.prototype._scroll = function(e4, t3) {
    var n2 = this.s, s2 = n2.itemSize, i = this._isVertical, a2 = this._scrollEl.style, r2 = Wt ? Wt + "T" : "t", o3 = t3 ? Ft + "transform " + oe(t3) + "ms " + n2.easing : "";
    if (a2[r2 + "ransform"] = "translate3d(" + (i ? "0," + e4 + "px," : e4 + "px,0,") + "0)", a2[r2 + "ransition"] = o3, this._endPos = e4, n2.scroll3d) {
      var l2 = this._scrollEl3d.style, c2 = 360 / (2 * n2.batchSize3d);
      l2[r2 + "ransform"] = "translateY(-50%) rotateX(" + -e4 / s2 * c2 + "deg)", l2[r2 + "ransition"] = o3;
    }
    if (this._scrollbarEl) {
      var d2 = this._scrollbarEl.style, h2 = this._isInfinite ? (this._maxSnapScroll * this._round - this._delta) / (this._maxSnapScroll * this._round * 2) : (e4 - this._max) / (this._min - this._max), u2 = G((this._barContSize - this._barSize) * h2, 0, this._barContSize - this._barSize);
      d2[r2 + "ransform"] = "translate3d(" + (i ? "0," + u2 + "px," : u2 + "px,0,") + "0)", d2[r2 + "ransition"] = o3;
    }
    t3 ? (Rt(this._raf), this._isAnimating = t3, this._scrollbarContEl.classList.add("mbsc-scroller-bar-started"), this._raf = this._anim(e4 > this._currPos ? 1 : -1)) : (this._currPos = e4, n2.changeOnEnd || this._infinite(e4));
  }, t2.prototype._move = function(e4, t3) {
    var n2 = this._currX, s2 = this._currY, i = this._timestamp, a2 = this._maxSnapScroll;
    if (e4) {
      this._currX = e4.endX, this._currY = e4.endY, this._timestamp = +/* @__PURE__ */ new Date();
      var r2 = this._timestamp - i;
      if (r2 > 0 && r2 < 100) {
        var o3 = (this._currX - n2) / r2, l2 = (this._currY - s2) / r2;
        this._velocityX = 0.7 * o3 + 0.3 * this._velocityX, this._velocityY = 0.7 * l2 + 0.3 * this._velocityY;
      }
    }
    a2 && !t3 && (this._delta = G(this._delta, -this._round * a2, this._round * a2)), this._scroll(G(this._startPos + this._delta, this._min - this.s.itemSize, this._max + this.s.itemSize)), this._raf = false;
  }, t2.defaults = { axis: "Y", batchSize: 40, easing: "cubic-bezier(0.190, 1.000, 0.220, 1.000)", mouseSwipe: true, mousewheel: true, prevDef: true, selectedIndex: 0, spaceAround: true, stopProp: true, swipe: true, thresholdX: 10, thresholdY: 5 }, t2;
}(wt)), Ks = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._onClick = function(e4) {
      t3._cellClick("onDayClick", e4);
    }, t3._onRightClick = function(e4) {
      t3._cellClick("onDayRightClick", e4);
    }, t3._onLabelClick = function(e4) {
      t3._labelClick("onLabelClick", e4);
    }, t3._onLabelDoubleClick = function(e4) {
      t3._labelClick("onLabelDoubleClick", e4);
    }, t3._onLabelRightClick = function(e4) {
      t3._labelClick("onLabelRightClick", e4);
    }, t3._onLabelHoverIn = function(e4) {
      t3._labelClick("onLabelHoverIn", e4);
    }, t3._onLabelHoverOut = function(e4) {
      t3._labelClick("onLabelHoverOut", e4);
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._mounted = function() {
    var e4, t3, n2, s2 = this;
    this._unlisten = Ds(this._el, { click: true, onBlur: function() {
      s2.setState({ hasFocus: false });
    }, onDoubleClick: function(e6) {
      var t4 = s2.s;
      t4.clickToCreate && "single" !== t4.clickToCreate && t4.labels && !t4.disabled && t4.display && (s2._hook("onLabelUpdateStart", e6), s2._hook("onLabelUpdateEnd", e6)), s2._cellClick("onDayDoubleClick", e6.domEvent);
    }, onEnd: function(i) {
      e4 && (i.domEvent.preventDefault(), s2._hook("onLabelUpdateEnd", i), e4 = false), clearTimeout(n2), e4 = false, t3 = false;
    }, onFocus: function() {
      s2.setState({ hasFocus: true });
    }, onHoverIn: function(e6) {
      var t4 = s2.s;
      t4.disabled || s2.setState({ hasHover: true }), s2._hook("onHoverIn", { date: new Date(t4.date), domEvent: e6, hidden: !t4.display, outer: t4.outer, target: s2._el });
    }, onHoverOut: function(e6) {
      var t4 = s2.s;
      s2.setState({ hasHover: false }), s2._hook("onHoverOut", { date: new Date(t4.date), domEvent: e6, hidden: !t4.display, outer: t4.outer, target: s2._el });
    }, onKeyDown: function(e6) {
      switch (e6.keyCode) {
        case 13:
        case 32:
          e6.preventDefault(), s2._onClick(e6);
      }
    }, onMove: function(i) {
      e4 && s2.s.dragToCreate ? (i.domEvent.preventDefault(), s2._hook("onLabelUpdateMove", i)) : t3 && s2.s.dragToCreate && (Math.abs(i.deltaX) > 7 || Math.abs(i.deltaY) > 7) ? (e4 = !i.isTouch, s2._hook("onLabelUpdateStart", i)) : clearTimeout(n2);
    }, onStart: function(i) {
      var a2 = s2.s;
      (i.create = true, a2.disabled || !a2.dragToCreate && !a2.clickToCreate || !a2.labels || e4) || (sn(i.domEvent.target, ".mbsc-calendar-text", s2._el) || (i.isTouch && a2.dragToCreate ? n2 = setTimeout(function() {
        s2._hook("onLabelUpdateStart", i), s2._hook("onLabelUpdateModeOn", i), e4 = true;
      }, 350) : "single" === a2.clickToCreate ? (s2._hook("onLabelUpdateStart", i), e4 = true) : t3 = !i.isTouch));
    } });
  }, t2.prototype._render = function(e4, t3) {
    var n2 = Je(e4), s2 = e4.date, i = e4.colors, a2 = e4.display, r2 = e4.dragData, o3 = e4.hoverEnd, l2 = e4.hoverStart, c2 = e4.labels, d2 = e4.rangeEnd, h2 = e4.rangeStart, u2 = new Date(s2), _2 = Pe(u2), m2 = Ue(n2, u2), p2 = c2 && c2.events, v2 = i && i[0], f2 = v2 && v2.background, g2 = v2 && v2.highlight, y2 = "", b2 = "";
    this._draggedLabel = r2 && r2.draggedDates && r2.draggedDates[_2], this._draggedLabelOrig = r2 && r2.originDates && r2.originDates[_2], this._todayClass = m2 ? " mbsc-calendar-today" : "", this._cellStyles = f2 && a2 ? { backgroundColor: f2, color: $t(f2) } : void 0, this._circleStyles = g2 ? { backgroundColor: g2, color: $t(v2.highlight) } : void 0, this._ariaLabel = "day" === e4.type ? (m2 ? e4.todayText + ", " : "") + e4.day + ", " + e4.month + " " + e4.text + ", " + e4.year : "month" === e4.type ? e4.month : "", a2 && ((h2 && s2 >= h2 && s2 <= (d2 || h2) || d2 && s2 <= d2 && s2 >= (h2 || d2)) && (b2 = " mbsc-range-day" + (s2 === (h2 || d2) ? " mbsc-range-day-start" : "") + (s2 === (d2 || h2) ? " mbsc-range-day-end" : "")), l2 && o3 && s2 >= l2 && s2 <= o3 && (b2 += " mbsc-range-hover" + (s2 === l2 ? " mbsc-range-hover-start mbsc-hover" : "") + (s2 === o3 ? " mbsc-range-hover-end mbsc-hover" : ""))), e4.marks && e4.marks.forEach(function(e6) {
      y2 += e6.cellCssClass ? " " + e6.cellCssClass : "";
    }), i && i.forEach(function(e6) {
      y2 += e6.cellCssClass ? " " + e6.cellCssClass : "";
    }), p2 && p2.forEach(function(e6) {
      y2 += e6.cellCssClass ? " " + e6.cellCssClass : "";
    }), this._cssClass = "mbsc-calendar-cell mbsc-flex-1-0-0 mbsc-calendar-" + e4.type + this._theme + this._rtl + this._hb + y2 + (c2 ? " mbsc-calendar-day-labels" : "") + (i ? " mbsc-calendar-day-colors" : "") + (e4.outer ? " mbsc-calendar-day-outer" : "") + (e4.hasMarks ? " mbsc-calendar-day-marked" : "") + (e4.disabled ? " mbsc-disabled" : "") + (a2 ? "" : " mbsc-calendar-day-empty") + (e4.selected ? " mbsc-selected" : "") + (t3.hasFocus ? " mbsc-focus" : "") + (!t3.hasHover || s2 !== l2 && s2 !== o3 && (l2 || o3) ? "" : " mbsc-hover") + (this._draggedLabel ? " mbsc-calendar-day-highlight" : "") + b2, this._data = { date: u2, events: p2, selected: e4.selected };
  }, t2.prototype._destroy = function() {
    this._unlisten();
  }, t2.prototype._cellClick = function(e4, t3) {
    var n2 = this.s;
    n2.display && this._hook(e4, { date: new Date(n2.date), disabled: n2.disabled, domEvent: t3, outer: n2.outer, selected: n2.selected, source: "calendar", target: this._el });
  }, t2.prototype._labelClick = function(e4, t3) {
    var n2 = this.s;
    t3.date = new Date(n2.date), t3.labels = n2.labels.events, this._hook(e4, t3);
  }, t2;
}(wt), qs = {}, Gs = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._onClick = function(e4) {
      if (t3._isDrag)
        e4.stopPropagation();
      else {
        t3._triggerEvent("onClick", e4);
        var n2 = t3.s, s2 = qs[n2.id];
        s2 && n2.selected && s2.next({ hasFocus: false });
      }
    }, t3._onRightClick = function(e4) {
      t3._triggerEvent("onRightClick", e4);
    }, t3._onDocTouch = function(e4) {
      Xt(t3._doc, "touchstart", t3._onDocTouch), Xt(t3._doc, hn, t3._onDocTouch), t3._isDrag = false, t3._hook("onDragModeOff", { data: t3.s.event });
    }, t3._updateState = function(e4) {
      t3.s.showText && t3.setState(e4);
    }, t3._triggerEvent = function(e4, n2) {
      t3._hook(e4, { domEvent: n2, label: t3.s.event, target: t3._el });
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._mounted = function() {
    var e4, t3 = this, n2 = this.s, s2 = n2.id, i = n2.isPicker, a2 = qs[s2];
    a2 || (a2 = new v$3(), qs[s2] = a2), this._unsubscribe = a2.subscribe(this._updateState), this._doc = Kt(this._el), this._unlisten = Ds(this._el, { keepFocus: true, onBlur: function() {
      i || a2.next({ hasFocus: false });
    }, onDoubleClick: function(e6) {
      e6.domEvent.stopPropagation(), t3._hook("onDoubleClick", { domEvent: e6.domEvent, label: t3.s.event, target: t3._el });
    }, onEnd: function(n3) {
      if (t3._isDrag) {
        var s3 = t3.s, i2 = d$2({}, n3);
        i2.domEvent.preventDefault(), i2.data = s3.event, s3.resize && e4 ? (i2.resize = true, i2.direction = e4) : s3.drag && (i2.drag = true), t3._hook("onDragEnd", i2), s3.isUpdate || (t3._isDrag = false);
      }
      clearTimeout(t3._touchTimer), e4 = void 0;
    }, onFocus: function() {
      i || a2.next({ hasFocus: true });
    }, onHoverIn: function(e6) {
      t3._isDrag || i || (a2.next({ hasHover: true }), t3._triggerEvent("onHoverIn", e6));
    }, onHoverOut: function(e6) {
      a2.next({ hasHover: false }), t3._triggerEvent("onHoverOut", e6);
    }, onKeyDown: function(e6) {
      var n3 = t3.s.event;
      switch (e6.keyCode) {
        case 13:
        case 32:
          t3._el.click(), e6.preventDefault();
          break;
        case 8:
        case 46:
          n3 && false !== n3.editable && t3._hook("onDelete", { domEvent: e6, event: n3, source: "calendar" });
      }
    }, onMove: function(n3) {
      var s3 = t3.s, i2 = d$2({}, n3);
      if (i2.data = s3.event, e4)
        i2.resize = true, i2.direction = e4;
      else {
        if (!s3.drag)
          return;
        i2.drag = true;
      }
      s3.event && false !== s3.event.editable && (t3._isDrag ? (i2.domEvent.preventDefault(), t3._hook("onDragMove", i2)) : (Math.abs(i2.deltaX) > 7 || Math.abs(i2.deltaY) > 7) && (clearTimeout(t3._touchTimer), i2.isTouch || (t3._isDrag = true, t3._hook("onDragStart", i2))));
    }, onStart: function(n3) {
      var s3 = t3.s, i2 = d$2({}, n3), a3 = i2.domEvent.target;
      if (i2.data = s3.event, s3.resize && a3.classList.contains("mbsc-calendar-label-resize"))
        e4 = a3.classList.contains("mbsc-calendar-label-resize-start") ? "start" : "end", i2.resize = true, i2.direction = e4;
      else {
        if (!s3.drag)
          return;
        i2.drag = true;
      }
      s3.event && false !== s3.event.editable && (!t3._isDrag && i2.isTouch || i2.domEvent.stopPropagation(), t3._isDrag ? t3._hook("onDragStart", i2) : i2.isTouch && (t3._touchTimer = setTimeout(function() {
        t3._hook("onDragModeOn", i2), t3._hook("onDragStart", i2), t3._isDrag = true;
      }, 350)));
    } }), this._isDrag && (Bt(this._doc, "touchstart", this._onDocTouch), Bt(this._doc, hn, this._onDocTouch));
  }, t2.prototype._destroy = function() {
    if (this._unsubscribe) {
      var e4 = this.s.id, t3 = qs[e4];
      t3 && (t3.unsubscribe(this._unsubscribe), t3.nr || delete qs[e4]);
    }
    this._unlisten && this._unlisten(), Xt(this._doc, "touchstart", this._onDocTouch), Xt(this._doc, hn, this._onDocTouch);
  }, t2.prototype._render = function(e4, t3) {
    var n2, s2, i, a2, r2, o3, l2 = e4.event, c2 = new Date(e4.date), d2 = e4.render || e4.renderContent, h2 = false;
    if (this._isDrag = this._isDrag || e4.isUpdate, this._content = void 0, this._title = e4.more || e4.count || !e4.showEventTooltip ? void 0 : function(e6) {
      if (Tt && e6) {
        var t4 = Tt.createElement("div");
        return t4.innerHTML = e6, t4.textContent.trim();
      }
      return e6 || "";
    }(l2.tooltip || l2.title || l2.text), this._tabIndex = e4.isActiveMonth && e4.showText && !e4.count && !e4.isPicker ? 0 : -1, l2) {
      var u2 = l2.allDay, _2 = u2 ? void 0 : e4;
      n2 = l2.start ? Ze(l2.start, _2) : null, s2 = l2.end ? Ze(l2.end, _2) : null;
      var m2 = n2 && s2 && Ve(e4, u2, n2, s2, true), p2 = it(Ae(c2, e4), 7), v2 = e4.lastDay && e4.lastDay < p2 ? e4.lastDay : p2;
      i = !(h2 = n2 && m2 && !Ue(n2, m2)) || n2 && Ue(n2, c2), a2 = !h2 || m2 && Ue(m2, c2), r2 = !h2 || (e4.showText ? m2 < v2 : a2), this._hasResizeStart = e4.resize && i, this._hasResizeEnd = e4.resize && r2;
      var f2 = l2.color;
      if (!f2 && l2.resource && e4.resourcesMap) {
        var g2 = e4.resourcesMap[j(l2.resource) ? l2.resource[0] : l2.resource];
        f2 = g2 && g2.color;
      }
      e4.showText && (this._textColor = f2 ? $t(f2) : void 0), this._color = e4.render || e4.template ? void 0 : l2.textColor && !f2 ? "transparent" : f2;
    }
    if (l2 && e4.showText && (d2 || e4.contentTemplate || e4.template)) {
      var y2 = l2.allDay || !n2 || h2 && !i && !a2;
      if (this._data = { end: !y2 && a2 && s2 ? et(e4.timeFormat, s2, e4) : "", id: l2.id, isMultiDay: h2, original: l2, start: !y2 && i && n2 ? et(e4.timeFormat, n2, e4) : "", title: this._title }, d2) {
        var b2 = d2(this._data);
        $(b2) ? o3 = b2 : this._content = b2;
      }
    } else
      o3 = e4.more || e4.count || e4.showText && (l2.title || l2.text) || "";
    o3 !== this._text && (this._text = o3, this._html = o3 ? this._safeHtml(o3) : void 0, this._shouldEnhance = o3 && l2 && e4.showText && !!d2), this._cssClass = "mbsc-calendar-text" + this._theme + this._rtl + (t3.hasFocus && !e4.inactive && !e4.selected || e4.selected && e4.showText ? " mbsc-calendar-label-active " : "") + (!t3.hasHover || e4.inactive || this._isDrag ? "" : " mbsc-calendar-label-hover") + (e4.more ? " mbsc-calendar-text-more" : e4.render || e4.template ? " mbsc-calendar-custom-label" : " mbsc-calendar-label") + (e4.inactive ? " mbsc-calendar-label-inactive" : "") + (e4.isUpdate ? " mbsc-calendar-label-dragging" : "") + (e4.hidden ? " mbsc-calendar-label-hidden" : "") + (i ? " mbsc-calendar-label-start" : "") + (r2 ? " mbsc-calendar-label-end" : "") + (l2 && false === l2.editable ? " mbsc-readonly-event" : "") + (l2 && l2.cssClass ? " " + l2.cssClass : "");
  }, t2;
}(wt), js = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    var t3 = e4.event && false !== e4.event.editable;
    return ls("div", { "aria-hidden": e4.showText ? void 0 : "true", className: this._cssClass, "data-id": e4.showText && e4.event ? e4.event.id : null, onClick: this._onClick, onContextMenu: this._onRightClick, ref: this._setEl, role: e4.showText ? "button" : void 0, style: { color: this._color }, tabIndex: this._tabIndex, title: this._title }, this._hasResizeStart && t3 && ls("div", { className: "mbsc-calendar-label-resize mbsc-calendar-label-resize-start" + this._rtl + (e4.isUpdate ? " mbsc-calendar-label-resize-start-touch" : "") }), this._hasResizeEnd && t3 && ls("div", { className: "mbsc-calendar-label-resize mbsc-calendar-label-resize-end" + this._rtl + (e4.isUpdate ? " mbsc-calendar-label-resize-end-touch" : "") }), e4.showText && !e4.more && !e4.render && ls("div", { className: "mbsc-calendar-label-background" + this._theme }), e4.showText && !e4.more && e4.render ? this._html ? ls("div", { dangerouslySetInnerHTML: this._html }) : this._content : ls("div", { className: "mbsc-calendar-label-inner" + this._theme, style: { color: this._textColor } }, ls("div", { "aria-hidden": "true", className: "mbsc-calendar-label-text" + this._theme, dangerouslySetInnerHTML: this._html, style: { color: e4.event && e4.event.textColor } }, this._content), e4.label && ls("div", { className: "mbsc-hidden-content" }, e4.label)));
  }, t2;
}(Gs), Js = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._renderEvent = function(e4, t3, n2, s2, i, a2) {
    return ls(js, { key: a2, amText: e4.amText, count: t3.count ? t3.count + " " + (t3.count > 1 ? e4.eventsText : e4.eventText) : void 0, date: e4.date, dataTimezone: e4.dataTimezone, displayTimezone: e4.displayTimezone, drag: e4.dragToMove, resize: e4.dragToResize, event: t3.event, exclusiveEndDates: e4.exclusiveEndDates, firstDay: e4.firstDay, hidden: s2, id: t3.id, inactive: !i && t3.event && e4.dragData && e4.dragData.draggedEvent && t3.event.id === e4.dragData.draggedEvent.id, isActiveMonth: e4.isActiveMonth, isPicker: e4.isPicker, isUpdate: i, label: t3.label, lastDay: t3.lastDay, more: t3.more, pmText: e4.pmText, resourcesMap: e4.resourcesMap, rtl: e4.rtl, selected: t3.event && e4.selectedEventsMap && (e4.selectedEventsMap[t3.id] || e4.selectedEventsMap[t3.event.id]), showEventTooltip: e4.showEventTooltip, showText: n2, theme: e4.theme, timeFormat: e4.timeFormat, timezonePlugin: e4.timezonePlugin, render: e4.renderLabel, renderContent: e4.renderLabelContent, onClick: this._onLabelClick, onDoubleClick: this._onLabelDoubleClick, onRightClick: this._onLabelRightClick, onHoverIn: this._onLabelHoverIn, onHoverOut: this._onLabelHoverOut, onDelete: e4.onLabelDelete, onDragStart: e4.onLabelUpdateStart, onDragMove: e4.onLabelUpdateMove, onDragEnd: e4.onLabelUpdateEnd, onDragModeOn: e4.onLabelUpdateModeOn, onDragModeOff: e4.onLabelUpdateModeOff });
  }, t2.prototype._renderLabel = function(e4, t3) {
    var n2 = t3.id;
    return t3.placeholder ? ls("div", { className: "mbsc-calendar-text mbsc-calendar-text-placeholder", key: n2 }) : t3.more || t3.count ? this._renderEvent(e4, t3, true, false, false, n2) : t3.multiDay ? [ls("div", { className: "mbsc-calendar-label-wrapper", style: { width: t3.width + "%" }, key: n2 }, this._renderEvent(e4, t3, true)), this._renderEvent(e4, t3, false, false, false, "-" + n2)] : this._renderEvent(e4, t3, t3.showText, false, false, n2);
  }, t2.prototype._template = function(e4) {
    var t3, n2 = this, s2 = this._draggedLabel, i = this._draggedLabelOrig, a2 = this._theme;
    return e4.renderDay && (t3 = e4.renderDay(this._data)), e4.renderDayContent && (t3 = e4.renderDayContent(this._data)), $(t3) && (t3 = ls("div", { dangerouslySetInnerHTML: this._safeHtml(t3) }), this._shouldEnhance = true), ls("div", { ref: this._setEl, className: this._cssClass, onClick: this._onClick, onContextMenu: this._onRightClick, style: this._cellStyles, tabIndex: e4.disabled ? void 0 : e4.active ? 0 : -1 }, ls("div", { className: "mbsc-calendar-cell-inner mbsc-calendar-" + e4.type + "-inner" + a2 + ("day" === e4.type ? "" : this._hb) + (e4.display ? "" : " mbsc-calendar-day-hidden") }, e4.renderDay ? t3 : ls(ds, null, 1 === e4.text && ls("div", { "aria-hidden": "true", className: "mbsc-calendar-month-name" + a2 + this._rtl }, e4.monthShort), ls("div", { "aria-label": this._ariaLabel, role: "button", "aria-pressed": e4.selected, className: "mbsc-calendar-cell-text mbsc-calendar-" + e4.type + "-text" + a2 + this._todayClass, style: this._circleStyles }, e4.text), e4.marks && ls("div", null, ls("div", { className: "mbsc-calendar-marks" + a2 + this._rtl }, e4.marks.map(function(e6, t4) {
      return ls("div", { className: "mbsc-calendar-mark " + (e6.markCssClass || "") + a2, key: t4, style: { background: e6.color } });
    }))), e4.renderDayContent && t3), e4.labels && ls("div", null, i && i.event && ls("div", { className: "mbsc-calendar-labels mbsc-calendar-labels-dragging" }, ls("div", { style: { width: i.width + "%" || "100%" } }, this._renderEvent(e4, { id: 0, event: i.event }, true, !!e4.dragData.draggedDates, true))), s2 && s2.event && ls("div", { className: "mbsc-calendar-labels mbsc-calendar-labels-dragging" }, ls("div", { className: "mbsc-calendar-label-wrapper", style: { width: s2.width + "%" || "100%" } }, this._renderEvent(e4, { id: 0, event: s2.event }, true, false, true))), ls("div", { className: "mbsc-calendar-labels" }, e4.labels.data.map(function(t4) {
      return n2._renderLabel(e4, t4);
    })), ls("div", { className: "mbsc-calendar-text mbsc-calendar-text-placeholder" }))));
  }, t2;
}(Ks), Zs = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3.state = { height: "sm", pageSize: 0, pickerSize: 0, width: "sm" }, t3._dim = {}, t3._months = [1, 2, 3], t3._title = [], t3.MONTH_VIEW = "month", t3.YEAR_VIEW = "year", t3.MULTI_YEAR_VIEW = "multi-year", t3.nextPage = function() {
      switch (t3._prevDocClick(), t3._view) {
        case "multi-year":
          t3._activeYearsChange(1);
          break;
        case "year":
          t3._activeYearChange(1);
          break;
        default:
          t3._activeChange(1);
      }
    }, t3.prevPage = function() {
      switch (t3._prevDocClick(), t3._view) {
        case "multi-year":
          t3._activeYearsChange(-1);
          break;
        case "year":
          t3._activeYearChange(-1);
          break;
        default:
          t3._activeChange(-1);
      }
    }, t3._changeView = function(e4) {
      var n2 = t3.s, s2 = t3._view, i = t3._hasPicker, a2 = n2.selectView, r2 = "year" === (n2.showCalendar ? n2.calendarType : n2.eventRange);
      if (!e4) {
        switch (s2) {
          case "month":
            e4 = "multi-year";
            break;
          case "multi-year":
            e4 = "year";
            break;
          default:
            e4 = i || "year" === a2 ? "multi-year" : "month";
        }
        "multi-year" === s2 && r2 && (e4 = "month");
      }
      var o3 = i && e4 === a2;
      t3.setState({ view: e4, viewClosing: o3 ? void 0 : s2, viewOpening: o3 ? void 0 : e4 });
    }, t3._onDayHoverIn = function(e4) {
      t3._disableHover || (t3._hook("onDayHoverIn", e4), t3._hoverTimer = setTimeout(function() {
        var n2 = Pe(e4.date);
        t3._labels && (e4.labels = t3._labels[n2]), t3._marked && (e4.marked = t3._marked[n2]), t3._isHover = true, t3._hook("onCellHoverIn", e4);
      }, 150));
    }, t3._onDayHoverOut = function(e4) {
      if (!t3._disableHover && (t3._hook("onDayHoverOut", e4), clearTimeout(t3._hoverTimer), t3._isHover)) {
        var n2 = Pe(e4.date);
        t3._labels && (e4.labels = t3._labels[n2]), t3._marked && (e4.marked = t3._marked[n2]), t3._isHover = false, t3._hook("onCellHoverOut", e4);
      }
    }, t3._onLabelClick = function(e4) {
      t3._isLabelClick = true, t3._hook("onLabelClick", e4);
    }, t3._onDayClick = function(e4) {
      t3._shouldFocus = !t3._isLabelClick, t3._prevAnim = false, t3._isLabelClick = false, t3._hook("onDayClick", e4);
    }, t3._onTodayClick = function(e4) {
      t3._prevAnim = false, t3._hook("onActiveChange", { date: +je(Je(t3.s)), today: true }), t3._hook("onTodayClick", {});
    }, t3._onMonthClick = function(e4) {
      if (!e4.disabled) {
        var n2 = e4.date, s2 = t3.s;
        if ("year" === s2.selectView)
          t3._hook("onDayClick", e4);
        else {
          var i = ht(n2, s2);
          t3._changeView("month"), t3._shouldFocus = true, t3._prevAnim = !t3._hasPicker, t3._hook("onActiveChange", { date: +n2, nav: true, pageChange: i !== t3._pageIndex });
        }
      }
    }, t3._onYearClick = function(e4) {
      if (!e4.disabled) {
        var n2 = e4.date, s2 = t3.s, i = s2.selectView;
        if ("multi-year" === i)
          t3._hook("onDayClick", e4);
        else if (t3._shouldFocus = true, t3._prevAnim = "year" === i, t3._activeMonth = +n2, t3._changeView(), "year" === (s2.showCalendar ? s2.calendarType : s2.eventRange)) {
          var a2 = ht(n2, s2);
          t3._hook("onActiveChange", { date: +n2, pageChange: a2 !== t3._pageIndex });
        }
      }
    }, t3._onPageChange = function(e4) {
      t3._isSwipeChange = true, t3._activeChange(e4.diff);
    }, t3._onYearPageChange = function(e4) {
      t3._activeYearChange(e4.diff);
    }, t3._onYearsPageChange = function(e4) {
      t3._activeYearsChange(e4.diff);
    }, t3._onAnimationEnd = function(e4) {
      t3._disableHover = false, t3._isIndexChange && (t3._pageLoaded(), t3._isIndexChange = false);
    }, t3._onStart = function() {
      clearTimeout(t3._hoverTimer);
    }, t3._onGestureStart = function(e4) {
      t3._disableHover = true, t3._hook("onGestureStart", e4);
    }, t3._onGestureEnd = function(e4) {
      t3._prevDocClick();
    }, t3._onPickerClose = function() {
      t3.setState({ view: "month" });
    }, t3._onPickerOpen = function() {
      var e4 = t3._pickerCont.clientHeight, n2 = t3._pickerCont.clientWidth;
      t3.setState({ pickerSize: t3._isVertical ? e4 : n2 });
    }, t3._onPickerBtnClick = function(e4) {
      "month" === t3._view && (t3._pickerBtn = e4.currentTarget), t3._prevDocClick(), t3._changeView();
    }, t3._onDocClick = function(e4) {
      var n2 = t3.s.selectView;
      t3._prevClick || t3._hasPicker || t3._view === n2 || !t3._pickerCont || t3._pickerCont.contains(e4.target) || t3._changeView(n2);
    }, t3._onViewAnimationEnd = function() {
      t3.state.viewClosing && t3.setState({ viewClosing: void 0 }), t3.state.viewOpening && t3.setState({ viewOpening: void 0 });
    }, t3._onResize = function() {
      if (t3._body && y$2) {
        var e4 = t3.s, n2 = t3.state, s2 = e4.showCalendar, i = s2 ? t3._body.querySelector(".mbsc-calendar-body-inner") : t3._body, a2 = t3._el.offsetWidth, r2 = t3._el.offsetHeight, o3 = i.clientHeight, l2 = i.clientWidth, c2 = t3._isVertical ? o3 : l2, d2 = t3._hasPicker ? n2.pickerSize : c2, h2 = void 0 !== s2, u2 = "sm", _2 = "sm", m2 = 1, p2 = false, v2 = 0, f2 = 0;
        if (e4.responsiveStyle && !t3._isGrid && (o3 > 300 && (_2 = "md"), l2 > 767 && (u2 = "md")), u2 !== n2.width || _2 !== n2.height)
          t3._shouldCheckSize = true, t3.setState({ width: u2, height: _2 });
        else {
          if (t3._labels && s2) {
            var g2 = i.querySelector(".mbsc-calendar-text"), b2 = i.querySelector(".mbsc-calendar-day-inner"), D2 = b2.querySelector(".mbsc-calendar-labels"), x2 = g2 ? qt(g2, "marginBottom") : 2, C2 = g2 ? g2.offsetHeight : 18;
            v2 = D2.offsetTop, p2 = i.scrollHeight > i.clientHeight, f2 = C2 + x2, m2 = Math.max(1, ce((b2.clientHeight - v2) / f2));
          }
          t3._hook("onResize", { height: r2, target: t3._el, width: a2 }), e4.navigationService.pageSize = c2, t3.setState({ cellTextHeight: v2, hasScrollY: p2, labelHeight: f2, maxLabels: m2, pageSize: c2, pickerSize: d2, ready: h2 });
        }
      }
    }, t3._onKeyDown = function(e4) {
      var n2, s2 = t3.s, i = t3._view, a2 = "month" === i ? t3._active : t3._activeMonth, r2 = new Date(a2), o3 = s2.getYear(r2), l2 = s2.getMonth(r2), c2 = s2.getDay(r2), d2 = s2.getDate, h2 = s2.weeks, u2 = "month" === s2.calendarType;
      if ("multi-year" === i) {
        var _2 = void 0;
        switch (e4.keyCode) {
          case 37:
            _2 = o3 - 1 * t3._rtlNr;
            break;
          case 39:
            _2 = o3 + 1 * t3._rtlNr;
            break;
          case 38:
            _2 = o3 - 3;
            break;
          case 40:
            _2 = o3 + 3;
            break;
          case 36:
            _2 = t3._getPageYears(t3._yearsIndex);
            break;
          case 35:
            _2 = t3._getPageYears(t3._yearsIndex) + 11;
            break;
          case 33:
            _2 = o3 - 12;
            break;
          case 34:
            _2 = o3 + 12;
        }
        _2 && t3._minYears <= _2 && t3._maxYears >= _2 && (e4.preventDefault(), t3._shouldFocus = true, t3._prevAnim = false, t3._activeMonth = +d2(_2, 0, 1), t3.forceUpdate());
      } else if ("year" === i) {
        switch (e4.keyCode) {
          case 37:
            n2 = d2(o3, l2 - 1 * t3._rtlNr, 1);
            break;
          case 39:
            n2 = d2(o3, l2 + 1 * t3._rtlNr, 1);
            break;
          case 38:
            n2 = d2(o3, l2 - 3, 1);
            break;
          case 40:
            n2 = d2(o3, l2 + 3, 1);
            break;
          case 36:
            n2 = d2(o3, 0, 1);
            break;
          case 35:
            n2 = d2(o3, 11, 1);
            break;
          case 33:
            n2 = d2(o3 - 1, l2, 1);
            break;
          case 34:
            n2 = d2(o3 + 1, l2, 1);
        }
        n2 && t3._minYear <= n2 && t3._maxYear >= n2 && (e4.preventDefault(), t3._shouldFocus = true, t3._prevAnim = false, t3._activeMonth = +n2, t3.forceUpdate());
      } else if ("month" === i) {
        switch (e4.keyCode) {
          case 37:
            n2 = d2(o3, l2, c2 - 1 * t3._rtlNr);
            break;
          case 39:
            n2 = d2(o3, l2, c2 + 1 * t3._rtlNr);
            break;
          case 38:
            n2 = d2(o3, l2, c2 - 7);
            break;
          case 40:
            n2 = d2(o3, l2, c2 + 7);
            break;
          case 36:
            n2 = d2(o3, l2, 1);
            break;
          case 35:
            n2 = d2(o3, l2 + 1, 0);
            break;
          case 33:
            n2 = e4.altKey ? d2(o3 - 1, l2, c2) : u2 ? d2(o3, l2 - 1, c2) : d2(o3, l2, c2 - 7 * h2);
            break;
          case 34:
            n2 = e4.altKey ? d2(o3 + 1, l2, c2) : u2 ? d2(o3, l2 + 1, c2) : d2(o3, l2, c2 + 7 * h2);
        }
        if (n2 && t3._minDate <= n2 && t3._maxDate >= n2) {
          e4.preventDefault();
          var m2 = ht(n2, s2);
          t3._shouldFocus = true, t3._prevAnim = false, t3._pageChange = s2.noOuterChange && m2 !== t3._pageIndex, t3._hook("onActiveChange", { date: +n2, pageChange: t3._pageChange });
        }
      }
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._getPageDay = function(e4) {
    return +dt(e4, this.s);
  }, t2.prototype._getPageStyle = function(e4, t3, n2) {
    var s2;
    return (s2 = {})[(Wt ? Wt + "T" : "t") + "ransform"] = "translate" + this._axis + "(" + 100 * (e4 - t3) * this._rtlNr + "%)", s2.width = 100 / (n2 || 1) + "%", s2;
  }, t2.prototype._getPageYear = function(e4) {
    var t3 = this.s, n2 = t3.refDate ? Ze(t3.refDate) : Te;
    return t3.getYear(n2) + e4;
  }, t2.prototype._getPageYears = function(e4) {
    var t3 = this.s, n2 = t3.refDate ? Ze(t3.refDate) : Te;
    return t3.getYear(n2) + 12 * e4;
  }, t2.prototype._getPickerClass = function(e4) {
    var t3, n2 = e4 === this.s.selectView ? " mbsc-calendar-picker-main" : "", s2 = "mbsc-calendar-picker", i = this._hasPicker, a2 = this.state, r2 = a2.viewClosing, o3 = a2.viewOpening;
    switch (e4) {
      case "month":
        t3 = i ? "" : ("month" === o3 ? "in-down" : "") + ("month" === r2 ? "out-down" : "");
        break;
      case "multi-year":
        t3 = i && "month" === r2 ? "" : ("multi-year" === o3 ? "in-up" : "") + ("multi-year" === r2 ? "out-up" : "");
        break;
      default:
        t3 = i && "month" === o3 ? "" : ("year" === o3 ? "multi-year" === r2 ? "in-down" : "in-up" : "") + ("year" === r2 ? "multi-year" === o3 ? "out-down" : "out-up" : "");
    }
    return s2 + n2 + (Vt && t3 ? " " + s2 + "-" + t3 : "");
  }, t2.prototype._isNextDisabled = function(e4) {
    if (!this._hasPicker || e4) {
      var t3 = this._view;
      if ("multi-year" === t3)
        return this._yearsIndex + 1 > this._maxYearsIndex;
      if ("year" === t3)
        return this._yearIndex + 1 > this._maxYearIndex;
    }
    return this._pageIndex + 1 > this._maxIndex;
  }, t2.prototype._isPrevDisabled = function(e4) {
    if (!this._hasPicker || e4) {
      var t3 = this._view;
      if ("multi-year" === t3)
        return this._yearsIndex - 1 < this._minYearsIndex;
      if ("year" === t3)
        return this._yearIndex - 1 < this._minYearIndex;
    }
    return this._pageIndex - 1 < this._minIndex;
  }, t2.prototype._render = function(e4, t3) {
    var n2 = e4.getDate, s2 = e4.getYear, i = e4.getMonth, a2 = e4.showCalendar, r2 = e4.calendarType, o3 = e4.eventRange, l2 = e4.eventRangeSize || 1, c2 = e4.firstDay, d2 = "week" === r2, h2 = "month" === r2, u2 = "year" === r2 ? 12 : e4.size || 1, _2 = u2 > 1 && !d2, m2 = a2 ? d2 ? e4.weeks : 6 : 0, p2 = e4.activeDate || this._active || +/* @__PURE__ */ new Date(), v2 = p2 !== this._active, f2 = new Date(p2), g2 = this._prevS, y2 = e4.dateFormat, b2 = e4.monthNames, D2 = e4.yearSuffix, x2 = J(e4.labelList) ? +e4.labelList + 1 : "all" === e4.labelList ? -1 : 0, C2 = e4.labelList !== g2.labelList, w2 = e4.navigationService, T2 = w2.pageIndex, k2 = w2.firstDay, S2 = w2.lastDay, E2 = w2.viewStart, M2 = w2.viewEnd;
    if (this._minDate = w2.minDate, this._maxDate = w2.maxDate, Q(e4.min))
      this._minIndex = -1 / 0, this._minYears = -1 / 0, this._minYearsIndex = -1 / 0, this._minYear = -1 / 0, this._minYearIndex = -1 / 0;
    else {
      var I2 = ze(this._minDate);
      this._minDate = ze(I2), this._minYear = n2(s2(I2), i(I2), 1), this._minYears = s2(I2), this._minIndex = ht(I2, e4), this._minYearIndex = _t(I2, e4), this._minYearsIndex = ut(I2, e4);
    }
    if (Q(e4.max))
      this._maxIndex = 1 / 0, this._maxYears = 1 / 0, this._maxYearsIndex = 1 / 0, this._maxYear = 1 / 0, this._maxYearIndex = 1 / 0;
    else {
      var N2 = this._maxDate;
      this._maxYear = n2(s2(N2), i(N2) + 1, 1), this._maxYears = s2(N2), this._maxIndex = ht(N2, e4), this._maxYearIndex = _t(N2, e4), this._maxYearsIndex = ut(N2, e4);
    }
    var L2 = r2 !== g2.calendarType || o3 !== g2.eventRange || c2 !== g2.firstDay || e4.eventRangeSize !== g2.eventRangeSize || e4.refDate !== g2.refDate || e4.showCalendar !== g2.showCalendar || e4.weeks !== g2.weeks;
    if (L2 && void 0 !== this._pageIndex && (this._prevAnim = true), v2 && (this._activeMonth = p2), this._view = t3.view || e4.selectView, this._yearsIndex = ut(new Date(this._activeMonth), e4), this._yearIndex = _t(new Date(this._activeMonth), e4), "year" === this._view)
      this._viewTitle = this._getPageYear(this._yearIndex) + "";
    else if ("multi-year" === this._view) {
      var H2 = this._getPageYears(this._yearsIndex);
      this._viewTitle = H2 + " - " + (H2 + 11);
    }
    var O2 = _2 ? 1 : pt(e4.pages, t3.pageSize), R2 = "vertical" === e4.calendarScroll && "auto" !== e4.pages && (void 0 === e4.pages || 1 === e4.pages), V2 = void 0 !== e4.showOuterDays ? e4.showOuterDays : !R2 && O2 < 2 && (d2 || !u2 || u2 < 2), P2 = y2.search(/m/i), z2 = y2.search(/y/i);
    if (_2 && (this._monthsMulti = [], void 0 !== T2)) {
      for (var Y2 = ce(0.96 * t3.pageSize / 325.6) || 1; u2 % Y2; )
        Y2--;
      for (var W2 = 0; W2 < u2 / Y2; ++W2) {
        for (var F2 = [], A2 = 0; A2 < Y2; ++A2)
          F2.push(+n2(s2(k2), i(k2) + W2 * Y2 + A2, 1));
        this._monthsMulti.push(F2);
      }
    }
    (r2 !== g2.calendarType || e4.theme !== g2.theme || e4.calendarScroll !== g2.calendarScroll || e4.hasContent !== g2.hasContent || e4.showCalendar !== g2.showCalendar || e4.showWeekNumbers !== g2.showWeekNumbers || e4.weeks !== g2.weeks || C2) && (this._shouldCheckSize = true), g2.width === e4.width && g2.height === e4.height || (this._dim = { height: ie(e4.height), width: ie(e4.width) }), this._cssClass = "mbsc-calendar mbsc-font" + this._theme + this._rtl + (t3.ready ? "" : " mbsc-hidden") + (_2 ? " mbsc-calendar-grid-view" : " mbsc-calendar-height-" + t3.height + " mbsc-calendar-width-" + t3.width) + " " + e4.cssClass, this._dayNames = "sm" === t3.width || _2 ? e4.dayNamesMin : e4.dayNamesShort, this._isSwipeChange = false, this._yearFirst = z2 < P2, this._pageNr = O2, this._variableRow = x2;
    var U2 = e4.pageLoad !== g2.pageLoad, B2 = +E2 != +this._viewStart || +M2 != +this._viewEnd;
    if (void 0 !== this._pageIndex && B2 && (this._isIndexChange = !this._isSwipeChange && !L2), void 0 !== T2 && (this._pageIndex = T2), void 0 !== T2 && (e4.marked !== g2.marked || e4.colors !== g2.colors || e4.labels !== g2.labels || e4.invalid !== g2.invalid || e4.valid !== g2.valid || t3.maxLabels !== this._maxLabels || B2 || C2 || U2)) {
      this._maxLabels = t3.maxLabels || 1, this._viewStart = E2, this._viewEnd = M2;
      var X2 = e4.labelsMap || Bn(e4.labels, E2, M2, e4), K2 = X2 && vt(e4, X2, E2, M2, this._variableRow || this._maxLabels, 7, false, c2, true, e4.eventOrder, !V2, e4.showLabelCount, e4.moreEventsText, e4.moreEventsPluralText);
      K2 && !this._labels && (this._shouldCheckSize = true), (K2 && t3.maxLabels || !K2) && (this._shouldPageLoad = !this._isIndexChange || this._prevAnim || !a2 || U2), this._labelsLayout = K2, this._labels = X2, this._marked = !X2 && (e4.marksMap || Bn(e4.marked, E2, M2, e4)), this._colors = Bn(e4.colors, E2, M2, e4), this._valid = Bn(e4.valid, E2, M2, e4, true), this._invalid = Bn(e4.invalid, E2, M2, e4, true);
    }
    if (B2 || v2 || o3 !== g2.eventRange || l2 !== g2.eventRangeSize || e4.monthNames !== g2.monthNames) {
      this._title = [];
      var q2 = it(S2, -1), G2 = void 0 === T2 ? f2 : k2;
      if (d2) {
        G2 = f2;
        for (var j2 = 0, Z2 = Object.keys(e4.selectedDates); j2 < Z2.length; j2++) {
          var $2 = Z2[j2];
          if (+$2 >= +k2 && +$2 < +S2) {
            G2 = /* @__PURE__ */ new Date(+$2);
            break;
          }
        }
      }
      if (this._pageNr > 1)
        for (W2 = 0; W2 < O2; W2++) {
          var ee2 = n2(s2(k2), i(k2) + W2, 1), te2 = s2(ee2) + D2, ne2 = b2[i(ee2)];
          this._title.push({ yearTitle: te2, monthTitle: ne2 });
        }
      else {
        var se2 = { yearTitle: s2(G2) + D2, monthTitle: b2[i(G2)] }, ae2 = e4.showSchedule && 1 === l2 ? o3 : a2 ? r2 : o3, re2 = o3 && !a2 && (!e4.showSchedule || l2 > 1);
        switch (ae2) {
          case "year":
            se2.title = s2(k2) + D2, l2 > 1 && (se2.title += " - " + (s2(q2) + D2));
            break;
          case "month":
            if (l2 > 1 && !a2) {
              var oe2 = b2[i(k2)], le2 = s2(k2) + D2, de2 = this._yearFirst ? le2 + " " + oe2 : oe2 + " " + le2, he2 = b2[i(q2)], ue2 = s2(q2) + D2, _e2 = this._yearFirst ? ue2 + " " + he2 : he2 + " " + ue2;
              se2.title = de2 + " - " + _e2;
            } else
              _2 && (se2.title = s2(k2) + D2);
            break;
          case "day":
          case "week":
            if (re2) {
              var me2 = y2.search(/d/i) < P2 ? "D MMM, YYYY" : "MMM D, YYYY";
              se2.title = et(me2, k2, e4), ("week" === ae2 || l2 > 1) && (se2.title += " - " + et(me2, q2, e4));
            }
        }
        this._title.push(se2);
      }
    }
    this._active = p2, this._hasPicker = e4.hasPicker || _2 || !h2 || !a2 || "md" === t3.width && false !== e4.hasPicker, this._axis = R2 ? "Y" : "X", this._rtlNr = !R2 && e4.rtl ? -1 : 1, this._weeks = m2, this._nextIcon = R2 ? e4.nextIconV : e4.rtl ? e4.prevIconH : e4.nextIconH, this._prevIcon = R2 ? e4.prevIconV : e4.rtl ? e4.nextIconH : e4.prevIconH, this._mousewheel = void 0 === e4.mousewheel ? R2 : e4.mousewheel, this._isGrid = _2, this._isVertical = R2, this._showOuter = V2;
  }, t2.prototype._mounted = function() {
    this._observer = pn(this._el, this._onResize, this._zone), this._doc = Kt(this._el), Bt(this._doc, dn, this._onDocClick);
  }, t2.prototype._updated = function() {
    var e4 = this;
    if (this._shouldCheckSize ? (setTimeout(function() {
      e4._onResize();
    }), this._shouldCheckSize = false) : this._shouldPageLoad && (this._pageLoaded(), this._shouldPageLoad = false), this._shouldFocus && setTimeout(function() {
      e4._focusActive(), e4._shouldFocus = false;
    }), this.s.instanceService && this.s.instanceService.onComponentChange.next({}), this._pageChange = false, this._variableRow && this._body.firstChild) {
      var t3 = this._body.firstChild, n2 = t3.scrollHeight > t3.clientHeight;
      n2 !== this.state.hasScrollY && (this._shouldCheckSize = true, this.setState({ hasScrollY: n2 }));
    }
  }, t2.prototype._destroy = function() {
    this._observer && this._observer.detach(), Xt(this._doc, dn, this._onDocClick), clearTimeout(this._hoverTimer);
  }, t2.prototype._getActiveCell = function() {
    var e4 = this._view, t3 = "month" === e4 ? this._body : this._pickerCont, n2 = "multi-year" === e4 ? "year" : "year" === e4 ? "month" : "cell";
    return t3 && t3.querySelector(".mbsc-calendar-" + n2 + '[tabindex="0"]');
  }, t2.prototype._focusActive = function() {
    var e4 = this._getActiveCell();
    e4 && e4.focus();
  }, t2.prototype._pageLoaded = function() {
    var e4 = this.s.navigationService;
    this._hook("onPageLoaded", { activeElm: this._getActiveCell(), firstDay: e4.firstPageDay, lastDay: e4.lastPageDay, month: "month" === this.s.calendarType ? e4.firstDay : void 0, viewEnd: e4.viewEnd, viewStart: e4.viewStart });
  }, t2.prototype._activeChange = function(e4) {
    var t3 = this._pageIndex + e4;
    this._minIndex <= t3 && this._maxIndex >= t3 && (this._prevAnim = false, this._pageChange = true, this._hook("onActiveChange", { date: this._getPageDay(t3), dir: e4, pageChange: true }));
  }, t2.prototype._activeYearsChange = function(e4) {
    var t3 = this._yearsIndex + e4;
    if (this._minYearsIndex <= t3 && this._maxYearsIndex >= t3) {
      var n2 = this._getPageYears(t3);
      this._prevAnim = false, this._activeMonth = +this.s.getDate(n2, 0, 1), this.forceUpdate();
    }
  }, t2.prototype._activeYearChange = function(e4) {
    var t3 = this._yearIndex + e4;
    if (this._minYearIndex <= t3 && this._maxYearIndex >= t3) {
      var n2 = this._getPageYear(t3);
      this._prevAnim = false, this._activeMonth = +this.s.getDate(n2, 0, 1), this.forceUpdate();
    }
  }, t2.prototype._prevDocClick = function() {
    var e4 = this;
    this._prevClick = true, setTimeout(function() {
      e4._prevClick = false;
    });
  }, t2;
}(wt), $s = function(e3) {
  var t2 = e3.firstDay, n2 = e3.hidden, s2 = e3.rtl, i = e3.theme, a2 = e3.dayNamesShort, r2 = e3.showWeekNumbers, o3 = e3.hasScroll;
  return ls("div", { "aria-hidden": "true", className: "mbsc-calendar-week-days mbsc-flex" + (n2 ? " mbsc-hidden" : "") }, r2 && ls("div", { className: "mbsc-calendar-week-day mbsc-flex-none mbsc-calendar-week-nr" + i + s2 }), q$5.map(function(e4, n3) {
    return ls("div", { className: "mbsc-calendar-week-day mbsc-flex-1-0-0" + i + s2, key: n3 }, a2[(n3 + t2) % 7]);
  }), o3 && ls("div", { className: "mbsc-schedule-fake-scroll-y" }));
}, Qs = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    var t3 = this, n2 = e4.showWeekNumbers, s2 = e4.showWeekDays ? ls($s, { dayNamesShort: e4.dayNamesShort, firstDay: e4.firstDay, rtl: this._rtl, showWeekNumbers: n2, theme: this._theme }) : null;
    return ls("div", { "aria-hidden": e4.isActive ? void 0 : "true", className: "mbsc-calendar-table mbsc-flex-col mbsc-flex-1-1" + (e4.isActive ? " mbsc-calendar-table-active" : "") }, s2, this._rows.map(function(s3, i) {
      var a2 = n2 ? t3._getWeekNr(e4, s3[0].date) : "";
      return ls("div", { className: "mbsc-calendar-row mbsc-flex mbsc-flex-1-0", key: i, style: { minHeight: t3._rowHeights[i] } }, n2 && ls("div", { className: "mbsc-calendar-cell mbsc-flex-none mbsc-calendar-day mbsc-calendar-week-nr" + t3._theme }, ls("div", { "aria-hidden": "true" }, a2), ls("div", { className: "mbsc-hidden-content" }, e4.weekText.replace("{count}", a2))), s3.map(function(n3, s4) {
        return ls(Js, { active: n3.display && t3._isActive(n3.date), amText: e4.amText, clickToCreate: e4.clickToCreate, colors: n3.colors, date: n3.date, day: n3.day, disabled: t3._isInvalid(n3.date), display: n3.display, dataTimezone: e4.dataTimezone, displayTimezone: e4.displayTimezone, dragData: e4.dragData, dragToCreate: e4.dragToCreate, dragToResize: e4.dragToResize, dragToMove: e4.dragToMove, eventText: e4.eventText, eventsText: e4.eventsText, exclusiveEndDates: e4.exclusiveEndDates, firstDay: e4.firstDay, hasMarks: e4.hasMarks, hoverEnd: e4.hoverEnd, hoverStart: e4.hoverStart, isActiveMonth: e4.isActive, isPicker: e4.isPicker, key: n3.date, labels: n3.labels, pmText: e4.pmText, marks: n3.marks, month: n3.month, monthShort: n3.monthShort, onDayClick: e4.onDayClick, onDayDoubleClick: e4.onDayDoubleClick, onDayRightClick: e4.onDayRightClick, onLabelClick: e4.onLabelClick, onLabelDoubleClick: e4.onLabelDoubleClick, onLabelRightClick: e4.onLabelRightClick, onLabelHoverIn: e4.onLabelHoverIn, onLabelHoverOut: e4.onLabelHoverOut, onLabelDelete: e4.onLabelDelete, onLabelUpdateStart: e4.onLabelUpdateStart, onLabelUpdateMove: e4.onLabelUpdateMove, onLabelUpdateEnd: e4.onLabelUpdateEnd, onLabelUpdateModeOn: e4.onLabelUpdateModeOn, onLabelUpdateModeOff: e4.onLabelUpdateModeOff, outer: n3.outer, renderDay: e4.renderDay, renderDayContent: e4.renderDayContent, renderLabel: e4.renderLabel, renderLabelContent: e4.renderLabelContent, rangeEnd: e4.rangeEnd, rangeStart: e4.rangeStart, resourcesMap: e4.resourcesMap, selectedEventsMap: e4.selectedEventsMap, rtl: e4.rtl, showEventTooltip: e4.showEventTooltip, selected: t3._isSelected(n3.date), text: n3.text, theme: e4.theme, timeFormat: e4.timeFormat, timezonePlugin: e4.timezonePlugin, todayText: e4.todayText, type: "day", year: n3.year, onHoverIn: e4.onDayHoverIn, onHoverOut: e4.onDayHoverOut });
      }));
    }));
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._isActive = function(e4) {
    return this.s.isActive && e4 === this.s.activeDate;
  }, t2.prototype._isInvalid = function(e4) {
    var t3 = this.s;
    return Xn(t3, Ge(t3, new Date(e4)), t3.invalid, t3.valid, +t3.min, +t3.max);
  }, t2.prototype._isSelected = function(e4) {
    var t3 = new Date(e4), n2 = Ge(this.s, t3);
    return !!this.s.selectedDates[+n2];
  }, t2.prototype._getWeekNr = function(e4, t3) {
    var n2 = new Date(t3);
    return "" + e4.getWeekNumber(e4.getDate(n2.getFullYear(), n2.getMonth(), n2.getDate() + (7 - e4.firstDay + 1) % 7));
  }, t2.prototype._render = function(e4) {
    var t3 = e4.weeks, n2 = e4.firstDay, s2 = new Date(e4.firstPageDay), i = e4.getYear(s2), a2 = e4.getMonth(s2), r2 = e4.getDay(s2), o3 = e4.getDate(i, a2, r2).getDay(), l2 = n2 - o3 > 0 ? 7 : 0, c2 = [], d2 = 0;
    this._rowHeights = [], this._rows = [], this._days = Array.apply(0, Array(7));
    for (var h2 = 0; h2 < 7 * t3; h2++) {
      var u2 = e4.getDate(i, a2, h2 + n2 - l2 - o3 + r2), _2 = Pe(u2), m2 = e4.getMonth(u2), p2 = m2 !== a2 && "week" !== e4.calendarType, v2 = e4.marked && e4.marked[_2], f2 = v2 ? e4.showSingleMark ? [{}] : v2 : null, g2 = e4.labels && e4.labels[_2], y2 = g2 ? g2.data.length : 0, b2 = h2 % 7 == 0;
      if (e4.variableRow) {
        if (b2 && p2 && h2)
          break;
        y2 > d2 && (d2 = y2), h2 % 7 == 6 && (this._rowHeights.push(d2 * (e4.labelHeight || 20) + (e4.cellTextHeight || 0) + 3), d2 = 0);
      }
      b2 && (c2 = [], this._rows.push(c2)), c2.push({ colors: e4.colors && e4.colors[_2], date: +u2, day: e4.dayNames[u2.getDay()], display: !p2 || e4.showOuter, labels: g2, marks: f2, month: e4.monthNames[m2], monthShort: e4.monthNamesShort[m2], outer: p2, text: e4.getDay(u2), year: e4.getYear(u2) });
    }
  }, t2;
}(wt)), ei = 0, ti = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._setHeader = function(e4) {
      t3._headerElement = e4;
    }, t3._setBody = function(e4) {
      t3._body = e4;
    }, t3._setPickerCont = function(e4) {
      t3._pickerCont = e4;
    }, t3._renderMonthView = function(e4, n2) {
      var s2 = t3.s, i = t3.state;
      return ls(Qs, d$2({}, n2, { activeDate: t3._active, amText: s2.amText, calendarType: s2.calendarType, cellTextHeight: i.cellTextHeight, clickToCreate: s2.clickToCreate, colors: t3._colors, dayNames: s2.dayNames, dayNamesShort: t3._dayNames, dataTimezone: s2.dataTimezone, displayTimezone: s2.displayTimezone, eventText: s2.eventText, eventsText: s2.eventsText, exclusiveEndDates: s2.exclusiveEndDates, firstDay: s2.firstDay, firstPageDay: e4, getDate: s2.getDate, getDay: s2.getDay, getMonth: s2.getMonth, getWeekNumber: s2.getWeekNumber, getYear: s2.getYear, hasMarks: !!t3._marked, hoverEnd: s2.hoverEnd, hoverStart: s2.hoverStart, isPicker: s2.isPicker, invalid: t3._invalid, labels: t3._labelsLayout, labelHeight: i.labelHeight, marked: t3._marked, max: t3._maxDate, min: t3._minDate, monthNames: s2.monthNames, monthNamesShort: s2.monthNamesShort, onDayClick: t3._onDayClick, onDayDoubleClick: s2.onDayDoubleClick, onDayRightClick: s2.onDayRightClick, onDayHoverIn: t3._onDayHoverIn, onDayHoverOut: t3._onDayHoverOut, onLabelClick: t3._onLabelClick, onLabelDoubleClick: s2.onLabelDoubleClick, onLabelRightClick: s2.onLabelRightClick, onLabelHoverIn: s2.onLabelHoverIn, onLabelHoverOut: s2.onLabelHoverOut, onLabelDelete: s2.onLabelDelete, pmText: s2.pmText, rangeEnd: s2.rangeEnd, rangeStart: s2.rangeStart, resourcesMap: s2.resourcesMap, rtl: s2.rtl, selectedDates: s2.selectedDates, selectedEventsMap: s2.selectedEventsMap, showEventTooltip: s2.showEventTooltip, showOuter: t3._showOuter, showWeekDays: !t3._isVertical && !t3._variableRow, showWeekNumbers: s2.showWeekNumbers, showSingleMark: !!s2.marksMap, todayText: s2.todayText, theme: s2.theme, timeFormat: s2.timeFormat, timezonePlugin: s2.timezonePlugin, valid: t3._valid, weeks: t3._weeks, weekText: s2.weekText, renderDay: s2.renderDay, renderDayContent: s2.renderDayContent, renderLabel: s2.renderLabel, renderLabelContent: s2.renderLabelContent, variableRow: t3._variableRow }));
    }, t3._renderMonth = function(e4, n2) {
      var s2 = t3.s, i = e4.key, a2 = i >= t3._pageIndex && i < t3._pageIndex + t3._pageNr && "month" === t3._view, r2 = { dragData: s2.dragData, dragToCreate: s2.dragToCreate, dragToMove: s2.dragToMove, dragToResize: s2.dragToResize, isActive: a2, onLabelUpdateEnd: s2.onLabelUpdateEnd, onLabelUpdateModeOff: s2.onLabelUpdateModeOff, onLabelUpdateModeOn: s2.onLabelUpdateModeOn, onLabelUpdateMove: s2.onLabelUpdateMove, onLabelUpdateStart: s2.onLabelUpdateStart };
      return ls("div", { className: "mbsc-calendar-slide" + (a2 ? " mbsc-calendar-slide-active" : "") + t3._theme + t3._rtl, key: i, style: t3._getPageStyle(i, n2, t3._pageNr) }, t3._renderMonthView(t3._getPageDay(i), r2));
    }, t3._renderYears = function(e4, n2) {
      var s2 = t3.s, i = e4.key, a2 = t3._getPageYears(i), r2 = s2.getYear(new Date(t3._active)), o3 = s2.getYear(new Date(t3._activeMonth));
      return ls("div", { "aria-hidden": t3._yearsIndex === i ? void 0 : "true", className: "mbsc-calendar-picker-slide mbsc-calendar-slide" + t3._theme + t3._rtl, key: i, style: t3._getPageStyle(i, n2) }, ls("div", { className: "mbsc-calendar-table mbsc-flex-col" }, K.map(function(e6, n3) {
        return ls("div", { className: "mbsc-calendar-row mbsc-flex mbsc-flex-1-0", key: n3 }, X.map(function(e7, i2) {
          var l2 = a2 + 3 * n3 + i2, c2 = +s2.getDate(l2, 0, 1);
          return ls(Js, { active: l2 === o3, date: c2, display: true, selected: l2 === r2, disabled: l2 < t3._minYears || l2 > t3._maxYears, rtl: s2.rtl, text: l2 + s2.yearSuffix, theme: s2.theme, type: "year", onDayClick: t3._onYearClick, key: l2 });
        }));
      })));
    }, t3._renderYear = function(e4, n2) {
      var s2 = t3.s, i = e4.key, a2 = t3._getPageYear(i), r2 = new Date(t3._activeMonth), o3 = s2.getYear(r2), l2 = s2.getMonth(r2), c2 = new Date(t3._active), d2 = s2.getYear(c2), h2 = s2.getMonth(c2);
      return ls("div", { "aria-hidden": t3._yearIndex === i ? void 0 : "true", className: "mbsc-calendar-picker-slide mbsc-calendar-slide" + t3._theme + t3._rtl, key: i, style: t3._getPageStyle(i, n2) }, ls("div", { className: "mbsc-calendar-table mbsc-flex-col" }, K.map(function(e6, n3) {
        return ls("div", { className: "mbsc-calendar-row mbsc-flex mbsc-flex-1-0", key: n3 }, X.map(function(e7, i2) {
          var r3 = s2.getDate(a2, 3 * n3 + i2, 1), c3 = s2.getYear(r3), u2 = s2.getMonth(r3);
          return ls(Js, { active: c3 === o3 && u2 === l2, date: +r3, display: true, selected: c3 === d2 && u2 === h2, disabled: r3 < t3._minYear || r3 >= t3._maxYear, month: s2.monthNames[u2], rtl: s2.rtl, text: s2.monthNamesShort[u2], theme: s2.theme, type: "month", onDayClick: t3._onMonthClick, key: +r3 });
        }));
      })));
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4, t3) {
    var n2 = this;
    ei++;
    var s2 = this._variableRow, i = "month" !== this._view, a2 = (this._isVertical || s2 && 1 == +e4.size) && e4.showCalendar ? ls($s, { dayNamesShort: this._dayNames, rtl: this._rtl, theme: this._theme, firstDay: e4.firstDay, hasScroll: t3.hasScrollY, hidden: "month" !== this._view && !this._hasPicker, showWeekNumbers: e4.showWeekNumbers }) : null, r2 = { axis: this._axis, batchSize: 1, changeOnEnd: true, className: "mbsc-calendar-scroll-wrapper" + this._theme, data: ei, easing: "ease-out", itemSize: t3.pickerSize, items: this._months, mousewheel: this._mousewheel, prevAnim: this._prevAnim, rtl: e4.rtl, snap: true, time: 200 }, o3 = ls("div", { ref: this._setPickerCont, className: this._hasPicker ? "mbsc-calendar-picker-wrapper" : "" }, ("multi-year" === t3.view || "multi-year" === t3.viewClosing || "multi-year" === e4.selectView) && ls("div", { onAnimationEnd: this._onViewAnimationEnd, className: this._getPickerClass("multi-year") }, ls(Xs, d$2({ key: "years", itemRenderer: this._renderYears, maxIndex: this._maxYearsIndex, minIndex: this._minYearsIndex, onGestureEnd: this._onGestureEnd, onIndexChange: this._onYearsPageChange, selectedIndex: this._yearsIndex }, r2))), ("year" === t3.view || "year" === t3.viewClosing || "year" === e4.selectView) && ls("div", { onAnimationEnd: this._onViewAnimationEnd, className: this._getPickerClass("year") }, ls(Xs, d$2({ key: "year", itemRenderer: this._renderYear, maxIndex: this._maxYearIndex, minIndex: this._minYearIndex, onGestureEnd: this._onGestureEnd, onIndexChange: this._onYearPageChange, selectedIndex: this._yearIndex }, r2))));
    return ls("div", { className: this._cssClass, ref: this._setEl, style: this._dim, onClick: ae }, ls("div", { className: "mbsc-calendar-wrapper mbsc-flex-col mbsc-flex-1-1" + this._theme + this._hb + (e4.hasContent || !e4.showCalendar ? " mbsc-calendar-wrapper-fixed" : "") }, ls("div", { className: "mbsc-calendar-header" + this._theme + this._hb + (this._isVertical || s2 ? " mbsc-calendar-header-vertical" : ""), ref: this._setHeader }, e4.showControls && function() {
      var t4, s3;
      if (e4.renderHeader)
        $(t4 = e4.renderHeader()) && (t4 !== n2._headerHTML && (n2._headerHTML = t4, n2._shouldEnhanceHeader = true), s3 = n2._safeHtml(t4));
      else {
        var i2 = n2._pageNr > 1;
        t4 = ls(ds, null, ls(Us, { className: "mbsc-calendar-title-wrapper" + (i2 ? " mbsc-calendar-title-wrapper-multi" : "") }), ls(Ws, { className: "mbsc-calendar-button-prev" + (i2 ? " mbsc-calendar-button-prev-multi" : "") }), e4.showToday && ls(As, { className: "mbsc-calendar-header-today" }), ls(Fs, { className: "mbsc-calendar-button-next" + (i2 ? " mbsc-calendar-button-next-multi" : "") }));
      }
      var a3 = ls("div", { className: "mbsc-calendar-controls" + n2._theme, dangerouslySetInnerHTML: s3 }, t4);
      return ls(Os.Provider, { children: a3, value: { instance: n2 } });
    }(), a2), ls("div", { className: "mbsc-calendar-body mbsc-flex-col mbsc-flex-1-1" + this._theme, ref: this._setBody, onKeyDown: this._onKeyDown }, e4.showCalendar && ls("div", { className: "mbsc-calendar-body-inner mbsc-flex-col mbsc-flex-1-1" + (s2 ? " mbsc-calendar-body-inner-variable" : "") }, this._isGrid ? ls("div", { "aria-hidden": i ? "true" : void 0, className: "mbsc-calendar-grid mbsc-flex-1-1 mbsc-flex-col" + this._theme + this._hb }, this._monthsMulti.map(function(t4, s3) {
      return ls("div", { key: s3, className: "mbsc-calendar-grid-row mbsc-flex mbsc-flex-1-1" }, t4.map(function(t5, s4) {
        return ls("div", { key: s4, className: "mbsc-calendar-grid-item mbsc-flex-col mbsc-flex-1-1" + n2._theme }, ls("div", { className: "mbsc-calendar-month-title" + n2._theme }, e4.monthNames[new Date(t5).getMonth()]), n2._renderMonthView(t5, { isActive: true }));
      }));
    })) : s2 ? ls("div", { "aria-hidden": i ? "true" : void 0, className: "mbsc-calendar-slide mbsc-calendar-slide-active " + this._getPickerClass("month") }, this._renderMonthView(+e4.navigationService.firstDay, { dragData: e4.dragData, dragToCreate: e4.dragToCreate, dragToMove: e4.dragToMove, dragToResize: e4.dragToResize, isActive: true, onLabelUpdateEnd: e4.onLabelUpdateEnd, onLabelUpdateModeOff: e4.onLabelUpdateModeOff, onLabelUpdateModeOn: e4.onLabelUpdateModeOn, onLabelUpdateMove: e4.onLabelUpdateMove, onLabelUpdateStart: e4.onLabelUpdateStart })) : "month" === e4.selectView && ls("div", { "aria-hidden": i ? "true" : void 0, className: this._getPickerClass("month"), onAnimationEnd: this._onViewAnimationEnd }, ls(Xs, d$2({}, r2, { itemNr: this._pageNr, itemSize: t3.pageSize / this._pageNr, itemRenderer: this._renderMonth, maxIndex: this._maxIndex, minIndex: this._minIndex, mouseSwipe: e4.mouseSwipe, onAnimationEnd: this._onAnimationEnd, onGestureStart: this._onGestureStart, onIndexChange: this._onPageChange, onStart: this._onStart, selectedIndex: this._pageIndex, swipe: e4.swipe }))), !this._hasPicker && o3))), this.props.children, this._hasPicker && ls(Ls, { anchor: this._pickerBtn, closeOnScroll: true, contentPadding: false, context: e4.context, cssClass: "mbsc-calendar-popup", display: "anchored", isOpen: "month" !== this._view, locale: e4.locale, onClose: this._onPickerClose, onOpen: this._onPickerOpen, rtl: e4.rtl, scrollLock: false, showOverlay: false, theme: e4.theme, themeVariant: e4.themeVariant }, ls("div", { onKeyDown: this._onKeyDown }, ls("div", { className: "mbsc-calendar-controls" + this._theme }, ls("div", { "aria-live": "polite", className: "mbsc-calendar-picker-button-wrapper mbsc-calendar-title-wrapper" + this._theme }, ls(Is, { className: "mbsc-calendar-button", onClick: this._onPickerBtnClick, theme: e4.theme, themeVariant: e4.themeVariant, type: "button", variant: "flat" }, this._viewTitle, e4.downIcon && ls(us, { svg: "multi-year" === t3.view ? e4.downIcon : e4.upIcon, theme: e4.theme }))), ls(Is, { className: "mbsc-calendar-button", ariaLabel: e4.prevPageText, disabled: this._isPrevDisabled(true), iconSvg: this._prevIcon, onClick: this.prevPage, theme: e4.theme, themeVariant: e4.themeVariant, type: "button", variant: "flat" }), ls(Is, { className: "mbsc-calendar-button", ariaLabel: e4.nextPageText, disabled: this._isNextDisabled(true), iconSvg: this._nextIcon, onClick: this.nextPage, theme: e4.theme, themeVariant: e4.themeVariant, type: "button", variant: "flat" })), o3)));
  }, t2.prototype._updated = function() {
    e3.prototype._updated.call(this), this._shouldEnhanceHeader && (cs(this._headerElement, { view: this }), this._shouldEnhanceHeader = false);
  }, t2;
}(Zs), ni = /* @__PURE__ */ function() {
  function e3() {
    this.onInstanceReady = new v$3(), this.onComponentChange = new v$3();
  }
  return Object.defineProperty(e3.prototype, "instance", { get: function() {
    return this.inst;
  }, set: function(e4) {
    this.inst = e4, this.onInstanceReady.next(e4);
  }, enumerable: true, configurable: true }), e3;
}(), si = /* @__PURE__ */ function() {
  function e3() {
    this.pageSize = 0, this._prevS = {}, this._s = {};
  }
  return e3.prototype.options = function(e4, t2) {
    var n2 = this._s = d$2({}, this._s, e4), s2 = this._prevS, i = n2.getDate, a2 = n2.getYear, r2 = n2.getMonth, o3 = n2.showCalendar, l2 = n2.calendarType, c2 = "week" === l2, h2 = o3 ? c2 ? n2.weeks : 6 : 0, u2 = n2.min === s2.min && this.minDate ? this.minDate : Q(n2.min) ? -1 / 0 : Ze(n2.min), _2 = n2.max === s2.max && this.maxDate ? this.maxDate : Q(n2.max) ? 1 / 0 : Ze(n2.max), m2 = G(n2.activeDate || +/* @__PURE__ */ new Date(), +u2, +_2), p2 = new Date(m2), v2 = m2 !== s2.activeDate, f2 = n2.calendarType !== s2.calendarType || n2.eventRange !== s2.eventRange || n2.firstDay !== s2.firstDay || n2.eventRangeSize !== s2.eventRangeSize || n2.refDate !== s2.refDate || o3 !== s2.showCalendar || n2.size !== s2.size || n2.weeks !== s2.weeks, g2 = this.forcePageChange || void 0 === this.pageIndex || f2 || !this.preventPageChange && v2 && (m2 < +this.firstDay || m2 >= +this.lastDay) ? ht(p2, n2) : this.pageIndex, y2 = "year" === l2 ? 12 : n2.size || 1, b2 = y2 > 1 && !c2, D2 = b2 ? 1 : pt(n2.pages, this.pageSize), x2 = "vertical" === n2.calendarScroll && "auto" !== n2.pages && (void 0 === n2.pages || 1 === n2.pages), C2 = void 0 !== n2.showOuterDays ? n2.showOuterDays : !x2 && D2 < 2 && (c2 || !y2 || y2 < 2), w2 = b2 ? 0 : 1, T2 = dt(g2, n2), k2 = dt(g2 + D2, n2);
    o3 || "week" !== n2.eventRange || void 0 === n2.startDay || void 0 === n2.endDay || (T2 = it(T2, n2.startDay - n2.firstDay + (n2.startDay < n2.firstDay ? 7 : 0)), k2 = it(T2, 7 * n2.eventRangeSize + n2.endDay - n2.startDay + 1 - (n2.endDay < n2.startDay ? 0 : 7)));
    var S2 = o3 && C2 ? Ae(T2, n2) : T2, E2 = b2 ? i(a2(k2), r2(k2) - 1, 1) : dt(g2 + D2 - 1, n2), M2 = o3 && C2 ? it(Ae(E2, n2), 7 * h2) : k2, I2 = o3 ? Ae(dt(g2 - w2, n2), n2) : T2, N2 = o3 ? Ae(dt(g2 + D2 + w2 - 1, n2), n2) : k2, L2 = o3 ? it(b2 ? Ae(E2, n2) : N2, 7 * h2) : k2, H2 = void 0 === this.pageIndex, O2 = false;
    void 0 !== g2 && (O2 = +I2 != +this.viewStart || +L2 != +this.viewEnd, this.pageIndex = g2), this.firstDay = T2, this.lastDay = k2, this.firstPageDay = S2, this.lastPageDay = M2, this.viewStart = I2, this.viewEnd = L2, this.forcePageChange = false, this.preventPageChange = false, this.minDate = u2, this.maxDate = _2, this._prevS = n2, void 0 !== g2 && (O2 || t2) && (O2 && !H2 && this.pageChange(), this.pageLoading(O2));
  }, e3.prototype.pageChange = function() {
    this._s.onPageChange && this._s.onPageChange({ firstDay: this.firstPageDay, lastDay: this.lastPageDay, month: "month" === this._s.calendarType ? this.firstDay : void 0, type: "onPageChange", viewEnd: this.viewEnd, viewStart: this.viewStart }, null);
  }, e3.prototype.pageLoading = function(e4) {
    this._s.onPageLoading && this._s.onPageLoading({ firstDay: this.firstPageDay, lastDay: this.lastPageDay, month: "month" === this._s.calendarType ? this.firstDay : void 0, type: "onPageLoading", viewChanged: e4, viewEnd: this.viewEnd, viewStart: this.viewStart }, null);
  }, e3;
}(), ii = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._instanceService = new ni(), t3._setCal = function(e4) {
      t3._calendarView = e4;
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    return ls(ti, { ref: this._setCal, refDate: e4.refDate, activeDate: e4.active, amText: e4.amText, cssClass: this._className + " mbsc-flex-1-1 mbsc-calendar-" + e4.display, calendarScroll: e4.calendarScroll, calendarType: e4.calendarType, colors: e4.colors, context: e4.context, dataTimezone: e4.dataTimezone, displayTimezone: e4.displayTimezone, timezonePlugin: e4.timezonePlugin, downIcon: e4.downIcon, exclusiveEndDates: e4.exclusiveEndDates, hoverEnd: e4.hoverEnd, hoverStart: e4.hoverStart, invalid: e4.invalid, instanceService: this._instanceService, isPicker: true, labels: e4.labels, marked: e4.marked, max: e4.max, min: e4.min, mousewheel: e4.mousewheel, navigationService: this._navService, nextIconH: e4.nextIconH, nextIconV: e4.nextIconV, nextPageText: e4.nextPageText, noOuterChange: e4.selectRange, onActiveChange: this._onActiveChange, onCellHoverIn: e4.onCellHoverIn, onCellHoverOut: e4.onCellHoverOut, onDayClick: this._onDayClick, onDayHoverIn: e4.onDayHoverIn, onDayHoverOut: e4.onDayHoverOut, onLabelClick: e4.onLabelClick, onPageChange: e4.onPageChange, onPageLoaded: e4.onPageLoaded, onPageLoading: e4.onPageLoading, onTodayClick: this._onTodayClick, pages: e4.pages, pmText: e4.pmText, prevIconH: e4.prevIconH, prevIconV: e4.prevIconV, prevPageText: e4.prevPageText, renderDay: e4.renderDay, renderDayContent: e4.renderDayContent, renderHeader: e4.renderCalendarHeader, rangeEnd: e4.rangeEnd, rangeStart: e4.rangeStart, rtl: e4.rtl, selectedDates: this._tempValueRep, selectView: e4.selectView, showCalendar: true, showControls: e4.showControls, showOuterDays: e4.showOuterDays, showToday: false, showWeekNumbers: e4.showWeekNumbers, size: e4.size, theme: e4.theme, themeVariant: e4.themeVariant, upIcon: e4.upIcon, valid: e4.valid, weeks: e4.weeks, width: e4.width, getDate: e4.getDate, getDay: e4.getDay, getMaxDayOfMonth: e4.getMaxDayOfMonth, getMonth: e4.getMonth, getWeekNumber: e4.getWeekNumber, getYear: e4.getYear, dateFormat: e4.dateFormat, dayNames: e4.dayNames, dayNamesMin: e4.dayNamesMin, dayNamesShort: e4.dayNamesShort, eventText: e4.eventText, eventsText: e4.eventsText, firstDay: e4.firstDay, fromText: e4.fromText, monthNames: e4.monthNames, monthNamesShort: e4.monthNamesShort, moreEventsPluralText: e4.moreEventsPluralText, moreEventsText: e4.moreEventsText, todayText: e4.todayText, toText: e4.toText, weekText: e4.weekText, yearSuffix: e4.yearSuffix });
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._navService = new si(), t3._onDayClick = function(e4) {
      var n2 = t3.s, s2 = Ge(n2, e4.date), i = +s2;
      if (!e4.disabled) {
        if (n2.selectMultiple) {
          var a2 = t3._tempValueRep;
          a2[i] ? delete a2[i] : (void 0 === n2.selectMax || Object.keys(a2).length < n2.selectMax) && (a2[i] = s2), t3._tempValueRep = d$2({}, a2);
        } else
          n2.selectRange || (t3._tempValueRep = {}), t3._tempValueRep[i] = s2;
        t3._navService.preventPageChange = n2.selectRange, t3._hook("onCellClick", e4), t3._setOrUpdate();
      }
    }, t3._onTodayClick = function() {
      var e4 = /* @__PURE__ */ new Date(), n2 = +e4;
      t3.s.selectRange || t3.s.selectMultiple || (t3._tempValueRep = {}, t3._tempValueRep[n2] = e4, t3._setOrUpdate());
    }, t3._onActiveChange = function(e4) {
      t3._navService.forcePageChange = e4.pageChange, t3._hook("onActiveChange", e4);
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._valueEquals = function(e4, t3) {
    return nt(e4, t3, this.s);
  }, t2.prototype._shouldValidate = function(e4, t3) {
    return e4.dataTimezone !== t3.dataTimezone || e4.displayTimezone !== t3.displayTimezone;
  }, t2.prototype._render = function(t3, n2) {
    e3.prototype._render.call(this, t3, n2), this._navService.options({ activeDate: t3.active, calendarType: t3.calendarType, firstDay: t3.firstDay, getDate: t3.getDate, getDay: t3.getDay, getMonth: t3.getMonth, getYear: t3.getYear, max: t3.max, min: t3.min, onPageChange: t3.onPageChange, onPageLoading: t3.onPageLoading, pages: t3.pages, refDate: t3.refDate, showCalendar: true, showOuterDays: t3.showOuterDays, size: t3.size, weeks: t3.weeks });
  }, t2.prototype._copy = function(e4) {
    return d$2({}, e4);
  }, t2.prototype._format = function(e4) {
    var t3 = this.s, n2 = [];
    for (var s2 in e4)
      void 0 !== e4[s2] && null !== e4[s2] && n2.push(et(t3.dateFormat, /* @__PURE__ */ new Date(+e4[s2]), t3));
    return t3.selectMultiple || t3.selectRange ? n2.join(", ") : n2[0];
  }, t2.prototype._parse = function(e4) {
    var t3 = this.s, n2 = t3.selectRange, s2 = {}, i = [];
    $(e4) ? i = e4.split(",") : j(e4) ? i = e4 : e4 && !j(e4) && (i = [e4]);
    for (var a2 = 0, r2 = i; a2 < r2.length; a2++) {
      var o3 = r2[a2];
      if (null !== o3) {
        var l2 = Ze(o3, t3, t3.dateFormat);
        s2[n2 ? +l2 : +ze(l2)] = l2;
      }
    }
    return s2;
  }, t2.prototype._get = function(e4) {
    var t3 = this.s, n2 = t3.selectRange;
    if (this.s.selectMultiple || n2) {
      for (var s2 = [], i = 0, a2 = Object.keys(e4); i < a2.length; i++) {
        var r2 = a2[i];
        s2.push(Je(t3, +e4[r2]));
      }
      return s2;
    }
    var o3 = Object.keys(e4 || {});
    return o3.length ? Je(t3, e4[o3[0]]) : null;
  }, t2.defaults = d$2({}, ct, { calendarScroll: "horizontal", calendarType: "month", selectedText: "{count} selected", showControls: true, showOnClick: true, weeks: 1 }), t2._name = "Calendar", t2;
}(En)), ai = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._onIndexChange = function(e4) {
      e4.wheel = t3.s.wheel, t3._hook("onIndexChange", e4);
    }, t3._onItemClick = function(e4) {
      t3._hook("onIndexChange", { click: true, index: e4.index, wheel: t3.s.wheel, selected: e4.selected });
    }, t3._onKeyDown = function(e4) {
      var n2 = 0;
      38 === e4.keyCode ? n2 = -1 : 40 === e4.keyCode && (n2 = 1);
      var s2 = t3.s, i = s2.activeIndex + n2, a2 = !(i < s2.minIndex || i > s2.maxIndex);
      if (n2 && e4.preventDefault(), n2 && a2) {
        var r2 = s2.selectOnScroll ? "onIndexChange" : "onActiveChange";
        t3._shouldFocus = true, t3._hook(r2, { diff: n2, index: i, wheel: s2.wheel });
      } else
        13 === e4.keyCode && s2.multiple && t3._hook("onSet", {});
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._getText = function(e4) {
    return void 0 !== e4 ? void 0 !== e4.display ? e4.display : e4 : void 0;
  }, t2.prototype._getValue = function(e4) {
    return e4 ? void 0 !== e4.value ? e4.value : void 0 !== e4.display ? e4.display : e4 : e4;
  }, t2.prototype._isActive = function(e4, t3, n2) {
    var s2 = this.s, i = s2.scroll3d && s2.multiple ? n2 : !n2;
    return s2.activeIndex === e4.key && t3 && i;
  }, t2.prototype._isSelected = function(e4) {
    var t3 = this.s, n2 = t3.selectedValues, s2 = this._getValue(e4.data);
    return t3.multiple ? !(!n2 || !n2.indexOf) && n2.indexOf(s2) >= 0 : t3.selectOnScroll ? e4.key === t3.selectedIndex : void 0 !== s2 && s2 === n2;
  }, t2.prototype._isDisabled = function(e4) {
    var t3 = this.s.disabled, n2 = e4 && e4.disabled, s2 = this._getValue(e4);
    return !!(n2 || t3 && t3.get(s2));
  }, t2.prototype._render = function(e4) {
    var t3 = e4.rows, n2 = e4.itemHeight, s2 = e4.wheel._key, i = 2 * oe((n2 - 0.03 * (n2 * t3 / 2 + 3)) / 2);
    this._items = e4.wheel.getItem || e4.wheel.data || [], this._batchSize3d = oe(1.8 * t3), this._angle3d = 360 / (2 * this._batchSize3d), this._style = { height: 2 * oe(t3 * n2 * (e4.scroll3d ? 1.1 : 1) / 2) }, this._itemNr = e4.wheel.spaceAround ? 1 : t3, this._innerStyle = { height: (e4.scroll3d ? i : e4.wheel.spaceAround ? n2 : n2 * t3) + "px" }, this._wheelStyle = e4.wheelWidth ? { width: e4.wheelWidth[s2] || e4.wheelWidth } : { maxWidth: j(e4.maxWheelWidth) ? e4.maxWheelWidth[s2] : e4.maxWheelWidth, minWidth: j(e4.minWheelWidth) ? e4.minWheelWidth[s2] : e4.minWheelWidth }, e4.scroll3d && (this._innerStyle[Ft + "transform"] = "translateY(-50%) translateZ(" + (n2 * t3 / 2 + 3) + "px");
  }, t2.prototype._updated = function() {
    if (this._shouldFocus) {
      var e4 = this._el.querySelector('[tabindex="0"]');
      e4 && setTimeout(function() {
        e4.focus();
      }), this._shouldFocus = false;
    }
  }, t2;
}(wt), ri = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    var t3;
    if (e4.renderItem && void 0 !== e4.data) {
      var n2 = e4.renderItem(e4.data), s2 = $(n2) ? { __html: n2 } : void 0;
      t3 = s2 ? ls("div", { dangerouslySetInnerHTML: s2 }) : ls("div", null, n2);
    } else
      t3 = e4.text;
    return ls("div", { "aria-disabled": e4.disabled ? "true" : void 0, "aria-hidden": void 0 === t3 || e4.is3d ? "true" : void 0, "aria-selected": e4.selected ? "true" : void 0, ref: this._setEl, tabIndex: e4.active ? 0 : void 0, className: this._cssClass, role: "option", style: this._style, onClick: this._onClick }, e4.checkmark && ls("span", { className: this._checkmarkClass }), t3);
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._onClick = function() {
      var e4 = t3.s;
      void 0 === e4.text || e4.isGroup || t3._hook("onClick", { index: e4.index, selected: e4.selected, disabled: e4.disabled });
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._mounted = function() {
    var e4 = this;
    this._unlisten = Ds(this._el, { click: true, keepFocus: false, onBlur: function() {
      e4.setState({ hasFocus: false });
    }, onFocus: function() {
      e4.setState({ hasFocus: true });
    }, onHoverIn: function() {
      void 0 !== e4.s.text && e4.setState({ hasHover: true });
    }, onHoverOut: function() {
      void 0 !== e4.s.text && e4.setState({ hasHover: false });
    }, onKeyDown: function(t3) {
      (32 === t3.keyCode || !e4.s.multiple && 13 === t3.keyCode) && e4._onClick();
    }, onPress: function() {
      void 0 !== e4.s.text && e4.setState({ isActive: true });
    }, onRelease: function() {
      void 0 !== e4.s.text && e4.setState({ isActive: false });
    } });
  }, t2.prototype._destroy = function() {
    this._unlisten();
  }, t2.prototype._render = function(e4, t3) {
    var n2 = e4.height;
    this._cssClass = "mbsc-scroller-wheel-" + (e4.isGroup ? "header" : "item") + this._theme + this._rtl + (e4.checkmark && !e4.isGroup ? " mbsc-wheel-item-checkmark" : "") + (e4.is3d ? " mbsc-scroller-wheel-item-3d" : "") + (e4.scroll3d && !e4.is3d ? " mbsc-scroller-wheel-item-2d" : "") + (e4.selected && !e4.is3d ? " mbsc-selected" : "") + (e4.selected && e4.is3d ? " mbsc-selected-3d" : "") + (e4.disabled ? " mbsc-disabled" : "") + (e4.multiple && !e4.isGroup ? " mbsc-wheel-item-multi" : "") + (t3.hasHover ? " mbsc-hover" : "") + (t3.hasFocus ? " mbsc-focus" : "") + (t3.isActive ? " mbsc-active" : ""), this._style = { height: n2, lineHeight: n2 + "px" }, this._checkmarkClass = this._theme + this._rtl + " mbsc-wheel-checkmark" + (e4.selected ? " mbsc-selected" : ""), e4.is3d && (this._transform = "rotateX(" + (e4.offset - e4.index) * e4.angle3d % 360 + "deg) translateZ(" + n2 * e4.rows / 2 + "px)", this._style[Ft + "transform"] = this._transform);
  }, t2;
}(wt)), oi = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3.renderer = function(e4, n2, s2) {
      var i = t3.s;
      if (void 0 !== e4) {
        var a2 = t3._getText(e4.data);
        return ls(ri, { active: t3._isActive(e4, a2, s2), angle3d: t3._angle3d, data: e4.data, disabled: t3._isDisabled(e4.data), height: i.itemHeight, index: e4.key, is3d: s2, isGroup: e4.data && e4.data.isGroup, key: e4.key, multiple: i.multiple, onClick: t3._onItemClick, offset: n2, checkmark: i.wheel.checkmark, renderItem: i.renderItem, rows: i.rows, rtl: i.rtl, scroll3d: i.scroll3d, selected: t3._isSelected(e4), text: a2, theme: i.theme });
      }
      return null;
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4, t3) {
    return ls("div", { "aria-multiselectable": e4.multiple ? "true" : void 0, className: "mbsc-scroller-wheel-wrapper mbsc-scroller-wheel-wrapper-" + e4.wheel._key + " " + (e4.wheel.cssClass || "") + (e4.scroll3d ? " mbsc-scroller-wheel-wrapper-3d" : "") + this._theme + this._rtl, onKeyDown: this._onKeyDown, ref: this._setEl, role: "listbox", style: this._wheelStyle }, ls(Xs, { batchSize3d: this._batchSize3d, className: "mbsc-scroller-wheel" + (e4.scroll3d ? " mbsc-scroller-wheel-3d" : "") + this._theme, innerClass: "mbsc-scroller-wheel-cont mbsc-scroller-wheel-cont-" + e4.display + (e4.scroll3d ? " mbsc-scroller-wheel-cont-3d" : "") + (e4.multiple ? " mbsc-scroller-wheel-multi" : "") + this._theme, innerStyles: this._innerStyle, items: this._items, itemSize: e4.itemHeight, itemRenderer: this.renderer, itemNr: this._itemNr, margin: true, maxIndex: e4.maxIndex, minIndex: e4.minIndex, onIndexChange: this._onIndexChange, offset: e4.wheel._offset, rtl: e4.rtl, scroll3d: e4.scroll3d, scrollBar: !this._touchUi, selectedIndex: e4.selectedIndex, snap: true, spaceAround: e4.wheel.spaceAround, styles: this._style, visibleSize: e4.rows }));
  }, t2;
}(ai);
function li(e3, t2, n2, s2) {
  var i = void 0 === e3.min ? -1 / 0 : e3.min, a2 = void 0 === e3.max ? 1 / 0 : e3.max, r2 = hi(e3, t2), o3 = ui(e3, r2), l2 = o3, c2 = o3, d2 = 0, h2 = 0;
  if (n2 && n2.get(o3)) {
    for (; r2 - d2 >= i && n2.get(l2) && d2 < 100; )
      l2 = ui(e3, r2 - ++d2);
    for (; r2 + h2 < a2 && n2.get(c2) && h2 < 100; )
      c2 = ui(e3, r2 + ++h2);
    if (n2.get(l2) && n2.get(c2))
      return o3;
    o3 = (h2 < d2 && h2 && -1 !== s2 || !d2 || r2 - d2 < 0 || 1 === s2) && !n2.get(c2) ? c2 : l2;
  }
  return o3;
}
function ci(e3) {
  return void 0 !== e3 ? void 0 !== e3.value ? e3.value : void 0 !== e3.display ? e3.display : e3 : e3;
}
function di(e3, t2) {
  if (e3.getItem)
    return e3.getItem(t2);
  var n2 = e3.data || [], s2 = n2.length, i = t2 % s2;
  return e3._circular ? n2[i >= 0 ? i : i + s2] : n2[G(t2, 0, s2 - 1)];
}
function hi(e3, t2) {
  var n2 = e3.multiple ? t2 && t2.length && t2[0] || void 0 : t2;
  return (e3.getIndex ? +e3.getIndex(t2) : e3._map.get(n2)) || 0;
}
function ui(e3, t2) {
  return ci(di(e3, t2));
}
var _i = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    var t3 = this, n2 = e4.renderPreContent ? e4.renderPreContent(e4.preContentData) : "", s2 = e4.renderInContent ? e4.renderInContent(e4.preContentData) : "", i = ls(ds, null, n2, ls("div", { className: "mbsc-scroller mbsc-scroller-" + this._displayStyle + this._theme + this._rtl + (this._touchUi ? " mbsc-scroller-touch" : " mbsc-scroller-pointer") + ("inline" === e4.display ? " mbsc-font " : " ") + this._className }, s2, this._wheels.map(function(n3, s3) {
      return ls("div", { key: s3, className: "mbsc-scroller-wheel-group-cont" + (e4.scroll3d ? " mbsc-scroller-wheel-group-cont-3d" : "") + t3._theme }, e4.selectOnScroll && ls("div", { className: "mbsc-scroller-wheel-line" + t3._theme, style: t3._lineStyle }), ls("div", { className: "mbsc-scroller-wheel-group" + (e4.scroll3d ? " mbsc-scroller-wheel-group-3d" : "") + t3._theme }, ls("div", { className: "mbsc-scroller-wheel-overlay mbsc-scroller-wheel-overlay-" + t3._displayStyle + t3._theme, style: t3._overlayStyle }), n3.map(function(n4, s4) {
        return ls(oi, { activeIndex: t3._activeIndexes[n4._key], disabled: t3._disabled && t3._disabled[n4._key], display: t3._displayStyle, key: s4, itemHeight: e4.itemHeight, onActiveChange: t3._onActiveChange, onIndexChange: t3._onWheelIndexChange, onSet: t3._onSet, maxIndex: n4.max, maxWheelWidth: e4.maxWheelWidth, minIndex: n4.min, minWheelWidth: e4.minWheelWidth, multiple: n4.multiple, renderItem: e4.renderItem, rows: t3._rows, scroll3d: t3._scroll3d, selectedIndex: t3._indexes[n4._key], selectedValues: t3._tempValueRep[n4._key], selectOnScroll: e4.selectOnScroll, theme: e4.theme, touchUi: e4.touchUi, rtl: e4.rtl, wheel: n4, wheelWidth: e4.wheelWidth });
      })));
    })));
    return Hs(this, e4, i);
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._indexes = [], t3._activeIndexes = [], t3._wheels = [], t3._batches = [], t3._lastIndexes = [], t3._onSet = function() {
      t3._setOrUpdate();
    }, t3._onActiveChange = function(e4) {
      var n2 = e4.wheel, s2 = e4.index, i = n2._key;
      t3._activeIndexes[i] = s2;
      var a2 = t3._indexes, r2 = a2[i];
      t3._scroll3d ? r2 = s2 : s2 - r2 >= t3._rows ? r2++ : s2 < r2 && r2--, a2[i] = r2, t3.forceUpdate();
    }, t3._onWheelIndexChange = function(e4) {
      var n2 = t3.s, s2 = e4.wheel, i = s2._key, a2 = s2.multiple, r2 = ui(s2, e4.index), o3 = t3._disabled && t3._disabled[i] && t3._disabled[i].get(r2), l2 = [], c2 = n2.selectOnScroll;
      (c2 || !e4.click) && (t3._lastIndexes[i] = t3._indexes[i] = e4.index, t3._indexes.forEach(function(e6, n3) {
        var s3 = t3._wheelMap[n3], i2 = s3.data ? s3.data.length : 0;
        t3._batches[n3] = i2 ? ce(e6 / i2) : 0, l2[n3] = i2;
      })), t3._activeIndexes[i] = e4.index;
      var d2 = t3._get(t3._tempValueRep), h2 = !!e4.click && !o3, u2 = c2 || h2;
      if (a2) {
        if (h2) {
          var _2 = (t3._tempValueRep[i] || []).slice();
          false === e4.selected ? _2.push(r2) : true === e4.selected && _2.splice(_2.indexOf(r2), 1), t3._tempValueRep[i] = _2;
        }
      } else
        u2 && (t3._tempValueRep[i] = r2);
      if (n2.onWheelMove && void 0 !== e4.index) {
        var m2 = n2.onWheelMove({ dataItem: di(s2, e4.index), selection: u2, wheelIndex: i });
        m2 && m2.forEach(function(e6, n3) {
          if (void 0 !== e6 && (t3._tempValueRep[n3] = e6), !u2) {
            var s3 = t3._wheelMap[n3], i2 = hi(s3, e6);
            t3._constrainIndex(i2, s3);
          }
        });
      }
      u2 && t3._validate(i, e4.diff > 0 ? 1 : -1), c2 && t3._tempValueRep.forEach(function(e6, n3) {
        var s3 = t3._wheelMap[n3], i2 = s3.data ? s3.data.length : 0, a3 = t3._indexes[n3], r3 = hi(s3, e6) + t3._batches[n3] * i2;
        t3._activeIndexes[n3] = t3._lastIndexes[n3] = t3._indexes[n3] = r3, s3._offset = i2 !== l2[n3] ? r3 - a3 : 0;
      });
      var p2 = t3._get(t3._tempValueRep), v2 = !t3._valueEquals(d2, p2);
      v2 || e4.click && t3._live && !t3._valueEquals(t3.value, p2) ? t3._setOrUpdate(!v2) : t3.forceUpdate(), t3._live && h2 && s2.closeOnTap && t3.close();
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._initWheels = function() {
    var e4 = this, t3 = 0, n2 = this.s.wheels || [];
    this._wheelMap = [], n2.forEach(function(n3) {
      n3.forEach(function(n4) {
        e4._initWheel(n4, t3), e4._wheelMap[t3] = n4, t3++;
      });
    }), this._wheels = n2;
  }, t2.prototype._shouldValidate = function(e4, t3) {
    return !!e4.shouldValidate && e4.shouldValidate(e4, t3);
  }, t2.prototype._valueEquals = function(e4, t3) {
    return this.s.valueEquality ? this.s.valueEquality(e4, t3) : e4 === t3;
  }, t2.prototype._render = function(t3, n2) {
    var s2 = this, i = this.props || {}, a2 = this._respProps || {}, r2 = this._prevS, o3 = !!this._touchUi && t3.circular, l2 = this._touchUi ? t3.rows : a2.rows || i.rows || 7;
    if (this._displayStyle = t3.displayStyle || t3.display, this._scroll3d = t3.scroll3d && this._touchUi && At, (t3.itemHeight !== r2.itemHeight || l2 !== this._rows) && (this._rows = l2, this._lineStyle = { height: t3.itemHeight + "px" }, this._scroll3d)) {
      var c2 = "translateZ(" + (t3.itemHeight * l2 / 2 + 3) + "px";
      this._overlayStyle = {}, this._overlayStyle[Ft + "transform"] = c2, this._lineStyle[Ft + "transform"] = "translateY(-50%) " + c2;
    }
    t3.wheels === r2.wheels && o3 === this._circular || (this._batches = [], this._shouldSetIndex = true, this._circular = o3, this._initWheels()), e3.prototype._render.call(this, t3, n2), this._shouldSetIndex && (this._setIndexes(), this._shouldSetIndex = this._indexFromValue = false), t3.wheels !== r2.wheels && void 0 !== r2.wheels && setTimeout(function() {
      for (var e4 = 0, t4 = s2._wheelMap; e4 < t4.length; e4++) {
        var n3 = t4[e4];
        s2._onWheelIndexChange({ diff: 0, index: s2._indexes[n3._key], wheel: n3 });
      }
    });
  }, t2.prototype._writeValue = function(t3, n2, s2) {
    return this.s.writeValue ? this.s.writeValue(t3, n2, s2) : e3.prototype._writeValue.call(this, t3, n2, s2);
  }, t2.prototype._copy = function(e4) {
    return e4.slice(0);
  }, t2.prototype._format = function(e4) {
    return this.s.formatValue ? this.s.formatValue(e4) : e4.join(" ");
  }, t2.prototype._get = function(e4) {
    return this.s.getValue ? this.s.getValue(e4) : e4;
  }, t2.prototype._parse = function(e4) {
    if (this.s.parseValue)
      return this.s.parseValue(e4);
    var t3 = [], n2 = [], s2 = 0;
    return null != e4 && (n2 = (e4 + "").split(" ")), this._wheels.forEach(function(e6) {
      e6.forEach(function(e7) {
        for (var i = e7.data || [], a2 = i.length, r2 = ci(i[0]), o3 = 0; r2 != n2[s2] && o3 < a2; )
          r2 = ci(i[o3]), o3++;
        t3.push(r2), s2++;
      });
    }), t3;
  }, t2.prototype._validate = function(e4, t3) {
    var n2 = this;
    if (this.s.validate) {
      var s2 = this.s.validate.call(this._el, { direction: t3, index: e4, values: this._tempValueRep.slice(0), wheels: this._wheelMap });
      this._disabled = s2.disabled, s2.init && this._initWheels(), s2.indexes && s2.indexes.forEach(function(e6, t4) {
        if (void 0 !== e6) {
          var s3 = n2._wheelMap[t4], i = hi(s3, e6);
          n2._constrainIndex(i, s3);
        }
      }), s2.valid ? this._tempValueRep = s2.valid.slice(0) : this._wheelMap.forEach(function(e6, s3) {
        n2._tempValueRep[s3] = li(e6, n2._tempValueRep[s3], n2._disabled && n2._disabled[s3], t3);
      });
    }
  }, t2.prototype._onOpen = function() {
    this._batches = [], this._shouldSetIndex = true, this._indexFromValue = true;
  }, t2.prototype._onParse = function() {
    this._shouldSetIndex = true;
  }, t2.prototype._initWheel = function(e4, t3) {
    var n2 = this._circular;
    e4._key = t3, e4._map = /* @__PURE__ */ new Map(), e4._circular = void 0 === n2 ? void 0 === e4.circular ? e4.data && e4.data.length > this._rows : e4.circular : j(n2) ? n2[t3] : n2, e4.data && (e4.min = e4._circular ? void 0 : 0, e4.max = e4._circular ? void 0 : e4.data.length - 1, e4.data.forEach(function(t4, n3) {
      e4._map.set(ci(t4), n3);
    }));
  }, t2.prototype._setIndexes = function() {
    var e4 = this, t3 = this._indexes || [];
    this._indexes = [], this._activeIndexes = [], this._tempValueRep.forEach(function(n2, s2) {
      var i = e4._wheelMap[s2], a2 = i.data ? i.data.length : 0, r2 = hi(i, n2);
      if (e4.s.selectOnScroll)
        e4._activeIndexes[s2] = e4._indexes[s2] = r2 + (e4._batches[s2] || 0) * a2;
      else {
        var o3 = r2;
        e4._indexFromValue || void 0 !== (o3 = t3[s2]) && (o3 = function(e6, t4) {
          if (e6.getItem && e6.getIndex)
            return e6.getIndex(ci(e6.getItem(t4)));
          var n3 = (e6.data || []).length, s3 = t4 % n3;
          return n3 ? s3 >= 0 ? s3 : s3 + n3 : 0;
        }(i, o3) + (e4._batches[s2] || 0) * a2), e4._constrainIndex(o3, i);
      }
    });
  }, t2.prototype._constrainIndex = function(e4, t3) {
    var n2 = t3._key;
    void 0 !== e4 && t3.data ? (t3.spaceAround || (e4 = G(e4, 0, Math.max(t3.data.length - this._rows, 0))), this._activeIndexes[n2] = this._indexes[n2] = e4) : this._activeIndexes[n2] = this._indexes[n2] = this._lastIndexes[n2] || 0;
  }, t2.defaults = { itemHeight: 40, rows: 5, selectOnScroll: true, showOnClick: true }, t2._name = "Scroller", t2;
}(En)), mi = { ios: 50, material: 46, windows: 50 }, pi$2 = ["a", "h", "i", "s", "tt"];
function vi(e3, t2, n2, s2, i, a2, r2, o3, l2, c2, d2, h2, u2, _2, m2, p2) {
  for (var v2 = Ue(u2, _2), f2 = v2 || !Ue(h2, _2) ? u2 : Oe(e3, u2), g2 = v2 || !Ue(h2, u2) ? _2 : Re(e3, _2), y2 = a2.a(f2), b2 = a2.a(g2), D2 = true, x2 = true, C2 = false, w2 = 0, T2 = 0, k2 = 0; k2 < n2; k2++) {
    var S2 = s2[i[I2 = pi$2[k2]]];
    if (void 0 !== S2) {
      var E2 = D2 ? a2[I2](f2) : 0, M2 = x2 ? a2[I2](g2) : r2[I2];
      t2 && 1 === k2 && (E2 += y2 ? 12 : 0, M2 += b2 ? 12 : 0, S2 += s2[i.a] ? 12 : 0), (D2 || x2) && E2 < S2 && S2 < M2 && (C2 = true), S2 !== E2 && (D2 = false), S2 !== M2 && (x2 = false);
    }
  }
  if (!m2) {
    for (k2 = n2 + 1; k2 < 4; k2++) {
      var I2;
      void 0 !== i[I2 = pi$2[k2]] && (a2[I2](f2) > 0 && D2 && (w2 = o3[l2]), a2[I2](g2) < r2[I2] && x2 && (T2 = o3[l2]));
    }
    x2 && p2 && !T2 && (T2 = 999 !== g2.getMilliseconds() ? o3[l2] : 0);
  }
  if (D2 || x2 || C2)
    for (E2 = D2 && !C2 ? a2[l2](f2) + w2 : 0, M2 = x2 && !C2 ? a2[l2](g2) - T2 : r2[l2], k2 = E2; k2 <= M2; k2 += o3[l2])
      c2[d2].set(k2, !m2);
}
function fi(e3, t2) {
  var n2 = new Date(e3);
  return t2 ? ce(+n2 / 864e5) : n2.getMonth() + 12 * (n2.getFullYear() - 1970);
}
function gi(e3) {
  return e3.getFullYear() + "-" + re$1(e3.getMonth() + 1) + "-" + re$1(e3.getDate());
}
function yi(e3) {
  return e3.getMilliseconds();
}
function bi(e3) {
  return e3.getHours() > 11 ? 1 : 0;
}
var Di = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._preset = "date", t3._innerValues = {}, t3._onChange = function(e4) {
      void 0 === t3.s.value && t3.setState({ value: e4.value }), t3._hook("onChange", e4);
    }, t3._parseDate = function(e4) {
      var n2 = t3.s;
      return e4 || (t3._innerValues = {}), t3._getArray(Ze(e4 || n2.defaultSelection || /* @__PURE__ */ new Date(), n2, t3._format), !!e4);
    }, t3._formatDate = function(e4) {
      var n2 = t3._getDate(e4);
      return n2 ? et(t3._format, n2, t3.s) : "";
    }, t3._getDate = function(e4) {
      var n2, s2, i = t3.s, a2 = t3._getArrayPart, r2 = t3._wheelOrder, o3 = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
      if (null == e4)
        return null;
      if (void 0 !== r2.dd) {
        var l2 = e4[r2.dd].split("-");
        n2 = new Date(l2[0], l2[1] - 1, l2[2]);
      }
      void 0 !== r2.tt && (s2 = n2 || o3, s2 = new Date(s2.getTime() + e4[r2.tt] % 86400 * 1e3));
      var c2 = a2(e4, "y", n2, o3), d2 = a2(e4, "m", n2, o3), h2 = Math.min(a2(e4, "d", n2, o3), i.getMaxDayOfMonth(c2, d2)), u2 = a2(e4, "h", s2, o3);
      return i.getDate(c2, d2, h2, t3._hasAmPm && a2(e4, "a", s2, o3) ? u2 + 12 : u2, a2(e4, "i", s2, o3), a2(e4, "s", s2, o3), a2(e4, "u", s2, o3));
    }, t3._validate = function(e4) {
      var n2 = e4.direction, s2 = e4.index, i = e4.values, a2 = e4.wheels, r2 = [], o3 = t3.s, l2 = o3.stepHour, c2 = o3.stepMinute, d2 = o3.stepSecond, h2 = o3.mode || t3._preset, u2 = t3._wheelOrder, _2 = t3._getDatePart, m2 = t3._max, p2 = t3._min, v2 = Ge(o3, t3._getDate(i)), f2 = o3.getYear(v2), g2 = o3.getMonth(v2), y2 = o3.getDate(f2, g2 - 1, 1), b2 = o3.getDate(f2, g2 + 2, 1);
      s2 !== u2.y && s2 !== u2.m && s2 !== u2.d && s2 !== u2.dd && void 0 !== s2 || (t3._valids = Bn(o3.valid, y2, b2, o3, true), t3._invalids = Bn(o3.invalid, y2, b2, o3, true));
      var D2 = t3._valids, x2 = t3._invalids, C2 = Kn(v2, o3, p2 ? +p2 : -1 / 0, m2 ? +m2 : 1 / 0, x2, D2, n2), w2 = t3._getArray(C2), T2 = t3._wheels && t3._wheels[0][u2.d], k2 = _2.y(C2), S2 = _2.m(C2), E2 = o3.getMaxDayOfMonth(k2, S2), M2 = { y: p2 ? p2.getFullYear() : -1 / 0, m: 0, d: 1, h: 0, i: 0, s: 0, a: 0, tt: 0 }, I2 = { y: m2 ? m2.getFullYear() : 1 / 0, m: 11, d: 31, h: le(t3._hasAmPm ? 11 : 23, l2), i: le(59, c2), s: le(59, d2), a: 1, tt: 86400 }, N2 = { y: 1, m: 1, d: 1, h: l2, i: c2, s: d2, a: 1, tt: t3._timeStep }, L2 = false, H2 = true, O2 = true;
      if (["dd", "y", "m", "d", "tt", "a", "h", "i", "s"].forEach(function(e6) {
        var t4 = M2[e6], n3 = I2[e6], s3 = _2[e6](C2), i2 = u2[e6];
        if (H2 && p2 && (t4 = _2[e6](p2)), O2 && m2 && (n3 = _2[e6](m2)), s3 < t4 && (s3 = t4), s3 > n3 && (s3 = n3), "dd" === e6 || "tt" === e6 || "a" === e6 && void 0 === i2 || (H2 && (H2 = s3 === t4), O2 && (O2 = s3 === n3)), void 0 !== i2) {
          if (r2[i2] = /* @__PURE__ */ new Map(), "y" !== e6 && "dd" !== e6)
            for (var a3 = M2[e6]; a3 <= I2[e6]; a3 += N2[e6])
              (a3 < t4 || a3 > n3) && r2[i2].set(a3, true);
          if ("d" === e6 && x2) {
            for (var l3 in x2)
              if (!D2 || !D2[l3]) {
                var c3 = new Date(l3), d3 = o3.getYear(c3), h3 = o3.getMonth(c3);
                d3 === k2 && h3 === S2 && Xn(o3, c3, x2, D2) && r2[i2].set(o3.getDay(c3), true);
              }
          }
        }
      }), /time/i.test(h2)) {
        var R2 = x2 && x2[Pe(C2)], V2 = D2 && D2[Pe(C2)];
        pi$2.forEach(function(e6, s3) {
          var i2 = u2[e6];
          if (void 0 !== i2) {
            var l3 = o3.valid ? V2 : R2;
            if (l3) {
              if (o3.valid)
                for (var c3 = 0; c3 <= I2[e6]; c3++)
                  r2[i2].set(c3, true);
              for (var d3 = 0, h3 = l3; d3 < h3.length; d3++) {
                var m3 = h3[d3], p3 = m3.start, v3 = m3.end;
                p3 && v3 && vi(o3, t3._hasAmPm, s3, w2, u2, _2, I2, N2, e6, r2, i2, C2, p3, v3, !!o3.valid, o3.exclusiveEndDates);
              }
            }
            w2[i2] = li(a2[i2], _2[e6](C2), r2[i2], n2);
          }
        });
      }
      var P2 = t3._dateDisplay;
      if (T2 && (T2.data.length !== E2 || /DDD/.test(P2))) {
        for (var z2 = [], Y2 = P2.replace(/[my|]/gi, "").replace(/DDDD/, "{dddd}").replace(/DDD/, "{ddd}").replace(/DD/, "{dd}").replace(/D/, "{d}"), W2 = 1; W2 <= E2; W2++) {
          var F2 = o3.getDate(k2, S2, W2).getDay(), A2 = Y2.replace(/{dddd}/, o3.dayNames[F2]).replace(/{ddd}/, o3.dayNamesShort[F2]).replace(/{dd}/, re$1(W2) + o3.daySuffix).replace(/{d}/, W2 + o3.daySuffix);
          z2.push({ display: A2, value: W2 });
        }
        T2.data = z2, L2 = true;
      }
      return { disabled: r2, init: L2, valid: w2 };
    }, t3._shouldValidate = function(e4, t4) {
      return !!(e4.min && +e4.min != +t4.min || e4.max && +e4.max != +t4.max) || e4.wheels !== t4.wheels || e4.dataTimezone !== t4.dataTimezone || e4.displayTimezone !== t4.displayTimezone;
    }, t3._getYearValue = function(e4) {
      return { display: (/yy/i.test(t3._dateDisplay) ? e4 : (e4 + "").substr(2, 2)) + t3.s.yearSuffix, value: e4 };
    }, t3._getYearIndex = function(e4) {
      return +e4;
    }, t3._getDateIndex = function(e4) {
      return fi(e4, t3._hasDay);
    }, t3._getDateItem = function(e4) {
      var n2 = t3.s, s2 = t3._hasDay, i = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0)), a2 = s2 ? new Date(864e5 * e4) : new Date(1970, e4, 1);
      return s2 && (a2 = new Date(a2.getUTCFullYear(), a2.getUTCMonth(), a2.getUTCDate())), { disabled: s2 && Xn(n2, a2, t3._invalids, t3._valids), display: i.getTime() === a2.getTime() ? n2.todayText : et(t3._dateTemplate, a2, n2), value: gi(a2) };
    }, t3._getArrayPart = function(e4, n2, s2, i) {
      var a2;
      return void 0 === t3._wheelOrder[n2] || (a2 = +e4[t3._wheelOrder[n2]], isNaN(a2)) ? s2 ? t3._getDatePart[n2](s2) : void 0 !== t3._innerValues[n2] ? t3._innerValues[n2] : t3._getDatePart[n2](i) : a2;
    }, t3._getHours = function(e4) {
      var n2 = e4.getHours();
      return le(n2 = t3._hasAmPm && n2 >= 12 ? n2 - 12 : n2, t3.s.stepHour);
    }, t3._getMinutes = function(e4) {
      return le(e4.getMinutes(), t3.s.stepMinute);
    }, t3._getSeconds = function(e4) {
      return le(e4.getSeconds(), t3.s.stepSecond);
    }, t3._getFullTime = function(e4) {
      return le(oe((e4.getTime() - new Date(e4).setHours(0, 0, 0, 0)) / 1e3), t3._timeStep || 1);
    }, t3;
  }
  return c$3(t2, e3), t2.prototype.getVal = function() {
    return this._value;
  }, t2.prototype.setVal = function(e4) {
    this._value = e4, this.setState({ value: e4 });
  }, t2.prototype.position = function() {
    this._scroller && this._scroller.position();
  }, t2.prototype.isVisible = function() {
    return this._scroller && this._scroller.isVisible();
  }, t2.prototype._valueEquals = function(e4, t3) {
    return nt(e4, t3, this.s);
  }, t2.prototype._render = function(e4, t3) {
    var n2 = false, s2 = this._prevS, i = e4.dateFormat, a2 = e4.timeFormat, r2 = e4.mode || this._preset, o3 = "datetime" === r2 ? i + e4.separator + a2 : "time" === r2 ? a2 : i;
    this._value = void 0 === e4.value ? t3.value : e4.value, this._minWheelWidth = e4.minWheelWidth || ("datetime" === r2 ? mi[e4.baseTheme || e4.theme] : void 0), this._dateWheels = e4.dateWheels || ("datetime" === r2 ? e4.dateWheelFormat : i), this._dateDisplay = e4.dateWheels || e4.dateDisplay, this._timeWheels = e4.timeWheels || a2, this._timeDisplay = this._timeWheels, this._format = o3, this._hasAmPm = /h/.test(this._timeDisplay), this._getDatePart = { y: e4.getYear, m: e4.getMonth, d: e4.getDay, h: this._getHours, i: this._getMinutes, s: this._getSeconds, u: yi, a: bi, dd: gi, tt: this._getFullTime }, +Ze(s2.min) != +Ze(e4.min) && (n2 = true, this._min = Q(e4.min) ? void 0 : Ze(e4.min, e4, o3)), +Ze(s2.max) != +Ze(e4.max) && (n2 = true, this._max = Q(e4.max) ? void 0 : Ze(e4.max, e4, o3)), (e4.theme !== s2.theme || e4.mode !== s2.mode || e4.locale !== s2.locale || e4.dateWheels !== s2.dateWheels || e4.timeWheels !== s2.timeWheels || n2) && (this._wheels = this._getWheels());
  }, t2.prototype._getWheels = function() {
    this._wheelOrder = {};
    var e4, t3 = this.s, n2 = t3.mode || this._preset, s2 = this._hasAmPm, i = this._dateDisplay, a2 = this._timeDisplay, r2 = this._wheelOrder, o3 = [], l2 = [], c2 = [], d2 = 0;
    if (/date/i.test(n2)) {
      for (var h2 = 0, u2 = this._dateWheels.split(/\|/.test(this._dateWheels) ? "|" : ""); h2 < u2.length; h2++) {
        var _2 = 0;
        if ((y2 = u2[h2]).length) {
          if (/y/i.test(y2) && _2++, /m/i.test(y2) && _2++, /d/i.test(y2) && _2++, _2 > 1 && void 0 === r2.dd)
            r2.dd = d2, d2++, l2.push(this._getDateWheel(y2)), c2 = l2;
          else if (/y/i.test(y2) && void 0 === r2.y)
            r2.y = d2, d2++, l2.push({ cssClass: "mbsc-datetime-year-wheel", getIndex: this._getYearIndex, getItem: this._getYearValue, max: this._max ? t3.getYear(this._max) : void 0, min: this._min ? t3.getYear(this._min) : void 0, spaceAround: true });
          else if (/m/i.test(y2) && void 0 === r2.m) {
            r2.m = d2, e4 = [], d2++;
            for (var m2 = i.replace(/[dy|]/gi, "").replace(/MMMM/, "{mmmm}").replace(/MMM/, "{mmm}").replace(/MM/, "{mm}").replace(/M/, "{m}"), p2 = 0; p2 < 12; p2++) {
              var v2 = m2.replace(/{mmmm}/, t3.monthNames[p2]).replace(/{mmm}/, t3.monthNamesShort[p2]).replace(/{mm}/, re$1(p2 + 1) + (t3.monthSuffix || "")).replace(/{m}/, p2 + 1 + (t3.monthSuffix || ""));
              e4.push({ display: v2, value: p2 });
            }
            l2.push({ cssClass: "mbsc-datetime-month-wheel", data: e4, spaceAround: true });
          } else if (/d/i.test(y2) && void 0 === r2.d) {
            r2.d = d2, e4 = [], d2++;
            for (p2 = 1; p2 < 32; p2++)
              e4.push({ display: (/dd/i.test(i) ? re$1(p2) : p2) + t3.daySuffix, value: p2 });
            l2.push({ cssClass: "mbsc-datetime-day-wheel", data: e4, spaceAround: true });
          }
        }
      }
      o3.push(l2);
    }
    if (/time/i.test(n2)) {
      for (var f2 = 0, g2 = this._timeWheels.split(/\|/.test(this._timeWheels) ? "|" : ""); f2 < g2.length; f2++) {
        var y2;
        _2 = 0;
        if ((y2 = g2[f2]).length && (/h/i.test(y2) && _2++, /m/i.test(y2) && _2++, /s/i.test(y2) && _2++, /a/i.test(y2) && _2++), _2 > 1 && void 0 === r2.tt)
          r2.tt = d2, d2++, c2.push(this._getTimeWheel(y2));
        else if (/h/i.test(y2) && void 0 === r2.h) {
          e4 = [], r2.h = d2, d2++;
          for (p2 = 0; p2 < (s2 ? 12 : 24); p2 += t3.stepHour)
            e4.push({ display: s2 && 0 === p2 ? 12 : /hh/i.test(a2) ? re$1(p2) : p2, value: p2 });
          c2.push({ cssClass: "mbsc-datetime-hour-wheel", data: e4, spaceAround: true });
        } else if (/m/i.test(y2) && void 0 === r2.i) {
          e4 = [], r2.i = d2, d2++;
          for (p2 = 0; p2 < 60; p2 += t3.stepMinute)
            e4.push({ display: /mm/i.test(a2) ? re$1(p2) : p2, value: p2 });
          c2.push({ cssClass: "mbsc-datetime-minute-wheel", data: e4, spaceAround: true });
        } else if (/s/i.test(y2) && void 0 === r2.s) {
          e4 = [], r2.s = d2, d2++;
          for (p2 = 0; p2 < 60; p2 += t3.stepSecond)
            e4.push({ display: /ss/i.test(a2) ? re$1(p2) : p2, value: p2 });
          c2.push({ cssClass: "mbsc-datetime-second-wheel", data: e4, spaceAround: true });
        } else
          /a/i.test(y2) && void 0 === r2.a && (r2.a = d2, d2++, c2.push({ cssClass: "mbsc-dt-whl-a", data: /A/.test(y2) ? [{ display: t3.amText.toUpperCase(), value: 0 }, { display: t3.pmText.toUpperCase(), value: 1 }] : [{ display: t3.amText, value: 0 }, { display: t3.pmText, value: 1 }], spaceAround: true }));
      }
      c2 !== l2 && o3.push(c2);
    }
    return o3;
  }, t2.prototype._getDateWheel = function(e4) {
    var t3 = /d/i.test(e4);
    return this._hasDay = t3, this._dateTemplate = e4, { cssClass: "mbsc-datetime-date-wheel", getIndex: this._getDateIndex, getItem: this._getDateItem, label: "", max: this._max ? fi(gi(this._max), t3) : void 0, min: this._min ? fi(gi(this._min), t3) : void 0, spaceAround: true };
  }, t2.prototype._getTimeWheel = function(e4) {
    var t3 = this.s, n2 = [], s2 = 1;
    /s/i.test(e4) ? s2 = t3.stepSecond : /m/i.test(e4) ? s2 = 60 * t3.stepMinute : /h/i.test(e4) && (s2 = 3600 * t3.stepHour), this._timeStep = s2;
    for (var i = 0; i < 86400; i += s2) {
      var a2 = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0) + 1e3 * i);
      n2.push({ display: et(e4, a2, t3), value: i });
    }
    return { data: n2, label: "", spaceAround: true };
  }, t2.prototype._getArray = function(e4, t3) {
    var n2 = [], s2 = this._wheelOrder;
    if (null == e4)
      return n2;
    for (var i = 0, a2 = ["y", "m", "d", "a", "h", "i", "s", "u", "dd", "tt"]; i < a2.length; i++) {
      var r2 = a2[i], o3 = this._getDatePart[r2](e4);
      void 0 !== s2[r2] && (n2[s2[r2]] = o3), t3 && (this._innerValues[r2] = o3);
    }
    return n2;
  }, t2.defaults = d$2({}, Ee, { dateDisplay: "MMMMDDYYYY", dateWheelFormat: "|DDD MMM D|", stepHour: 1, stepMinute: 1, stepSecond: 1 }), t2._name = "Datetime", t2;
}(wt), xi = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._preset = "datetime", t3;
  }
  return c$3(t2, e3), t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._setScroller = function(e4) {
      t3._scroller = e4;
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4, t3) {
    return ls(_i, d$2({}, e4, { formatValue: this._formatDate, getValue: this._getDate, minWheelWidth: this._minWheelWidth, parseValue: this._parseDate, ref: this._setScroller, shouldValidate: this._shouldValidate, validate: this._validate, value: this._value, valueEquality: this._valueEquals, wheels: this._wheels, onChange: this._onChange }), e4.children);
  }, t2;
}(Di)), Ci = os({}), wi = {};
function Ti(e3, t2) {
  return wi[e3] || (wi[e3] = { change: new v$3(), selectedIndex: -1 }), wi[e3].change.subscribe(t2);
}
function ki(e3, t2) {
  var n2 = wi[e3];
  n2 && (n2.change.unsubscribe(t2), n2.change.nr || delete wi[e3]);
}
function Si(e3, t2, n2) {
  var s2 = wi[e3];
  s2 && (void 0 !== n2 && (s2.selectedIndex = n2), void 0 !== t2 && (s2.value = t2), s2.change.next(s2.value));
}
function Ei(e3) {
  return wi[e3] && wi[e3].selectedIndex;
}
var Mi = 1, Ii = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    var t3 = { color: e4.color, disabled: e4.disabled, name: this._name, onChange: this._onChange, select: e4.select, value: e4.value }, n2 = ls("div", { className: this._groupClass, ref: this._setEl }, e4.children);
    return ls(Ci.Provider, { children: n2, value: t3 });
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._id = "mbsc-segmented-group" + Mi++, t3._onChange = function(e4, n2) {
      var s2 = t3.s, i = t3.value;
      if ("multiple" === s2.select) {
        if (void 0 !== i) {
          var a2 = (i = i || []).indexOf(n2);
          -1 !== a2 ? i.splice(a2, 1) : i.push(n2), t3.value = i.slice();
        }
      } else
        t3.value = n2;
      s2.onChange && s2.onChange(e4);
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._setupDrag = function() {
    var e4, t3, n2, s2, i, a2, r2 = this, o3 = [], l2 = [];
    this._unlisten = Ds(this._el, { onEnd: function() {
      n2 && s2 !== i && !o3[s2] && r2._el.querySelectorAll(".mbsc-segmented-input")[s2].click();
      n2 = false, r2.setState({ dragging: false });
    }, onMove: function(i2) {
      if (n2) {
        for (var c2 = Math.min(Math.max(i2.endX - t3, 0), e4), d2 = 0, h2 = l2[0]; c2 > h2 && l2.length > d2 + 1; )
          d2++, h2 += l2[d2];
        (d2 = r2.s.rtl ? l2.length - 1 - d2 : d2) === s2 || o3[d2] || Si(a2, void 0, s2 = d2);
      }
    }, onStart: function(c2) {
      var d2 = sn(c2.domEvent.target, ".mbsc-segmented-item", r2._el);
      if (d2) {
        var h2 = d2.querySelector(".mbsc-segmented-input");
        if (h2.classList.contains("mbsc-selected")) {
          o3 = [], rn(r2._el.querySelectorAll(".mbsc-segmented-button"), function(e6) {
            o3.push(e6.classList.contains("mbsc-disabled"));
          }), l2 = [], rn(r2._el.querySelectorAll(".mbsc-segmented-item"), function(e6) {
            l2.push(e6.clientWidth);
          });
          e4 = r2._el.clientWidth - 30, t3 = tn(r2._el).left + 15, a2 = h2.name, s2 = Ei(a2), i = s2, l2.length && "radio" === h2.type && (n2 = true, r2.setState({ dragging: true }));
        }
      }
    } });
  }, t2.prototype._cleanupDrag = function() {
    this._unlisten && (this._unlisten(), this._unlisten = null);
  }, t2.prototype._render = function(e4) {
    this._name = void 0 === e4.name ? this._id : e4.name, this._groupClass = "mbsc-segmented " + this._className + this._theme + this._rtl + (e4.color ? " mbsc-segmented-" + e4.color : "") + (this.state.dragging ? " mbsc-segmented-dragging" : "");
  }, t2.prototype._updated = function() {
    this.s.drag && "multiple" !== this.s.select ? this._unlisten || this._setupDrag() : this._cleanupDrag();
  }, t2.prototype._destroy = function() {
    this._cleanupDrag();
  }, t2.defaults = { select: "single" }, t2._name = "SegmentedGroup", t2;
}(wt)), Ni = 1, Li = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._setBox = function(e4) {
      t3._box = e4;
    }, t3;
  }
  return c$3(t2, e3), Object.defineProperty(t2.prototype, "checked", { get: function() {
    return this._checked;
  }, set: function(e4) {
    this._toggle(e4);
  }, enumerable: true, configurable: true }), t2.prototype._template = function(e4, t3) {
    var n2 = this;
    return ls(Ci.Consumer, null, function(s2) {
      return n2._groupOptions(s2), ls("label", { className: n2._cssClass }, ls("input", { ref: n2._setEl, "aria-labelledby": n2._id, checked: n2._checked, className: "mbsc-segmented-input mbsc-reset " + (e4.inputClass || "") + n2._theme + (n2._checked ? " mbsc-selected" : ""), disabled: n2._disabled, name: n2._isMultiple ? e4.name : n2._name, onChange: ae, type: n2._isMultiple ? "checkbox" : "radio", value: n2._value }), ls("div", { ref: n2._setBox, className: "mbsc-segmented-selectbox" + n2._theme + (n2._animate ? " mbsc-segmented-selectbox-animate" : "") + (n2._checked ? " mbsc-selected" : "") }, ls("div", { className: "mbsc-segmented-selectbox-inner" + n2._theme + (n2._index === n2._selectedIndex || n2._checked ? " mbsc-segmented-selectbox-inner-visible" : "") + (n2._checked ? " mbsc-selected" : "") })), ls(Is, { "aria-hidden": true, ariaLabel: e4.ariaLabel, className: "mbsc-segmented-button" + (n2._checked ? " mbsc-selected" : "") + (t3.hasFocus ? " mbsc-focus" : ""), color: n2._color, disabled: n2._disabled, endIcon: e4.endIcon, endIconSrc: e4.endIconSrc, endIconSvg: e4.endIconSvg, icon: e4.icon, iconSrc: e4.iconSrc, iconSvg: e4.iconSvg, id: n2._id, ripple: e4.ripple, rtl: e4.rtl, startIcon: e4.startIcon, startIconSrc: e4.startIconSrc, startIconSvg: e4.startIconSvg, tag: "span", tabIndex: -1, theme: e4.theme, themeVariant: e4.themeVariant }, e4.children));
    });
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._id = "mbsc-segmented-" + Ni++, t3._onChange = function(e4) {
      var n2 = t3.s, s2 = e4.target.checked;
      s2 !== t3._checked && (t3._change(s2), t3._onGroupChange && t3._onGroupChange(e4, t3._value), t3._toggle(s2), n2.onChange && n2.onChange(e4));
    }, t3._onValueChange = function(e4) {
      var n2 = t3.s, s2 = t3._isMultiple ? e4 && -1 !== e4.indexOf(t3._value) : e4 === t3._value;
      void 0 === n2.checked && s2 !== t3.state.selected ? t3.setState({ selected: s2 }) : t3.forceUpdate(), t3._change(s2);
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._change = function(e4) {
  }, t2.prototype._toggle = function(e4) {
    void 0 === this.s.checked && this.setState({ selected: e4 });
  }, t2.prototype._groupOptions = function(e4) {
    var t3 = this, n2 = e4.color, s2 = e4.disabled, i = e4.name, a2 = e4.onChange, r2 = e4.select, o3 = e4.value, l2 = this.s, c2 = this.state, d2 = this._checked, h2 = void 0 !== l2.checked ? ne(l2.checked) : void 0 === c2.selected ? ne(l2.defaultChecked) : c2.selected;
    this._value = void 0 === l2.value ? this._id : l2.value, this._onGroupChange = a2, this._isMultiple = "multiple" === (r2 || l2.select), this._name = void 0 === i ? l2.name : i, this._disabled = void 0 === s2 ? void 0 === l2.disabled ? c2.disabled : ne(l2.disabled) : ne(s2), this._color = void 0 === n2 ? l2.color : n2, this._checked = void 0 === o3 ? h2 : this._isMultiple ? o3 && -1 !== o3.indexOf(this._value) : o3 === this._value, this._name && !this._unsubscribe && (this._unsubscribe = Ti(this._name, this._onValueChange)), this._isMultiple || d2 || !this._checked || setTimeout(function() {
      t3._checked && Si(t3._name, t3._value, t3._index);
    }), this._selectedIndex = Ei(this._name), this._cssClass = "mbsc-segmented-item " + this._className + this._theme + this._rtl + (this._checked ? " mbsc-segmented-item-checked" : "") + (c2.hasFocus ? " mbsc-focus" : "") + (this._index === this._selectedIndex || void 0 === this._index && this._checked || this._isMultiple && this._checked ? " mbsc-segmented-item-selected" : "");
  }, t2.prototype._mounted = function() {
    var e4 = this;
    Bt(this._el, dn, this._onChange), this._unlisten = Ds(this._el, { onBlur: function() {
      e4.setState({ hasFocus: false });
    }, onFocus: function() {
      e4.setState({ hasFocus: true });
    } });
  }, t2.prototype._updated = function() {
    if (!this._isMultiple) {
      var e4 = sn(this._el, ".mbsc-segmented"), t3 = -1, n2 = -1;
      if (e4)
        for (var s2 = e4.querySelectorAll('.mbsc-segmented-input[name="' + this._name + '"]'), i = 0; i < s2.length; i++)
          s2[i] === this._el && (t3 = i), s2[i].checked && (n2 = i);
      this._index !== t3 && -1 !== n2 && function(e6, t4) {
        wi[e6] && (wi[e6].selectedIndex = t4);
      }(this._name, n2), -1 !== this._selectedIndex && (this._box.style.transform = "translateX(" + (this.s.rtl ? -1 : 1) * (this._selectedIndex - t3) * 100 + "%)", this._animate = true), -1 !== t3 && (this._index = t3);
    }
  }, t2.prototype._destroy = function() {
    ki(this._name, this._unsubscribe), Xt(this._el, dn, this._onChange), this._unlisten();
  }, t2.defaults = { select: "single" }, t2._name = "Segmented", t2;
}(wt));
function Oi(e3) {
  var t2 = e3.disabled, n2 = e3.selected, s2 = e3.theme, i = e3.timeSlot, a2 = e3.onClick, r2 = e3.onKeyDown;
  return ls("div", { className: "mbsc-timegrid-item" + (n2 ? " mbsc-selected" : "") + (t2 ? " mbsc-disabled" : "") + s2, onClick: function() {
    return a2(i);
  }, onKeyDown: r2, tabIndex: t2 ? void 0 : 0, "data-timeslot": i.value }, i.formattedValue);
}
var Ri = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._setCont = function(e4) {
      t3._gridContEl = e4 && e4.parentElement;
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    var t3 = this;
    return ls("div", { className: this._cssClass, ref: this._setCont }, this._timeSlots.map(function(e6, n2) {
      return ls("div", { className: "mbsc-timegrid-row", key: n2 }, e6.map(function(e7, n3) {
        var s2 = t3._isDisabled(e7.value);
        return ls("div", { className: "mbsc-timegrid-cell" + (s2 ? " mbsc-disabled" : ""), key: n3 }, ls(Oi, { disabled: s2, onKeyDown: t3._onKeyDown, selected: t3._value === e7.value, timeSlot: e7, onClick: t3._setTime, theme: t3._theme }));
      }));
    }));
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._setTime = function(e4) {
      t3._hook("onChange", { value: Je(t3.s, e4.value) });
    }, t3._isDisabled = function(e4) {
      if (e4) {
        var n2 = Pe(Je(t3.s, e4)), s2 = t3._invalids && t3._invalids[n2], i = t3._valids && t3._valids[n2], a2 = t3.s.exclusiveEndDates;
        if (i) {
          for (var r2 = 0, o3 = i; r2 < o3.length; r2++) {
            var l2 = o3[r2], c2 = l2.end && (a2 ? e4 < +l2.end : e4 <= +l2.end);
            if (l2.start && e4 >= +l2.start && c2 || l2.allDay)
              return false;
          }
          return true;
        }
        if (s2) {
          for (var d2 = 0, h2 = s2; d2 < h2.length; d2++) {
            var u2 = h2[d2];
            c2 = u2.end && (a2 ? e4 < +u2.end : e4 <= +u2.end);
            if (u2.start && e4 >= +u2.start && c2 || u2.allDay)
              return true;
          }
          return false;
        }
      }
      return false;
    }, t3._onKeyDown = function(e4) {
      if (32 === e4.keyCode)
        e4.target.click(), e4.preventDefault();
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._render = function(e4, t3) {
    var n2 = this, s2 = this._prevS;
    this._cssClass = "mbsc-timegrid-container mbsc-font" + this._theme + this._rtl;
    var i = e4.min !== s2.min, a2 = e4.max !== s2.max, r2 = e4.timeFormat, o3 = s2.value && !e4.value || e4.value && +e4.value !== this._value;
    i && (this._min = Q(e4.min) ? void 0 : Ze(e4.min, e4, r2)), a2 && (this._max = Q(e4.max) ? void 0 : Ze(e4.max, e4, r2));
    var l2 = ze(e4.value || Je(e4)), c2 = it(l2, 1), d2 = this._selectedDate !== +l2, h2 = e4.invalid !== s2.invalid, u2 = e4.valid !== s2.valid;
    (h2 || d2) && (this._invalids = Bn(e4.invalid, l2, c2, e4, true)), (u2 || d2) && (this._valids = Bn(e4.valid, l2, c2, e4, true)), o3 && (this._value = e4.value && +e4.value);
    var _2 = d2 || h2 || i || a2 || r2 !== s2.timeFormat;
    if (_2) {
      this._selectedDate = +l2;
      var m2 = Math.max(+l2, +(this._min || -1 / 0)), p2 = Math.min(+c2, +(this._max || 1 / 0) + 1), v2 = 36e5 * e4.stepHour + 6e4 * e4.stepMinute;
      this._timeSlots = [], this._validTimes = [];
      for (var f2 = [], g2 = 0, y2 = +l2; y2 < +c2; y2 += v2)
        if (p2 >= m2 ? y2 >= m2 && y2 < p2 : y2 >= m2 || y2 < p2) {
          var b2 = { formattedValue: et(r2, Je(e4, y2), e4), value: y2 };
          f2.push(b2), 2 === g2 && (this._timeSlots.push(f2), f2 = [], g2 = -1), this._isDisabled(y2) || this._validTimes.push(b2), g2++;
        }
      f2.length && this._timeSlots.push(f2);
    }
    if (this._isDisabled(this._value) || (o3 || _2) && -1 === pe(this._validTimes, function(e6) {
      return e6.value === n2._value;
    })) {
      var D2 = function(e6, t4) {
        if (null == t4 || !e6.length)
          return null;
        for (var n3 = 0; n3 < e6.length && t4 >= e6[n3]; )
          n3++;
        if (n3 === e6.length)
          return e6[n3 - 1];
        if (0 === n3)
          return e6[0];
        var s3 = e6[n3 - 1], i2 = e6[n3];
        return t4 - s3 < i2 - t4 ? s3 : i2;
      }(this._validTimes.map(function(e6) {
        return e6.value;
      }), this._value);
      D2 && (clearTimeout(this._validationHandle), this._validationHandle = setTimeout(function() {
        var e6 = me(n2._validTimes, function(e7) {
          return e7.value === D2;
        });
        n2._setTime(e6);
      }));
    } else
      _2 && clearTimeout(this._validationHandle);
    this._valueChanged = this._valueChanged || o3;
  }, t2.prototype._updated = function() {
    if (void 0 !== this._value && (this._valueChanged || this._isOpen !== this.s.isOpen && this.s.isOpen)) {
      var e4 = void 0 !== this._lastValue, t3 = this._gridContEl, n2 = t3.querySelector('[data-timeslot="' + this._value + '"]');
      n2 && setTimeout(function() {
        var s2 = n2.getBoundingClientRect(), i = s2.top, a2 = s2.height, r2 = t3.getBoundingClientRect(), o3 = r2.top, l2 = r2.height, c2 = jt(t3);
        (i + a2 > o3 + l2 || i < o3) && en(t3, void 0, i - o3 + c2 - 5, e4);
      }), this._valueChanged = false, this._lastValue = this._value;
    }
    this._isOpen = this.s.isOpen;
  }, t2.defaults = d$2({}, Ee, { stepHour: 0, stepMinute: 30 }), t2._name = "Timegrid", t2;
}(wt));
Qn.Datetime = xi, Qn.Calendar = ii, Qn.Timegrid = Ri;
var Vi = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    var t3 = this, n2 = this._renderTabs, s2 = this._controls, i = this._activeSelect, a2 = this._rtl, r2 = this._theme, o3 = ls("div", { className: "mbsc-datepicker mbsc-flex-col mbsc-datepicker-" + e4.display + r2 + ("inline" === e4.display ? " " + this._className : "") + this._controlsClass }, this._headerText && "inline" === e4.display && ls("div", { className: "mbsc-picker-header" + r2 + this._hb }, this._headerText), n2 && ls(Ii, { rtl: e4.rtl, theme: e4.theme, themeVariant: e4.themeVariant, value: this._activeTab, onChange: this._changeActiveTab }, s2.map(function(t4, n3) {
      return ls(Li, { key: n3, rtl: e4.rtl, theme: e4.theme, themeVariant: e4.themeVariant, value: t4.name }, t4.title);
    })), this._renderControls && ls("div", { className: "mbsc-range-control-wrapper" + r2 }, ls(Ii, { theme: e4.theme, themeVariant: e4.themeVariant, rtl: e4.rtl, value: i, onChange: this._changeActiveSelect }, ls(Li, { rtl: e4.rtl, theme: e4.theme, themeVariant: e4.themeVariant, value: "start", className: "mbsc-range-start" + (this._tempStartText ? " mbsc-range-value-nonempty" : "") }, ls("div", { className: "mbsc-range-control-label" + r2 + a2 + ("start" === i ? " active" : "") }, e4.rangeStartLabel), ls("div", { className: "mbsc-range-control-value" + r2 + a2 + ("start" === i ? " active" : "") + (this._tempStartText ? "" : " mbsc-range-control-text-empty") }, this._tempStartText || e4.rangeStartHelp), "start" === i && this._tempStartText && ls(us, { className: "mbsc-range-label-clear" + a2, onClick: this._clearStart, svg: e4.clearIcon, theme: e4.theme })), ls(Li, { rtl: e4.rtl, theme: e4.theme, themeVariant: e4.themeVariant, value: "end", className: "mbsc-range-end" + (this._tempEndText ? " mbsc-range-value-nonempty" : "") }, ls("div", { className: "mbsc-range-control-label" + r2 + a2 + ("end" === i ? " active" : "") }, e4.rangeEndLabel), ls("div", { className: "mbsc-range-control-value" + r2 + a2 + ("end" === i ? " active" : "") + (this._tempEndText ? "" : " mbsc-range-control-text-empty") }, this._tempEndText || e4.rangeEndHelp), "end" === i && this._tempEndText && ls(us, { className: "mbsc-range-label-clear" + a2, onClick: this._clearEnd, svg: e4.clearIcon, theme: e4.theme })))), ls("div", { className: "mbsc-datepicker-tab-wrapper mbsc-flex-1-1" + r2, ref: this._setWrapper }, s2.map(function(e6, i2) {
      return ls("div", { key: i2, className: "mbsc-datepicker-tab mbsc-datepicker-tab-" + e6.name + r2 + (n2 && e6.name === t3._activeTab || !n2 ? " mbsc-datepicker-tab-active" : "") + (n2 && "time" === e6.name ? " mbsc-datepicker-time-modal" : "") + (n2 || 1 === s2.length ? " mbsc-datepicker-tab-expand" : "") }, ls(e6.Component, d$2({}, e6.options)));
    })));
    return Hs(this, e4, o3);
  }, t2;
}(rs);
var Wi = new v$3();
function Fi(e3) {
  return Wi.subscribe(e3);
}
function Ai(e3) {
  Wi.unsubscribe(e3);
}
var Xi = 1;
function Ki(e3, t2, n2, s2, i, a2) {
  var r2 = n2, o3 = s2, l2 = /* @__PURE__ */ new Map(), c2 = [];
  i && (r2 = Ze(i, t2)), a2 ? o3 = Ze(a2, t2) : i && (o3 = it(r2, 1));
  var h2 = Bn(e3, r2, o3, t2);
  for (var u2 in h2)
    if (u2)
      for (var _2 = 0, m2 = h2[u2]; _2 < m2.length; _2++) {
        var p2 = m2[_2], v2 = Ze(p2.start, t2), f2 = Ze(p2.end, t2) || v2;
        if (p2.start) {
          if (!l2.has(p2) && He(r2, o3, v2, f2)) {
            var g2 = d$2({}, p2);
            (t2.dataTimezone || t2.displayTimezone) && (g2.start = v2.toISOString(), g2.end = f2.toISOString()), l2.set(p2, true), c2.push(g2);
          }
        } else
          c2.push(p2);
      }
  return c2;
}
function qi() {
  return "mbsc_" + Xi++;
}
function Gi(e3, t2, n2, s2, i, a2, r2, o3, l2, c2, d2) {
  var h2 = t2.color || o3 && o3.color, u2 = t2.start || t2.date, _2 = t2.recurring ? t2.original.start : t2.start, m2 = t2.allDay || !_2, p2 = u2 ? Ze(u2, m2 ? void 0 : e3) : null, v2 = t2.end ? Ze(t2.end, m2 ? void 0 : e3) : null, f2 = Ve(e3, t2.allDay, p2, v2, l2), g2 = p2 && f2 && !Ue(p2, f2), y2 = !g2 || Ue(p2, n2), b2 = !g2 || Ue(f2, n2), D2 = m2 || !c2 && g2 && !y2 && !b2, x2 = d2 || !p2 || m2 ? "" : et(i, p2, e3), C2 = d2 || !v2 || m2 ? "" : et(i, v2, e3), w2 = d2 || D2 || !y2 && !c2 ? "" : x2, T2 = d2 || D2 || !b2 && !c2 ? "" : C2, k2 = t2.title || t2.text || "", S2 = k2, E2 = S2 + (D2 ? "" : ", " + w2 + " - " + T2), M2 = "DDDD, MMMM D, YYYY", I2 = !d2 && p2 ? ", " + e3.fromText + ": " + et(M2, p2, e3) + (m2 ? "" : ", " + x2) : "", N2 = !d2 && v2 ? ", " + e3.toText + ": " + et(M2, v2, e3) + (m2 ? "" : ", " + C2) : "";
  return { allDay: m2, allDayText: D2 ? a2 : "", ariaLabel: S2 + (o3 && o3.name ? ", " + o3.name : "") + I2 + N2, color: h2, currentResource: o3, date: +n2, end: T2, endDate: v2 || (p2 ? new Date(p2) : null), html: k2, id: t2.id, isMultiDay: g2, lastDay: !D2 && g2 && b2 ? r2 : "", original: t2, position: {}, resource: t2.resource, slot: t2.slot, start: w2, startDate: p2, style: { background: h2, color: s2 && h2 ? $t(h2) : "" }, title: S2, tooltip: e3.showEventTooltip ? t2.tooltip || E2 : void 0, uid: t2.occurrenceId ? t2.occurrenceId : t2.id };
}
function ji(e3) {
  var t2 = [];
  if (e3)
    for (var n2 = 0, s2 = e3; n2 < s2.length; n2++) {
      var i = s2[n2];
      void 0 === i.id && (i.id = qi()), t2.push(i);
    }
  return t2;
}
function Ji(e3, t2, n2, s2, i, a2, r2, o3, l2) {
  if ("start-end" === o3) {
    var c2 = Xn(e3, s2, t2, n2, a2, r2), d2 = Xn(e3, i, t2, n2, a2, r2);
    if (c2)
      return c2;
    if (d2)
      return d2;
  } else
    for (var h2 = l2 ? i : ze(it(i, 1)), u2 = ze(s2); u2 < h2; u2.setDate(u2.getDate() + 1)) {
      var _2 = Xn(e3, u2, t2, n2, a2, r2);
      if (_2)
        return _2;
    }
  return false;
}
var Zi = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3.state = { activeDate: void 0, eventList: [], popoverList: [], selectedDate: void 0 }, t3.print = ae, t3._navService = new si(), t3._pageLoad = 0, t3._selectedDates = {}, t3._shouldScrollSchedule = 0, t3._update = 0, t3._onScroll = de(function() {
      if (!t3._isListScrolling && !t3._viewChanged) {
        for (var e4 in t3._listDays)
          if (t3._listDays[e4]) {
            var n2 = t3._listDays[e4];
            if (n2.offsetTop + n2.offsetHeight - t3._list.scrollTop > 0) {
              +e4 !== t3._selected && (t3._shouldSkipScroll = true, t3.setState({ selectedDate: +e4 }), t3._selectedChange(/* @__PURE__ */ new Date(+e4)));
              break;
            }
          }
      }
    }), t3._isListScrolling = 0, t3._onWeekDayClick = function(e4) {
      e4 !== t3._selected && (t3._skipScheduleScroll = true, t3.setState({ selectedDate: e4 }), t3._selectedChange(new Date(e4)));
    }, t3._onDayClick = function(e4) {
      var n2 = e4.date, s2 = +n2, i = Pe(n2), a2 = t3.state, r2 = ft(t3._eventMap[i], t3.s.eventOrder), o3 = t3._showEventPopover, l2 = void 0 === o3 ? !t3._showEventLabels && !t3._showEventList && !t3._showSchedule : o3, c2 = false !== o3 && t3._moreLabelClicked, d2 = (l2 || c2) && (!a2.showPopover || a2.showPopover && s2 !== a2.popoverDate) && r2 && r2.length > 0;
      e4.events = r2, t3._isEventClick || t3._resetSelection(), t3._navService.preventPageChange = !t3._showEventList, t3._hook("onCellClick", e4), t3._moreLabelClicked = false, e4.disabled || (t3.setState({ selectedDate: s2 }), s2 !== t3._selected && (t3._skipScheduleScroll = true, t3._selectedChange(n2))), d2 && setTimeout(function() {
        t3._anchor = e4.target, t3._popoverClass = t3._popoverClass.replace(" mbsc-popover-hidden", ""), t3.setState({ popoverDate: s2, popoverList: r2.map(function(e6) {
          return t3._getEventData(e6, n2);
        }), showPopover: true });
      }), t3._isEventClick = false;
    }, t3._onActiveChange = function(e4) {
      var n2 = t3._getValidDay(e4.date, e4.dir), s2 = { activeDate: n2 };
      t3._active = n2, t3._update++, t3._skipScheduleScroll = e4.pageChange && !e4.nav, (e4.pageChange || e4.today) && (s2.selectedDate = n2, t3._selectedChange(new Date(n2)), t3._navService.forcePageChange = true), t3.setState(s2);
    }, t3._onGestureStart = function(e4) {
      t3._hidePopover();
    }, t3._onDayDoubleClick = function(e4) {
      t3._dayClick("onCellDoubleClick", e4);
    }, t3._onDayRightClick = function(e4) {
      t3._dayClick("onCellRightClick", e4);
    }, t3._onCellHoverIn = function(e4) {
      e4.events = t3._eventMap[Pe(e4.date)], t3._hook("onCellHoverIn", e4);
    }, t3._onCellHoverOut = function(e4) {
      e4.events = t3._eventMap[Pe(e4.date)], t3._hook("onCellHoverOut", e4);
    }, t3._onEventHoverIn = function(e4) {
      t3._hoverTimer = setTimeout(function() {
        t3._isHover = true, t3._eventClick("onEventHoverIn", e4);
      }, 150);
    }, t3._onEventHoverOut = function(e4) {
      clearTimeout(t3._hoverTimer), t3._isHover && (t3._isHover = false, t3._eventClick("onEventHoverOut", e4));
    }, t3._onEventClick = function(e4) {
      var n2 = t3.s;
      t3._handleMultipleSelect(e4), false === t3._eventClick("onEventClick", e4) || n2.selectMultipleEvents || n2.eventDelete || (n2.dragToCreate || n2.clickToCreate) && false !== n2.eventDelete || t3._hidePopover();
    }, t3._onEventDoubleClick = function(e4) {
      t3._eventClick("onEventDoubleClick", e4);
    }, t3._onEventRightClick = function(e4) {
      t3._eventClick("onEventRightClick", e4);
    }, t3._onEventDragEnd = function(e4) {
      t3._hook("onEventDragEnd", e4);
    }, t3._onEventDragStart = function(e4) {
      t3._hook("onEventDragStart", e4);
    }, t3._onLabelHoverIn = function(e4) {
      t3._hoverTimer = setTimeout(function() {
        t3._isHover = true, t3._labelClick("onEventHoverIn", e4);
      }, 150);
    }, t3._onLabelHoverOut = function(e4) {
      clearTimeout(t3._hoverTimer), t3._isHover && (t3._isHover = false, t3._labelClick("onEventHoverOut", e4));
    }, t3._onLabelClick = function(e4) {
      t3._handleMultipleSelect(e4), t3._hook("onLabelClick", e4), t3._labelClick("onEventClick", e4), t3._isEventClick = true, e4.label || (t3._moreLabelClicked = true);
    }, t3._onLabelDoubleClick = function(e4) {
      t3._labelClick("onEventDoubleClick", e4);
    }, t3._onLabelRightClick = function(e4) {
      t3._labelClick("onEventRightClick", e4);
    }, t3._onCellClick = function(e4) {
      t3._resetSelection(), t3._cellClick("onCellClick", e4);
    }, t3._onCellDoubleClick = function(e4) {
      t3._cellClick("onCellDoubleClick", e4);
    }, t3._onCellRightClick = function(e4) {
      t3._cellClick("onCellRightClick", e4);
    }, t3._onPageChange = function(e4) {
      setTimeout(function() {
        t3._hidePopover();
      }), t3._isPageChange = true, t3._hook("onPageChange", e4);
    }, t3._onPageLoading = function(e4) {
      var n2 = t3.s, s2 = Bn(t3._events, e4.viewStart, e4.viewEnd, n2);
      t3._colorsMap = Bn(n2.colors, e4.viewStart, e4.viewEnd, n2), t3._invalidsMap = Bn(n2.invalid, e4.viewStart, e4.viewEnd, n2, true), t3._validsMap = Bn(n2.valid, e4.viewStart, e4.viewEnd, n2, true), t3._eventMap = s2, t3._firstDay = Ae(e4.firstDay, n2, t3._firstWeekDay), t3._lastDay = e4.lastDay, t3._labelsMap = t3._marksMap = void 0, n2.labels || !t3._showEventLabels && !t3._showEventCount ? n2.marked || (t3._marksMap = s2) : t3._labelsMap = s2, e4.viewChanged && t3._hook("onPageLoading", e4);
    }, t3._onPageLoaded = function(e4) {
      t3._shouldAnimateScroll = t3._isPageChange, t3._isPageChange = false;
      var n2 = t3._eventListType;
      if (t3._showEventList && (!t3._showCalendar || "day" !== n2)) {
        var s2 = t3.s, i = e4.month, a2 = t3._showEventList && i && "month" === n2, r2 = a2 ? i : e4.firstDay, o3 = a2 ? s2.getDate(s2.getYear(i), s2.getMonth(i) + t3._eventListSize, 1) : e4.lastDay;
        t3._setEventList(r2, o3);
      }
      t3._hook("onPageLoaded", e4);
    }, t3._onPopoverClose = function() {
      t3._hidePopover();
    }, t3._onResize = function(e4) {
      var n2;
      if (t3._showEventList && y$2) {
        var s2 = e4.target, i = s2.offsetHeight, a2 = s2.getBoundingClientRect().top;
        n2 = i - t3._list.getBoundingClientRect().top + a2 > 170;
      }
      t3.setState({ height: e4.height, isListScrollable: n2, width: e4.width });
    }, t3._onSelectedEventsChange = function(e4) {
      t3._emit("selectedEventsChange", e4), t3._hook("onSelectedEventsChange", { events: e4 });
    }, t3._getDragDates = function(e4, n2, s2) {
      for (var i = {}, a2 = t3._firstWeekDay, r2 = Ve(t3.s, s2.allDay, e4, n2, true), o3 = ze(it(r2, 1)), l2 = ze(e4); l2 < o3; l2.setDate(l2.getDate() + 1)) {
        var c2 = l2.getDay(), d2 = a2 - c2 > 0 ? 7 : 0;
        Ue(e4, l2) || c2 === a2 ? i[Pe(l2)] = { event: s2, width: 100 * Math.min(We(l2, r2) + 1, 7 + a2 - c2 - d2) } : i[Pe(l2)] = {};
      }
      return i;
    }, t3._onLabelUpdateModeOn = function(e4) {
      var n2 = e4.create ? t3._tempEvent : e4.data;
      if (n2) {
        var s2 = Ze(n2.start), i = Ze(n2.end || s2);
        t3.setState({ isTouchDrag: true, labelDragData: { draggedEvent: n2, originDates: e4.external ? void 0 : t3._getDragDates(s2, i, n2) } });
      }
    }, t3._onLabelUpdateModeOff = function(e4) {
      var n2 = e4.create ? t3._tempEvent : e4.data;
      t3._hook("onEventDragEnd", { domEvent: e4.domEvent, event: n2, source: "calendar" }), t3.setState({ isTouchDrag: false, labelDragData: void 0 });
    }, t3._onLabelUpdateStart = function(e4) {
      var n2 = t3.s, s2 = t3._el, i = t3._showWeekNumbers ? s2.querySelector(".mbsc-calendar-week-nr").getBoundingClientRect().width : 0, a2 = s2.querySelectorAll(".mbsc-calendar-slide")["all" === t3._calendarLabelList || J(t3._calendarLabelList) ? 0 : 1], r2 = a2.getBoundingClientRect(), o3 = s2.querySelector(".mbsc-calendar-week-days"), l2 = a2.querySelectorAll(".mbsc-calendar-row"), c2 = /click/.test(e4.domEvent.type);
      if (t3._areaTop = 0, o3) {
        var h2 = o3.getBoundingClientRect();
        t3._areaTop = h2.top + h2.height;
      }
      t3._areaLeft = r2.left + (n2.rtl ? 0 : i), t3._areaBottom = r2.top + r2.height, t3._areaRight = t3._areaLeft + r2.width - (n2.rtl ? i : 0), t3._calCellWidth = (t3._areaRight - t3._areaLeft) / 7;
      var u2 = 0;
      if (t3._rowTops = [], l2.forEach(function(n3, s3) {
        var i2 = n3.getBoundingClientRect().top - t3._areaTop;
        t3._rowTops.push(i2), e4.endY - t3._areaTop > i2 && (u2 = s3);
      }), e4.create) {
        var _2 = ce((n2.rtl ? t3._areaRight - e4.endX : e4.endX - t3._areaLeft) / t3._calCellWidth), m2 = it(t3._firstDay, 7 * u2 + _2), p2 = new Date(m2.getFullYear(), m2.getMonth(), m2.getDate()), v2 = it(p2, 1), f2 = n2.exclusiveEndDates ? v2 : new Date(+v2 - 1), g2 = n2.extendDefaultEvent ? n2.extendDefaultEvent({ start: p2 }) : void 0;
        t3._tempEvent = d$2({ allDay: true, end: f2, id: qi(), start: p2, title: n2.newEventText }, e4.event, g2);
      }
      c2 || t3._hook("onEventDragStart", { domEvent: e4.domEvent, event: e4.create ? t3._tempEvent : e4.data, source: "calendar" });
    }, t3._onLabelUpdateMove = function(e4) {
      var n2 = t3.s, s2 = e4.create ? t3._tempEvent : e4.data, i = s2.allDay ? void 0 : n2;
      if (e4.endY > t3._areaTop && e4.endY < t3._areaBottom && e4.endX > t3._areaLeft && e4.endX < t3._areaRight) {
        var a2 = t3.state.labelDragData, r2 = ce((n2.rtl ? t3._areaRight - e4.endX : e4.endX - t3._areaLeft) / t3._calCellWidth), o3 = ce((n2.rtl ? t3._areaRight - e4.startX : e4.startX - t3._areaLeft) / t3._calCellWidth), l2 = 0, c2 = 0;
        t3._rowTops.forEach(function(n3, s3) {
          e4.startY - t3._areaTop > n3 && (c2 = s3), e4.endY - t3._areaTop > n3 && (l2 = s3);
        });
        var h2 = 7 * (l2 - c2) + (r2 - o3);
        if (r2 !== t3._tempDay || l2 !== t3._tempWeek) {
          var u2 = Ze(s2.start, i), _2 = Ze(s2.end, i) || u2, m2 = d$2({}, s2), p2 = u2, v2 = _2;
          if (e4.external) {
            var f2 = Le(u2), g2 = +_2 - +u2;
            p2 = Je(n2, +it(t3._firstDay, 7 * l2 + r2) + f2), v2 = Je(n2, +p2 + g2);
          } else if (e4.drag)
            p2 = it(u2, h2), v2 = it(_2, h2);
          else {
            var y2 = n2.rtl ? -1 : 1, b2 = e4.create ? l2 === c2 ? e4.deltaX * y2 > 0 : h2 > 0 : "end" === e4.direction, D2 = We(u2, _2);
            b2 ? v2 = it(_2, Math.max(-D2, h2)) : p2 = it(u2, Math.min(D2, h2)), v2 < p2 && (b2 ? v2 = Je(i, p2) : p2 = Je(i, v2));
          }
          m2.start = p2, m2.end = v2, /mbsc-popover-hidden/.test(t3._popoverClass) || (t3._popoverClass = t3._popoverClass + " mbsc-popover-hidden"), t3.setState({ labelDragData: { draggedDates: t3._getDragDates(p2, v2, m2), draggedEvent: m2, originDates: a2 && a2.originDates } }), t3._tempDay = r2, t3._tempWeek = l2;
        }
      }
    }, t3._onLabelUpdateEnd = function(e4) {
      var n2 = t3.state, s2 = e4.create, i = n2.labelDragData || {}, a2 = s2 ? t3._tempEvent : e4.data, r2 = i.draggedEvent || a2, o3 = Ze(a2.start), l2 = Ze(a2.end), c2 = Ze(r2.start), d2 = Ze(r2.end), h2 = s2 || +o3 != +c2 || +l2 != +d2, u2 = { allDay: a2.allDay, endDate: d2, original: a2, startDate: c2 }, _2 = e4.action || (i.draggedEvent ? "drag" : "click"), m2 = !h2 || t3._onEventDragStop({ action: _2, collision: Ji(t3.s, t3._invalidsMap, t3._validsMap, c2, d2, t3._minDate, t3._maxDate, t3.s.invalidateEvent, t3.s.exclusiveEndDates), create: s2, domEvent: e4.domEvent, event: u2, source: "calendar" }), p2 = n2.isTouchDrag && (!s2 || m2);
      p2 || "click" === _2 || t3._hook("onEventDragEnd", { domEvent: e4.domEvent, event: a2, source: "calendar" }), t3.setState({ isTouchDrag: p2, labelDragData: p2 ? { draggedEvent: r2, originDates: m2 ? t3._getDragDates(c2, d2, u2.original) : i.originDates } : {} }), e4.drag && t3._hidePopover(), t3._tempWeek = -1, t3._tempDay = -1;
    }, t3._onEventDragStop = function(e4) {
      var n2 = t3.s, s2 = e4.action, i = e4.resource, a2 = e4.slot, r2 = e4.collision, o3 = e4.create, l2 = e4.source, c2 = e4.event, h2 = c2.original, u2 = h2.recurring ? h2.original : h2, _2 = d$2({}, u2), m2 = d$2({}, u2), p2 = Se(h2.start, n2), v2 = Se(c2.startDate, n2), f2 = Se(c2.endDate, n2), g2 = c2.allDay, y2 = m2.recurring;
      y2 ? m2.recurringException = An(m2.recurringException).concat([p2]) : (m2.allDay = g2, m2.start = v2, m2.end = f2, void 0 !== i && (m2.resource = i), void 0 !== a2 && (m2.slot = a2));
      var b2 = false, D2 = y2 ? d$2({}, u2) : u2;
      return (o3 || y2) && (y2 && delete D2.recurring, (y2 || void 0 === D2.id) && (D2.id = qi()), void 0 !== i && (D2.resource = i), void 0 !== a2 && (D2.slot = a2), D2.start = v2, D2.end = f2, D2.allDay = g2, b2 = false !== t3._hook("onEventCreate", d$2({ action: s2, domEvent: e4.domEvent, event: D2, source: l2 }, y2 && { originEvent: h2 })), false !== r2 && (b2 = false, t3._hook("onEventCreateFailed", d$2({ action: s2, event: D2, invalid: r2, source: l2 }, y2 && { originEvent: h2 })))), o3 && !y2 || (b2 = false !== t3._hook("onEventUpdate", d$2({ domEvent: e4.domEvent, event: m2, oldEvent: _2, source: l2 }, y2 && { newEvent: D2, oldEventOccurrence: h2 })), false !== r2 && (b2 = false, t3._hook("onEventUpdateFailed", d$2({ event: m2, invalid: r2, oldEvent: _2, source: l2 }, y2 && { newEvent: D2, oldEventOccurrence: h2 })))), b2 && ((o3 || y2) && (t3._events.push(D2), t3._triggerCreated = { action: s2, event: D2, source: l2 }), o3 && !y2 || (y2 ? (c2.id = D2.id, c2.original = D2, u2.recurringException = m2.recurringException) : (u2.start = v2, u2.end = f2, u2.allDay = g2, void 0 !== i && (u2.resource = i), void 0 !== a2 && (u2.slot = a2)), t3._triggerUpdated = { event: u2, oldEvent: _2, source: l2 }), t3._refresh = true, "calendar" !== l2 && t3.forceUpdate()), b2;
    }, t3._onExternalDrag = function(e4) {
      if (t3.s.externalDrop && t3._showCalendar)
        switch (e4.eventName) {
          case "onDragModeOff":
            t3._onLabelUpdateModeOff(e4);
            break;
          case "onDragModeOn":
            t3._onLabelUpdateModeOn(e4);
            break;
          case "onDragStart":
            t3._onLabelUpdateStart(e4);
            break;
          case "onDragMove":
            var n2 = e4.clone;
            e4.endY > t3._areaTop && e4.endY < t3._areaBottom && e4.endX > t3._areaLeft && e4.endX < t3._areaRight ? (n2.style.display = "none", t3._onLabelUpdateMove(e4), t3._onCalendar = true) : t3._onCalendar && (n2.style.display = "table", t3.setState({ labelDragData: {} }), t3._tempWeek = -1, t3._tempDay = -1, t3._onCalendar = false);
            break;
          case "onDragEnd":
            e4.endY > t3._areaTop && e4.endY < t3._areaBottom && e4.endX > t3._areaLeft && e4.endX < t3._areaRight ? t3._onLabelUpdateEnd(e4) : (t3.setState({ labelDragData: void 0 }), t3._hook("onEventDragEnd", { domEvent: e4.domEvent, event: e4.event, source: "calendar" }));
        }
    }, t3._onEventDelete = function(e4) {
      var n2, s2 = t3.s;
      if ((void 0 !== s2.eventDelete || s2.dragToCreate || s2.clickToCreate) && false !== s2.eventDelete) {
        for (var i, a2, r2, o3 = false, l2 = false, c2 = false, h2 = e4.event, u2 = h2, _2 = s2.selectMultipleEvents, m2 = _2 ? t3._selectedEventsMap : ((n2 = {})[h2.id] = h2, n2), p2 = [], v2 = [], f2 = [], g2 = {}, y2 = [], b2 = 0, D2 = ge(m2); b2 < D2.length; b2++) {
          var x2 = D2[b2];
          if (x2.recurring) {
            u2 = x2, l2 = true;
            var C2 = (i = x2.original).id;
            g2[C2] ? r2 = g2[C2] : (a2 = d$2({}, i), r2 = d$2({}, i), v2.push(i), p2.push(a2), f2.push(r2), g2[C2] = r2);
            var w2 = Se(x2.start, s2);
            r2.recurringException = An(r2.recurringException).concat([w2]);
          } else
            c2 = true, h2 = x2, y2.push(x2);
        }
        if (l2) {
          if (false !== t3._hook("onEventUpdate", { domEvent: e4.domEvent, event: r2, events: _2 ? f2 : void 0, isDelete: true, oldEvent: _2 ? void 0 : a2, oldEventOccurrence: u2, oldEvents: _2 ? p2 : void 0 })) {
            o3 = true;
            for (var T2 = 0, k2 = v2; T2 < k2.length; T2++) {
              var S2 = k2[T2], E2 = g2[S2.id];
              S2.recurringException = E2.recurringException;
            }
            t3._triggerUpdated = { event: i, events: _2 ? v2 : void 0, oldEvent: _2 ? void 0 : a2, oldEvents: _2 ? p2 : void 0, source: e4.source };
          }
        }
        if (c2)
          false !== t3._hook("onEventDelete", { domEvent: e4.domEvent, event: h2, events: _2 ? y2 : void 0 }) && (o3 = true, t3._events = t3._events.filter(function(e6) {
            return !m2[e6.id];
          }), t3._selectedEventsMap = {}, t3._triggerDeleted = { event: h2, events: _2 ? y2 : void 0, source: e4.source });
        o3 && (t3._hidePopover(), t3.refresh());
      }
    }, t3._onKeyDown = function(e4) {
      9 === e4.keyCode && t3._resetSelection();
    }, t3;
  }
  return c$3(t2, e3), t2.prototype.addEvent = function(e4) {
    for (var t3 = [], n2 = 0, s2 = ji(j(e4) ? e4 : [e4]); n2 < s2.length; n2++) {
      var i = s2[n2];
      t3.push("" + i.id), this._events.push(i);
    }
    return this.refresh(), t3;
  }, t2.prototype.getEvents = function(e4, t3) {
    return Ki(this._events, this.s, this._firstDay, this._lastDay, e4, t3);
  }, t2.prototype.getInvalids = function(e4, t3) {
    return Ki(this.s.invalid, this.s, this._firstDay, this._lastDay, e4, t3);
  }, t2.prototype.getSelectedEvents = function() {
    return ge(this._selectedEventsMap);
  }, t2.prototype.setEvents = function(e4) {
    for (var t3 = [], n2 = ji(e4), s2 = 0, i = n2; s2 < i.length; s2++) {
      var a2 = i[s2];
      t3.push("" + a2.id);
    }
    return this._events = n2, this.refresh(), t3;
  }, t2.prototype.setSelectedEvents = function(e4) {
    this._selectedEventsMap = (e4 || []).reduce(function(e6, t3) {
      return t3.occurrenceId ? e6[t3.occurrenceId] = t3 : e6[t3.id] = t3, e6;
    }, {}), this.forceUpdate();
  }, t2.prototype.removeEvent = function(e4) {
    for (var t3 = j(e4) ? e4 : [e4], n2 = this._events, s2 = n2.length, i = 0, a2 = t3; i < a2.length; i++)
      for (var r2 = a2[i], o3 = false, l2 = 0; !o3 && l2 < s2; ) {
        var c2 = n2[l2];
        c2.id !== r2 && c2.id !== r2.id || (o3 = true, n2.splice(l2, 1)), l2++;
      }
    this.refresh();
  }, t2.prototype.navigateToEvent = function(e4) {
    this._navigateToEvent = e4, this._shouldScrollSchedule++, this.navigate(e4.start, true);
  }, t2.prototype.navigate = function(e4, t3) {
    var n2 = +Ze(e4), s2 = n2 !== this._selectedDateTime || void 0 !== this._navigateToEvent;
    s2 && (this._shouldAnimateScroll = !!t3), void 0 === this.s.selectedDate ? !this._showSchedule && !this._showTimeline || s2 ? this.setState({ selectedDate: n2 }) : (this._shouldScrollSchedule++, this.forceUpdate()) : s2 && this._selectedChange(e4);
  }, t2.prototype.updateEvent = function(e4) {
    for (var t3 = j(e4) ? e4 : [e4], n2 = this._events, s2 = n2.length, i = 0, a2 = t3; i < a2.length; i++)
      for (var r2 = a2[i], o3 = false, l2 = 0; !o3 && l2 < s2; ) {
        n2[l2].id === r2.id && (o3 = true, n2.splice(l2, 1, d$2({}, r2))), l2++;
      }
    this.refresh();
  }, t2.prototype.refresh = function() {
    this._refresh = true, this.forceUpdate();
  }, t2.prototype._render = function(e4, t3) {
    var n2, s2, i, a2 = this, r2 = this._prevS, o3 = this._showDate, l2 = e4.displayTimezone !== r2.displayTimezone || e4.dataTimezone !== r2.dataTimezone, c2 = false;
    if (this._colorEventList = void 0 === e4.eventTemplate && void 0 === e4.renderEvent && e4.colorEventList, void 0 === e4.exclusiveEndDates && (e4.exclusiveEndDates = !!e4.displayTimezone), Q(e4.min) ? this._minDate = -1 / 0 : r2.min !== e4.min && (this._minDate = +Ze(e4.min)), Q(e4.max) ? this._maxDate = 1 / 0 : r2.max !== e4.max && (this._maxDate = +Ze(e4.max)), void 0 !== e4.selectedDate ? s2 = +Ze(e4.selectedDate) : (this._defaultDate || (this._defaultDate = +(void 0 !== e4.defaultSelectedDate ? Ze(e4.defaultSelectedDate) : je(Je(e4)))), s2 = t3.selectedDate || this._defaultDate), this.eventList = t3.eventList, e4.data !== r2.data && (this._events = ji(e4.data), this._refresh = true), (e4.invalid !== r2.invalid || e4.colors !== r2.colors || l2) && (this._refresh = true), e4.view !== r2.view || e4.firstDay !== r2.firstDay) {
      var d2 = e4.firstDay, h2 = e4.view || {}, u2 = h2.agenda || {}, _2 = h2.calendar || {}, m2 = h2.schedule || {}, p2 = h2.timeline || {}, v2 = +(u2.size || 1), f2 = u2.type || "month", g2 = +(m2.size || 1), y2 = m2.type || "week", b2 = void 0 !== m2.startDay ? m2.startDay : d2, D2 = void 0 !== m2.endDay ? m2.endDay : (d2 + 6) % 7, x2 = m2.startTime, C2 = m2.endTime, w2 = m2.timeCellStep || 60, T2 = m2.timeLabelStep || 60, k2 = m2.timezones, S2 = !!h2.calendar, E2 = _2.count, M2 = !!h2.agenda, I2 = !!h2.schedule, N2 = void 0 !== m2.days ? m2.days : !S2 && I2 && !("day" === y2 && e4.resources && e4.resources.length > 0 && g2 < 2), L2 = !!h2.timeline, H2 = p2.weekNumbers, O2 = void 0 !== p2.startDay ? p2.startDay : d2, R2 = void 0 !== p2.endDay ? p2.endDay : (d2 + 6) % 7, V2 = p2.startTime, P2 = p2.endTime, z2 = L2 && !!e4.slots && e4.slots.length > 0, Y2 = p2.eventList || z2, W2 = +(p2.size || 1), F2 = p2.type || "week", A2 = "month" === F2 || "year" === F2 || Y2 ? 1440 : 60, U2 = z2 ? A2 : p2.timeCellStep || A2, B2 = z2 ? A2 : p2.timeLabelStep || A2, X2 = _2.type || "month", K2 = void 0 !== _2.labels ? !!_2.labels : !(M2 || I2 || L2 || e4.marked || "year" === X2 || "month" === X2 && _2.size);
      this._calendarScroll = _2.scroll, this._calendarSize = _2.size || 1, this._calendarLabelList = _2.labels, this._calendarType = X2, this._showEventPopover = _2.popover, this._showOuterDays = _2.outerDays, this._showWeekNumbers = _2.weekNumbers, this._popoverClass = _2.popoverClass || "", this._showScheduleAllDay = void 0 === m2.allDay || m2.allDay, v2 === this._eventListSize && f2 === this._eventListType && S2 === this._showCalendar && E2 === this._showEventCount && K2 === this._showEventLabels && M2 === this._showEventList && g2 === this._scheduleSize && y2 === this._scheduleType && I2 === this._showSchedule && N2 === this._showScheduleDays && b2 === this._scheduleStartDay && D2 === this._scheduleEndDay && x2 === this._scheduleStartTime && C2 === this._scheduleEndTime && w2 === this._scheduleTimeCellStep && T2 === this._scheduleTimeLabelStep && L2 === this._showTimeline && O2 === this._timelineStartDay && R2 === this._timelineEndDay && V2 === this._timelineStartTime && P2 === this._timelineEndTime && W2 === this._timelineSize && F2 === this._timelineType && U2 === this._timelineTimeCellStep && B2 === this._timelineTimeLabelStep && Y2 === this._timelineListing || (this._refresh = true), this._eventListSize = v2, this._eventListType = f2, this._scheduleType = y2, this._showCalendar = S2, this._showEventCount = E2, this._showEventLabels = K2, this._showEventList = M2, this._showSchedule = I2, this._showScheduleDays = N2, this._scheduleStartDay = b2, this._scheduleEndDay = D2, this._scheduleStartTime = x2, this._scheduleEndTime = C2, this._scheduleSize = g2, this._scheduleTimeCellStep = w2, this._scheduleTimeLabelStep = T2, this._scheduleTimezones = k2, this._showTimeline = L2, this._showTimelineWeekNumbers = H2, this._timelineSize = W2, this._timelineType = F2, this._timelineStartDay = O2, this._timelineEndDay = R2, this._timelineListing = Y2, this._timelineStartTime = V2, this._timelineEndTime = P2, this._timelineTimeCellStep = U2, this._timelineTimeLabelStep = B2, this._timelineRowHeight = p2.rowHeight, this._rangeType = I2 ? y2 : L2 ? F2 : f2, this._rangeStartDay = I2 ? b2 : L2 ? O2 : void 0, this._rangeEndDay = I2 ? D2 : L2 ? R2 : void 0, this._firstWeekDay = I2 ? b2 : L2 ? O2 : d2, this._viewChanged = true;
    }
    this._showDate = !this._showScheduleDays && (this._showSchedule && "day" === this._scheduleType || this._showEventList && "day" === this._eventListType && this._eventListSize < 2);
    var q2 = this._pageLoad;
    if ((this._refresh || e4.locale !== r2.locale || e4.theme !== r2.theme) && (c2 = true, this._pageLoad++), e4.resources !== r2.resources && (this._resourcesMap = (e4.resources || []).reduce(function(e6, t4) {
      return e6[t4.id] = t4, e6;
    }, {})), e4.selectMultipleEvents && e4.selectedEvents !== r2.selectedEvents && (this._selectedEventsMap = (e4.selectedEvents || []).reduce(function(e6, t4) {
      return t4.occurrenceId ? e6[t4.occurrenceId] = t4 : e6[t4.id] = t4, e6;
    }, {})), void 0 === this._selectedEventsMap && (this._selectedEventsMap = {}), e4.refDate !== r2.refDate && (this._refDate = Ze(e4.refDate)), this._refDate || this._showCalendar || !this._showSchedule && !this._showTimeline || (this._refDate = ze(/* @__PURE__ */ new Date())), s2 !== this._selectedDateTime || this._viewChanged) {
      var j2 = this._showCalendar && (this._showSchedule || this._showTimeline || this._showEventList) ? +Kn(new Date(s2), e4, this._minDate, this._maxDate, void 0, void 0, 1) : G(s2, this._minDate, this._maxDate);
      j2 = this._getValidDay(j2), s2 !== j2 && (s2 = j2, setTimeout(function() {
        a2._selectedChange(new Date(s2));
      })), this._skipScheduleScroll || s2 === this._selectedDateTime || this._shouldScrollSchedule++, this._selectedDateTime = s2;
    }
    (n2 = +(i = ze(new Date(s2)))) === this._selected && o3 === this._showDate && e4.locale === r2.locale && r2.dateFormatLong === e4.dateFormatLong || (this._selectedDateHeader = this._showDate ? et(e4.dateFormatLong, i, e4) : ""), n2 === this._selected && e4.dataTimezone === r2.dataTimezone && e4.displayTimezone === r2.displayTimezone || (this._shouldScroll = !this._isPageChange && !this._shouldSkipScroll, this._shouldAnimateScroll = void 0 !== this._shouldAnimateScroll ? this._shouldAnimateScroll : void 0 !== this._selected, this._selected = n2, this._selectedDates = {}, this._selectedDates[+Ge(e4, new Date(n2))] = true, this._active = n2, c2 = true), c2 && this._showCalendar && ("day" === this._eventListType || "day" === this._scheduleType || "day" === this._timelineType) && this._setEventList(i, it(i, 1)), this._refresh && t3.showPopover && setTimeout(function() {
      a2._hidePopover();
    }), this._refresh = false, this._cssClass = this._className + " mbsc-eventcalendar" + (this._showEventList ? " mbsc-eventcalendar-agenda" : "") + (this._showSchedule ? " mbsc-eventcalendar-schedule" : "") + (this._showTimeline ? " mbsc-eventcalendar-timeline" : ""), this._navService.options({ activeDate: this._active, calendarType: this._calendarType, endDay: this._showSchedule ? this._scheduleEndDay : this._showTimeline ? this._timelineEndDay : this._rangeEndDay, eventRange: this._rangeType, eventRangeSize: this._showSchedule ? this._scheduleSize : this._showTimeline ? this._timelineSize : this._eventListSize, firstDay: e4.firstDay, getDate: e4.getDate, getDay: e4.getDay, getMonth: e4.getMonth, getYear: e4.getYear, max: e4.max, min: e4.min, onPageChange: this._onPageChange, onPageLoading: this._onPageLoading, refDate: this._refDate, showCalendar: this._showCalendar, showOuterDays: this._showOuterDays, size: this._calendarSize, startDay: this._rangeStartDay, weeks: this._calendarSize }, this._pageLoad !== q2);
  }, t2.prototype._mounted = function() {
    this._unsubscribe = Fi(this._onExternalDrag), Bt(this._el, "keydown", this._onKeyDown);
  }, t2.prototype._updated = function() {
    var e4 = this;
    if (this._shouldScroll && this.state.isListScrollable && (this._scrollToDay(), this._shouldScroll = false, this._shouldAnimateScroll = void 0), this._shouldLoadDays && (this._shouldLoadDays = false, rn(this._list.querySelectorAll("[mbsc-timestamp]"), function(t4) {
      e4._listDays[t4.getAttribute("mbsc-timestamp")] = t4;
    })), this._shouldEnhance && (this._shouldEnhance = "popover" === this._shouldEnhance ? this._popoverList : this._list), this._triggerCreated) {
      var t3 = this._triggerCreated, n2 = "calendar" === t3.source ? this._calendarView._body.querySelector('.mbsc-calendar-table-active .mbsc-calendar-text[data-id="' + t3.event.id + '"]') : this._el.querySelector('.mbsc-schedule-event[data-id="' + t3.event.id + '"]');
      this._hook("onEventCreated", d$2({}, this._triggerCreated, { target: n2 })), this._triggerCreated = null;
    }
    if (this._triggerUpdated) {
      var s2 = this._triggerUpdated;
      n2 = "calendar" === s2.source ? this._calendarView._body.querySelector('.mbsc-calendar-table-active .mbsc-calendar-text[data-id="' + s2.event.id + '"]') : this._el.querySelector('.mbsc-schedule-event[data-id="' + s2.event.id + '"]');
      this._hook("onEventUpdated", d$2({}, this._triggerUpdated, { target: n2 })), this._triggerUpdated = null;
    }
    this._triggerDeleted && (this._hook("onEventDeleted", d$2({}, this._triggerDeleted)), this._triggerDeleted = null), this._viewChanged && setTimeout(function() {
      e4._viewChanged = false;
    }, 10), this._shouldSkipScroll && setTimeout(function() {
      e4._shouldSkipScroll = false;
    }), this._skipScheduleScroll = false, this._navigateToEvent = void 0;
  }, t2.prototype._destroy = function() {
    Ai(this._unsubscribe), Xt(this._el, "keydown", this._onKeyDown);
  }, t2.prototype._resetSelection = function() {
    this.s.selectMultipleEvents && Object.keys(this._selectedEventsMap).length > 0 && (this._selectedEventsMap = {}, this._onSelectedEventsChange([]), this.forceUpdate());
  }, t2.prototype._getAgendaEvents = function(e4, t3, n2) {
    var s2 = this, i = [], a2 = this.s;
    if (n2 && this._showEventList)
      for (var r2 = function(e6) {
        var t4 = n2[Pe(e6)];
        if (t4 && t4.length) {
          var r3 = ft(t4, a2.eventOrder);
          i.push({ date: et(a2.dateFormatLong, e6, a2), events: r3.map(function(t5) {
            return s2._getEventData(t5, e6);
          }), timestamp: +e6 });
        }
      }, o3 = ze(e4); o3 < t3; o3.setDate(o3.getDate() + 1))
        r2(o3);
    return i;
  }, t2.prototype._getEventData = function(e4, t3) {
    var n2, s2 = this.s;
    if (!e4.color && e4.resource) {
      var i = j(e4.resource) ? e4.resource : [e4.resource];
      n2 = (this._resourcesMap || {})[i[0]];
    }
    var a2 = Gi(s2, e4, t3, this._colorEventList, s2.timeFormat, s2.allDayText, s2.toText, n2, true);
    return a2.html = this._safeHtml(a2.html), a2;
  }, t2.prototype._getValidDay = function(e4, t3) {
    void 0 === t3 && (t3 = 1);
    var n2 = this._rangeStartDay, s2 = this._rangeEndDay;
    if (!this._showCalendar && "day" === this._rangeType && void 0 !== n2 && void 0 !== s2) {
      var i = new Date(e4), a2 = i.getDay(), r2 = 0;
      if ((s2 < n2 ? a2 > s2 && a2 < n2 : a2 > s2 || a2 < n2) && (r2 = t3 < 0 ? s2 - a2 : n2 - a2), r2)
        return +it(i, r2 += t3 < 0 ? r2 > 0 ? -7 : 0 : r2 < 0 ? 7 : 0);
    }
    return e4;
  }, t2.prototype._setEventList = function(e4, t3) {
    var n2 = this;
    setTimeout(function() {
      n2._eventListHTML = void 0, n2._shouldScroll = true, n2._listDays = null, n2._scrollToDay(0), n2.setState({ eventList: n2._getAgendaEvents(e4, t3, n2._eventMap) });
    });
  }, t2.prototype._hidePopover = function() {
    this.state.showPopover && this.setState({ showPopover: false });
  }, t2.prototype._scrollToDay = function(e4) {
    var t3 = this;
    if (this._list) {
      var n2 = e4, s2 = void 0;
      if (void 0 === e4 && this._listDays) {
        var i = this._listDays[this._selected], a2 = this._navigateToEvent && this._navigateToEvent.id;
        if (i)
          if (void 0 !== a2) {
            var r2 = i.querySelector('.mbsc-event[data-id="' + a2 + '"]'), o3 = i.querySelector(".mbsc-event-day");
            r2 && (n2 = r2.offsetTop - (o3 ? o3.offsetHeight : 0) + 1);
          } else
            n2 = i.offsetTop;
        void 0 !== n2 && (s2 = this._shouldAnimateScroll);
      }
      void 0 !== n2 && (this._isListScrolling++, en(this._list, void 0, n2, s2, false, function() {
        setTimeout(function() {
          t3._isListScrolling--;
        }, 150);
      }));
    }
  }, t2.prototype._selectedChange = function(e4) {
    this._emit("selectedDateChange", e4), this._hook("onSelectedDateChange", { date: e4 });
  }, t2.prototype._cellClick = function(e4, t3) {
    this._hook(e4, d$2({ target: t3.domEvent.currentTarget }, t3));
  }, t2.prototype._dayClick = function(e4, t3) {
    var n2 = Pe(t3.date), s2 = ft(this._eventMap[n2], this.s.eventOrder);
    t3.events = s2, this._hook(e4, t3);
  }, t2.prototype._labelClick = function(e4, t3) {
    t3.label && this._hook(e4, { date: t3.date, domEvent: t3.domEvent, event: t3.label, source: "calendar" });
  }, t2.prototype._eventClick = function(e4, t3) {
    return t3.date = new Date(t3.date), this._hook(e4, t3);
  }, t2.prototype._handleMultipleSelect = function(e4) {
    var t3 = e4.label || e4.event;
    if (t3 && this.s.selectMultipleEvents) {
      var n2 = e4.domEvent, s2 = n2.shiftKey || n2.ctrlKey || n2.metaKey ? this._selectedEventsMap : {}, i = t3.occurrenceId || t3.id;
      s2[i] ? delete s2[i] : s2[i] = t3, this._selectedEventsMap = d$2({}, s2), this._onSelectedEventsChange(ge(s2)), void 0 === this.s.selectedEvents && this.forceUpdate();
    }
  }, t2.defaults = d$2({}, ct, { actionableEvents: true, allDayText: "All-day", data: [], dragTimeStep: 15, newEventText: "New event", noEventsText: "No events", showControls: true, showEventTooltip: true, view: { calendar: { type: "month" } } }), t2._name = "Eventcalendar", t2;
}(wt), $i = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    return ls("div", { ref: this._setEl, className: this._cssClass }, e4.children);
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._render = function(e4) {
    this._cssClass = this._className + " mbsc-list-header" + this._theme + this._hb;
  }, t2;
}(wt)), Qi = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    var t3 = this.props;
    t3.actionable;
    var n2 = t3.children;
    t3.className, t3.data, t3.drag, t3.ripple, t3.rtl;
    var s2 = t3.theme;
    t3.themeVariant, t3.onHoverIn, t3.onHoverOut, t3.onDragEnd, t3.onDragMove, t3.onDragStart, t3.onDragModeOn, t3.onDragModeOff, t3.onDelete, t3.onClick;
    var i = h$6(t3, ["actionable", "children", "className", "data", "drag", "ripple", "rtl", "theme", "themeVariant", "onHoverIn", "onHoverOut", "onDragEnd", "onDragMove", "onDragStart", "onDragModeOn", "onDragModeOff", "onDelete", "onClick"]);
    return ls("div", d$2({ tabIndex: 0, ref: this._setEl, onClick: this._onClick, className: this._cssClass }, i), n2, ls("div", { className: "mbsc-list-item-background mbsc-" + s2 }));
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._onClick = function(e4) {
      t3._hook("onClick", { domEvent: e4 }), t3.s.selected && t3.setState({ hasFocus: false });
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._mounted = function() {
    var e4, t3, n2 = this;
    this._unlisten = Ds(this._el, { click: true, keepFocus: true, onBlur: function() {
      n2.setState({ hasFocus: false });
    }, onEnd: function(s2) {
      if (e4) {
        var i = d$2({}, s2);
        i.domEvent.preventDefault(), i.data = n2.s.data, i.drag = true, n2._hook("onDragEnd", i), e4 = false;
      }
      clearTimeout(t3);
    }, onFocus: function() {
      n2.setState({ hasFocus: true });
    }, onHoverIn: function(e6) {
      n2.s.actionable && n2.setState({ hasHover: true }), n2._hook("onHoverIn", { domEvent: e6 });
    }, onHoverOut: function(e6) {
      n2.setState({ hasHover: false }), n2._hook("onHoverOut", { domEvent: e6 });
    }, onKeyDown: function(e6) {
      var t4 = n2.s.data;
      switch (e6.keyCode) {
        case 13:
        case 32:
          n2._el.click(), e6.preventDefault();
          break;
        case 8:
        case 46:
          t4 && false !== t4.editable && n2._hook("onDelete", { domEvent: e6, event: t4, source: "agenda" });
      }
    }, onMove: function(s2) {
      var i = n2.s, a2 = d$2({}, s2);
      a2.data = i.data, a2.drag = true, a2.external = true, !e4 && a2.isTouch || a2.domEvent.preventDefault(), e4 ? n2._hook("onDragMove", a2) : (Math.abs(a2.deltaX) > 7 || Math.abs(a2.deltaY) > 7) && (clearTimeout(t3), !a2.isTouch && i.drag && false !== i.data.editable && (e4 = true, n2._hook("onDragStart", a2)));
    }, onPress: function() {
      n2.s.actionable && n2.setState({ isActive: true });
    }, onRelease: function() {
      n2.setState({ isActive: false });
    }, onStart: function(s2) {
      var i = n2.s;
      return s2.isTouch && i.drag && false !== i.data.editable && !e4 && (t3 = setTimeout(function() {
        var t4 = d$2({}, s2);
        t4.data = i.data, t4.drag = true, n2._hook("onDragModeOn", t4), n2._hook("onDragStart", t4), e4 = true;
      }, 350)), { ripple: i.actionable && i.ripple };
    } });
  }, t2.prototype._render = function(e4, t3) {
    this._cssClass = this._className + " mbsc-list-item" + this._theme + this._hb + this._rtl + (e4.actionable ? " mbsc-list-item-actionable" : "") + (t3.hasFocus ? " mbsc-focus" : "") + (t3.hasHover ? " mbsc-hover" : "") + (t3.isActive ? " mbsc-active" : "") + (e4.selected ? " mbsc-selected" : "");
  }, t2.prototype._destroy = function() {
    this._unlisten();
  }, t2.defaults = { actionable: true, ripple: false }, t2._name = "ListItem", t2;
}(wt)), ea = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    return ls("div", { ref: this._setEl, className: this._cssClass }, e4.children);
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._render = function(e4) {
    this._cssClass = this._className + this._rtl + " mbsc-font mbsc-list" + this._theme;
  }, t2;
}(wt)), ta = "mbsc-def";
function na(e3, t2, n2, s2, i, a2) {
  for (var r2 = "start-end" === i, o3 = a2 ? n2 : ze(it(n2, 1)), l2 = 0, c2 = Object.keys(e3); l2 < c2.length; l2++)
    for (var d2 = e3[c2[l2]], h2 = ze(t2); h2 < o3; h2.setDate(h2.getDate() + 1)) {
      var u2 = d2[Pe(h2)];
      if (u2) {
        if (u2.allDay && (!r2 || Ue(h2, t2) || Ue(h2, n2)))
          return u2.allDay;
        if (!s2)
          for (var _2 = 0, m2 = u2.invalids; _2 < m2.length; _2++) {
            var p2 = m2[_2];
            if (r2) {
              if (He(p2.startDate, p2.endDate, t2, t2, true))
                return p2.original;
              if (He(p2.startDate, p2.endDate, n2, n2))
                return p2.original;
            } else if (He(p2.startDate, p2.endDate, t2, n2))
              return p2.original;
          }
      }
    }
  return false;
}
function sa(e3, t2, n2, s2, i) {
  for (var a2 = n2.allDay || i, r2 = n2.startDate, o3 = a2 ? Ve(e3, a2, r2, n2.endDate) : n2.endDate, l2 = a2 ? Je(e3, r2.getFullYear(), r2.getMonth(), r2.getDate()) : r2, c2 = a2 ? Je(e3, o3.getFullYear(), o3.getMonth(), o3.getDate(), 23, 59, 59, 999) : o3, d2 = false, h2 = 0, u2 = t2; h2 < u2.length; h2++) {
    for (var _2 = u2[h2], m2 = 0, p2 = false, v2 = void 0, f2 = 0, g2 = _2; f2 < g2.length; f2++) {
      for (var y2 = g2[f2], b2 = false, D2 = 0, x2 = y2; D2 < x2.length; D2++) {
        var C2 = x2[D2], w2 = C2.allDay, T2 = C2.startDate, k2 = w2 ? Ve(e3, w2, T2, C2.endDate) : C2.endDate;
        He(w2 ? Je(e3, T2.getFullYear(), T2.getMonth(), T2.getDate()) : T2, w2 ? Je(e3, k2.getFullYear(), k2.getMonth(), k2.getDate(), 23, 59, 59, 999) : k2, l2, c2, true) && (b2 = true, p2 = true, v2 ? s2[n2.uid] = s2[n2.uid] || m2 : s2[C2.uid] = m2 + 1);
      }
      b2 || v2 || (v2 = y2), m2++;
    }
    p2 && (v2 ? v2.push(n2) : _2.push([n2]), d2 = true);
  }
  d2 || (s2[n2.uid] = 0, t2.push([[n2]]));
}
function ia(e3) {
  return (e3 = Math.abs(oe(e3))) > 60 ? 60 * oe(e3 / 60) : 60 % e3 == 0 ? e3 : [6, 10, 12, 15, 20, 30].reduce(function(t2, n2) {
    return Math.abs(n2 - e3) < Math.abs(t2 - e3) ? n2 : t2;
  });
}
function aa(e3, t2, n2, s2, i, a2) {
  s2 && s2 > e3 && (e3 = s2);
  var r2 = Le(e3);
  return (t2 > r2 || void 0 !== i && void 0 !== a2 && !at(e3.getDay(), i, a2)) && (r2 = t2), 100 * (r2 - t2) / n2;
}
function ra(e3, t2, n2, s2, i) {
  e3 = e3 || {};
  var a2 = Object.keys(e3), r2 = {}, o3 = t2.map(function(e4) {
    return e4.id;
  }), l2 = n2.map(function(e4) {
    return e4.id;
  });
  o3.forEach(function(e4) {
    r2[e4] = {}, l2.forEach(function(t3) {
      r2[e4][t3] = {};
    });
  });
  for (var c2 = function(t3) {
    for (var n3 = function(e4) {
      var n4 = e4.resource, a4 = e4.slot, c4 = void 0 !== n4 && s2 ? j(n4) ? n4 : [n4] : o3, d3 = void 0 !== a4 && i ? [a4] : l2;
      c4.forEach(function(n5) {
        var s3 = r2[n5];
        s3 && d3.forEach(function(n6) {
          var i2 = s3[n6];
          i2 && (i2[t3] || (i2[t3] = []), i2[t3].push(e4));
        });
      });
    }, a3 = 0, c3 = e3[t3]; a3 < c3.length; a3++) {
      n3(c3[a3]);
    }
  }, d2 = 0, h2 = a2; d2 < h2.length; d2++) {
    c2(h2[d2]);
  }
  return r2;
}
function oa(e3, t2) {
  var n2 = new Date(e3), s2 = new Date(+Te + t2);
  return new Date(n2.getFullYear(), n2.getMonth(), n2.getDate(), s2.getHours(), s2.getMinutes());
}
var la = {}, ca = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._onClick = function(e4) {
      t3._triggerClick("onClick", e4);
      var n2 = t3.s, s2 = la[n2.event.uid];
      s2 && n2.selected && s2.next({ hasFocus: false });
    }, t3._onRightClick = function(e4) {
      t3._triggerClick("onRightClick", e4);
    }, t3._onDocTouch = function(e4) {
      Xt(t3._doc, "touchstart", t3._onDocTouch), Xt(t3._doc, hn, t3._onDocTouch), t3._isDrag = false, t3._hook("onDragModeOff", { event: t3.s.event.original });
    }, t3._updateState = function(e4) {
      t3.setState(e4);
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._render = function(e4, t3) {
    var n2 = e4.event, s2 = new Date(n2.date), i = n2.position, a2 = n2.startDate, r2 = Ve(e4, n2.allDay, a2, n2.endDate), o3 = e4.isTimeline, l2 = e4.isListing, c2 = l2 || n2.allDay, h2 = !Ue(a2, r2), u2 = h2 && Ue(a2, s2), _2 = h2 && Ue(r2, s2), m2 = c2 && (!o3 || l2), p2 = o3 ? "timeline" : "schedule", v2 = e4.gridStartTime, f2 = e4.gridEndTime, g2 = Le(a2), y2 = Le(r2), b2 = o3 && e4.slot !== ta, D2 = e4.singleDay ? it(s2, 1) : new Date(e4.lastDay), x2 = at(r2.getDay(), e4.startDay, e4.endDay);
    this._isStart = b2 || !h2 || u2, this._isEnd = b2 || !h2 || (c2 || o3 ? r2 < D2 && x2 : _2), b2 || c2 || !(v2 > g2 || f2 < g2) || (this._isStart = false), b2 || c2 || !(f2 < y2 || v2 > y2) || (this._isEnd = false), this._isDrag = this._isDrag || e4.isDrag, this._content = void 0, this._rangeText = n2.start + " - " + n2.end, this._isAllDay = m2, this._host = p2, (n2.allDay || !o3 && h2 && !u2 && !_2) && (this._rangeText = n2.allDayText), this._cssClass = "mbsc-schedule-event" + this._theme + this._rtl + (e4.render || e4.template ? " mbsc-schedule-event-custom" : "") + (o3 ? " mbsc-timeline-event" : "") + (l2 ? " mbsc-timeline-event-listing" : "") + (this._isStart ? " mbsc-" + p2 + "-event-start" : "") + (this._isEnd ? " mbsc-" + p2 + "-event-end" : "") + (m2 ? " mbsc-schedule-event-all-day" : "") + (b2 ? " mbsc-timeline-event-slot" : "") + (t3.hasFocus && !e4.inactive && !e4.selected || e4.selected ? " mbsc-schedule-event-active" : "") + (!t3.hasHover || e4.inactive || this._isDrag ? "" : " mbsc-schedule-event-hover") + (e4.isDrag ? " mbsc-schedule-event-dragging" + (o3 ? " mbsc-timeline-event-dragging" : "") : "") + (e4.hidden ? " mbsc-schedule-event-hidden" : "") + (e4.inactive ? " mbsc-schedule-event-inactive" : "") + (false === n2.original.editable ? " mbsc-readonly-event" : "") + (n2.original.cssClass ? " " + n2.original.cssClass : ""), this._style = d$2({}, i, { color: n2.color, top: e4.eventHeight && void 0 !== i.top ? i.top * e4.eventHeight + "px" : i.top });
    var C2, w2 = e4.render || e4.renderContent;
    if (w2) {
      var T2 = w2(n2);
      $(T2) ? C2 = T2 : this._content = T2;
    } else
      e4.contentTemplate || (C2 = n2.html);
    C2 !== this._text && (this._text = C2, this._html = C2 ? this._safeHtml(C2) : void 0, this._shouldEnhance = C2 && !!w2);
  }, t2.prototype._mounted = function() {
    var e4, t3, n2 = this, s2 = this.s.event.uid, i = la[s2];
    i || (i = new v$3(), la[s2] = i), this._unsubscribe = i.subscribe(this._updateState), this._doc = Kt(this._el), this._unlisten = Ds(this._el, { keepFocus: true, onBlur: function() {
      i.next({ hasFocus: false });
    }, onDoubleClick: function(e6) {
      e6.domEvent.stopPropagation(), n2._triggerClick("onDoubleClick", e6.domEvent);
    }, onEnd: function(s3) {
      if (n2._isDrag) {
        var i2 = n2.s, a2 = d$2({}, s3);
        a2.domEvent.preventDefault(), a2.event = i2.event, a2.resource = i2.resource, a2.slot = i2.slot, i2.resize && e4 ? (a2.resize = true, a2.direction = e4) : i2.drag && (a2.drag = true), n2._hook("onDragEnd", a2), i2.isDrag || (n2._isDrag = false), n2._el && a2.moved && n2._el.blur();
      }
      clearTimeout(t3), e4 = void 0;
    }, onFocus: function() {
      i.next({ hasFocus: true });
    }, onHoverIn: function(e6) {
      i.next({ hasHover: true }), n2._triggerClick("onHoverIn", e6);
    }, onHoverOut: function(e6) {
      i.next({ hasHover: false }), n2._triggerClick("onHoverOut", e6);
    }, onKeyDown: function(e6) {
      var t4 = n2.s.event.original;
      switch (e6.keyCode) {
        case 13:
        case 32:
          n2._el.click(), e6.preventDefault();
          break;
        case 8:
        case 46:
          false !== t4.editable && n2._hook("onDelete", { domEvent: e6, event: t4, source: n2._host });
      }
    }, onMove: function(s3) {
      var i2 = n2.s, a2 = d$2({}, s3);
      if (a2.event = i2.event, a2.resource = i2.resource, a2.slot = i2.slot, e4)
        a2.resize = true, a2.direction = e4;
      else {
        if (!i2.drag)
          return;
        a2.drag = true;
      }
      false !== i2.event.original.editable && (!n2._isDrag && a2.isTouch || a2.domEvent.preventDefault(), n2._isDrag ? n2._hook("onDragMove", a2) : (Math.abs(a2.deltaX) > 7 || Math.abs(a2.deltaY) > 7) && (clearTimeout(t3), a2.isTouch || (n2._isDrag = true, n2._hook("onDragStart", a2))));
    }, onStart: function(s3) {
      var i2 = n2.s, a2 = d$2({}, s3), r2 = a2.domEvent.target;
      if (a2.event = i2.event, a2.resource = i2.resource, a2.slot = i2.slot, i2.resize && r2.classList.contains("mbsc-schedule-event-resize"))
        e4 = r2.classList.contains("mbsc-schedule-event-resize-start") ? "start" : "end", a2.resize = true, a2.direction = e4;
      else {
        if (!i2.drag)
          return;
        a2.drag = true;
      }
      false !== i2.event.original.editable && (n2._isDrag ? (a2.domEvent.stopPropagation(), n2._hook("onDragStart", a2)) : a2.isTouch && (t3 = setTimeout(function() {
        n2._hook("onDragModeOn", a2), n2._hook("onDragStart", a2), n2._isDrag = true;
      }, 350)));
    } }), this._isDrag && (Bt(this._doc, "touchstart", this._onDocTouch), Bt(this._doc, hn, this._onDocTouch));
  }, t2.prototype._destroy = function() {
    if (this._el && this._el.blur(), this._unsubscribe) {
      var e4 = this.s.event.uid, t3 = la[e4];
      t3 && (t3.unsubscribe(this._unsubscribe), t3.nr || delete la[e4]);
    }
    this._unlisten && this._unlisten(), Xt(this._doc, "touchstart", this._onDocTouch), Xt(this._doc, hn, this._onDocTouch);
  }, t2.prototype._triggerClick = function(e4, t3) {
    var n2 = this.s;
    this._hook(e4, { date: n2.event.date, domEvent: t3, event: n2.event.original, resource: n2.resource, slot: n2.slot, source: this._host });
  }, t2;
}(wt), da = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    var t3 = e4.event, n2 = this._isAllDay, s2 = e4.isTimeline, i = this._theme, a2 = e4.resize && false !== t3.original.editable;
    return ls("div", { tabIndex: 0, className: this._cssClass, "data-id": t3.id, style: this._style, ref: this._setEl, title: t3.tooltip, onClick: this._onClick, onContextMenu: this._onRightClick }, this._isStart && a2 && ls("div", { className: "mbsc-schedule-event-resize mbsc-schedule-event-resize-start" + (s2 ? " mbsc-timeline-event-resize" : "") + this._rtl + (e4.isDrag ? " mbsc-schedule-event-resize-start-touch" : "") }), this._isEnd && a2 && ls("div", { className: "mbsc-schedule-event-resize mbsc-schedule-event-resize-end" + (s2 ? " mbsc-timeline-event-resize" : "") + this._rtl + (e4.isDrag ? " mbsc-schedule-event-resize-end-touch" : "") }), e4.render ? this._html ? ls("div", { style: { height: "100%" }, dangerouslySetInnerHTML: this._html }) : this._content : ls(ds, null, !n2 && !s2 && ls("div", { className: "mbsc-schedule-event-bar" + i + this._rtl }), ls("div", { className: "mbsc-schedule-event-background" + (s2 ? " mbsc-timeline-event-background" : "") + (n2 ? " mbsc-schedule-event-all-day-background" : "") + i, style: { background: t3.style.background } }), ls("div", { "aria-hidden": "true", className: "mbsc-schedule-event-inner" + i + (n2 ? " mbsc-schedule-event-all-day-inner" : "") + (t3.cssClass || ""), style: { color: t3.style.color } }, ls("div", { className: "mbsc-schedule-event-title" + (n2 ? " mbsc-schedule-event-all-day-title" : "") + i, dangerouslySetInnerHTML: this._html }, this._content), !n2 && ls("div", { className: "mbsc-schedule-event-range" + i }, this._rangeText)), t3.ariaLabel && ls("div", { className: "mbsc-hidden-content" }, t3.ariaLabel)));
  }, t2;
}(ca), ha = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._onScroll = function() {
    }, t3._onMouseLeave = function() {
      t3._cursorTimeCont && !t3.state.dragData && (t3._cursorTimeCont.style.visibility = "hidden", t3._isCursorTimeVisible = false);
    }, t3._onMouseMove = function(e4, n2) {
      if (t3._showCursorTime) {
        var s2 = t3.s, i = s2.rtl, a2 = t3._isTimeline, r2 = t3._scrollCont, o3 = t3._cursorTimeCont;
        if (!t3._isTouch || t3._tempStart ? !t3._isCursorTimeVisible && e4 && (t3._calcGridSizes(), o3.style.visibility = "visible", t3._isCursorTimeVisible = true) : (o3.style.visibility = "hidden", t3._isCursorTimeVisible = false), t3._isCursorTimeVisible) {
          var l2 = e4 ? e4.clientX : t3._cursorX || 0, c2 = e4 ? e4.clientY : t3._cursorY || 0, d2 = l2 + r2.scrollLeft - t3._resWidth * (i ? -1 : 1), h2 = i ? t3._gridContRight - d2 : d2 - t3._gridContLeft, u2 = G(c2 + r2.scrollTop - t3._gridContTop, 8, t3._colHeight), _2 = void 0, m2 = void 0, p2 = void 0;
          if (void 0 !== n2)
            m2 = Je(s2, n2 < 0 ? t3._tempStart : t3._tempEnd), _2 = a2 ? t3._dayIndexMap[Pe(m2)] : 0, p2 = 0 === (p2 = Le(m2)) ? n2 < 0 ? p2 : 864e5 : p2;
          else {
            _2 = a2 ? G(ce(h2 / t3._colWidth), 0, t3._daysNr - 1) : 0, p2 = t3._startTime + le(t3._isTimeline ? ce(t3._time * (h2 - _2 * t3._colWidth) / t3._colWidth) : ce(t3._time * (u2 - 8) / (t3._colHeight - 16)), 6e4 * s2.dragTimeStep);
            var v2 = t3._days[_2].date, f2 = new Date(+Te + p2);
            m2 = Je(s2, v2.getFullYear(), v2.getMonth(), v2.getDate(), f2.getHours(), f2.getMinutes());
          }
          var g2 = t3._time * (a2 ? t3._daysNr : 1), y2 = a2 ? i ? "right" : "left" : "top", b2 = o3.style;
          b2[y2] = 100 * (_2 * t3._time + p2 - t3._startTime) / g2 + "%", b2[i ? "left" : "right"] = "", o3.textContent = et(s2.timeFormat, m2, s2), t3._cursorX = l2, t3._cursorY = c2;
        }
      }
    }, t3._onEventDragModeOn = function(e4) {
      var n2 = e4.create ? t3._tempEvent : e4.event, s2 = e4.create ? t3._tempResource : e4.resource, i = e4.create ? t3._tempSlot : e4.slot;
      t3.setState({ dragData: { draggedEvent: n2, originDates: e4.external ? void 0 : t3._getDragDates(n2, s2, i), resource: s2 }, isTouchDrag: true });
    }, t3._onEventDragModeOff = function(e4) {
      t3._hook("onEventDragEnd", { domEvent: e4.domEvent, event: e4.event, resource: e4.resource, slot: e4.slot, source: e4.source }), t3.setState({ dragData: void 0, isTouchDrag: false });
    }, t3._onEventDragStart = function(e4) {
      var n2 = t3.s, s2 = e4.click, i = n2.eventList, a2 = t3._isTimeline, r2 = t3._visibleResources, o3 = t3._slots, l2 = n2.dragTimeStep, c2 = e4.startX, h2 = e4.startY, u2 = t3._groupByResource, _2 = u2 ? t3._daysNr : t3._hasSlots ? t3._slots.length : r2.length;
      t3._scrollY = 0, t3._scrollX = 0, t3._calcGridSizes();
      var m2 = n2.rtl ? t3._gridRight - c2 : c2 - t3._gridLeft, p2 = G(h2 - t3._gridTop, 8, t3._colHeight - 9), v2 = t3._colWidth, f2 = v2 ? ce(m2 / v2) : 1, g2 = t3._resourceTops, y2 = 0, b2 = f2, D2 = 0;
      if (a2)
        D2 = v2 ? ce(m2 / (v2 / o3.length)) % o3.length : 1, r2.forEach(function(e6, t4) {
          p2 > g2[e6.id] && (y2 = t4);
        });
      else {
        var x2 = t3._el.querySelector(".mbsc-schedule-all-day-wrapper"), C2 = x2 && x2.getBoundingClientRect();
        t3._allDayTop = C2 ? C2.top : t3._gridContTop, y2 = u2 ? ce(f2 / _2) : f2 % _2, b2 = u2 ? f2 % _2 : ce(f2 / _2);
      }
      var w2 = e4.external ? void 0 : r2[y2], T2 = w2 ? w2.id : void 0, k2 = e4.external ? void 0 : o3[D2], S2 = k2 ? k2.id : void 0;
      if (e4.create) {
        b2 = G(b2, 0, t3._daysNr - 1);
        var E2 = !a2 && n2.showAllDay && e4.endY < t3._gridContTop, M2 = "day" === n2.type && 1 === n2.size ? t3._firstDay : t3._days[b2].date, I2 = i || !e4.external && !s2 ? 6e4 * l2 : t3._stepCell, N2 = t3._getGridTime(M2, m2, p2, b2, s2 ? t3._stepCell / 6e4 : l2), L2 = E2 || i ? M2 : N2, H2 = it(L2, 1), O2 = n2.exclusiveEndDates ? H2 : new Date(+H2 - 1), R2 = E2 || i ? O2 : rt(Je(n2, +L2 + I2), s2 ? 1 : l2), V2 = n2.extendDefaultEvent ? n2.extendDefaultEvent({ resource: T2, slot: S2, start: L2 }) : void 0, P2 = d$2({ allDay: E2, end: R2, id: qi(), resource: w2 && T2 !== ta ? T2 : void 0, slot: k2 && S2 !== ta ? S2 : void 0, start: L2, title: n2.newEventText }, V2, e4.event), z2 = t3._getEventData(P2, M2, w2);
        if (a2 && T2 && (z2.position.top = G(ce((p2 - g2[T2]) / t3._eventHeight), 0, t3._eventRows[T2] - 1)), e4.event) {
          var Y2 = +z2.endDate - +z2.startDate;
          z2.startDate = M2, z2.endDate = new Date(+M2 + Y2);
        }
        t3._tempEvent = z2, t3._tempResource = T2, t3._tempSlot = S2;
      }
      s2 || t3._hook("onEventDragStart", { domEvent: e4.domEvent, event: (e4.create ? t3._tempEvent : e4.event).original, resource: T2, slot: S2, source: a2 ? "timeline" : "schedule" });
    }, t3._onEventDragMove = function(e4) {
      clearTimeout(t3._scrollTimer);
      var n2 = t3.s, s2 = n2.rtl, i = s2 ? -1 : 1, a2 = t3._isTimeline, r2 = t3._daysNr, o3 = t3._slots, l2 = t3._groupByResource, c2 = t3._visibleResources, h2 = t3.state.dragData, u2 = n2.dragTimeStep, _2 = n2.timeFormat, m2 = n2.eventList, p2 = e4.startX, v2 = G(e4.endX, t3._gridContLeft, t3._gridContRight - 1), f2 = G(e4.endY, t3._gridContTop, t3._gridContBottom - 1), g2 = f2 - e4.startY + t3._scrollY, y2 = s2 ? p2 - v2 + t3._scrollX : v2 - p2 + t3._scrollX, b2 = a2 ? y2 : g2, D2 = a2 ? t3._colWidth : t3._colHeight - 16, x2 = G(s2 ? t3._gridRight + t3._scrollX - v2 : v2 - t3._gridLeft + t3._scrollX, 0, t3._gridRight - t3._gridLeft - 1), C2 = G(f2 - t3._gridTop + t3._scrollY, 8, t3._colHeight - 9), w2 = ce((s2 ? t3._gridRight - p2 : p2 - t3._gridLeft) / t3._colWidth), T2 = ce(x2 / t3._colWidth), k2 = n2.showAllDay && e4.endY < t3._gridContTop, S2 = t3._scrollCont, E2 = w2, M2 = T2, I2 = 0, N2 = 0, L2 = false, H2 = t3._gridContBottom - e4.endY, O2 = e4.endY - t3._gridContTop, R2 = e4.endX - t3._gridContLeft, V2 = t3._gridContRight - e4.endX, P2 = (S2.scrollWidth - S2.clientWidth) * i, z2 = s2 ? 0 : P2, Y2 = s2 ? P2 : 0;
      if (H2 < 30 && S2.scrollTop < S2.scrollHeight - S2.clientHeight && (S2.scrollTop += 5, t3._scrollY += 5, L2 = true), O2 < 30 && !k2 && S2.scrollTop > 0 && (S2.scrollTop -= 5, t3._scrollY -= 5, L2 = true), R2 < 30 + (s2 ? 0 : t3._resWidth) && S2.scrollLeft > Y2 && (S2.scrollLeft -= 5, t3._scrollX -= 5 * i, L2 = true), V2 < 30 + (s2 ? t3._resWidth : 0) && S2.scrollLeft < z2 && (S2.scrollLeft += 5, t3._scrollX += 5 * i, L2 = true), L2 && (t3._scrollTimer = setTimeout(function() {
        t3._onEventDragMove(e4);
      }, 20)), a2)
        N2 = ce(x2 / (t3._colWidth / o3.length)) % o3.length, c2.forEach(function(e6, n3) {
          C2 > t3._resourceTops[e6.id] && (I2 = n3);
        });
      else {
        var W2 = l2 ? r2 : t3._resources.length;
        E2 = l2 ? w2 % W2 : ce(w2 / W2), M2 = l2 ? T2 % W2 : ce(T2 / W2), I2 = l2 ? ce(T2 / W2) : T2 % W2;
      }
      E2 = G(E2, 0, r2 - 1), M2 = G(M2, 0, r2 - 1);
      var F2, A2 = e4.create ? t3._tempEvent : e4.event, U2 = A2.startDate, B2 = A2.endDate, X2 = +B2 - +U2, K2 = t3._time, q2 = ce(K2 * b2 / D2), j2 = o3[N2].id, J2 = c2[I2].id, Z2 = A2.allDay, $2 = Z2 ? void 0 : n2, Q2 = Z2 || m2, ee2 = U2, te2 = B2, ne2 = t3._days[E2].date, se2 = t3._days[M2].date, ie2 = "day" === n2.type && 1 === n2.size ? 0 : We(ne2, se2), ae2 = ie2 - M2 + E2;
      if (e4.drag || e4.external) {
        if (Z2 = k2 || a2 && A2.allDay, Q2 = k2 || m2 || a2 && A2.allDay, $2 = Z2 ? void 0 : n2, A2.allDay && !a2 && !k2 || e4.external && !k2) {
          var re2 = ze(it(U2, ie2));
          ee2 = t3._getGridTime(re2, x2, C2, M2, u2);
        } else
          a2 && !Q2 ? ee2 = rt(Je(n2, +U2 + q2 + (864e5 - K2) * ie2 + K2 * ae2), u2) : (F2 = it(U2, ie2), ee2 = Q2 ? F2 : rt(Je($2, +F2 + q2), u2));
        te2 = Je($2, +ee2 + X2);
      } else {
        var oe2 = a2 ? 0 : T2 - w2, le2 = e4.create ? oe2 ? oe2 > 0 : b2 > 0 : "end" === e4.direction, de2 = We(U2, B2), he2 = e4.create ? t3._tempResource : e4.resource;
        !a2 && l2 && he2 !== J2 && h2 && h2.draggedEvent && (ie2 = We(h2.draggedEvent.startDate, h2.draggedEvent.endDate) * (le2 ? 1 : -1)), le2 ? a2 && !Q2 ? te2 = rt(Je(n2, +B2 + q2 + ie2 * (864e5 - K2) + K2 * ae2), u2) : (F2 = it(B2, Math.max(-de2, ie2)), te2 = Q2 ? F2 : rt(Je($2, +F2 + q2), u2), !Q2 && (Le(te2) > t3._endTime + 1 || te2 >= it(ze(F2), 1)) && (te2 = Je(n2, +ze(F2) + t3._endTime + 1))) : a2 && !Q2 ? ee2 = rt(Je(n2, +U2 + q2 + ie2 * (864e5 - K2) + K2 * ae2), u2) : (F2 = it(U2, Math.min(de2, ie2)), ee2 = Q2 ? F2 : rt(Je($2, +F2 + q2), u2), !Q2 && (Le(ee2) < t3._startTime || ee2 < ze(F2)) && (ee2 = Je(n2, +ze(F2) + t3._startTime))), J2 = he2, Q2 && te2 < ee2 && (le2 ? te2 = Je(n2, ee2) : ee2 = Je(n2, te2)), !Q2 && (te2 < ee2 || Math.abs(+te2 - +ee2) < 6e4 * u2) && (le2 ? te2 = Je(n2, +ee2 + 6e4 * u2) : ee2 = Je(n2, +te2 - 6e4 * u2));
      }
      if (t3._tempStart !== +ee2 || t3._tempEnd !== +te2 || t3._tempAllDay !== Z2 || t3._tempResource !== J2 || t3._tempSlot !== j2) {
        var ue2 = d$2({}, A2);
        ue2.startDate = ee2, ue2.endDate = te2, ue2.start = et(_2, ee2, n2), ue2.end = et(_2, te2, n2), ue2.allDay = Z2, t3._tempStart = +ee2, t3._tempEnd = +te2, t3._tempAllDay = Z2, t3._tempResource = J2, t3._tempSlot = j2, Z2 || t3._onMouseMove(e4.domEvent, e4.drag ? -1 : e4.direction ? "end" === e4.direction ? 1 : -1 : b2), t3.setState({ dragData: { draggedDates: t3._getDragDates(ue2, J2, j2), draggedEvent: ue2, originDates: h2 && h2.originDates, resource: J2, slot: j2 } });
      }
    }, t3._onEventDragEnd = function(e4) {
      clearTimeout(t3._scrollTimer);
      var n2 = t3.s, s2 = e4.create, i = t3.state, a2 = i.dragData;
      if (s2 && !a2 && ((a2 = {}).draggedEvent = t3._tempEvent), a2 && a2.draggedEvent) {
        var r2 = e4.event, o3 = a2.draggedEvent, l2 = o3.startDate, c2 = o3.endDate, d2 = o3.allDay, h2 = o3.original, u2 = e4.resource, _2 = void 0 === a2.resource ? u2 : a2.resource, m2 = void 0 === h2.resource ? _2 : h2.resource, p2 = s2 ? t3._tempSlot : e4.slot, v2 = void 0 === a2.slot ? p2 : a2.slot, f2 = {}, g2 = t3._isTimeline ? "timeline" : "schedule", y2 = s2 || +l2 != +r2.startDate || +c2 != +r2.endDate || d2 !== r2.allDay || u2 !== _2 || p2 !== v2, b2 = m2, D2 = void 0;
        if (u2 !== _2 && !s2 && !t3._isSingleResource)
          if (j(m2) && m2.length && _2) {
            var x2 = m2.indexOf(u2);
            -1 === m2.indexOf(_2) && (b2 = m2.slice()).splice(x2, 1, _2);
          } else
            b2 = _2;
        D2 = b2 && n2.resources ? j(b2) ? b2 : [b2] : t3._resources.map(function(e6) {
          return e6.id;
        });
        for (var C2 = 0, w2 = D2; C2 < w2.length; C2++) {
          var T2 = w2[C2];
          t3._invalids[T2] && (f2[T2] = t3._invalids[T2][v2]);
        }
        var k2 = e4.action || (i.dragData ? "drag" : "click"), S2 = !y2 || n2.eventDragEnd({ action: k2, collision: na(f2, l2, c2, d2, n2.invalidateEvent, n2.exclusiveEndDates), create: s2, domEvent: e4.domEvent, event: o3, resource: b2 !== ta ? b2 : void 0, slot: v2 !== ta ? v2 : void 0, source: g2 }), E2 = i.isTouchDrag && (!s2 || S2);
        if (S2 && E2 && u2 !== _2 && !h2.color) {
          var M2 = me(t3._resources, function(e6) {
            return e6.id === _2;
          }), I2 = M2 && M2.color;
          I2 ? (o3.color = I2, o3.style.background = I2, o3.style.color = $t(I2)) : (o3.color = void 0, o3.style = {});
        }
        E2 || "click" === k2 || t3._hook("onEventDragEnd", { domEvent: e4.domEvent, event: (s2 ? t3._tempEvent : e4.event).original, resource: _2, slot: v2, source: g2 }), t3.setState({ dragData: E2 ? { draggedEvent: o3, originDates: S2 ? t3._getDragDates(o3, _2, v2) : a2.originDates } : void 0, isTouchDrag: E2 }), t3._tempStart = 0, t3._tempEnd = 0, t3._tempAllDay = void 0;
      }
    }, t3._onExternalDrag = function(e4) {
      if (t3.s.externalDrop) {
        var n2 = e4.endY < t3._gridContBottom && e4.endY > t3._allDayTop && e4.endX > t3._gridContLeft && e4.endX < t3._gridContRight;
        switch (e4.eventName) {
          case "onDragModeOff":
            t3._onEventDragModeOff(e4);
            break;
          case "onDragModeOn":
            t3._onEventDragModeOn(e4);
            break;
          case "onDragStart":
            t3._onEventDragStart(e4);
            break;
          case "onDragMove":
            var s2 = e4.clone;
            n2 ? (s2.style.display = "none", t3._onEventDragMove(e4), t3._onCalendar = true) : t3._onCalendar && (clearTimeout(t3._scrollTimer), s2.style.display = "table", t3.setState({ dragData: {} }), t3._tempStart = 0, t3._tempEnd = 0, t3._tempAllDay = void 0, t3._onCalendar = false);
            break;
          case "onDragEnd":
            n2 ? t3._onEventDragEnd(e4) : (t3.setState({ dragData: void 0, isTouchDrag: false }), t3._hook("onEventDragEnd", { domEvent: e4.domEvent, event: e4.event, resource: e4.resource, slot: e4.slot, source: e4.source }));
        }
      }
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._isToday = function(e4) {
    return Ue(new Date(e4), Je(this.s));
  }, t2.prototype._formatTime = function(e4, t3) {
    var n2 = this.s, s2 = n2.timeFormat, i = /a/i.test(s2) && 36e5 === this._stepLabel && e4 % 36e5 == 0 ? s2.replace(/.[m]+/i, "") : s2, a2 = new Date(+Te + e4), r2 = Je(n2, a2.getFullYear(), a2.getMonth(), a2.getDate(), a2.getHours(), a2.getMinutes());
    return ke(r2) && t3 && r2.setTimezone(t3), et(i, r2, n2);
  }, t2.prototype._getEventPos = function(e4, t3, n2, s2) {
    var i = this.s, a2 = e4.allDay ? void 0 : i, r2 = Je(a2, t3.getFullYear(), t3.getMonth(), t3.getDate()), o3 = this._dayIndexMap[n2], l2 = ze(it(r2, 1)), c2 = a2 ? this._firstDayTz : this._firstDay, d2 = a2 ? this._lastDayTz : this._lastDay, h2 = this._isTimeline, u2 = !h2 && !this._groupByResource, _2 = e4.allDay, m2 = this._startTime, p2 = this._endTime + 1, v2 = this._time, f2 = this._hasSlots, g2 = e4.endDate, y2 = e4.start, b2 = e4.startDate, D2 = e4.end, x2 = Ve(i, _2, b2, g2), C2 = +b2 == +x2 ? 1 : 0;
    if (_2 || h2) {
      if (!s2.get(e4.original) || f2 || u2) {
        var w2 = i.startDay, T2 = i.endDay, k2 = i.eventList, S2 = _2 || k2, E2 = !Ue(b2, x2), M2 = this._daysNr;
        h2 && E2 && Le(b2) >= p2 && (b2 = Je(i, +ze(b2) + p2));
        var I2 = S2 ? x2 : g2, N2 = aa(b2, m2, v2, c2, w2, T2), L2 = function(e6, t4, n3, s3, i2, a3, r3, o4, l3, c3) {
          var d3 = e6, h3 = t4;
          d3 < s3 && (d3 = s3), h3 > i2 && (h3 = i2);
          var u3 = Le(d3), _3 = Le(h3);
          a3 > u3 && (u3 = a3), r3 < _3 && (_3 = r3), Ue(d3, h3) || (u3 > r3 && (u3 = r3), _3 < a3 && (_3 = a3));
          var m3 = 0;
          if (Ue(d3, h3))
            m3 = c3 ? n3 : _3 - u3;
          else
            for (var p3 = ze(d3); p3 <= h3; p3.setDate(p3.getDate() + 1))
              at(p3.getDay(), o4, l3) && (!c3 && Ue(p3, d3) ? m3 += n3 - u3 + a3 : !c3 && Ue(p3, h3) ? m3 += _3 - a3 : m3 += n3);
          return 100 * m3 / n3;
        }(b2, I2, v2, c2, d2, m2, p2, w2, T2, S2);
        h2 && (L2 /= M2, N2 = (N2 + 100 * o3) / M2);
        var H2 = h2 ? S2 ? { left: i.rtl ? "" : (f2 ? "" : 100 * o3 / M2) + "%", right: i.rtl ? (f2 ? "" : 100 * o3 / M2) + "%" : "", width: (f2 ? "" : L2) + "%" } : { height: this._setRowHeight ? "" : "100%", left: i.rtl ? "" : N2 + "%", right: i.rtl ? N2 + "%" : "", top: "0", width: L2 + "%" } : { width: (E2 && !u2 ? L2 : 100) + "%" }, O2 = Le(b2) < p2 && x2 > c2, R2 = Le(x2) + C2 > m2;
        if (S2 || E2 && L2 > 0 || O2 && R2)
          return s2.set(e4.original, true), { end: D2, endDate: x2, position: H2, start: y2, startDate: b2 };
      }
    } else if (b2 < r2 && (y2 = "", b2 = Je(i, r2)), x2 >= l2 && (D2 = "", x2 = Je(i, +l2 - 1)), g2 >= l2 && (g2 = Je(i, +l2 - 1)), Le(b2) < p2 && Le(x2) + C2 > m2 && x2 >= b2) {
      var V2 = function(e6, t4, n3, s3, i2) {
        var a3 = Le(e6), r3 = Le(t4);
        return s3 > a3 && (a3 = s3), i2 < r3 && (r3 = i2), 100 * (r3 - a3) / n3;
      }(b2, g2, v2, m2, p2);
      return { cssClass: V2 < 2 ? " mbsc-schedule-event-small-height" : "", end: D2, endDate: x2, position: { height: V2 + "%", top: aa(b2, m2, v2) + "%", width: "100%" }, start: y2, startDate: b2 };
    }
  }, t2.prototype._getEventData = function(e4, t3, n2, s2) {
    var i = this.s, a2 = Gi(i, e4, t3, true, i.timeFormat, i.allDayText, "", n2, false, this._isTimeline, s2);
    return e4.allDay && i.exclusiveEndDates && +a2.endDate == +a2.startDate && (a2.endDate = ze(it(a2.startDate, 1))), a2;
  }, t2.prototype._getEvents = function(e4) {
    var t3 = this, n2 = this.s, s2 = this._resources, i = this._slots, a2 = this._hasSlots, r2 = this._isTimeline, o3 = !r2, l2 = {}, c2 = ra(e4, s2, i, !!n2.resources, !!n2.slots), d2 = {}, h2 = this._firstDay, u2 = this._lastDay, _2 = {};
    if (n2.connections)
      for (var m2 = 0, p2 = n2.connections; m2 < p2.length; m2++) {
        var v2 = p2[m2];
        _2[v2.from] = true, _2[v2.to] = true;
      }
    for (var f2 = function(s3) {
      var m3 = s3.id, p3 = /* @__PURE__ */ new Map(), v3 = [], f3 = 0;
      l2[m3] = {};
      for (var y3 = function(i2) {
        var y4 = i2.id, b4 = c2[m3][y4], D3 = Object.keys(b4).sort();
        l2[m3][y4] = { all: { allDay: [], events: [] } }, o3 && (d2[y4] = vt(n2, b4, h2, u2, -1, g2._daysNr, true, n2.startDay, false, n2.eventOrder));
        for (var x3 = function(i3) {
          var c3 = e4[i3].date;
          if (void 0 !== g2._dayIndexMap[i3] && at(c3.getDay(), n2.startDay, n2.endDay)) {
            var h3 = ft(b4[i3]) || [], u3 = [], D4 = {}, x4 = !a2 && r2 ? "all" : i3, C4 = 0;
            (o3 || a2) && (l2[m3][y4][x4] = { allDay: [], events: [] });
            for (var w4 = 0, T3 = h3; w4 < T3.length; w4++) {
              var k3 = T3[w4];
              if (!k3.allDay || r2) {
                var S3 = g2._getEventData(k3, c3, s3), E3 = g2._getEventPos(S3, c3, i3, p3);
                E3 && (S3.cssClass = E3.cssClass, S3.position = E3.position, o3 && (S3.showText = true, sa(n2, u3, S3, D4, n2.eventList)), l2[m3][y4][x4].events.push(S3), v3.push(S3), C4++, g2._eventMap[S3.id] = S3);
              }
            }
            if (a2 && C4 > f3 && (f3 = C4), o3) {
              d2[y4][i3] && d2[y4][i3].data.forEach(function(e6) {
                var n3 = e6.event, a3 = e6.width;
                if (n3) {
                  var r3 = t3._getEventData(n3, c3, s3), o4 = t3._getEventPos(r3, c3, i3, p3);
                  r3.position = { width: o4 ? o4.position.width : a3 }, r3.showText = !!o4, l2[m3][y4][x4].allDay.push(r3);
                }
              });
              for (var M3 = function(e6) {
                var t4 = e6.length;
                e6.forEach(function(e7, s4) {
                  for (var i4 = 0, a3 = e7; i4 < a3.length; i4++) {
                    var r3 = a3[i4], o4 = ((D4[r3.uid] || t4) - s4) / t4 * 100;
                    r3.position.width = o4 + "%", r3.position[n2.rtl ? "right" : "left"] = 100 * s4 / t4 + "%", r3.position[n2.rtl ? "left" : "right"] = "auto";
                  }
                });
              }, I3 = 0, N2 = u3; I3 < N2.length; I3++) {
                M3(N2[I3]);
              }
            }
          } else if (n2.connections)
            for (var L2 = 0, H2 = h3 = b4[i3] || []; L2 < H2.length; L2++) {
              var O2 = H2[L2], R2 = O2.id;
              !g2._eventMap[R2] && _2[R2] && (g2._eventMap[R2] = g2._getEventData(O2, c3, s3));
            }
        }, C3 = 0, w3 = D3; C3 < w3.length; C3++) {
          x3(w3[C3]);
        }
      }, b3 = 0, D2 = i; b3 < D2.length; b3++) {
        y3(D2[b3]);
      }
      if (r2 && !a2) {
        for (var x2 = [], C2 = {}, w2 = g2._setRowHeight, T2 = 0, k2 = v3; T2 < k2.length; T2++) {
          var S2 = k2[T2];
          sa(n2, x2, S2, C2, n2.eventList);
        }
        for (var E2 = function(e6) {
          var t4 = e6.length;
          w2 && t4 > f3 && (f3 = t4), e6.forEach(function(e7, n3) {
            for (var s4 = 0, i2 = e7; s4 < i2.length; s4++) {
              var a3 = i2[s4], r3 = ((C2[a3.uid] || t4) - n3) / t4 * 100;
              a3.position.height = w2 ? "" : r3 + "%", a3.position.top = w2 ? n3 : 100 * n3 / t4 + "%";
            }
          });
        }, M2 = 0, I2 = x2; M2 < I2.length; M2++) {
          E2(I2[M2]);
        }
      }
      g2._eventRows[m3] = f3 || 1;
    }, g2 = this, y2 = 0, b2 = s2; y2 < b2.length; y2++) {
      f2(b2[y2]);
    }
    return l2;
  }, t2.prototype._getInvalids = function(e4) {
    for (var t3, n2 = this.s, s2 = n2.eventList, i = {}, a2 = ra(e4, this._resources, this._slots, !!n2.resources, !!n2.slots), r2 = Object.keys(e4 || {}).sort(), o3 = s2 ? ze(new Date(n2.minDate)) : new Date(n2.minDate), l2 = s2 ? ze(it(new Date(n2.maxDate), 1)) : new Date(n2.maxDate), c2 = this._isTimeline, d2 = 0, h2 = this._resources; d2 < h2.length; d2++) {
      var u2 = h2[d2], _2 = u2.id, m2 = /* @__PURE__ */ new Map();
      i[_2] = {};
      for (var p2 = 0, v2 = this._slots; p2 < v2.length; p2++) {
        var f2 = v2[p2].id, g2 = { invalids: [] };
        i[_2][f2] = { all: g2 };
        for (var y2 = 0, b2 = r2; y2 < b2.length; y2++) {
          var D2 = b2[y2], x2 = Ze(D2);
          if (at(x2.getDay(), n2.startDay, n2.endDay)) {
            var C2 = a2[_2][f2][D2] || [], w2 = { invalids: [] }, T2 = [];
            i[_2][f2][D2] = w2, x2 < o3 && C2.push({ end: o3, start: new Date(x2) }), x2 >= ze(l2) && C2.push({ end: new Date(this._lastDay), start: l2 });
            for (var k2 = 0, S2 = C2; k2 < S2.length; k2++) {
              var E2 = S2[k2];
              if ($(E2) || Ke(E2)) {
                var M2 = Ze(E2);
                E2 = { allDay: true, end: new Date(M2), start: M2 };
              }
              var I2 = this._getEventData(E2, x2, u2, true);
              I2.cssClass = E2.cssClass ? " " + E2.cssClass : "", I2.position = void 0;
              var N2 = this._getEventPos(I2, x2, D2, m2);
              if (N2 && (!c2 && 0 === Le(N2.startDate) && /* @__PURE__ */ new Date(+N2.endDate + 1) >= it(x2, 1) ? I2.allDay = true : (I2.position = N2.position, Le(N2.startDate) <= this._startTime && (I2.cssClass += " mbsc-schedule-invalid-start"), Le(N2.endDate) >= this._endTime && (I2.cssClass += " mbsc-schedule-invalid-end")), T2.push(I2)), w2.invalids.push(I2), I2.allDay) {
                c2 || (I2.position = {}), w2.allDay = I2, w2.invalids = [I2], T2 = [I2];
                break;
              }
            }
            (t3 = g2.invalids).push.apply(t3, T2);
          }
        }
      }
    }
    return i;
  }, t2.prototype._getColors = function(e4) {
    for (var t3 = this.s, n2 = {}, s2 = ra(e4, this._resources, this._slots, !!t3.resources, !!t3.slots), i = Object.keys(e4 || {}).sort(), a2 = this._hasSlots, r2 = this._isTimeline, o3 = 0, l2 = this._resources; o3 < l2.length; o3++) {
      var c2 = l2[o3], d2 = c2.id, h2 = /* @__PURE__ */ new Map();
      n2[d2] = {};
      for (var u2 = 0, _2 = this._slots; u2 < _2.length; u2++) {
        var m2 = _2[u2].id;
        n2[d2][m2] = { all: { colors: [] } };
        for (var p2 = 0, v2 = i; p2 < v2.length; p2++) {
          var f2 = v2[p2], g2 = Ze(f2);
          if (at(g2.getDay(), t3.startDay, t3.endDay)) {
            var y2 = s2[d2][m2][f2] || [], b2 = !a2 && r2 ? "all" : f2;
            r2 && !a2 || (n2[d2][m2][b2] = { colors: [] });
            for (var D2 = n2[d2][m2][b2], x2 = 0, C2 = y2; x2 < C2.length; x2++) {
              var w2 = C2[x2], T2 = this._getEventData(w2, g2, c2, true);
              if (T2.cssClass = w2.cssClass ? " " + w2.cssClass : "", T2.allDay && !r2)
                D2.allDay = T2;
              else {
                var k2 = this._getEventPos(T2, g2, f2, h2);
                k2 && (T2.position = k2.position, Le(k2.startDate) <= this._startTime && (T2.cssClass += " mbsc-schedule-color-start"), Le(k2.endDate) >= this._endTime && (T2.cssClass += " mbsc-schedule-color-end"), D2.colors.push(T2));
              }
              T2.position.background = w2.background, T2.position.color = w2.textColor ? w2.textColor : $t(w2.background);
            }
          }
        }
      }
    }
    return n2;
  }, t2.prototype._flattenResources = function(e4, t3, n2, s2) {
    for (var i = 0, a2 = e4 && e4.length ? e4 : [{ id: ta }]; i < a2.length; i++) {
      var r2 = a2[i];
      r2.depth = n2, r2.isParent = !(!r2.children || !r2.children.length), t3.push(r2), r2.isParent && (this._hasHierarchy = true, r2.collapsed && !s2 || this._flattenResources(r2.children, t3, n2 + 1, s2));
    }
    return t3;
  }, t2.prototype._render = function(e4, t3) {
    var n2 = this, s2 = this._prevS, i = this._isTimeline, a2 = new Date(e4.selected), r2 = +e4.size, o3 = ia(e4.timeLabelStep), l2 = ia(e4.timeCellStep), c2 = e4.firstDay, d2 = e4.startDay, h2 = e4.endDay, u2 = e4.resources, _2 = e4.slots, m2 = e4.groupBy !== s2.groupBy || u2 !== s2.resources, p2 = false === e4.virtualScroll, v2 = e4.rtl !== s2.rtl || m2, f2 = this._startTime, g2 = this._endTime;
    if (e4.startTime !== s2.startTime || e4.endTime !== s2.endTime || e4.timeLabelStep !== s2.timeLabelStep || e4.timeCellStep !== s2.timeCellStep || e4.timeFormat !== s2.timeFormat || void 0 === this._startTime || void 0 === this._endTime) {
      var b2 = Ze(e4.startTime || "00:00"), D2 = new Date(+Ze(e4.endTime || "00:00") - 1);
      this._startTime = f2 = Le(b2), this._endTime = g2 = Le(D2), this._time = g2 - f2 + 1, this._timesBetween = se(ce(l2 / o3) - 1), this._times = [], this._timeLabels = {};
      for (var x2 = 6e4 * l2, C2 = ce(f2 / x2) * x2, w2 = function(e6) {
        if (T2._times.push(e6), i) {
          var t4 = e6 === C2;
          T2._timeLabels[e6] = t4 || e6 % (6e4 * o3) == 0 ? T2._formatTime(t4 ? f2 : e6) : "", T2._timesBetween.forEach(function(t5, s3) {
            var i2 = e6 + (s3 + 1) * o3 * 6e4;
            n2._timeLabels[i2] = n2._formatTime(i2);
          });
        }
      }, T2 = this, k2 = C2; k2 <= g2; k2 += x2)
        w2(k2);
      v2 = true;
    }
    if (m2 || d2 !== s2.startDay || h2 !== s2.endDay || _2 !== s2.slots || e4.dayNames !== s2.dayNames || e4.eventList !== s2.eventList || e4.getDay !== s2.getDay || e4.refDate !== s2.refDate || e4.rowHeight !== s2.rowHeight || e4.selected !== s2.selected || e4.size !== s2.size || e4.showDays !== s2.showDays || e4.type !== s2.type || e4.weekNumbers !== s2.weekNumbers) {
      var S2 = je(Je(e4)), E2 = "day" === e4.type, M2 = "month" === e4.type, I2 = "year" === e4.type, N2 = void 0, L2 = void 0, H2 = void 0, O2 = void 0;
      if (r2 > 1 || I2 || M2) {
        var R2 = e4.navigationService;
        H2 = N2 = R2.firstDay, O2 = L2 = R2.lastDay;
      } else {
        H2 = it(Ae(a2, e4), d2 - c2 + (d2 < c2 ? 7 : 0)), E2 && (a2 < H2 && (H2 = it(H2, -7)), a2 >= it(H2, 7) && (H2 = it(H2, 7))), O2 = it(H2, h2 - d2 + 1 + (h2 < d2 ? 7 : 0)), N2 = E2 ? ze(a2) : H2, L2 = E2 ? it(N2, 1) : O2;
      }
      this._isMulti = r2 > 1 || I2, this._hasHierarchy = false, this._resources = this._flattenResources(u2, [], 0, true), this._visibleResources = this._flattenResources(u2, [], 0), this._hasSlots = i && !!_2 && _2.length > 0, this._slots = _2 && _2.length ? _2 : [{ id: ta }], this._isSingleResource = 1 === this._resources.length, this._groupByResource = "date" !== e4.groupBy && !(E2 && r2 < 2) || this._isSingleResource, this._firstDay = N2, this._lastDay = L2, this._firstDayTz = Je(e4, N2.getFullYear(), N2.getMonth(), N2.getDate()), this._lastDayTz = Je(e4, L2.getFullYear(), L2.getMonth(), L2.getDate()), this._selectedDay = +ze(a2), this._setRowHeight = e4.eventList || "equal" !== e4.rowHeight, this._shouldAnimateScroll = void 0 !== s2.selected, this._showTimeIndicator = (!i || i && !M2 && !I2) && !e4.eventList && (E2 && r2 < 2 ? Ue(S2, a2) : N2 <= S2 && L2 >= S2), this._dayIndexMap = {}, this._days = [], this._headerDays = [];
      var V2 = 0, P2 = -1, z2 = -1, Y2 = "", W2 = -1, F2 = -1, A2 = "", U2 = N2, B2 = L2, X2 = E2 && r2 < 2, K2 = e4.dateFormat.search(/m/i), q2 = e4.dateFormat.search(/y/i) < K2;
      !i && X2 && (U2 = H2, B2 = O2);
      for (k2 = ze(U2); k2 < ze(B2); k2.setDate(k2.getDate() + 1))
        if (at(k2.getDay(), d2, h2)) {
          var j2 = Pe(k2), J2 = "", Z2 = "";
          if (i) {
            var $2 = e4.getWeekNumber(it(k2, (7 - c2 + 1) % 7)), Q2 = e4.getMonth(k2);
            if (P2 !== Q2) {
              z2 = V2, P2 = Q2;
              var ee2 = e4.getYear(k2), te2 = e4.monthNames[P2];
              J2 = Y2 = q2 ? ee2 + " " + te2 : te2 + " " + ee2, V2 > 0 && (this._days[V2 - 1].lastOfMonth = true);
            }
            W2 !== $2 && (F2 = V2, W2 = $2, Z2 = A2 = e4.weekText.replace(/{count}/, W2), V2 > 0 && (this._days[V2 - 1].lastOfWeek = true));
          }
          var ne2 = { date: new Date(k2), dateIndex: V2, dateKey: j2, dateText: et(M2 || this._isMulti ? "D DDD" : e4.dateFormatLong, k2, e4), day: e4.getDay(k2), label: et("DDDD, MMMM D, YYYY", k2, e4), monthIndex: z2, monthText: Y2, monthTitle: J2, timestamp: +ze(k2), weekIndex: F2, weekText: A2, weekTitle: Z2 };
          X2 && this._headerDays.push(ne2), X2 && this._selectedDay !== +k2 || this._days.push(ne2), this._dayIndexMap[j2] = V2, V2++;
        }
      this._daysNr = X2 ? 1 : V2, v2 = true;
    }
    (e4.colorsMap !== s2.colorsMap || v2) && (this._colors = this._getColors(e4.colorsMap)), e4.eventMap === s2.eventMap && !v2 && this._events || (this._eventMap = {}, this._eventRows = {}, this._events = this._getEvents(e4.eventMap)), (e4.invalidsMap !== s2.invalidsMap || v2) && (this._invalids = this._getInvalids(e4.invalidsMap));
    var ie2 = i && e4.eventMap !== s2.eventMap;
    if ((e4.height !== s2.height || e4.width !== s2.width || ie2 || v2) && (this._shouldCheckSize = y$2 && !!e4.height && !!e4.width), e4.scroll !== s2.scroll && (this._shouldScroll = true), void 0 !== e4.height && (this._hasSideSticky = Ut && !e4.rtl, this._hasSticky = Ut), this._stepCell = 6e4 * l2, this._stepLabel = 6e4 * o3, this._dayNames = t3.dayNameWidth > 49 ? e4.dayNamesShort : e4.dayNamesMin, this._displayTime = o3 < 1440, this._eventHeight = t3.eventHeight || (e4.eventList ? 24 : 46), this._showCursorTime = this._displayTime && !!(e4.dragToCreate || e4.dragToMove || e4.dragToResize), i) {
      var ae2 = [], re2 = void 0 === this._daysBatchNr ? G(ce(this._stepCell / (this._time / 30)), 1, 30) : this._daysBatchNr, le2 = this._dayIndexMap[Pe(a2)] || 0, de2 = void 0 !== t3.batchIndexX ? t3.batchIndexX : oe(le2 / re2), he2 = Math.min(de2 * re2, this._daysNr - 1), ue2 = p2 ? 0 : Math.max(0, he2 - ce(3 * re2 / 2)), _e2 = p2 ? this._daysNr : Math.min(ue2 + 3 * re2, this._daysNr), me2 = this._days[ue2].date, pe2 = it(this._days[_e2 - 1].date, 1);
      for (V2 = ue2; V2 < _e2; V2++)
        ae2.push(this._days[V2]);
      this._batchStart = Je(e4, me2.getFullYear(), me2.getMonth(), me2.getDate()), this._batchEnd = Je(e4, pe2.getFullYear(), pe2.getMonth(), pe2.getDate()), this._daysBatch = ae2, this._daysBatchNr = re2, this._placeholderSizeX = t3.dayWidth * oe(Math.max(0, he2 - 3 * re2 / 2)) || 0;
      var ve2 = (t3.scrollContHeight || 0) - (t3.headerHeight || 0), fe2 = t3.rowHeight || 52, ge2 = [], ye = t3.batchIndexY || 0, be2 = this._visibleResources, De2 = [], xe = -1, Ce2 = 0;
      ve2 && (t3.hasScrollY && (this._resourceTops = {}), be2.forEach(function(e6, s3) {
        var i2 = n2._setRowHeight ? Math.max(n2._eventRows[e6.id] * n2._eventHeight + 16, 52) : fe2, a3 = ce(Ce2 / ve2);
        t3.hasScrollY && (n2._resourceTops[e6.id] = Ce2), a3 !== xe && (De2.push({ startIndex: s3, top: Ce2 }), xe = a3), Ce2 += i2;
      }));
      var we2 = De2[ye - 1], Te2 = De2[ye + 2], ke2 = we2 ? we2.startIndex : 0, Se2 = Te2 ? Te2.startIndex : Ce2 ? be2.length : 30;
      (p2 || Ce2 && !t3.hasScrollY) && (ke2 = 0, Se2 = be2.length);
      for (V2 = ke2; V2 < Se2; V2++) {
        var Ee2 = be2[V2];
        Ee2 && ge2.push(Ee2);
      }
      this._gridHeight = Ce2, this._virtualPagesY = De2, this._resourcesBatch = ge2, this._placeholderSizeY = we2 && !p2 ? we2.top : 0;
    }
  }, t2.prototype._mounted = function() {
    var e4, t3, n2, s2 = this;
    this._unlisten = Ds(this._el, { onDoubleClick: function(e6) {
      var t4 = s2.s;
      n2 && t4.clickToCreate && "single" !== t4.clickToCreate && (e6.click = true, s2._onEventDragStart(e6), s2._onEventDragEnd(e6));
    }, onEnd: function(n3) {
      !e4 && t3 && "single" === s2.s.clickToCreate && (e4 = true, n3.click = true, s2._onEventDragStart(n3)), e4 && (n3.domEvent.preventDefault(), s2._onEventDragEnd(n3)), clearTimeout(s2._touchTimer), e4 = false, t3 = false;
    }, onMove: function(n3) {
      var i = s2.s;
      e4 && i.dragToCreate ? (n3.domEvent.preventDefault(), s2._onEventDragMove(n3)) : t3 && i.dragToCreate && (Math.abs(n3.deltaX) > 7 || Math.abs(n3.deltaY) > 7) ? (e4 = true, s2._onEventDragStart(n3)) : clearTimeout(s2._touchTimer);
    }, onStart: function(i) {
      var a2 = s2.s;
      if (i.create = true, i.click = false, s2._isTouch = i.isTouch, !e4 && (a2.dragToCreate || a2.clickToCreate)) {
        var r2 = i.domEvent.target && i.domEvent.target.classList || [];
        (n2 = r2.contains("mbsc-schedule-item") || r2.contains("mbsc-schedule-all-day-item") || r2.contains("mbsc-timeline-column")) && (i.isTouch && a2.dragToCreate ? s2._touchTimer = setTimeout(function() {
          s2._onEventDragStart(i), s2._onEventDragModeOn(i), e4 = true;
        }, 350) : t3 = !i.isTouch);
      }
    } }), this._unsubscribe = Fi(this._onExternalDrag);
  }, t2.prototype._updated = function() {
    var e4 = this, t3 = this.s, n2 = this.state;
    this._shouldCheckSize && _e(this, function() {
      var s2, i, a2, r2, o3, l2, c2 = e4._resCont, d2 = c2 ? c2.offsetWidth : 0, h2 = e4._headerCont, u2 = h2.offsetHeight, _2 = e4._scrollCont, m2 = _2.offsetWidth, p2 = _2.offsetHeight, v2 = _2.clientWidth, f2 = _2.clientHeight, g2 = m2 - v2, y2 = p2 - f2, b2 = m2 - d2, D2 = p2 - u2, x2 = _2.scrollHeight > f2, C2 = _2.scrollWidth > v2, w2 = n2.eventHeight;
      if (e4._isTimeline) {
        var T2 = _2.querySelector(".mbsc-timeline-day"), k2 = _2.querySelector(".mbsc-timeline-row");
        if (a2 = T2 ? T2.offsetWidth : 64, l2 = k2 ? k2.offsetHeight : 52, a2 * e4._daysNr < b2 && (C2 = false), e4._gridHeight && e4._gridHeight < D2 && (x2 = false), a2 = C2 ? a2 : oe(b2 / e4._daysNr), o3 = C2 ? a2 * e4._daysNr : b2, i = e4._stepCell * a2 / e4._time, e4._gridWidth = o3, e4._daysBatchNr = Math.max(1, Math.ceil(b2 / a2)), e4._hasSticky || (h2.style[t3.rtl ? "left" : "right"] = g2 + "px"), !e4._hasSideSticky && c2 && (c2.style.bottom = y2 + "px"), e4._setRowHeight) {
          var S2 = _2.querySelector(".mbsc-schedule-event");
          S2 && (w2 = S2.clientHeight);
        }
        if (!x2) {
          e4._resourceTops = {};
          var E2 = e4._gridCont, M2 = E2.getBoundingClientRect();
          E2.querySelectorAll(".mbsc-timeline-row").forEach(function(t4, n3) {
            e4._resourceTops[e4._visibleResources[n3].id] = t4.getBoundingClientRect().top - M2.top;
          });
        }
      } else {
        e4._calcGridSizes();
        var I2 = e4._el.querySelector(".mbsc-schedule-column-inner"), N2 = e4._el.querySelector(".mbsc-schedule-header-item");
        s2 = I2 ? e4._stepCell * I2.offsetHeight / e4._time : 0, r2 = N2 ? N2.offsetWidth : 0;
      }
      e4._onScroll(), e4._calcConnections = !!t3.connections && (e4._isParentClick || e4._calcConnections || !x2), e4._shouldCheckSize = false, e4._isCursorTimeVisible = false, e4._isTouch = false, e4.setState({ cellHeight: s2, cellWidth: i, dayNameWidth: r2, dayWidth: a2, eventHeight: w2, gridWidth: o3, hasScrollX: C2, hasScrollY: x2, headerHeight: u2, rowHeight: l2, scrollContHeight: C2 ? f2 : p2, update: e4._calcConnections ? (n2.update || 0) + 1 : n2.update });
    }), !this._shouldScroll || !n2.dayWidth && this._isTimeline || (_e(this, function() {
      e4._scrollToTime(e4._shouldAnimateScroll);
    }), this._shouldScroll = false);
  }, t2.prototype._destroy = function() {
    this._unlisten(), Ai(this._unsubscribe);
  }, t2.prototype._calcGridSizes = function() {
    var e4 = this.s, t3 = this._resources, n2 = this._isTimeline, s2 = this._daysNr * (n2 ? 1 : t3.length), i = this._gridCont, a2 = this._scrollCont, r2 = i.getBoundingClientRect(), o3 = a2.getBoundingClientRect(), l2 = n2 ? r2.width : i.scrollWidth;
    this._gridLeft = e4.rtl ? r2.right - l2 : r2.left, this._gridRight = e4.rtl ? r2.right : r2.left + l2, this._gridTop = r2.top, this._gridContTop = o3.top, this._gridContBottom = o3.bottom, this._gridContLeft = o3.left, this._gridContRight = o3.right, this._allDayTop = this._gridContTop, this._colWidth = l2 / s2, this._colHeight = r2.height, this._resWidth = this._resCont ? this._resCont.offsetWidth : 0;
  }, t2.prototype._getDragDates = function(e4, t3, n2) {
    var s2 = this.s, i = {}, a2 = /* @__PURE__ */ new Map(), r2 = e4.allDay ? this._firstDay : this._firstDayTz, o3 = e4.startDate, l2 = e4.endDate;
    for (o3 = (o3 = ze(o3)) < r2 ? r2 : o3, l2 = Ve(s2, e4.allDay || s2.eventList, o3, l2); o3 <= l2; ) {
      var c2 = d$2({}, e4), h2 = Pe(o3), u2 = at(o3.getDay(), s2.startDay, s2.endDay) && this._getEventPos(e4, o3, h2, a2);
      if (u2) {
        var _2 = c2.resource;
        this._isTimeline && -1 !== (j(_2) ? _2 : [_2]).indexOf(this._tempResource) && (u2.position.top = c2.position.top);
        var m2 = this._isTimeline && !this._hasSlots ? "all" : h2;
        c2.date = +ze(o3, true), c2.cssClass = u2.cssClass, c2.start = u2.start, c2.end = u2.end, c2.position = u2.position, i[t3 + "__" + (this._isTimeline ? n2 + "__" : "") + m2] = c2;
      }
      o3 = it(o3, 1);
    }
    return i;
  }, t2.prototype._getGridTime = function(e4, t3, n2, s2, i) {
    var a2 = le(this._isTimeline ? ce(this._time * (t3 - s2 * this._colWidth) / this._colWidth) : ce(this._time * (n2 - 8) / (this._colHeight - 16)), 6e4 * i), r2 = new Date(+Te + this._startTime + a2);
    return Je(this.s, e4.getFullYear(), e4.getMonth(), e4.getDate(), r2.getHours(), r2.getMinutes());
  }, t2.prototype._scrollToTime = function(e4) {
    var t3 = this._scrollCont, n2 = this._gridCont, s2 = this._isTimeline;
    if (t3) {
      var i = this.s, a2 = i.navigateToEvent, r2 = a2 && a2.start ? rt(new Date(+Ze(a2.start, i) - this._stepCell), i.timeCellStep) : new Date(i.selected);
      r2.setHours(i.eventList ? 0 : r2.getHours(), 0);
      var o3 = aa(r2, this._startTime, this._time * (s2 ? this._daysNr : 1)), l2 = Fe(this._firstDay, r2, i.startDay, i.endDay), c2 = (s2 ? n2.offsetWidth : n2.scrollWidth) * (100 * l2 / this._daysNr + (s2 ? o3 : 0)) / 100, d2 = void 0;
      if (a2) {
        var h2 = a2.resource, u2 = j(h2) ? h2[0] : h2;
        if (u2)
          if (s2)
            d2 = this._resourceTops[u2];
          else {
            var _2 = this._colWidth, m2 = this._visibleResources, p2 = pe(m2, function(e6) {
              return e6.id === u2;
            }) || 0;
            c2 = this._groupByResource && !this._isSingleResource ? this._daysNr * _2 * p2 + _2 * l2 : m2.length * l2 * _2 + p2 * _2;
          }
      }
      if (!s2) {
        var v2 = t3.querySelector(".mbsc-schedule-column-inner");
        d2 = v2 ? v2.offsetHeight * o3 / 100 : 0, !this._groupByResource || this._isSingleResource || a2 || (c2 = void 0);
      }
      en(t3, c2, d2, e4, i.rtl);
    }
  }, t2;
}(wt), ua = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._onScroll = function() {
      var e4 = t3._scrollCont;
      if (e4) {
        var n2 = e4.scrollTop, s2 = "translateX(" + -e4.scrollLeft + "px)", i = t3._timeCont, a2 = t3._allDayCont, r2 = t3._headerCont, o3 = (Wt ? Wt + "T" : "t") + "ransform";
        a2 && (a2.style[o3] = s2), i && (i.style.marginTop = -n2 + "px"), r2 && (r2.style[o3] = s2), 0 === n2 ? t3.setState({ showShadow: false }) : t3.state.showShadow || t3.setState({ showShadow: true }), t3._onMouseMove();
      }
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._render = function(t3, n2) {
    e3.prototype._render.call(this, t3, n2);
    var s2 = this._prevS, i = t3.timezones, a2 = this._stepCell / 6e4, r2 = ce(this._startTime / 6e4) % a2, o3 = ce(this._endTime / 6e4) % a2 + 1;
    if (i !== s2.timezones && (this._timeWidth = i ? { width: 4.25 * i.length + "em" } : void 0, this._timezones = void 0, i)) {
      for (var l2 = [], c2 = 0, d2 = i; c2 < d2.length; c2++) {
        var h2 = d2[c2], u2 = void 0;
        if ($(h2)) {
          var _2 = Je(t3, 1970, 0, 1);
          ke(_2) && _2.setTimezone(h2);
          var m2 = _2.getTimezoneOffset() / 60 * -1;
          u2 = { label: "UTC" + (m2 > 0 ? "+" : "") + m2, timezone: h2 };
        } else
          u2 = h2;
        l2.push(u2);
      }
      this._timezones = l2;
    }
    this._largeDayNames = n2.dayNameWidth > 99, this._startCellStyle = r2 % a2 != 0 ? { height: (n2.cellHeight || 50) * ((a2 - r2) % a2 / a2) + "px" } : void 0, this._endCellStyle = o3 % a2 != 0 ? { height: (n2.cellHeight || 50) * (o3 % a2) / a2 + "px" } : void 0;
  }, t2;
}(ha), _a = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4) {
    var t3 = this, n2 = e4.timezones;
    return ls("div", { "aria-hidden": "true", className: this._cssClass, style: this._pos }, ls("div", { className: (n2 ? "mbsc-flex " : "") + "mbsc-schedule-time-indicator-time mbsc-schedule-time-indicator-time-" + e4.orientation + this._theme + this._rtl }, n2 ? n2.map(function(e6, n3) {
      return ls("div", { key: n3, className: "mbsc-schedule-time-indicator-tz" + t3._theme + t3._rtl }, t3._times[n3]);
    }) : this._time), e4.showDayIndicator && ls("div", { className: "mbsc-schedule-time-indicator-day" + this._theme, style: this._dayPos }));
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._mounted = function() {
    var e4 = this;
    clearInterval(this._timer), this._timer = setInterval(function() {
      e4._zone ? e4._zone.runOutsideAngular(function() {
        e4.forceUpdate();
      }) : e4.forceUpdate();
    }, 1e4);
  }, t2.prototype._destroy = function() {
    clearInterval(this._timer);
  }, t2.prototype._render = function(e4) {
    var t3 = Je(e4), n2 = e4.rtl, s2 = e4.displayedDays, i = e4.displayedTime, a2 = e4.startTime, r2 = 6e4 * ce(Le(t3) / 6e4), o3 = e4.timezones, l2 = { amText: e4.amText, pmText: e4.pmText };
    if (o3 && ke(t3)) {
      this._times = [];
      for (var c2 = 0, d2 = o3; c2 < d2.length; c2++) {
        var h2 = d2[c2], u2 = t3.clone();
        u2.setTimezone(h2.timezone), this._times.push(et(e4.timeFormat, u2, l2));
      }
    } else
      this._time = et(e4.timeFormat, t3, l2);
    this._cssClass = "mbsc-schedule-time-indicator mbsc-schedule-time-indicator-" + e4.orientation + this._theme + this._rtl + " " + (r2 < a2 || r2 > a2 + i || !at(t3.getDay(), e4.startDay, e4.endDay) ? " mbsc-hidden" : "");
    var _2 = Fe(e4.firstDay, t3, e4.startDay, e4.endDay);
    if ("x" === e4.orientation) {
      var m2 = 100 * _2 / s2 + "%", p2 = o3 && 4.25 * o3.length + "em";
      this._pos = { left: o3 && !n2 ? p2 : void 0, right: o3 && n2 ? p2 : void 0, top: 100 * (r2 - a2) / i + "%" }, this._dayPos = { left: n2 ? "" : m2, right: n2 ? m2 : "", width: 100 / s2 + "%" };
    } else {
      var v2 = 100 * (_2 * i + r2 - a2) / (s2 * i) + "%";
      this._pos = { left: n2 ? "" : v2, right: n2 ? v2 : "" };
    }
  }, t2;
}(wt)), ma = /* @__PURE__ */ function(e3) {
  function t2() {
    return null !== e3 && e3.apply(this, arguments) || this;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4, t3) {
    var n2;
    return e4.renderDay && (n2 = e4.renderDay(this._data)), e4.renderDayContent && (n2 = e4.renderDayContent(this._data)), $(n2) && (n2 = ls("div", { dangerouslySetInnerHTML: this._safeHtml(n2) }), this._shouldEnhance = true), ls("div", { ref: this._setEl, className: this._cssClass, onClick: this._onClick }, e4.renderDay ? n2 : ls(ds, null, ls("div", { "aria-hidden": "true", className: "mbsc-schedule-header-dayname" + this._theme + (e4.selected ? " mbsc-selected" : "") + (e4.isToday ? " mbsc-schedule-header-dayname-curr" : "") }, e4.dayNames[this._day]), ls("div", { "aria-hidden": "true", className: "mbsc-schedule-header-day" + this._theme + this._rtl + (e4.selected ? " mbsc-selected" : "") + (e4.isToday ? " mbsc-schedule-header-day-today" : "") + (t3.hasHover ? " mbsc-hover" : "") }, e4.day), e4.label && ls("div", { className: "mbsc-hidden-content", "aria-pressed": e4.selectable ? e4.selected ? "true" : "false" : void 0, role: e4.selectable ? "button" : void 0 }, e4.label), e4.renderDayContent && n2));
  }, t2;
}(/* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._onClick = function() {
      var e4 = t3.s;
      e4.selectable && e4.onClick(e4.timestamp);
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._render = function(e4, t3) {
    var n2 = new Date(e4.timestamp);
    this._cssClass = "mbsc-schedule-header-item " + this._className + this._theme + this._rtl + this._hb + (e4.largeNames ? " mbsc-schedule-header-item-large" : "") + (e4.selected ? " mbsc-selected" : "") + (t3.hasHover ? " mbsc-hover" : ""), this._data = { date: n2, events: e4.events, resource: e4.resource, selected: e4.selected }, this._day = n2.getDay();
  }, t2.prototype._mounted = function() {
    var e4 = this;
    this._unlisten = Ds(this._el, { onHoverIn: function() {
      e4.s.selectable && e4.setState({ hasHover: true });
    }, onHoverOut: function() {
      e4.s.selectable && e4.setState({ hasHover: false });
    } });
  }, t2.prototype._destroy = function() {
    this._unlisten && this._unlisten();
  }, t2;
}(wt)), pa = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._setCont = function(e4) {
      t3._scrollCont = e4;
    }, t3._setTimeCont = function(e4) {
      t3._timeCont = e4;
    }, t3._setAllDayCont = function(e4) {
      t3._allDayCont = e4;
    }, t3._setGridCont = function(e4) {
      t3._gridCont = e4;
    }, t3._setHeaderCont = function(e4) {
      t3._headerCont = e4;
    }, t3._setCursorTimeCont = function(e4) {
      t3._cursorTimeCont = e4;
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4, t3) {
    var n2 = this, s2 = this._colors, i = t3.dragData, a2 = i && i.draggedEvent && i.draggedEvent.id, r2 = this._events, o3 = this._invalids, l2 = this._hb, c2 = this._rtl, h2 = this._times, u2 = this._startTime, _2 = this._endTime, m2 = this._startCellStyle, p2 = this._endCellStyle, v2 = this._stepLabel, f2 = this._theme, g2 = this._isSingleResource, y2 = e4.eventMap || {}, b2 = "schedule", D2 = " mbsc-flex-1-0 mbsc-schedule-resource-group" + f2 + c2, x2 = this._timezones, C2 = this._groupByResource, w2 = this._days, T2 = this._resources, k2 = { dayNames: this._dayNames, largeNames: this._largeDayNames, onClick: e4.onWeekDayClick, renderDay: e4.renderDay, renderDayContent: e4.renderDayContent, rtl: e4.rtl, theme: e4.theme }, S2 = function(t4) {
      var s3, i2 = t4.name;
      return e4.renderResource && $(i2 = e4.renderResource(t4)) && (s3 = n2._safeHtml(i2), n2._shouldEnhance = true), i2 && ls("div", { key: t4.id, className: "mbsc-schedule-resource" + f2 + c2 + l2 + (!C2 || "day" === e4.type && 1 === e4.size ? " mbsc-flex-1-0 mbsc-schedule-col-width" : "") }, ls("div", { dangerouslySetInnerHTML: s3, className: "mbsc-schedule-resource-title" }, i2));
    }, E2 = function(t4, s3, r3, o4) {
      var l3 = r3 + "__" + s3, c3 = { displayTimezone: e4.displayTimezone, drag: e4.dragToMove, endDay: e4.endDay, exclusiveEndDates: e4.exclusiveEndDates, gridEndTime: _2, gridStartTime: u2, lastDay: +n2._lastDay, render: e4.renderEvent, renderContent: e4.renderEventContent, resize: e4.dragToResize, resource: r3, rtl: e4.rtl, singleDay: !C2, slot: ta, startDay: e4.startDay, theme: e4.theme, timezonePlugin: e4.timezonePlugin };
      return ls(ds, null, t4.map(function(t5) {
        return t5.showText ? ls(da, d$2({}, c3, { event: t5, key: t5.uid, inactive: a2 === t5.id, selected: e4.selectedEventsMap[t5.uid] || e4.selectedEventsMap[t5.id], onClick: e4.onEventClick, onDoubleClick: e4.onEventDoubleClick, onRightClick: e4.onEventRightClick, onDelete: e4.onEventDelete, onHoverIn: e4.onEventHoverIn, onHoverOut: e4.onEventHoverOut, onDragStart: n2._onEventDragStart, onDragMove: n2._onEventDragMove, onDragEnd: n2._onEventDragEnd, onDragModeOn: n2._onEventDragModeOn, onDragModeOff: n2._onEventDragModeOff })) : ls("div", { key: t5.uid, className: "mbsc-schedule-event mbsc-schedule-event-all-day mbsc-schedule-event-all-day-placeholder" }, ls("div", { className: "mbsc-schedule-event-all-day-inner" + f2 }));
      }), i && i.originDates && i.originDates[l3] && !!i.originDates[l3].allDay == !!o4 && ls(da, d$2({}, c3, { event: i.originDates[l3], hidden: i && !!i.draggedDates, isDrag: true, onDragStart: n2._onEventDragStart, onDragMove: n2._onEventDragMove, onDragEnd: n2._onEventDragEnd, onDragModeOff: n2._onEventDragModeOff })), i && i.draggedDates && i.draggedDates[l3] && !!i.draggedDates[l3].allDay == !!o4 && ls(da, d$2({}, c3, { event: i.draggedDates[l3], isDrag: true })));
    }, M2 = function(e6) {
      return h2.map(function(t4, s3) {
        var i2 = !s3, a3 = s3 === h2.length - 1;
        return ls("div", { key: s3, className: "mbsc-flex-col mbsc-flex-1-0 mbsc-schedule-time-wrapper" + f2 + c2 + (a3 ? " mbsc-schedule-time-wrapper-end" : "") + (i2 && m2 || a3 && p2 ? " mbsc-flex-none" : ""), style: i2 ? m2 : a3 ? p2 : {} }, ls("div", { className: "mbsc-flex-1-1 mbsc-schedule-time" + f2 + c2 }, i2 || t4 % v2 == 0 ? n2._formatTime(i2 ? u2 : t4, e6) : ""), n2._timesBetween.map(function(s4, i3) {
          var a4 = t4 + (i3 + 1) * v2;
          return a4 > u2 && a4 < _2 && ls("div", { key: i3, className: "mbsc-flex-1-1 mbsc-schedule-time" + f2 + c2 }, n2._formatTime(a4, e6));
        }), a3 && ls("div", { className: "mbsc-schedule-time mbsc-schedule-time-end" + f2 + c2 }, n2._formatTime(_2 + 1, e6)));
      });
    }, I2 = function(e6, t4, n3, i2) {
      var a3 = o3[e6][ta][t4] && o3[e6][ta][t4].allDay, d2 = s2[e6][ta][t4] && s2[e6][ta][t4].allDay, h3 = r2[e6][ta][t4] && r2[e6][ta][t4].allDay;
      return ls("div", { key: n3 + "-" + i2, className: "mbsc-schedule-all-day-item mbsc-schedule-col-width mbsc-flex-1-0" + f2 + c2 + l2 }, E2(h3 || [], t4, e6, true), a3 && ls("div", { className: "mbsc-schedule-invalid mbsc-schedule-invalid-all-day" + a3.cssClass + f2 }, ls("div", { className: "mbsc-schedule-invalid-text" }, a3.title)), d2 && ls("div", { className: "mbsc-schedule-color mbsc-schedule-color-all-day" + d2.cssClass + f2, style: d2.position }, ls("div", { className: "mbsc-schedule-color-text" }, d2.title)));
    }, N2 = function(t4, n3, i2, a3) {
      var d2 = o3[t4][ta][n3] && o3[t4][ta][n3].invalids, u3 = s2[t4][ta][n3] && s2[t4][ta][n3].colors, _3 = r2[t4][ta][n3] && r2[t4][ta][n3].events;
      return ls("div", { key: i2 + "-" + a3, className: "mbsc-flex-col mbsc-flex-1-0 mbsc-schedule-column mbsc-schedule-col-width" + f2 + c2 + l2 }, ls("div", { className: "mbsc-flex-col mbsc-flex-1-1 mbsc-schedule-column-inner" + f2 + c2 + l2 }, ls("div", { className: "mbsc-schedule-events" + c2 }, E2(_3 || [], n3, t4)), d2 && d2.map(function(e6, t5) {
        return e6.position && ls("div", { key: t5, className: "mbsc-schedule-invalid" + e6.cssClass + f2, style: e6.position }, ls("div", { className: "mbsc-schedule-invalid-text" }, e6.allDay ? "" : e6.title || ""));
      }), u3 && u3.map(function(e6, t5) {
        return ls("div", { key: t5, className: "mbsc-schedule-color" + e6.cssClass + f2, style: e6.position }, ls("div", { className: "mbsc-schedule-color-text" }, e6.title));
      }), h2.map(function(n4, s3) {
        var i3 = oa(a3, n4), r3 = !s3, o4 = s3 === h2.length - 1;
        return ls("div", { key: s3, className: "mbsc-schedule-item mbsc-flex-1-0" + f2 + l2 + (o4 ? " mbsc-schedule-item-last" : "") + (r3 && m2 || o4 && p2 ? " mbsc-flex-none" : ""), onClick: function(n5) {
          return e4.onCellClick({ date: i3, domEvent: n5, resource: t4, source: b2 });
        }, onDoubleClick: function(n5) {
          return e4.onCellDoubleClick({ date: i3, domEvent: n5, resource: t4, source: b2 });
        }, onContextMenu: function(n5) {
          return e4.onCellRightClick({ date: i3, domEvent: n5, resource: t4, source: b2 });
        }, style: r3 ? m2 : o4 ? p2 : {} });
      })));
    };
    return ls("div", { ref: this._setEl, className: "mbsc-flex-col mbsc-flex-1-1 mbsc-schedule-wrapper" + f2 + (this._daysNr > 7 ? " mbsc-schedule-wrapper-multi" : "") }, ls("div", { className: "mbsc-schedule-header mbsc-flex mbsc-flex-none" + f2 + l2 }, ls("div", { className: "mbsc-schedule-time-col mbsc-schedule-time-col-empty" + f2 + c2 + l2, style: this._timeWidth }), ls("div", { className: "mbsc-flex-1-1 mbsc-schedule-header-wrapper" }, ls("div", { ref: this._setHeaderCont, className: "mbsc-flex" }, "day" === e4.type && 1 === e4.size ? ls("div", { className: D2 }, ls("div", { className: "mbsc-flex" }, e4.showDays && this._headerDays.map(function(e6) {
      var t4 = e6.timestamp;
      return ls(ma, d$2({}, k2, { key: t4, cssClass: "mbsc-flex-1-1", day: e6.day, events: y2[e6.dateKey], isToday: n2._isToday(t4), label: e6.label, selectable: true, selected: n2._selectedDay === t4, timestamp: t4 }));
    })), e4.resources && ls("div", { className: "mbsc-flex" }, T2.map(S2))) : C2 ? T2.map(function(t4, s3) {
      return ls("div", { key: s3, className: D2 }, S2(t4), ls("div", { className: "mbsc-flex" }, e4.showDays && w2.map(function(e6) {
        var s4 = e6.timestamp;
        return ls(ma, d$2({}, k2, { key: s4, cssClass: "mbsc-flex-1-0 mbsc-schedule-col-width", day: e6.day, events: y2[e6.dateKey], isToday: g2 && n2._isToday(s4), label: e6.label, resource: t4.id, selectable: false, selected: g2 && n2._isToday(s4), timestamp: s4 }));
      })));
    }) : w2.map(function(t4, s3) {
      var i2 = t4.timestamp;
      return ls("div", { key: s3, className: D2 }, e4.showDays && ls(ma, d$2({}, k2, { key: i2, day: t4.day, events: y2[t4.dateKey], isToday: g2 && n2._isToday(i2), label: t4.label, selectable: false, selected: n2._isToday(i2), timestamp: i2 })), e4.resources && ls("div", { className: "mbsc-flex" }, T2.map(S2)));
    }))), ls("div", { className: "mbsc-schedule-fake-scroll-y" })), ls("div", { className: "mbsc-schedule-all-day-cont" + (t3.showShadow ? " mbsc-schedule-all-day-wrapper-shadow" : "") + f2 }, x2 && ls("div", { className: "mbsc-flex mbsc-schedule-timezone-labels", style: this._timeWidth }, x2.map(function(e6, t4) {
      return ls("div", { key: t4, className: "mbsc-flex-1-0-0 mbsc-schedule-timezone-label" + f2 + c2 }, e6.label);
    })), e4.showAllDay && ls("div", { className: "mbsc-schedule-all-day-wrapper mbsc-flex-none" + f2 + l2 }, ls("div", { className: "mbsc-flex mbsc-schedule-all-day" + f2 }, ls("div", { className: "mbsc-schedule-time-col" + f2 + c2, style: this._timeWidth }, !x2 && ls("div", { className: "mbsc-schedule-all-day-text" + f2 + c2 }, e4.allDayText)), ls("div", { className: "mbsc-flex-col mbsc-flex-1-1 mbsc-schedule-all-day-group-wrapper" }, ls("div", { ref: this._setAllDayCont, className: "mbsc-flex mbsc-flex-1-1" }, C2 ? T2.map(function(e6, t4) {
      return ls("div", { key: t4, className: "mbsc-flex" + D2 }, w2.map(function(t5, n3) {
        return I2(e6.id, t5.dateKey, n3, t5.timestamp);
      }));
    }) : w2.map(function(e6, t4) {
      return ls("div", { key: t4, className: "mbsc-flex" + D2 }, T2.map(function(t5, n3) {
        return I2(t5.id, e6.dateKey, n3, e6.timestamp);
      }));
    })))))), ls("div", { className: "mbsc-flex mbsc-flex-1-1 mbsc-schedule-grid-wrapper" + f2 }, ls("div", { "aria-hidden": "true", className: "mbsc-flex-col mbsc-schedule-time-col mbsc-schedule-time-cont" + f2 + c2, style: this._timeWidth, ref: this._setTimeCont }, ls("div", { className: "mbsc-flex mbsc-schedule-time-cont-inner" }, ls("div", { className: "mbsc-flex-col mbsc-flex-1-1" }, ls("div", { className: "mbsc-flex-1-1 mbsc-schedule-time-cont-pos" + f2 + (x2 ? " mbsc-flex" : " mbsc-flex-col mbsc-schedule-time-col-last") }, x2 ? x2.map(function(e6, t4) {
      return ls("div", { key: t4, className: "mbsc-flex-col" + f2 + (t4 === x2.length - 1 ? " mbsc-schedule-time-col-last" : "") }, M2(e6.timezone));
    }) : M2(), this._showTimeIndicator && ls(_a, { amText: e4.amText, displayedTime: this._time, displayedDays: this._daysNr, displayTimezone: e4.displayTimezone, endDay: e4.endDay, firstDay: this._firstDayTz, orientation: "x", pmText: e4.pmText, rtl: e4.rtl, showDayIndicator: g2 && !this._isMulti && "week" === e4.type, startDay: e4.startDay, startTime: u2, theme: e4.theme, timeFormat: e4.timeFormat, timezones: x2, timezonePlugin: e4.timezonePlugin }), this._showCursorTime && ls("div", { ref: this._setCursorTimeCont, className: "mbsc-schedule-cursor-time mbsc-schedule-cursor-time-x" + f2 + c2 })), t3.hasScrollX && ls("div", { className: "mbsc-schedule-fake-scroll-x" })), ls("div", { className: "mbsc-schedule-fake-scroll-y" }))), ls("div", { ref: this._setCont, className: "mbsc-flex-col mbsc-flex-1-1 mbsc-schedule-grid-scroll" + f2, onScroll: this._onScroll }, ls("div", { className: "mbsc-flex mbsc-flex-1-1" }, ls("div", { className: "mbsc-flex mbsc-schedule-grid", ref: this._setGridCont, onMouseLeave: this._onMouseLeave, onMouseMove: this._onMouseMove }, C2 ? T2.map(function(e6, t4) {
      return ls("div", { key: t4, className: "mbsc-flex" + D2 }, w2.map(function(t5, n3) {
        return N2(e6.id, t5.dateKey, n3, t5.timestamp);
      }));
    }) : w2.map(function(e6, t4) {
      return ls("div", { key: t4, className: "mbsc-flex" + D2 }, T2.map(function(t5, n3) {
        return N2(t5.id, e6.dateKey, n3, e6.timestamp);
      }));
    }))))), i && !t3.isTouchDrag && ls("div", { className: "mbsc-calendar-dragging" }));
  }, t2;
}(ua), va = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._isTimeline = true, t3._onScroll = function() {
      for (var e4 = t3.s, n2 = e4.rtl, s2 = t3.state, i = t3._gridWidth, a2 = t3._scrollCont, r2 = a2.scrollTop, o3 = a2.scrollLeft, l2 = t3._resCont, c2 = t3._headerCont, d2 = t3._stickyHeader, h2 = t3._daysNr, u2 = n2 ? -1 : 1, _2 = n2 ? "marginRight" : "marginLeft", m2 = oe(o3 * u2 * (h2 / t3._daysBatchNr) / i), p2 = e4.renderDay || e4.dayTemplate, v2 = 0, f2 = t3._virtualPagesY || [], g2 = 0, y2 = 0; y2 < f2.length && f2[y2].top - s2.scrollContHeight / 2 <= r2; )
        g2 = y2, y2++;
      if (!l2 || Ut && !n2 || (l2.scrollTop = r2), d2 && Ut) {
        var b2 = d2.style;
        b2.marginTop = r2 < 0 ? -r2 + "px" : "", b2[_2] = o3 * u2 < 0 ? -o3 * u2 + "px" : "";
      }
      if (c2 && i) {
        var D2 = t3._days, x2 = i / h2;
        v2 = G(ce(o3 * u2 / x2), 0, h2 - 1);
        var C2 = function(e6, t4) {
          if (e6 && x2) {
            (!p2 || p2 && "date" !== t4) && (e6.textContent = D2[v2][t4 + "Text"]);
            var n3 = e6.offsetWidth, s3 = e6.style, i2 = G(ce((o3 * u2 + n3) / x2), 0, h2 - 1);
            D2[v2][t4 + "Index"] !== D2[i2][t4 + "Index"] ? s3[_2] = -(o3 * u2 + n3 - D2[i2][t4 + "Index"] * x2 + 1) + "px" : s3[_2] = "";
          }
        };
        C2(t3._stickyDate, "date"), C2(t3._stickyMonth, "month"), C2(t3._stickyWeek, "week"), Ut || (c2.scrollLeft = o3);
      }
      i && (m2 !== s2.batchIndexX || g2 !== s2.batchIndexY || p2 && v2 !== s2.dayIndex) && t3.setState({ batchIndexX: m2, batchIndexY: g2, dayIndex: v2 }), t3._onMouseMove();
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._onParentClick = function(e4) {
    e4.collapsed = !e4.collapsed, this._visibleResources = this._flattenResources(this.s.resources, [], 0), this._shouldCheckSize = true, this._isParentClick = true, this.forceUpdate();
  }, t2.prototype._render = function(t3, n2) {
    e3.prototype._render.call(this, t3, n2);
    var s2 = this._prevS, i = this._eventMap, a2 = this._resourceTops, r2 = this._stepCell / 6e4, o3 = ce(this._startTime / 6e4) % r2, l2 = ce(this._endTime / 6e4) % r2 + 1;
    if (this._startCellStyle = this._displayTime && o3 % r2 != 0 ? { width: (n2.cellWidth || 64) * ((r2 - o3) % r2 / r2) + "px" } : void 0, this._endCellStyle = this._displayTime && l2 % r2 != 0 ? { width: (n2.cellWidth || 64) * (l2 % r2) / r2 + "px" } : void 0, t3.connections === s2.connections && t3.eventMap === s2.eventMap && t3.theme === s2.theme && t3.rtl === s2.rtl || (this._calcConnections = true), this._hasSlots && (this._connections = void 0), this._calcConnections && !this._hasSlots && !this._shouldCheckSize && a2) {
      for (var c2 = [], d2 = this._eventHeight, h2 = this._gridWidth, u2 = n2.hasScrollY ? this._gridHeight : n2.scrollContHeight - n2.headerHeight, _2 = 1500 / h2, m2 = true === t3.rtl, p2 = m2 ? -1 : 1, v2 = 750 / h2 * p2, f2 = 400 / u2 * p2, g2 = 100 * d2 / u2, y2 = 0, b2 = t3.connections || []; y2 < b2.length; y2++) {
        var D2 = b2[y2], x2 = i[D2.from], C2 = i[D2.to], w2 = D2.arrow, T2 = D2.color, k2 = D2.cssClass || "", S2 = D2.from + "__" + D2.to;
        if (x2 && C2) {
          var E2 = x2.position, M2 = C2.position, I2 = void 0 !== E2.width, N2 = void 0 !== M2.width, L2 = x2.resource, H2 = C2.resource;
          if ((I2 || N2) && a2[L2] >= 0 && a2[H2] >= 0) {
            var O2 = x2.endDate, R2 = C2.startDate, V2 = R2 < O2, P2 = V2 ? R2 : O2, z2 = V2 ? O2 : R2, Y2 = E2.top || 0, W2 = M2.top || 0, F2 = m2 ? "right" : "left", A2 = I2 ? +E2[F2].replace("%", "") : V2 ? 100 : 0, U2 = N2 ? +M2[F2].replace("%", "") : V2 ? 0 : 100, B2 = I2 ? +E2.width.replace("%", "") : 0, X2 = x2.resource === C2.resource && V2 && W2 === Y2, K2 = U2 - A2 - B2 - 2 * _2, q2 = a2[H2] - a2[L2], G2 = q2 < 0 || !q2 && W2 < Y2 ? -1 : 1, j2 = 100 * (q2 - Y2 * d2 + W2 * d2 + (X2 ? d2 : 0)) / u2, J2 = (m2 ? 100 - A2 : A2) + B2 * p2, Z2 = 100 * (a2[L2] + Y2 * d2 + 3 + d2 / 2) / u2;
            !I2 || "from" !== w2 && "bidirectional" !== w2 || c2.push({ color: T2, cssClass: "mbsc-connection-arrow " + k2, endDate: z2, fill: T2, id: S2 + "__start", pathD: "M " + J2 + ", " + Z2 + " L " + (J2 + v2) + " " + (Z2 - f2) + " L " + (J2 + v2) + " " + (Z2 + f2) + " Z", startDate: P2 });
            var $2 = "M " + J2 + ", " + Z2;
            J2 += _2 * p2, j2 && ($2 += " H " + J2, $2 += " V " + (Z2 += j2 - (K2 < 0 ? g2 / 2 : 0) * G2)), J2 += K2 * p2, j2 && ($2 += " H " + J2), j2 && K2 < 0 && ($2 += " V " + (Z2 += g2 / 2 * G2 * (X2 ? -1 : 1))), $2 += " H " + (J2 += _2 * p2), c2.push({ color: T2, cssClass: k2, id: S2, pathD: $2, startDate: P2, endDate: z2 }), !N2 || "to" !== w2 && "bidirectional" !== w2 && true !== w2 || c2.push({ color: T2, cssClass: "mbsc-connection-arrow " + k2, endDate: z2, fill: T2, id: S2 + "__end", pathD: "M " + J2 + ", " + Z2 + " L " + (J2 - v2) + " " + (Z2 - f2) + " L " + (J2 - v2) + " " + (Z2 + f2) + " Z", startDate: P2 });
          }
        }
      }
      this._connections = c2, this._calcConnections = false;
    }
  }, t2;
}(ha), fa = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._setStickyHeader = function(e4) {
      t3._stickyHeader = e4;
    }, t3._setStickyDay = function(e4) {
      t3._stickyDate = e4;
    }, t3._setStickyMonth = function(e4) {
      t3._stickyMonth = e4;
    }, t3._setStickyWeek = function(e4) {
      t3._stickyWeek = e4;
    }, t3._setCont = function(e4) {
      t3._scrollCont = e4;
    }, t3._setResCont = function(e4) {
      t3._resCont = e4;
    }, t3._setGridCont = function(e4) {
      t3._gridCont = e4;
    }, t3._setHeaderCont = function(e4) {
      t3._headerCont = e4;
    }, t3._setCursorTimeCont = function(e4) {
      t3._cursorTimeCont = e4;
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._template = function(e4, t3) {
    var n2, s2, i = this, a2 = t3.dragData, r2 = a2 && a2.draggedEvent && a2.draggedEvent.id, o3 = this._hasSlots, l2 = this._hb, c2 = this._rtl, h2 = this._times, u2 = this._theme, _2 = this._startTime, m2 = this._endTime, p2 = this._stepLabel, v2 = this._slots, f2 = "timeline", g2 = e4.resources, y2 = e4.eventList, b2 = "month" === e4.type, D2 = this._stepCell < 864e5, x2 = this._startCellStyle, C2 = this._endCellStyle, w2 = this._daysBatch, T2 = { height: t3.headerHeight }, k2 = this._days, S2 = t3.dayIndex || 0, E2 = function(t4, n3) {
      var s3, a3;
      return e4.renderDay ? $(s3 = e4.renderDay({ date: t4.date, events: e4.eventMap[t4.dateKey] })) && (a3 = i._safeHtml(s3), i._shouldEnhance = true) : s3 = n3 ? void 0 : t4.dateText, ls("div", { ref: n3 ? i._setStickyDay : void 0, "aria-hidden": "true", dangerouslySetInnerHTML: a3, className: (n3 ? "mbsc-timeline-header-text" : "") + (e4.renderDay ? " mbsc-timeline-header-date-cont" : " mbsc-timeline-header-date-text") + u2 }, s3);
    }, M2 = function(e6, t4, n3, s3, a3) {
      for (var o4 = [], l3 = 0, c3 = e6[n3][ta].all[t4]; l3 < c3.length; l3++) {
        var d2 = c3[l3];
        (a3 && r2 === d2.id || He(i._batchStart, i._batchEnd, d2.startDate, d2.endDate, true)) && o4.push(d2);
      }
      return s3(o4, "all", n3, ta);
    }, I2 = function(e6) {
      return e6.map(function(e7, t4) {
        return ls("div", { key: t4, className: "mbsc-schedule-color mbsc-timeline-color" + e7.cssClass + u2, style: e7.position }, ls("div", { className: "mbsc-schedule-color-text" }, e7.title));
      });
    }, N2 = function(e6) {
      return e6.map(function(e7, t4) {
        return e7.position && ls("div", { key: t4, className: "mbsc-schedule-invalid mbsc-timeline-invalid" + e7.cssClass + u2, style: e7.position }, ls("div", { className: "mbsc-schedule-invalid-text" }, e7.title));
      });
    }, L2 = function(t4, n3, s3, o4) {
      var l3 = s3 + "__" + o4 + "__" + n3, c3 = { displayTimezone: e4.displayTimezone, drag: e4.dragToMove, endDay: e4.endDay, eventHeight: i._setRowHeight ? i._eventHeight : void 0, exclusiveEndDates: e4.exclusiveEndDates, gridEndTime: m2, gridStartTime: _2, isListing: y2, isTimeline: true, lastDay: +i._lastDay, render: e4.renderEvent, renderContent: e4.renderEventContent, resize: e4.dragToResize, resource: s3, rtl: e4.rtl, slot: o4, startDay: e4.startDay, theme: e4.theme, timezonePlugin: e4.timezonePlugin };
      return ls(ds, null, t4.map(function(t5) {
        return ls(da, d$2({}, c3, { event: t5, inactive: r2 === t5.id, key: t5.uid, selected: e4.selectedEventsMap[t5.uid] || e4.selectedEventsMap[t5.id], onClick: e4.onEventClick, onDoubleClick: e4.onEventDoubleClick, onRightClick: e4.onEventRightClick, onHoverIn: e4.onEventHoverIn, onHoverOut: e4.onEventHoverOut, onDelete: e4.onEventDelete, onDragStart: i._onEventDragStart, onDragMove: i._onEventDragMove, onDragEnd: i._onEventDragEnd, onDragModeOn: i._onEventDragModeOn, onDragModeOff: i._onEventDragModeOff }));
      }), a2 && a2.originDates && a2.originDates[l3] && ls(da, d$2({}, c3, { event: a2.originDates[l3], hidden: a2 && !!a2.draggedDates, isDrag: true, onDragStart: i._onEventDragStart, onDragMove: i._onEventDragMove, onDragEnd: i._onEventDragEnd, onDragModeOff: i._onEventDragModeOff })), a2 && a2.draggedDates && a2.draggedDates[l3] && ls(da, d$2({}, c3, { event: a2.draggedDates[l3], isDrag: true })));
    };
    return ls("div", { ref: this._setEl, className: "mbsc-timeline mbsc-flex-1-1 mbsc-flex-col" + (t3.cellWidth ? "" : " mbsc-hidden") + (this._hasSticky ? " mbsc-has-sticky" : "") + (g2 ? "" : " mbsc-timeline-no-resource") + u2 + c2 }, ls("div", { ref: this._setStickyHeader, className: "mbsc-timeline-header-sticky mbsc-flex" }, g2 && ls("div", { className: "mbsc-timeline-resource-empty mbsc-timeline-resource-col" + u2 + c2 + l2, style: T2 }, (e4.renderResourceHeader && $(n2 = e4.renderResourceHeader()) && (s2 = i._safeHtml(n2), i._shouldEnhance = true), ls("div", { className: "mbsc-timeline-resource-header", dangerouslySetInnerHTML: s2 }, n2))), ls("div", { className: "mbsc-flex-1-1" }, this._isMulti && ls("div", { className: "mbsc-timeline-header-month" + u2 + c2 + l2 }, ls("div", { ref: this._setStickyMonth, className: "mbsc-timeline-header-text mbsc-timeline-header-month-text" + u2 })), e4.weekNumbers && ls("div", { className: "mbsc-timeline-header-week" + u2 + c2 + l2 }, ls("div", { ref: this._setStickyWeek, className: "mbsc-timeline-header-text mbsc-timeline-header-week-text" + u2 })), (o3 || D2) && ls("div", { className: "mbsc-timeline-header-date mbsc-flex" + u2 + c2 + l2 }, E2(k2[S2] || k2[0], true))), t3.hasScrollY && ls("div", { className: "mbsc-schedule-fake-scroll-y" })), ls("div", { ref: this._setCont, className: "mbsc-timeline-grid-scroll mbsc-flex-col mbsc-flex-1-1" + u2 + c2 + l2, onScroll: this._onScroll }, ls("div", { className: "mbsc-flex-none", style: this._hasSticky ? void 0 : T2 }), ls("div", { className: "mbsc-timeline-header mbsc-flex" + u2 + c2 + l2, ref: this._setHeaderCont }, g2 && ls("div", { className: "mbsc-timeline-resource-empty mbsc-timeline-resource-col" + u2 + c2 + l2 }), ls("div", { className: "mbsc-timeline-header-bg mbsc-flex-1-0 mbsc-flex" + u2 }, ls("div", { className: "mbsc-timeline-time-indicator-cont", style: { height: (t3.scrollContHeight || 0) - (t3.headerHeight || 0), width: t3.hasScrollX ? this._gridWidth : void 0 } }, this._showTimeIndicator && ls(_a, { amText: e4.amText, displayedTime: this._time, displayedDays: this._daysNr, displayTimezone: e4.displayTimezone, endDay: e4.endDay, firstDay: this._firstDayTz, orientation: "y", pmText: e4.pmText, rtl: e4.rtl, startDay: e4.startDay, startTime: _2, theme: e4.theme, timeFormat: e4.timeFormat, timezonePlugin: e4.timezonePlugin }), this._showCursorTime && ls("div", { ref: this._setCursorTimeCont, className: "mbsc-schedule-cursor-time mbsc-schedule-cursor-time-y" + u2 })), ls("div", { className: "mbsc-flex-none", style: { width: this._placeholderSizeX } }), ls("div", { className: t3.hasScrollX ? "mbsc-flex-none" : "mbsc-flex-1-1" }, this._isMulti && ls("div", { className: "mbsc-flex" }, w2.map(function(e6) {
      var t4 = e6.lastOfMonth;
      return ls("div", { key: e6.timestamp, className: "mbsc-timeline-month mbsc-flex-1-0-0" + u2 + c2 + l2 + (t4 ? " mbsc-timeline-day mbsc-timeline-day-border" : "") }, ls("div", { className: "mbsc-timeline-header-month" + u2 + c2 + l2 + (t4 ? " mbsc-timeline-header-month-last" : "") }, ls("div", { className: "mbsc-timeline-header-month-text" + (t4 ? " mbsc-timeline-header-month-text-last" : "") }, e6.monthTitle)));
    })), e4.weekNumbers && ls("div", { className: "mbsc-flex" }, w2.map(function(e6) {
      var t4 = e6.lastOfWeek;
      return ls("div", { key: e6.timestamp, className: "mbsc-timeline-month mbsc-flex-1-0-0" + u2 + c2 + l2 + (t4 && (D2 || e6.lastOfMonth) ? " mbsc-timeline-day mbsc-timeline-day-border" : "") }, ls("div", { className: "mbsc-timeline-header-week" + u2 + c2 + l2 + (t4 ? " mbsc-timeline-header-week-last" : "") }, ls("div", { className: "mbsc-timeline-header-week-text" + (t4 ? " mbsc-timeline-header-week-text-last" : "") }, e6.weekTitle)));
    })), ls("div", { className: "mbsc-flex" }, w2.map(function(t4) {
      return ls("div", { key: t4.timestamp, className: "mbsc-timeline-day mbsc-flex-1-0-0" + u2 + c2 + l2 + (t4.dateIndex < i._daysNr - 1 && D2 || t4.lastOfMonth ? " mbsc-timeline-day-border" : "") + (b2 || i._isMulti ? " mbsc-timeline-day-month" : "") }, ls("div", { className: "mbsc-timeline-header-date" + u2 + c2 + l2 }, E2(t4), t4.label && ls("div", { className: "mbsc-hidden-content" }, t4.label)), o3 && ls("div", { className: "mbsc-flex mbsc-timeline-slots" + u2 }, v2.map(function(n3) {
        return ls("div", { key: n3.id, className: "mbsc-timeline-slot mbsc-timeline-slot-header" + c2 + u2 }, n3.name && function(t5) {
          var n4, s3 = t5.slot, a3 = s3.name;
          return e4.renderSlot && $(a3 = e4.renderSlot(t5)) && (n4 = i._safeHtml(a3), i._shouldEnhance = true), ls("div", { key: s3.id, className: "mbsc-timeline-slot-title", dangerouslySetInnerHTML: n4 }, a3);
        }({ slot: n3, date: t4.date }));
      })), ls("div", { "aria-hidden": "true", className: "mbsc-flex" }, h2.map(function(e6, t5) {
        var n3 = !t5, s3 = t5 === h2.length - 1;
        return ls("div", { key: t5, style: n3 && !s3 ? x2 : s3 && !n3 ? C2 : void 0, className: "mbsc-flex mbsc-flex-1-1 mbsc-timeline-header-column" + u2 + c2 + l2 + (!i._displayTime || o3 ? " mbsc-timeline-no-height" : "") + (p2 > i._stepCell && h2[t5 + 1] % p2 ? " mbsc-timeline-no-border" : "") + (n3 && x2 || s3 && C2 ? " mbsc-flex-none" : "") }, ls("div", { className: "mbsc-timeline-header-time mbsc-flex-1-1 " + u2 }, i._displayTime ? i._timeLabels[e6] : ""), i._timesBetween.map(function(t6, n4) {
          var s4 = e6 + (n4 + 1) * p2;
          return s4 > _2 && s4 < m2 && ls("div", { key: n4, className: "mbsc-timeline-header-time mbsc-flex-1-1 " + u2 }, i._timeLabels[s4]);
        }));
      })));
    }))))), ls("div", { className: "mbsc-flex mbsc-flex-1-1" }, ls("div", { className: "mbsc-flex mbsc-flex-1-1" }, g2 && ls("div", { className: "mbsc-timeline-resources mbsc-timeline-resource-col mbsc-flex-col" + u2 + c2, ref: this._setResCont }, ls("div", { className: "mbsc-flex-none", style: this._hasSideSticky ? void 0 : T2 }), ls("div", { className: "mbsc-timeline-resource-bg mbsc-flex-1-1" + (this._hasHierarchy || t3.hasScrollY ? "" : " mbsc-flex-col") + u2 }, ls("div", { style: { height: this._placeholderSizeY }, className: "mbsc-flex-none" }), this._resourcesBatch.map(function(t4) {
      var n3, s3 = t4.isParent, a3 = i._hasHierarchy ? 1.75 * t4.depth + "em" : void 0, r3 = { minHeight: i._setRowHeight ? i._eventRows[t4.id] * i._eventHeight + 16 : void 0, paddingLeft: e4.rtl ? void 0 : a3, paddingRight: e4.rtl ? a3 : void 0 }, o4 = t4.name;
      return e4.renderResource && $(o4 = e4.renderResource(t4)) && (n3 = i._safeHtml(o4), i._shouldEnhance = true), ls("div", { key: t4.id, className: "mbsc-timeline-resource" + u2 + c2 + l2 + (s3 ? " mbsc-timeline-parent mbsc-flex" : ""), style: r3 }, s3 && ls(us, { className: "mbsc-timeline-resource-icon" + c2 + l2, svg: t4.collapsed ? e4.rtl ? e4.nextIconRtl : e4.nextIcon : e4.downIcon, theme: e4.theme, onClick: function() {
        return i._onParentClick(t4);
      } }), ls("div", { className: "mbsc-timeline-resource-title" + (s3 ? " mbsc-flex-1-1" : ""), dangerouslySetInnerHTML: n3 }, o4));
    }))), g2 && ls("div", { className: this._hasSideSticky ? "" : "mbsc-timeline-resource-col" }), ls("div", { className: "mbsc-timeline-grid mbsc-flex-1-0" + (this._hasHierarchy || t3.hasScrollY ? "" : " mbsc-flex-col"), ref: this._setGridCont, style: { height: t3.hasScrollY ? this._gridHeight : void 0, width: t3.hasScrollX ? this._gridWidth : void 0 }, onMouseLeave: this._onMouseLeave, onMouseMove: this._onMouseMove }, ls("div", { style: { height: this._placeholderSizeY }, className: "mbsc-flex-none" }), this._resourcesBatch.map(function(n3) {
      var s3 = n3.id;
      return ls("div", { key: s3, className: "mbsc-flex mbsc-timeline-row" + u2 + l2 + (n3.isParent ? " mbsc-timeline-parent" : ""), style: { minHeight: i._setRowHeight ? i._eventRows[s3] * i._eventHeight + 16 : void 0 } }, !o3 && ls(ds, null, ls("div", { className: "mbsc-timeline-events" }, M2(i._events, "events", s3, L2, true)), M2(i._invalids, "invalids", s3, N2), M2(i._colors, "colors", s3, I2)), ls("div", { style: { width: i._placeholderSizeX }, className: "mbsc-flex-none" }), w2.map(function(n4) {
        var a3 = n4.timestamp, r3 = n4.dateKey;
        return ls("div", { key: a3, className: "mbsc-timeline-day mbsc-flex" + u2 + c2 + l2 + (n4.dateIndex < i._daysNr - 1 && D2 || n4.lastOfMonth ? " mbsc-timeline-day-border" : "") + (t3.hasScrollX ? " mbsc-flex-none" : " mbsc-flex-1-0-0") + (b2 || i._isMulti ? " mbsc-timeline-day-month" : "") }, v2.map(function(t4) {
          var n5 = t4.id, d2 = i._events[s3][n5][r3], _3 = i._colors[s3][n5][r3], m3 = i._invalids[s3][n5][r3];
          return ls("div", { key: n5, className: "mbsc-flex mbsc-flex-1-1" + (o3 ? " mbsc-timeline-slot" : "") }, o3 && ls(ds, null, ls("div", { className: "mbsc-timeline-events" }, L2(d2 ? d2.events : [], r3, s3, n5)), m3 && N2(m3.invalids), _3 && I2(_3.colors)), h2.map(function(t5, i2) {
            var r4 = oa(a3, t5), o4 = !i2, d3 = i2 === h2.length - 1;
            return ls("div", { key: i2, className: "mbsc-timeline-column mbsc-flex-1-1" + u2 + c2 + l2 + (o4 && x2 || d3 && C2 ? " mbsc-flex-none" : ""), onClick: function(t6) {
              return e4.onCellClick({ date: r4, domEvent: t6, resource: s3, slot: n5, source: f2 });
            }, onDoubleClick: function(t6) {
              return e4.onCellDoubleClick({ date: r4, domEvent: t6, resource: s3, slot: n5, source: f2 });
            }, onContextMenu: function(t6) {
              return e4.onCellRightClick({ date: r4, domEvent: t6, resource: s3, slot: n5, source: f2 });
            }, style: o4 && !d3 ? x2 : d3 && !o4 ? C2 : void 0 });
          }));
        }));
      }));
    }), this._connections && ls("svg", { className: "mbsc-connections" + u2, viewBox: "0 0 100 100", preserveAspectRatio: "none" }, this._connections.map(function(e6) {
      var t4, n3 = ((t4 = { className: "mbsc-connection " + e6.cssClass + u2, d: e6.pathD, style: { stroke: e6.color, fill: e6.fill } }).vectorEffect = "non-scaling-stroke", t4);
      return He(i._batchStart, i._batchEnd, e6.startDate, e6.endDate, true) && ls("path", d$2({ key: e6.id }, n3));
    })))))), a2 && !t3.isTouchDrag && ls("div", { className: "mbsc-calendar-dragging" }));
  }, t2;
}(va), ga = /* @__PURE__ */ function(e3) {
  function t2() {
    var t3 = null !== e3 && e3.apply(this, arguments) || this;
    return t3._instanceService = new ni(), t3._setList = function(e4) {
      t3._list = e4;
    }, t3._setPopoverList = function(e4) {
      t3._popoverList = e4 && e4._el;
    }, t3._setEl = function(e4) {
      t3._el = e4 ? e4._el || e4 : null, t3._calendarView = e4;
    }, t3;
  }
  return c$3(t2, e3), t2.prototype._eventRenderer = function(e4, t3, n2, s2, i) {
    var a2, r2 = this, o3 = !this._colorEventList, l2 = i ? "popover" : "agenda", c2 = !i || this.state.showPopover, d2 = this._theme, h2 = s2.renderEventContent ? s2.renderEventContent(e4) : ls("div", { className: "mbsc-event-text " + d2, title: e4.tooltip, dangerouslySetInnerHTML: e4.html });
    $(h2) ? (h2 = ls("div", { className: "mbsc-event-content" + d2, dangerouslySetInnerHTML: { __html: h2 } }), this._shouldEnhance = c2 && l2) : h2 = ls("div", { className: "mbsc-event-content" + d2 }, h2);
    var u2 = s2.renderEvent ? s2.renderEvent(e4) : ls(ds, null, ls("div", { className: "mbsc-event-color" + d2 + this._rtl, style: e4.style }), h2, ls("div", { className: "mbsc-event-time" + d2 + this._rtl }, e4.allDayText && ls("div", { className: "mbsc-event-all-day" + d2 }, e4.allDayText), e4.lastDay && ls("div", { className: "mbsc-event-until" + d2 }, e4.lastDay), e4.start && ls("div", { className: "mbsc-event-start" + d2 }, e4.start), e4.start && e4.end && ls("div", { className: "mbsc-event-sep" + d2 }, "-"), e4.end && ls("div", { className: "mbsc-event-end" + d2 }, e4.end)));
    return $(u2) && (a2 = { __html: u2 }, u2 = void 0, this._shouldEnhance = c2 && l2), ls(Qi, { className: "mbsc-event" + (o3 ? "" : " mbsc-colored-event") + (e4.original.cssClass ? " " + e4.original.cssClass : ""), "data-id": e4.original.id, key: t3, actionable: s2.actionableEvents, dangerouslySetInnerHTML: a2, data: e4.original, drag: i && this._showEventLabels && s2.dragToMove, rtl: s2.rtl, selected: this._selectedEventsMap[e4.uid] || this._selectedEventsMap[e4.id], style: o3 ? void 0 : e4.style, theme: s2.theme, themeVariant: s2.themeVariant, onClick: function(t4) {
      return r2._onEventClick({ date: n2, domEvent: t4.domEvent, event: e4.original, source: l2 });
    }, onDoubleClick: function(t4) {
      return r2._onEventDoubleClick({ date: n2, domEvent: t4, event: e4.original, source: l2 });
    }, onContextMenu: function(t4) {
      return r2._onEventRightClick({ date: n2, domEvent: t4, event: e4.original, source: l2 });
    }, onHoverIn: function(t4) {
      var s3 = t4.domEvent;
      return r2._onEventHoverIn({ date: n2, domEvent: s3, event: e4.original, source: l2 });
    }, onHoverOut: function(t4) {
      var s3 = t4.domEvent;
      return r2._onEventHoverOut({ date: n2, domEvent: s3, event: e4.original, source: l2 });
    }, onDelete: this._onEventDelete, onDragEnd: this._onLabelUpdateEnd, onDragModeOff: this._onLabelUpdateModeOff, onDragModeOn: this._onLabelUpdateModeOn, onDragMove: this._onLabelUpdateMove, onDragStart: this._onLabelUpdateStart }, u2);
  }, t2.prototype._listRenderer = function() {
    var e4 = this, t3 = this.s, n2 = t3.theme, s2 = this._listDays, i = this.state.eventList;
    return t3.renderAgenda ? void 0 === this._eventListHTML ? t3.renderAgenda(i, t3, s2) : void 0 : ls(ea, { theme: n2, themeVariant: t3.themeVariant, rtl: t3.rtl }, !i.length && ls("div", { className: "mbsc-event-list-empty" + this._theme }, t3.noEventsText), i.map(function(i2, a2) {
      return ls("div", { className: "mbsc-event-group" + e4._theme, key: a2, ref: function(e6) {
        return s2[i2.timestamp] = e6;
      } }, ("day" !== e4._eventListType || e4._eventListSize > 1) && ls($i, { theme: n2, themeVariant: t3.themeVariant, className: "mbsc-event-day" }, i2.date), i2.events.map(function(n3, s3) {
        return e4._eventRenderer(n3, s3, i2.timestamp, t3);
      }));
    }));
  }, t2.prototype._template = function(e4, t3) {
    var n2, s2 = this;
    this._listDays || (this._listDays = {}), this._showEventList && $(n2 = this._listRenderer()) && (this._eventListHTML = { __html: n2 }, this._shouldLoadDays = true, this._shouldEnhance = true, n2 = void 0);
    var i = { amText: e4.amText, clickToCreate: e4.clickToCreate, dataTimezone: e4.dataTimezone, dateFormat: e4.dateFormat, dayNames: e4.dayNames, dayNamesMin: e4.dayNamesMin, dayNamesShort: e4.dayNamesShort, displayTimezone: e4.displayTimezone, dragToCreate: e4.dragToCreate, dragToMove: e4.dragToMove, dragToResize: e4.dragToResize, eventOrder: e4.eventOrder, exclusiveEndDates: e4.exclusiveEndDates, firstDay: e4.firstDay, fromText: e4.fromText, getDate: e4.getDate, getDay: e4.getDay, getMonth: e4.getMonth, getYear: e4.getYear, monthNames: e4.monthNames, monthNamesShort: e4.monthNamesShort, pmText: e4.pmText, refDate: this._refDate, rtl: e4.rtl, selectedEventsMap: this._selectedEventsMap, showEventTooltip: e4.showEventTooltip, theme: e4.theme, themeVariant: e4.themeVariant, timeFormat: e4.timeFormat, timezonePlugin: e4.timezonePlugin, toText: e4.toText }, a2 = d$2({}, i, { allDayText: e4.allDayText, colorsMap: this._colorsMap, dateFormatLong: e4.dateFormatLong, dragTimeStep: e4.dragTimeStep, eventDragEnd: this._onEventDragStop, eventMap: this._eventMap, extendDefaultEvent: e4.extendDefaultEvent, externalDrop: e4.externalDrop, groupBy: e4.groupBy, height: t3.height, invalidateEvent: e4.invalidateEvent, invalidsMap: this._invalidsMap, maxDate: this._maxDate, minDate: this._minDate, navigateToEvent: this._navigateToEvent, navigationService: this._navService, newEventText: e4.newEventText, onCellClick: this._onCellClick, onCellDoubleClick: this._onCellDoubleClick, onCellRightClick: this._onCellRightClick, onEventClick: this._onEventClick, onEventDelete: this._onEventDelete, onEventDoubleClick: this._onEventDoubleClick, onEventDragEnd: this._onEventDragEnd, onEventDragStart: this._onEventDragStart, onEventHoverIn: this._onEventHoverIn, onEventHoverOut: this._onEventHoverOut, onEventRightClick: this._onEventRightClick, renderDay: e4.renderDay, renderEvent: e4.renderScheduleEvent, renderEventContent: e4.renderScheduleEventContent, renderResource: e4.renderResource, resources: e4.resources, scroll: this._shouldScrollSchedule, selected: this._selectedDateTime, width: t3.width });
    return ls(ti, d$2({ ref: this._setEl }, i, { activeDate: this._active, calendarScroll: this._calendarScroll, calendarType: this._calendarType, colors: e4.colors, context: e4.context, cssClass: this._cssClass, downIcon: e4.downIcon, dragData: t3.labelDragData, endDay: this._rangeEndDay, eventRange: this._rangeType, eventRangeSize: this._showSchedule ? this._scheduleSize : this._showTimeline ? this._timelineSize : this._eventListSize, hasContent: this._showEventList || this._showSchedule || this._showTimeline, hasPicker: true, height: e4.height, invalid: e4.invalid, instanceService: this._instanceService, labels: e4.labels, labelList: this._calendarLabelList, labelsMap: this._labelsMap, marked: e4.marked, marksMap: this._marksMap, max: e4.max, min: e4.min, mouseSwipe: !e4.dragToCreate && "single" !== e4.clickToCreate || !this._showEventLabels && !this._showEventCount, mousewheel: e4.mousewheel, navigationService: this._navService, nextIconH: e4.nextIconH, nextIconV: e4.nextIconV, nextPageText: e4.nextPageText, noOuterChange: !this._showEventList, onActiveChange: this._onActiveChange, onCellHoverIn: this._onCellHoverIn, onCellHoverOut: this._onCellHoverOut, onDayClick: this._onDayClick, onDayDoubleClick: this._onDayDoubleClick, onDayRightClick: this._onDayRightClick, onGestureStart: this._onGestureStart, onLabelClick: this._onLabelClick, onLabelDoubleClick: this._onLabelDoubleClick, onLabelRightClick: this._onLabelRightClick, onLabelHoverIn: this._onLabelHoverIn, onLabelHoverOut: this._onLabelHoverOut, onLabelDelete: this._onEventDelete, onLabelUpdateStart: this._onLabelUpdateStart, onLabelUpdateMove: this._onLabelUpdateMove, onLabelUpdateEnd: this._onLabelUpdateEnd, onLabelUpdateModeOn: this._onLabelUpdateModeOn, onLabelUpdateModeOff: this._onLabelUpdateModeOff, onPageChange: this._onPageChange, onPageLoaded: this._onPageLoaded, onPageLoading: this._onPageLoading, onResize: this._onResize, pageLoad: this._pageLoad, prevIconH: e4.prevIconH, prevIconV: e4.prevIconV, prevPageText: e4.prevPageText, resourcesMap: this._resourcesMap, responsiveStyle: true, renderHeader: e4.renderHeader, renderDay: e4.renderDay, renderDayContent: e4.renderDayContent, renderLabel: e4.renderLabel, renderLabelContent: e4.renderLabelContent, selectedDates: this._selectedDates, selectView: "month", showCalendar: this._showCalendar, showControls: e4.showControls, showLabelCount: this._showEventCount, showOuterDays: this._showOuterDays, showSchedule: this._showSchedule || this._showTimeline, showToday: e4.showToday, showWeekNumbers: this._showWeekNumbers, size: this._calendarSize, startDay: this._rangeStartDay, swipe: !t3.isTouchDrag, upIcon: e4.upIcon, valid: e4.valid, weeks: this._calendarSize, width: e4.width, getMaxDayOfMonth: e4.getMaxDayOfMonth, getWeekNumber: e4.getWeekNumber, eventText: e4.eventText, eventsText: e4.eventsText, fromText: e4.fromText, moreEventsPluralText: e4.moreEventsPluralText, moreEventsText: e4.moreEventsText, todayText: e4.todayText, toText: e4.toText, weekText: e4.weekText, yearSuffix: e4.yearSuffix }), this._showDate && ls("div", { className: "mbsc-schedule-date-header mbsc-flex" + this._theme + this._hb }, this._showSchedule && !this._showCalendar && e4.resources && ls("div", { className: "mbsc-schedule-time-col" }), ls("div", { className: "mbsc-schedule-date-header-text mbsc-flex-1-1" + this._theme }, this._selectedDateHeader), this._showSchedule && !this._showCalendar && e4.resources && ls("div", { className: "mbsc-schedule-fake-scroll-y" })), this._showEventList && ls("div", { className: "mbsc-event-list" + (t3.isListScrollable ? " mbsc-event-list-scroll" : ""), dangerouslySetInnerHTML: this._eventListHTML, onScroll: this._onScroll, ref: this._setList }, n2), this._showSchedule && ls(pa, d$2({}, a2, { endDay: this._scheduleEndDay, endTime: this._scheduleEndTime, renderDayContent: e4.renderDayContent, showAllDay: this._showScheduleAllDay, showDays: this._showScheduleDays, size: this._scheduleSize, startDay: this._scheduleStartDay, startTime: this._scheduleStartTime, timeCellStep: this._scheduleTimeCellStep, timeLabelStep: this._scheduleTimeLabelStep, timezones: this._scheduleTimezones, type: this._scheduleType, onWeekDayClick: this._onWeekDayClick })), this._showTimeline && ls(fa, d$2({}, a2, { dragToCreate: !e4.slots && e4.dragToCreate, dragToResize: !e4.slots && e4.dragToResize, downIcon: e4.chevronIconDown, connections: e4.connections, endDay: this._timelineEndDay, endTime: this._timelineEndTime, eventList: this._timelineListing, getWeekNumber: e4.getWeekNumber, nextIcon: e4.nextIconH, nextIconRtl: e4.prevIconH, renderResourceHeader: e4.renderResourceHeader, renderSlot: e4.renderSlot, rowHeight: this._timelineRowHeight, weekNumbers: this._showTimelineWeekNumbers, weekText: e4.weekText, size: this._timelineSize, slots: e4.slots, startDay: this._timelineStartDay, startTime: this._timelineStartTime, timeCellStep: this._timelineTimeCellStep, timeLabelStep: this._timelineTimeLabelStep, type: this._timelineType, virtualScroll: !this._print })), ls(Ls, { anchor: this._anchor, closeOnScroll: true, contentPadding: false, context: e4.context, cssClass: "mbsc-calendar-popup " + this._popoverClass, display: "anchored", isOpen: t3.showPopover, locale: e4.locale, maxHeight: "24em", onClose: this._onPopoverClose, rtl: e4.rtl, scrollLock: false, showOverlay: false, theme: e4.theme, themeVariant: e4.themeVariant }, t3.popoverList && ls(ea, { ref: this._setPopoverList, theme: e4.theme, themeVariant: e4.themeVariant, rtl: e4.rtl, className: "mbsc-popover-list" }, t3.popoverList.map(function(n3, i2) {
      return s2._eventRenderer(n3, i2, t3.popoverDate, e4, true);
    }))), t3.labelDragData && t3.labelDragData.draggedEvent && !t3.isTouchDrag && ls("div", { className: "mbsc-calendar-dragging" }));
  }, t2;
}(Zi), xa = [], Ca = [], wa = y$2 && !!kt.Promise;
function Ta(e3, t2, n2, s2, i) {
  return d$2({ closeOnOverlayClick: false, context: t2.context, cssClass: "mbsc-alert", display: t2.display || "center", onClose: function() {
    e3.shift();
  }, onClosed: function() {
    Sa(t2, s2, i);
  }, theme: t2.theme, themeVariant: t2.themeVariant }, n2);
}
function ka$1(e3, t2, n2, s2) {
  return Ta(Ca, e3, { animation: e3.animation || (s2 ? "pop" : void 0), buttons: [], closeOnOverlayClick: false, contentPadding: s2, cssClass: "mbsc-" + (s2 ? "toast" : "snackbar") + " mbsc-" + (e3.color ? e3.color : "color-none") + " " + (e3.cssClass || ""), display: e3.display || "bottom", focusOnClose: false, focusOnOpen: false, focusTrap: false, onOpen: function(t3, n3) {
    !function(e4, t4) {
      false !== e4.duration && setTimeout(function() {
        t4.close();
      }, e4.duration || 3e3);
    }(e3, n3);
  }, scrollLock: false, showOverlay: false, touchUi: true }, t2, n2);
}
function Sa(e3, t2, n2, s2) {
  n2(s2), e3.callback && e3.callback(s2), xa.length ? xa[0].open() : Ca.length && Ca[0].open(), t2();
}
function Ea(e3, t2, n2) {
  return ka$1(e3, t2, n2, true);
}
function Oa(e3) {
  var t2 = Ca[0];
  Ca.push(e3), xa.length || (t2 ? t2.close() : e3.open());
}
function Ra(e3, t2) {
  var n2;
  return wa ? n2 = new Promise(function(n3) {
    e3(t2, n3);
  }) : e3(t2, ae), n2;
}
function Pa(e3, t2, n2, s2, i, a2, l2) {
  if (Tt) {
    var c2 = Tt.createElement("div"), h2 = n2(t2, function() {
      setTimeout(function() {
        reactDomExports.unmountComponentAtNode(c2);
      });
    }, i, l2), u2 = ls(Ls, d$2({ onInit: function(e4, t3) {
      a2 && a2(t3), s2(t3);
    } }, h2), e3);
    reactDomExports.render(u2, c2);
  }
}
function za(e3, t2) {
  Pa(ls("div", { className: "mbsc-toast-background mbsc-toast-message" }, e3.message || ""), e3, Ea, Oa, t2);
}
function Ua(e3) {
  return Ra(za, e3);
}
class LuxonError extends Error {
}
class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
}
class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
}
class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
}
class ConflictingSpecificationError extends LuxonError {
}
class InvalidUnitError extends LuxonError {
  constructor(unit2) {
    super(`Invalid unit ${unit2}`);
  }
}
class InvalidArgumentError extends LuxonError {
}
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}
const n$5 = "numeric", s$1 = "short", l$4 = "long";
const DATE_SHORT = {
  year: n$5,
  month: n$5,
  day: n$5
};
const DATE_MED = {
  year: n$5,
  month: s$1,
  day: n$5
};
const DATE_MED_WITH_WEEKDAY = {
  year: n$5,
  month: s$1,
  day: n$5,
  weekday: s$1
};
const DATE_FULL = {
  year: n$5,
  month: l$4,
  day: n$5
};
const DATE_HUGE = {
  year: n$5,
  month: l$4,
  day: n$5,
  weekday: l$4
};
const TIME_SIMPLE = {
  hour: n$5,
  minute: n$5
};
const TIME_WITH_SECONDS = {
  hour: n$5,
  minute: n$5,
  second: n$5
};
const TIME_WITH_SHORT_OFFSET = {
  hour: n$5,
  minute: n$5,
  second: n$5,
  timeZoneName: s$1
};
const TIME_WITH_LONG_OFFSET = {
  hour: n$5,
  minute: n$5,
  second: n$5,
  timeZoneName: l$4
};
const TIME_24_SIMPLE = {
  hour: n$5,
  minute: n$5,
  hourCycle: "h23"
};
const TIME_24_WITH_SECONDS = {
  hour: n$5,
  minute: n$5,
  second: n$5,
  hourCycle: "h23"
};
const TIME_24_WITH_SHORT_OFFSET = {
  hour: n$5,
  minute: n$5,
  second: n$5,
  hourCycle: "h23",
  timeZoneName: s$1
};
const TIME_24_WITH_LONG_OFFSET = {
  hour: n$5,
  minute: n$5,
  second: n$5,
  hourCycle: "h23",
  timeZoneName: l$4
};
const DATETIME_SHORT = {
  year: n$5,
  month: n$5,
  day: n$5,
  hour: n$5,
  minute: n$5
};
const DATETIME_SHORT_WITH_SECONDS = {
  year: n$5,
  month: n$5,
  day: n$5,
  hour: n$5,
  minute: n$5,
  second: n$5
};
const DATETIME_MED = {
  year: n$5,
  month: s$1,
  day: n$5,
  hour: n$5,
  minute: n$5
};
const DATETIME_MED_WITH_SECONDS = {
  year: n$5,
  month: s$1,
  day: n$5,
  hour: n$5,
  minute: n$5,
  second: n$5
};
const DATETIME_MED_WITH_WEEKDAY = {
  year: n$5,
  month: s$1,
  day: n$5,
  weekday: s$1,
  hour: n$5,
  minute: n$5
};
const DATETIME_FULL = {
  year: n$5,
  month: l$4,
  day: n$5,
  hour: n$5,
  minute: n$5,
  timeZoneName: s$1
};
const DATETIME_FULL_WITH_SECONDS = {
  year: n$5,
  month: l$4,
  day: n$5,
  hour: n$5,
  minute: n$5,
  second: n$5,
  timeZoneName: s$1
};
const DATETIME_HUGE = {
  year: n$5,
  month: l$4,
  day: n$5,
  weekday: l$4,
  hour: n$5,
  minute: n$5,
  timeZoneName: l$4
};
const DATETIME_HUGE_WITH_SECONDS = {
  year: n$5,
  month: l$4,
  day: n$5,
  weekday: l$4,
  hour: n$5,
  minute: n$5,
  second: n$5,
  timeZoneName: l$4
};
class Zone {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts2, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts2, format2) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts2) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
}
let singleton$1 = null;
class SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton$1 === null) {
      singleton$1 = new SystemZone();
    }
    return singleton$1;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts2, { format: format2, locale: locale2 }) {
    return parseZoneInfo(ts2, format2, locale2);
  }
  /** @override **/
  formatOffset(ts2, format2) {
    return formatOffset(this.offset(ts2), format2);
  }
  /** @override **/
  offset(ts2) {
    return -new Date(ts2).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
}
let dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date2) {
  const formatted = dtf.format(date2).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date2) {
  const formatted = dtf.formatToParts(date2);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type: type3, value } = formatted[i];
    const pos = typeToPos[type3];
    if (type3 === "era") {
      filled[pos] = value;
    } else if (!isUndefined$2(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
let ianaZoneCache = {};
class IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e3) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = IANAZone.isValidZone(name);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts2, { format: format2, locale: locale2 }) {
    return parseZoneInfo(ts2, format2, locale2, this.name);
  }
  /** @override **/
  formatOffset(ts2, format2) {
    return formatOffset(this.offset(ts2), format2);
  }
  /** @override **/
  offset(ts2) {
    const date2 = new Date(ts2);
    if (isNaN(date2))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second2] = dtf.formatToParts ? partsOffset(dtf, date2) : hackyOffset(dtf, date2);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second: second2,
      millisecond: 0
    });
    let asTS = +date2;
    const over3 = asTS % 1e3;
    asTS -= over3 >= 0 ? over3 : 1e3 + over3;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
}
let intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
let intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
let intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
let intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
let sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e3) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar: calendar2 } = options;
    return [selectedStr, numberingSystem, calendar2];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f2) {
  const ms2 = [];
  for (let i = 1; i <= 12; i++) {
    const dt2 = DateTime.utc(2016, i, 1);
    ms2.push(f2(dt2));
  }
  return ms2;
}
function mapWeekdays(f2) {
  const ms2 = [];
  for (let i = 1; i <= 7; i++) {
    const dt2 = DateTime.utc(2016, 11, 13 + i);
    ms2.push(f2(dt2));
  }
  return ms2;
}
function listStuff(loc, length3, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length3);
  } else {
    return intlFn(length3);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
}
class PolyDateFormatter {
  constructor(dt2, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z2 = void 0;
    if (this.opts.timeZone) {
      this.dt = dt2;
    } else if (dt2.zone.type === "fixed") {
      const gmtOffset = -1 * (dt2.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt2.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z2 = offsetZ;
        this.dt = dt2;
      } else {
        z2 = "UTC";
        this.dt = dt2.offset === 0 ? dt2 : dt2.setZone("UTC").plus({ minutes: dt2.offset });
        this.originalZone = dt2.zone;
      }
    } else if (dt2.zone.type === "system") {
      this.dt = dt2;
    } else if (dt2.zone.type === "iana") {
      this.dt = dt2;
      z2 = dt2.zone.name;
    } else {
      z2 = "UTC";
      this.dt = dt2.setZone("UTC").plus({ minutes: dt2.offset });
      this.originalZone = dt2.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z2;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count2, unit2) {
    if (this.rtf) {
      return this.rtf.format(count2, unit2);
    } else {
      return formatRelativeTime(unit2, count2, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count2, unit2) {
    if (this.rtf) {
      return this.rtf.formatToParts(count2, unit2);
    } else {
      return [];
    }
  }
}
let Locale$1 = class Locale {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }
  static create(locale2, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale2 || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale: locale2, numberingSystem, outputCalendar } = {}) {
    return Locale.create(locale2, numberingSystem, outputCalendar);
  }
  constructor(locale2, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale2);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length3, format2 = false, defaultOK = true) {
    return listStuff(this, length3, defaultOK, months$1, () => {
      const intl = format2 ? { month: length3, day: "numeric" } : { month: length3 }, formatStr = format2 ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length3]) {
        this.monthsCache[formatStr][length3] = mapMonths((dt2) => this.extract(dt2, intl, "month"));
      }
      return this.monthsCache[formatStr][length3];
    });
  }
  weekdays(length3, format2 = false, defaultOK = true) {
    return listStuff(this, length3, defaultOK, weekdays, () => {
      const intl = format2 ? { weekday: length3, year: "numeric", month: "long", day: "numeric" } : { weekday: length3 }, formatStr = format2 ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length3]) {
        this.weekdaysCache[formatStr][length3] = mapWeekdays(
          (dt2) => this.extract(dt2, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length3];
    });
  }
  meridiems(defaultOK = true) {
    return listStuff(
      this,
      void 0,
      defaultOK,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt2) => this.extract(dt2, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length3, defaultOK = true) {
    return listStuff(this, length3, defaultOK, eras, () => {
      const intl = { era: length3 };
      if (!this.eraCache[length3]) {
        this.eraCache[length3] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt2) => this.extract(dt2, intl, "era")
        );
      }
      return this.eraCache[length3];
    });
  }
  extract(dt2, intlOpts, field) {
    const df2 = this.dtFormatter(dt2, intlOpts), results = df2.formatToParts(), matching = results.find((m2) => m2.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt2, intlOpts = {}) {
    return new PolyDateFormatter(dt2, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
};
let singleton = null;
class FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton === null) {
      singleton = new FixedOffsetZone(0);
    }
    return singleton;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r2 = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r2) {
        return new FixedOffsetZone(signedOffset(r2[1], r2[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(ts2, format2) {
    return formatOffset(this.fixed, format2);
  }
  /** @override **/
  get isUniversal() {
    return true;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return true;
  }
}
class InvalidZone extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
}
function normalizeZone(input, defaultZone2) {
  if (isUndefined$2(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString$3(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default")
      return defaultZone2;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber$5(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}
let now$6 = () => Date.now(), defaultZone = "system", defaultLocale$2 = null, defaultNumberingSystem = null, defaultOutputCalendar = null, twoDigitCutoffYear = 60, throwOnInvalid;
class Settings {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now$6;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now$6 = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale$2;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale2) {
    defaultLocale$2 = locale2;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpretted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpretted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpretted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t2) {
    throwOnInvalid = t2;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale$1.resetCache();
    IANAZone.resetCache();
  }
}
function isUndefined$2(o3) {
  return typeof o3 === "undefined";
}
function isNumber$5(o3) {
  return typeof o3 === "number";
}
function isInteger(o3) {
  return typeof o3 === "number" && o3 % 1 === 0;
}
function isString$3(o3) {
  return typeof o3 === "string";
}
function isDate$2(o3) {
  return Object.prototype.toString.call(o3) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e3) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair3 = [by(next), next];
    if (!best) {
      return pair3;
    } else if (compare(best[0], pair3[0]) === best[0]) {
      return best;
    } else {
      return pair3;
    }
  }, null)[1];
}
function pick2(obj, keys4) {
  return keys4.reduce((a2, k2) => {
    a2[k2] = obj[k2];
    return a2;
  }, {});
}
function hasOwnProperty$a(obj, prop3) {
  return Object.prototype.hasOwnProperty.call(obj, prop3);
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x2, n2) {
  return x2 - n2 * Math.floor(x2 / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string4) {
  if (isUndefined$2(string4) || string4 === null || string4 === "") {
    return void 0;
  } else {
    return parseInt(string4, 10);
  }
}
function parseFloating(string4) {
  if (isUndefined$2(string4) || string4 === null || string4 === "") {
    return void 0;
  } else {
    return parseFloat(string4);
  }
}
function parseMillis(fraction) {
  if (isUndefined$2(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f2 = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f2);
  }
}
function roundTo(number2, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number2 * factor) / factor;
}
function isLeapYear$2(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear$1(year) {
  return isLeapYear$2(year) ? 366 : 365;
}
function daysInMonth$1(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear$2(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d2 = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d2 = new Date(d2);
    d2.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d2;
}
function weeksInWeekYear(weekYear) {
  const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last2 = weekYear - 1, p2 = (last2 + Math.floor(last2 / 4) - Math.floor(last2 / 100) + Math.floor(last2 / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear$1(year) {
  if (year > 99) {
    return year;
  } else
    return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts2, offsetFormat, locale2, timeZone = null) {
  const date2 = new Date(ts2), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale2, modified).formatToParts(date2).find((m2) => m2.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u2 in obj) {
    if (hasOwnProperty$a(obj, u2)) {
      const v2 = obj[u2];
      if (v2 === void 0 || v2 === null)
        continue;
      normalized[normalizer(u2)] = asNumber(v2);
    }
  }
  return normalized;
}
function formatOffset(offset2, format2) {
  const hours2 = Math.trunc(Math.abs(offset2 / 60)), minutes2 = Math.trunc(Math.abs(offset2 % 60)), sign2 = offset2 >= 0 ? "+" : "-";
  switch (format2) {
    case "short":
      return `${sign2}${padStart(hours2, 2)}:${padStart(minutes2, 2)}`;
    case "narrow":
      return `${sign2}${hours2}${minutes2 > 0 ? `:${minutes2}` : ""}`;
    case "techie":
      return `${sign2}${padStart(hours2, 2)}${padStart(minutes2, 2)}`;
    default:
      throw new RangeError(`Value format ${format2} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick2(obj, ["hour", "minute", "second", "millisecond"]);
}
const monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
const monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months$1(length3) {
  switch (length3) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length3) {
  switch (length3) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const meridiems = ["AM", "PM"];
const erasLong = ["Before Christ", "Anno Domini"];
const erasShort = ["BC", "AD"];
const erasNarrow = ["B", "A"];
function eras(length3) {
  switch (length3) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt2) {
  return meridiems[dt2.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt2, length3) {
  return weekdays(length3)[dt2.weekday - 1];
}
function monthForDateTime(dt2, length3) {
  return months$1(length3)[dt2.month - 1];
}
function eraForDateTime(dt2, length3) {
  return eras(length3)[dt2.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit2, count2, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit2) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit2 === "days";
    switch (count2) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit2][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit2][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit2][0]}`;
    }
  }
  const isInPast = Object.is(count2, -0) || count2 < 0, fmtValue = Math.abs(count2), singular = fmtValue === 1, lilUnits = units[unit2], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit2][0] : unit2;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token2 of splits) {
    if (token2.literal) {
      s2 += token2.val;
    } else {
      s2 += tokenToString(token2.val);
    }
  }
  return s2;
}
const macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
class Formatter {
  static create(locale2, opts = {}) {
    return new Formatter(locale2, opts);
  }
  static parseFormat(fmt) {
    let current2 = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c2 = fmt.charAt(i);
      if (c2 === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current2 = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c2;
      } else if (c2 === current2) {
        currentFull += c2;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c2;
        current2 = c2;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token2) {
    return macroTokenToFormatOpts[token2];
  }
  constructor(locale2, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale2;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt2, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df2 = this.systemLoc.dtFormatter(dt2, { ...this.opts, ...opts });
    return df2.format();
  }
  formatDateTime(dt2, opts = {}) {
    const df2 = this.loc.dtFormatter(dt2, { ...this.opts, ...opts });
    return df2.format();
  }
  formatDateTimeParts(dt2, opts = {}) {
    const df2 = this.loc.dtFormatter(dt2, { ...this.opts, ...opts });
    return df2.formatToParts();
  }
  formatInterval(interval, opts = {}) {
    const df2 = this.loc.dtFormatter(interval.start, { ...this.opts, ...opts });
    return df2.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt2, opts = {}) {
    const df2 = this.loc.dtFormatter(dt2, { ...this.opts, ...opts });
    return df2.resolvedOptions();
  }
  num(n2, p2 = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p2);
    }
    const opts = { ...this.opts };
    if (p2 > 0) {
      opts.padTo = p2;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt2, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string4 = (opts, extract) => this.loc.extract(dt2, opts, extract), formatOffset2 = (opts) => {
      if (dt2.isOffsetFixed && dt2.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt2.isValid ? dt2.zone.formatOffset(dt2.ts, opts.format) : "";
    }, meridiem2 = () => knownEnglish ? meridiemForDateTime(dt2) : string4({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length3, standalone) => knownEnglish ? monthForDateTime(dt2, length3) : string4(standalone ? { month: length3 } : { month: length3, day: "numeric" }, "month"), weekday = (length3, standalone) => knownEnglish ? weekdayForDateTime(dt2, length3) : string4(
      standalone ? { weekday: length3 } : { weekday: length3, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token2) => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token2);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt2, formatOpts);
      } else {
        return token2;
      }
    }, era = (length3) => knownEnglish ? eraForDateTime(dt2, length3) : string4({ era: length3 }, "era"), tokenToString = (token2) => {
      switch (token2) {
        case "S":
          return this.num(dt2.millisecond);
        case "u":
        case "SSS":
          return this.num(dt2.millisecond, 3);
        case "s":
          return this.num(dt2.second);
        case "ss":
          return this.num(dt2.second, 2);
        case "uu":
          return this.num(Math.floor(dt2.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt2.millisecond / 100));
        case "m":
          return this.num(dt2.minute);
        case "mm":
          return this.num(dt2.minute, 2);
        case "h":
          return this.num(dt2.hour % 12 === 0 ? 12 : dt2.hour % 12);
        case "hh":
          return this.num(dt2.hour % 12 === 0 ? 12 : dt2.hour % 12, 2);
        case "H":
          return this.num(dt2.hour);
        case "HH":
          return this.num(dt2.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt2.zone.offsetName(dt2.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt2.zone.offsetName(dt2.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt2.zoneName;
        case "a":
          return meridiem2();
        case "d":
          return useDateTimeFormatter ? string4({ day: "numeric" }, "day") : this.num(dt2.day);
        case "dd":
          return useDateTimeFormatter ? string4({ day: "2-digit" }, "day") : this.num(dt2.day, 2);
        case "c":
          return this.num(dt2.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt2.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string4({ month: "numeric", day: "numeric" }, "month") : this.num(dt2.month);
        case "LL":
          return useDateTimeFormatter ? string4({ month: "2-digit", day: "numeric" }, "month") : this.num(dt2.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string4({ month: "numeric" }, "month") : this.num(dt2.month);
        case "MM":
          return useDateTimeFormatter ? string4({ month: "2-digit" }, "month") : this.num(dt2.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string4({ year: "numeric" }, "year") : this.num(dt2.year);
        case "yy":
          return useDateTimeFormatter ? string4({ year: "2-digit" }, "year") : this.num(dt2.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string4({ year: "numeric" }, "year") : this.num(dt2.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string4({ year: "numeric" }, "year") : this.num(dt2.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt2.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt2.weekYear, 4);
        case "W":
          return this.num(dt2.weekNumber);
        case "WW":
          return this.num(dt2.weekNumber, 2);
        case "o":
          return this.num(dt2.ordinal);
        case "ooo":
          return this.num(dt2.ordinal, 3);
        case "q":
          return this.num(dt2.quarter);
        case "qq":
          return this.num(dt2.quarter, 2);
        case "X":
          return this.num(Math.floor(dt2.ts / 1e3));
        case "x":
          return this.num(dt2.ts);
        default:
          return maybeMacro(token2);
      }
    };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token2) => {
      switch (token2[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token2) => {
      const mapped = tokenToField(token2);
      if (mapped) {
        return this.num(lildur.get(mapped), token2.length);
      } else {
        return token2;
      }
    }, tokens2 = Formatter.parseFormat(fmt), realTokens = tokens2.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t2) => t2));
    return stringifyTokens(tokens2, tokenToString(collapsed));
  }
}
class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
}
const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes2) {
  const full = regexes2.reduce((f2, r2) => f2 + r2.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m2) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m2, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse$3(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m2 = regex.exec(s2);
    if (m2) {
      return extractor(m2);
    }
  }
  return [null, null];
}
function simpleParse(...keys4) {
  return (match5, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys4.length; i++) {
      ret[keys4[i]] = parseInteger(match5[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
const isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
const isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
const isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
const isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
const isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
const isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
const isoOrdinalRegex = /(\d{4})-?(\d{3})/;
const extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
const extractISOOrdinalData = simpleParse("year", "ordinal");
const sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
const sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
const sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match5, pos, fallback) {
  const m2 = match5[pos];
  return isUndefined$2(m2) ? fallback : parseInteger(m2);
}
function extractISOYmd(match5, cursor) {
  const item = {
    year: int(match5, cursor),
    month: int(match5, cursor + 1, 1),
    day: int(match5, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match5, cursor) {
  const item = {
    hours: int(match5, cursor, 0),
    minutes: int(match5, cursor + 1, 0),
    seconds: int(match5, cursor + 2, 0),
    milliseconds: parseMillis(match5[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match5, cursor) {
  const local = !match5[cursor] && !match5[cursor + 1], fullOffset = signedOffset(match5[cursor + 1], match5[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match5, cursor) {
  const zone = match5[cursor] ? IANAZone.create(match5[cursor]) : null;
  return [{}, zone, cursor + 1];
}
const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
const isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match5) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match5;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
const obsOffsets$1 = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear$1(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
const rfc2822$1 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match5) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match5, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets$1[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822$1(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match5) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match5, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match5) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match5, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
const extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s2) {
  return parse$3(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse$3(preprocessRFC2822$1(s2), [rfc2822$1, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse$3(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse$3(s2, [isoDuration, extractISODuration]);
}
const extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse$3(s2, [isoTimeOnly, extractISOTimeOnly]);
}
const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
const extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse$3(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}
const INVALID$2 = "Invalid Duration";
const lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
}, daysInYearAccurate = 146097 / 400, daysInMonthAccurate = 146097 / 4800, accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
const orderedUnits$1 = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
const reverseUnits = orderedUnits$1.slice(0).reverse();
function clone$3(dur, alts, clear3 = false) {
  const conf = {
    values: clear3 ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration$1(conf);
}
function antiTrunc(n2) {
  return n2 < 0 ? Math.floor(n2) : Math.ceil(n2);
}
function convert$1(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
}
function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current2) => {
    if (!isUndefined$2(vals[current2])) {
      if (previous) {
        convert$1(matrix, vals, previous, vals, current2);
      }
      return current2;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
let Duration$1 = class Duration {
  /**
   * @private
   */
  constructor(config2) {
    const accurate = config2.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config2.matrix) {
      matrix = config2.matrix;
    }
    this.values = config2.values;
    this.loc = config2.loc || Locale$1.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config2.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count2, opts) {
    return Duration.fromObject({ milliseconds: count2 }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale$1.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber$5(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit2) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit2 ? unit2.toLowerCase() : unit2];
    if (!normalized)
      throw new InvalidUnitError(unit2);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o3) {
    return o3 && o3.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    const l2 = orderedUnits$1.map((unit2) => {
      const val = this.values[unit2];
      if (isUndefined$2(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit2.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid)
      return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let s2 = "P";
    if (this.years !== 0)
      s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s2 += this.weeks + "W";
    if (this.days !== 0)
      s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0)
      s2 += this.hours + "H";
    if (this.minutes !== 0)
      s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P")
      s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts
    };
    const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
      fmt += opts.format === "basic" ? "ss" : ":ss";
      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }
    let str = value.toFormat(fmt);
    if (opts.includePrefix) {
      str = "T" + str;
    }
    return str;
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.as("milliseconds");
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration), result = {};
    for (const k2 of orderedUnits$1) {
      if (hasOwnProperty$a(dur.values, k2) || hasOwnProperty$a(this.values, k2)) {
        result[k2] = dur.get(k2) + this.get(k2);
      }
    }
    return clone$3(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn2) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k2 of Object.keys(this.values)) {
      result[k2] = asNumber(fn2(this.values[k2], k2));
    }
    return clone$3(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit2) {
    return this[Duration.normalizeUnit(unit2)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values3) {
    if (!this.isValid)
      return this;
    const mixed = { ...this.values, ...normalizeObject(values3, Duration.normalizeUnit) };
    return clone$3(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: locale2, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale: locale2, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone$3(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit2) {
    return this.isValid ? this.shiftTo(unit2).get(unit2) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone$3(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone$3(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u2) => Duration.normalizeUnit(u2));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k2 of orderedUnits$1) {
      if (units.indexOf(k2) >= 0) {
        lastUnit = k2;
        let own = 0;
        for (const ak2 in accumulated) {
          own += this.matrix[ak2][k2] * accumulated[ak2];
          accumulated[ak2] = 0;
        }
        if (isNumber$5(vals[k2])) {
          own += vals[k2];
        }
        const i = Math.trunc(own);
        built[k2] = i;
        accumulated[k2] = (own * 1e3 - i * 1e3) / 1e3;
        for (const down in vals) {
          if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k2)) {
            convert$1(this.matrix, vals, down, built, k2);
          }
        }
      } else if (isNumber$5(vals[k2])) {
        accumulated[k2] = vals[k2];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    return clone$3(this, { values: built }, true).normalize();
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid)
      return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k2 of Object.keys(this.values)) {
      negated[k2] = this.values[k2] === 0 ? 0 : -this.values[k2];
    }
    return clone$3(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq2(v1, v2) {
      if (v1 === void 0 || v1 === 0)
        return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u2 of orderedUnits$1) {
      if (!eq2(this.values[u2], other.values[u2])) {
        return false;
      }
    }
    return true;
  }
};
const INVALID$1 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
class Interval {
  /**
   * @private
   */
  constructor(config2) {
    this.s = config2.start;
    this.e = config2.end;
    this.invalid = config2.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration$1.fromDurationLike(duration), dt2 = friendlyDateTime(start);
    return Interval.fromDateTimes(dt2, dt2.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration$1.fromDurationLike(duration), dt2 = friendlyDateTime(end);
    return Interval.fromDateTimes(dt2.minus(dur), dt2);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s2, e3] = (text || "").split("/", 2);
    if (s2 && e3) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e4) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e3, opts);
        endIsValid = end.isValid;
      } catch (e4) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration$1.fromISO(e3, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration$1.fromISO(s2, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o3) {
    return o3 && o3.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit2 = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit2]).get(unit2) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(unit2 = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const start = this.start.startOf(unit2), end = this.end.startOf(unit2);
    return Math.floor(end.diff(start, unit2).get(unit2)) + (end.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit2) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit2) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid)
      return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d2) => this.contains(d2)).sort(), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration$1.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x2) => x2 * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s > other.s ? this.s : other.s, e3 = this.e < other.e ? this.e : other.e;
    if (s2 >= e3) {
      return null;
    } else {
      return Interval.fromDateTimes(s2, e3);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s < other.s ? this.s : other.s, e3 = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s2, e3);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a2, b2) => a2.s - b2.s).reduce(
      ([sofar, current2], item) => {
        if (!current2) {
          return [sofar, item];
        } else if (current2.overlaps(item) || current2.abutsStart(item)) {
          return [sofar, current2.union(item)];
        } else {
          return [sofar.concat([current2]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a2, b2) => a2.time - b2.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid)
      return INVALID$1;
    return `[${this.s.toISO()}  ${this.e.toISO()})`;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid)
      return INVALID$1;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid)
      return INVALID$1;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID$1;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = "  " } = {}) {
    if (!this.isValid)
      return INVALID$1;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit2, opts) {
    if (!this.isValid) {
      return Duration$1.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit2, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
}
class Info {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto2 = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto2.offset !== proto2.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(length3 = "long", { locale: locale2 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale$1.create(locale2, numberingSystem, outputCalendar)).months(length3);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length3 = "long", { locale: locale2 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale$1.create(locale2, numberingSystem, outputCalendar)).months(length3, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(length3 = "long", { locale: locale2 = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale$1.create(locale2, numberingSystem, null)).weekdays(length3);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length3 = "long", { locale: locale2 = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale$1.create(locale2, numberingSystem, null)).weekdays(length3, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale: locale2 = null } = {}) {
    return Locale$1.create(locale2).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(length3 = "short", { locale: locale2 = null } = {}) {
    return Locale$1.create(locale2, null, "gregory").eras(length3);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative() };
  }
}
function dayDiff(earlier, later) {
  const utcDayStart = (dt2) => dt2.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms2 = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration$1.fromMillis(ms2).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a2, b2) => b2.year - a2.year],
    ["quarters", (a2, b2) => b2.quarter - a2.quarter + (b2.year - a2.year) * 4],
    ["months", (a2, b2) => b2.month - a2.month + (b2.year - a2.year) * 12],
    [
      "weeks",
      (a2, b2) => {
        const days2 = dayDiff(a2, b2);
        return (days2 - days2 % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit2, differ] of differs) {
    if (units.indexOf(unit2) >= 0) {
      lowestOrder = unit2;
      results[unit2] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit2]--;
        cursor = earlier.plus(results);
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff$1(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u2) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u2) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration$1.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration$1.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}
const numberingSystems = {
  arab: "[-]",
  arabext: "[-]",
  bali: "[-]",
  beng: "[-]",
  deva: "[-]",
  fullwide: "[-]",
  gujr: "[-]",
  hanidec: "[|||||||||]",
  khmr: "[-]",
  knda: "[-]",
  laoo: "[-]",
  limb: "[-]",
  mlym: "[-]",
  mong: "[-]",
  mymr: "[-]",
  orya: "[-]",
  tamldec: "[-]",
  telu: "[-]",
  thai: "[-]",
  tibt: "[-]",
  latn: "\\d"
};
const numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code2 = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min3, max3] = numberingSystemsUTF16[key];
          if (code2 >= min3 && code2 <= max3) {
            value += code2 - min3;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append3 = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append3}`);
}
const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
const NBSP = String.fromCharCode(160);
const spaceOrNBSP = `[ ${NBSP}]`;
const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset$1(regex, groups) {
  return { regex, deser: ([, h2, m2]) => signedOffset(h2, m2), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token2, loc) {
  const one2 = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t2) => ({ regex: RegExp(escapeToken(t2.val)), deser: ([s2]) => s2, literal: true }), unitate = (t2) => {
    if (token2.literal) {
      return literal(t2);
    }
    switch (t2.val) {
      case "G":
        return oneOf(loc.eras("short", false), 0);
      case "GG":
        return oneOf(loc.eras("long", false), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear$1);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true, false), 1);
      case "MMMM":
        return oneOf(loc.months("long", true, false), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false, false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false, false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one2);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear$1);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one2);
      case "EEE":
        return oneOf(loc.weekdays("short", false, false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false, false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true, false), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true, false), 1);
      case "Z":
      case "ZZ":
        return offset$1(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset$1(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal(t2);
    }
  };
  const unit2 = unitate(token2) || {
    invalidReason: MISSING_FTP
  };
  unit2.token = token2;
  return unit2;
}
const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts) {
  const { type: type3, value } = part;
  if (type3 === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type3];
  let val = partTypeStyleToTokenVal[type3];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re2 = units.map((u2) => u2.regex).reduce((f2, r2) => `${f2}(${r2.source})`, "");
  return [`^${re2}$`, units];
}
function match2(input, regex, handlers) {
  const matches2 = input.match(regex);
  if (matches2) {
    const all4 = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty$a(handlers, i)) {
        const h2 = handlers[i], groups = h2.groups ? h2.groups + 1 : 1;
        if (!h2.literal && h2.token) {
          all4[h2.token.val[0]] = h2.deser(matches2.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches2, all4];
  } else {
    return [matches2, {}];
  }
}
function dateTimeFromMatches(matches2) {
  const toField = (token2) => {
    switch (token2) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined$2(matches2.z)) {
    zone = IANAZone.create(matches2.z);
  }
  if (!isUndefined$2(matches2.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches2.Z);
    }
    specificOffset = matches2.Z;
  }
  if (!isUndefined$2(matches2.q)) {
    matches2.M = (matches2.q - 1) * 3 + 1;
  }
  if (!isUndefined$2(matches2.h)) {
    if (matches2.h < 12 && matches2.a === 1) {
      matches2.h += 12;
    } else if (matches2.h === 12 && matches2.a === 0) {
      matches2.h = 0;
    }
  }
  if (matches2.G === 0 && matches2.y) {
    matches2.y = -matches2.y;
  }
  if (!isUndefined$2(matches2.u)) {
    matches2.S = parseMillis(matches2.u);
  }
  const vals = Object.keys(matches2).reduce((r2, k2) => {
    const f2 = toField(k2);
    if (f2) {
      r2[f2] = matches2[k2];
    }
    return r2;
  }, {});
  return [vals, zone, specificOffset];
}
let dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token2, locale2) {
  if (token2.literal) {
    return token2;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token2.val);
  const tokens2 = formatOptsToTokens(formatOpts, locale2);
  if (tokens2 == null || tokens2.includes(void 0)) {
    return token2;
  }
  return tokens2;
}
function expandMacroTokens(tokens2, locale2) {
  return Array.prototype.concat(...tokens2.map((t2) => maybeExpandMacroToken(t2, locale2)));
}
function explainFromTokens(locale2, input, format2) {
  const tokens2 = expandMacroTokens(Formatter.parseFormat(format2), locale2), units = tokens2.map((t2) => unitForToken(t2, locale2)), disqualifyingUnit = units.find((t2) => t2.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens: tokens2, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches2] = match2(input, regex, handlers), [result, zone, specificOffset] = matches2 ? dateTimeFromMatches(matches2) : [null, null, void 0];
    if (hasOwnProperty$a(matches2, "a") && hasOwnProperty$a(matches2, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input, tokens: tokens2, regex, rawMatches, matches: matches2, result, zone, specificOffset };
  }
}
function parseFromTokens(locale2, input, format2) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale2, input, format2);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale2) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale2, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  return parts.map((p2) => tokenForPart(p2, formatOpts));
}
const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit2, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit2}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d2 = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
  }
  const js2 = d2.getUTCDay();
  return js2 === 0 ? 7 : js2;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear$2(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal2) {
  const table = isLeapYear$2(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal2), day = ordinal2 - table[month0];
  return { month: month0 + 1, day };
}
function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj, ordinal2 = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal2 - weekday + 10) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear$1(weekYear);
  let ordinal2 = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
  if (ordinal2 < 1) {
    year = weekYear - 1;
    ordinal2 += daysInYear$1(year);
  } else if (ordinal2 > yearInDays) {
    year = weekYear + 1;
    ordinal2 -= daysInYear$1(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal2);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal2 = computeOrdinal(year, month, day);
  return { year, ordinal: ordinal2, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal: ordinal2 } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal2);
  return { year, month, day, ...timeObject(ordinalData) };
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear$1(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth$1(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second: second2, millisecond: millisecond2 } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second2 === 0 && millisecond2 === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second2, 0, 59), validMillisecond = integerBetween(millisecond2, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second2);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond2);
  } else
    return false;
}
const INVALID = "Invalid DateTime";
const MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt2) {
  if (dt2.weekData === null) {
    dt2.weekData = gregorianToWeek(dt2.c);
  }
  return dt2.weekData;
}
function clone$2(inst, alts) {
  const current2 = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current2, ...alts, old: current2 });
}
function fixOffset(localTS, o3, tz) {
  let utcGuess = localTS - o3 * 60 * 1e3;
  const o22 = tz.offset(utcGuess);
  if (o3 === o22) {
    return [utcGuess, o3];
  }
  utcGuess -= (o22 - o3) * 60 * 1e3;
  const o32 = tz.offset(utcGuess);
  if (o22 === o32) {
    return [utcGuess, o22];
  }
  return [localTS - Math.min(o22, o32) * 60 * 1e3, Math.max(o22, o32)];
}
function tsToObj(ts2, offset2) {
  ts2 += offset2 * 60 * 1e3;
  const d2 = new Date(ts2);
  return {
    year: d2.getUTCFullYear(),
    month: d2.getUTCMonth() + 1,
    day: d2.getUTCDate(),
    hour: d2.getUTCHours(),
    minute: d2.getUTCMinutes(),
    second: d2.getUTCSeconds(),
    millisecond: d2.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c2 = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth$1(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration$1.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c2);
  let [ts2, o3] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts2 += millisToAdd;
    o3 = inst.zone.offset(ts2);
  }
  return { ts: ts2, o: o3 };
}
function parseDataToDateTime(parsed, parsedZone, opts, format2, text, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text}" can't be parsed as ${format2}`)
    );
  }
}
function toTechFormat(dt2, format2, allowZ = true) {
  return dt2.isValid ? Formatter.create(Locale$1.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt2, format2) : null;
}
function toISODate(o3, extended) {
  const longFormat = o3.c.year > 9999 || o3.c.year < 0;
  let c2 = "";
  if (longFormat && o3.c.year >= 0)
    c2 += "+";
  c2 += padStart(o3.c.year, longFormat ? 6 : 4);
  if (extended) {
    c2 += "-";
    c2 += padStart(o3.c.month);
    c2 += "-";
    c2 += padStart(o3.c.day);
  } else {
    c2 += padStart(o3.c.month);
    c2 += padStart(o3.c.day);
  }
  return c2;
}
function toISOTime(o3, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c2 = padStart(o3.c.hour);
  if (extended) {
    c2 += ":";
    c2 += padStart(o3.c.minute);
    if (o3.c.second !== 0 || !suppressSeconds) {
      c2 += ":";
    }
  } else {
    c2 += padStart(o3.c.minute);
  }
  if (o3.c.second !== 0 || !suppressSeconds) {
    c2 += padStart(o3.c.second);
    if (o3.c.millisecond !== 0 || !suppressMilliseconds) {
      c2 += ".";
      c2 += padStart(o3.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o3.isOffsetFixed && o3.offset === 0 && !extendedZone) {
      c2 += "Z";
    } else if (o3.o < 0) {
      c2 += "-";
      c2 += padStart(Math.trunc(-o3.o / 60));
      c2 += ":";
      c2 += padStart(Math.trunc(-o3.o % 60));
    } else {
      c2 += "+";
      c2 += padStart(Math.trunc(o3.o / 60));
      c2 += ":";
      c2 += padStart(Math.trunc(o3.o % 60));
    }
  }
  if (extendedZone) {
    c2 += "[" + o3.zone.ianaName + "]";
  }
  return c2;
}
const defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
const orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"], orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit2) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit2.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit2);
  return normalized;
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale$1.fromObject(opts), tsNow = Settings.now();
  let ts2, o3;
  if (!isUndefined$2(obj.year)) {
    for (const u2 of orderedUnits) {
      if (isUndefined$2(obj[u2])) {
        obj[u2] = defaultUnitValues[u2];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts2, o3] = objToTS(obj, offsetProvis, zone);
  } else {
    ts2 = tsNow;
  }
  return new DateTime({ ts: ts2, zone, loc, o: o3 });
}
function diffRelative(start, end, opts) {
  const round2 = isUndefined$2(opts.round) ? true : opts.round, format2 = (c2, unit2) => {
    c2 = roundTo(c2, round2 || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c2, unit2);
  }, differ = (unit2) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit2)) {
        return end.startOf(unit2).diff(start.startOf(unit2), unit2).get(unit2);
      } else
        return 0;
    } else {
      return end.diff(start, unit2).get(unit2);
    }
  };
  if (opts.unit) {
    return format2(differ(opts.unit), opts.unit);
  }
  for (const unit2 of opts.units) {
    const count2 = differ(unit2);
    if (Math.abs(count2) >= 1) {
      return format2(count2, unit2);
    }
  }
  return format2(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
class DateTime {
  /**
   * @access private
   */
  constructor(config2) {
    const zone = config2.zone || Settings.defaultZone;
    let invalid = config2.invalid || (Number.isNaN(config2.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined$2(config2.ts) ? Settings.now() : config2.ts;
    let c2 = null, o3 = null;
    if (!invalid) {
      const unchanged = config2.old && config2.old.ts === this.ts && config2.old.zone.equals(zone);
      if (unchanged) {
        [c2, o3] = [config2.old.c, config2.old.o];
      } else {
        const ot2 = zone.offset(this.ts);
        c2 = tsToObj(this.ts, ot2);
        invalid = Number.isNaN(c2.year) ? new Invalid("invalid input") : null;
        c2 = invalid ? null : c2;
        o3 = invalid ? null : ot2;
      }
    }
    this._zone = zone;
    this.loc = config2.loc || Locale$1.create();
    this.invalid = invalid;
    this.weekData = null;
    this.c = c2;
    this.o = o3;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second2, millisecond2] = args;
    return quickDT({ year, month, day, hour, minute, second: second2, millisecond: millisecond2 }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second2, millisecond2] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second: second2, millisecond: millisecond2 }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date2, options = {}) {
    const ts2 = isDate$2(date2) ? date2.valueOf() : NaN;
    if (Number.isNaN(ts2)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts: ts2,
      zone: zoneToUse,
      loc: Locale$1.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds2, options = {}) {
    if (!isNumber$5(milliseconds2)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds2} with value ${milliseconds2}`
      );
    } else if (milliseconds2 < -MAX_DATE || milliseconds2 > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds2,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale$1.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds2, options = {}) {
    if (!isNumber$5(seconds2)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds2 * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale$1.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const tsNow = Settings.now(), offsetProvis = !isUndefined$2(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined$2(normalized.ordinal), containsGregorYear = !isUndefined$2(normalized.year), containsGregorMD = !isUndefined$2(normalized.month) || !isUndefined$2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale$1.fromObject(opts);
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u2 of units) {
      const v2 = normalized[u2];
      if (!isUndefined$2(v2)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u2] = defaultValues[u2];
      } else {
        normalized[u2] = objNow[u2];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined$2(text) || isUndefined$2(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale: locale2 = null, numberingSystem = null } = opts, localeToUse = Locale$1.fromOpts({
      locale: locale2,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  /**
   * Create an invalid DateTime.
   * @param {DateTime} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o3) {
    return o3 && o3.isLuxonDateTime || false;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale$1.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t2) => t2 ? t2.val : null).join("");
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale$1.fromObject(localeOpts));
    return expanded.map((t2) => t2.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit2) {
    return this[unit2];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear$2(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth$1(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear$1(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale: locale2, numberingSystem, calendar: calendar2 } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale: locale2, numberingSystem, outputCalendar: calendar2 };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone$2(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: locale2, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale: locale2, numberingSystem, outputCalendar });
    return clone$2(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale2) {
    return this.reconfigure({ locale: locale2 });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values3) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values3, normalizeUnit), settingWeekStuff = !isUndefined$2(normalized.weekYear) || !isUndefined$2(normalized.weekNumber) || !isUndefined$2(normalized.weekday), containsOrdinal = !isUndefined$2(normalized.ordinal), containsGregorYear = !isUndefined$2(normalized.year), containsGregorMD = !isUndefined$2(normalized.month) || !isUndefined$2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
    } else if (!isUndefined$2(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined$2(normalized.day)) {
        mixed.day = Math.min(daysInMonth$1(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts2, o3] = objToTS(mixed, this.o, this.zone);
    return clone$2(this, { ts: ts2, o: o3 });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration$1.fromDurationLike(duration);
    return clone$2(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration$1.fromDurationLike(duration).negate();
    return clone$2(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit2) {
    if (!this.isValid)
      return this;
    const o3 = {}, normalizedUnit = Duration$1.normalizeUnit(unit2);
    switch (normalizedUnit) {
      case "years":
        o3.month = 1;
      case "quarters":
      case "months":
        o3.day = 1;
      case "weeks":
      case "days":
        o3.hour = 0;
      case "hours":
        o3.minute = 0;
      case "minutes":
        o3.second = 0;
      case "seconds":
        o3.millisecond = 0;
        break;
    }
    if (normalizedUnit === "weeks") {
      o3.weekday = 1;
    }
    if (normalizedUnit === "quarters") {
      const q2 = Math.ceil(this.month / 3);
      o3.month = (q2 - 1) * 3 + 1;
    }
    return this.set(o3);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit2) {
    return this.isValid ? this.plus({ [unit2]: 1 }).startOf(unit2).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: format2 = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format2 === "extended";
    let c2 = toISODate(this, ext);
    c2 += "T";
    c2 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: format2 = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format2 === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format: format2 = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c2 = includePrefix ? "T" : "";
    return c2 + toISOTime(
      this,
      format2 === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit2 = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration$1.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit2).map(Duration$1.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff$1(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit2 = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit2, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit2) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit2) <= inputMs && inputMs <= adjustedToZone.endOf(unit2);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit2 = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit2 = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit: unit2
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale: locale2 = null, numberingSystem = null } = options, localeToUse = Locale$1.fromOpts({
      locale: locale2,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
}
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber$5(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}
const VERSION$1 = "3.3.0";
const luxon = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DateTime,
  Duration: Duration$1,
  FixedOffsetZone,
  IANAZone,
  Info,
  Interval,
  InvalidZone,
  Settings,
  SystemZone,
  VERSION: VERSION$1,
  Zone
}, Symbol.toStringTag, { value: "Module" }));
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i = links.length - 1; i >= 0; i--) {
        const link3 = links[i];
        if (link3.href === dep && (!isCss || link3.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link2 = document.createElement("link");
    link2.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link2.as = "script";
      link2.crossOrigin = "";
    }
    link2.href = dep;
    document.head.appendChild(link2);
    if (isCss) {
      return new Promise((res, rej) => {
        link2.addEventListener("load", res);
        link2.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
const BUILD$1 = {
  allRenderFn: false,
  cmpDidLoad: true,
  cmpDidUnload: false,
  cmpDidUpdate: true,
  cmpDidRender: true,
  cmpWillLoad: true,
  cmpWillUpdate: true,
  cmpWillRender: true,
  connectedCallback: true,
  disconnectedCallback: true,
  element: true,
  event: true,
  hasRenderFn: true,
  lifecycle: true,
  hostListener: true,
  hostListenerTargetWindow: true,
  hostListenerTargetDocument: true,
  hostListenerTargetBody: true,
  hostListenerTargetParent: false,
  hostListenerTarget: true,
  member: true,
  method: true,
  mode: true,
  observeAttribute: true,
  prop: true,
  propMutable: true,
  reflect: true,
  scoped: true,
  shadowDom: true,
  slot: true,
  cssAnnotations: true,
  state: true,
  style: true,
  svg: true,
  updatable: true,
  vdomAttribute: true,
  vdomXlink: true,
  vdomClass: true,
  vdomFunctional: true,
  vdomKey: true,
  vdomListener: true,
  vdomRef: true,
  vdomPropOrAttr: true,
  vdomRender: true,
  vdomStyle: true,
  vdomText: true,
  watchCallback: true,
  taskQueue: true,
  hotModuleReplacement: false,
  isDebug: false,
  isDev: false,
  isTesting: false,
  hydrateServerSide: false,
  hydrateClientSide: false,
  lifecycleDOMEvents: false,
  lazyLoad: false,
  profile: false,
  slotRelocation: true,
  appendChildSlotFix: false,
  cloneNodeFix: false,
  hydratedAttribute: false,
  hydratedClass: true,
  // TODO(STENCIL-663): Remove code related to deprecated `safari10` field.
  safari10: false,
  scriptDataOpts: false,
  scopedSlotTextContentFix: false,
  // TODO(STENCIL-662): Remove code related to deprecated shadowDomShim field
  shadowDomShim: false,
  slotChildNodesFix: false,
  invisiblePrehydration: true,
  propBoolean: true,
  propNumber: true,
  propString: true,
  // TODO(STENCIL-659): Remove code implementing the CSS variable shim
  cssVarShim: false,
  constructableCSS: true,
  cmpShouldUpdate: true,
  devTools: false,
  // TODO(STENCIL-661): Remove code related to the dynamic import shim
  dynamicImportShim: false,
  shadowDelegatesFocus: true,
  initializeNextTick: false,
  asyncLoading: false,
  asyncQueue: false,
  transformTagName: false,
  attachStyles: true
};
let scopeId$1;
let contentRef$1;
let hostTagName$1;
let useNativeShadowDom$1 = false;
let checkSlotFallbackVisibility$1 = false;
let checkSlotRelocate$1 = false;
let isSvgMode$1 = false;
let renderingRef$1 = null;
let queuePending$1 = false;
const Build = {
  isDev: false,
  isBrowser: true,
  isServer: false,
  isTesting: false
};
const getAssetPath$1 = (path3) => {
  const assetUrl = new URL(path3, plt$1.$resourcesUrl$);
  return assetUrl.origin !== win$3.location.origin ? assetUrl.href : assetUrl.pathname;
};
const createTime$1 = (fnName, tagName = "") => {
  {
    return () => {
      return;
    };
  }
};
const XLINK_NS$1 = "http://www.w3.org/1999/xlink";
const EMPTY_OBJ$1 = {};
const SVG_NS$1 = "http://www.w3.org/2000/svg";
const HTML_NS$1 = "http://www.w3.org/1999/xhtml";
const isDef$1 = (v2) => v2 != null;
const isComplexType$1 = (o3) => {
  o3 = typeof o3;
  return o3 === "object" || o3 === "function";
};
function queryNonceMetaTagContent$1(doc2) {
  var _a2, _b, _c;
  return (_c = (_b = (_a2 = doc2.head) === null || _a2 === void 0 ? void 0 : _a2.querySelector('meta[name="csp-nonce"]')) === null || _b === void 0 ? void 0 : _b.getAttribute("content")) !== null && _c !== void 0 ? _c : void 0;
}
const h$5 = (nodeName, vnodeData, ...children) => {
  let child = null;
  let key = null;
  let slotName = null;
  let simple2 = false;
  let lastSimple = false;
  const vNodeChildren = [];
  const walk3 = (c2) => {
    for (let i = 0; i < c2.length; i++) {
      child = c2[i];
      if (Array.isArray(child)) {
        walk3(child);
      } else if (child != null && typeof child !== "boolean") {
        if (simple2 = typeof nodeName !== "function" && !isComplexType$1(child)) {
          child = String(child);
        }
        if (simple2 && lastSimple) {
          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
        } else {
          vNodeChildren.push(simple2 ? newVNode$1(null, child) : child);
        }
        lastSimple = simple2;
      }
    }
  };
  walk3(children);
  if (vnodeData) {
    if (vnodeData.key) {
      key = vnodeData.key;
    }
    if (vnodeData.name) {
      slotName = vnodeData.name;
    }
    {
      const classData = vnodeData.className || vnodeData.class;
      if (classData) {
        vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k2) => classData[k2]).join(" ");
      }
    }
  }
  if (typeof nodeName === "function") {
    return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils$1);
  }
  const vnode = newVNode$1(nodeName, null);
  vnode.$attrs$ = vnodeData;
  if (vNodeChildren.length > 0) {
    vnode.$children$ = vNodeChildren;
  }
  {
    vnode.$key$ = key;
  }
  {
    vnode.$name$ = slotName;
  }
  return vnode;
};
const newVNode$1 = (tag, text) => {
  const vnode = {
    $flags$: 0,
    $tag$: tag,
    $text$: text,
    $elm$: null,
    $children$: null
  };
  {
    vnode.$attrs$ = null;
  }
  {
    vnode.$key$ = null;
  }
  {
    vnode.$name$ = null;
  }
  return vnode;
};
const Host$1 = {};
const isHost$1 = (node) => node && node.$tag$ === Host$1;
const vdomFnUtils$1 = {
  forEach: (children, cb2) => children.map(convertToPublic$1).forEach(cb2),
  map: (children, cb2) => children.map(convertToPublic$1).map(cb2).map(convertToPrivate$1)
};
const convertToPublic$1 = (node) => ({
  vattrs: node.$attrs$,
  vchildren: node.$children$,
  vkey: node.$key$,
  vname: node.$name$,
  vtag: node.$tag$,
  vtext: node.$text$
});
const convertToPrivate$1 = (node) => {
  if (typeof node.vtag === "function") {
    const vnodeData = Object.assign({}, node.vattrs);
    if (node.vkey) {
      vnodeData.key = node.vkey;
    }
    if (node.vname) {
      vnodeData.name = node.vname;
    }
    return h$5(node.vtag, vnodeData, ...node.vchildren || []);
  }
  const vnode = newVNode$1(node.vtag, node.vtext);
  vnode.$attrs$ = node.vattrs;
  vnode.$children$ = node.vchildren;
  vnode.$key$ = node.vkey;
  vnode.$name$ = node.vname;
  return vnode;
};
const computeMode$1 = (elm) => modeResolutionChain$1.map((h2) => h2(elm)).find((m2) => !!m2);
const setMode = (handler) => modeResolutionChain$1.push(handler);
const getMode = (ref) => getHostRef$1(ref).$modeName$;
const parsePropertyValue$1 = (propValue, propType) => {
  if (propValue != null && !isComplexType$1(propValue)) {
    if (propType & 4) {
      return propValue === "false" ? false : propValue === "" || !!propValue;
    }
    if (propType & 2) {
      return parseFloat(propValue);
    }
    if (propType & 1) {
      return String(propValue);
    }
    return propValue;
  }
  return propValue;
};
const getElement = (ref) => ref;
const createEvent = (ref, name, flags2) => {
  const elm = getElement(ref);
  return {
    emit: (detail) => {
      return emitEvent(elm, name, {
        bubbles: !!(flags2 & 4),
        composed: !!(flags2 & 2),
        cancelable: !!(flags2 & 1),
        detail
      });
    }
  };
};
const emitEvent = (elm, name, opts) => {
  const ev = plt$1.ce(name, opts);
  elm.dispatchEvent(ev);
  return ev;
};
const rootAppliedStyles$1 = /* @__PURE__ */ new WeakMap();
const registerStyle$1 = (scopeId2, cssText, allowCS) => {
  let style = styles$1.get(scopeId2);
  if (supportsConstructableStylesheets$1 && allowCS) {
    style = style || new CSSStyleSheet();
    if (typeof style === "string") {
      style = cssText;
    } else {
      style.replaceSync(cssText);
    }
  } else {
    style = cssText;
  }
  styles$1.set(scopeId2, style);
};
const addStyle$1 = (styleContainerNode, cmpMeta, mode, hostElm) => {
  var _a2;
  let scopeId2 = getScopeId$1(cmpMeta, mode);
  const style = styles$1.get(scopeId2);
  styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc$2;
  if (style) {
    if (typeof style === "string") {
      styleContainerNode = styleContainerNode.head || styleContainerNode;
      let appliedStyles = rootAppliedStyles$1.get(styleContainerNode);
      let styleElm;
      if (!appliedStyles) {
        rootAppliedStyles$1.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
      }
      if (!appliedStyles.has(scopeId2)) {
        {
          {
            styleElm = doc$2.createElement("style");
            styleElm.innerHTML = style;
          }
          const nonce = (_a2 = plt$1.$nonce$) !== null && _a2 !== void 0 ? _a2 : queryNonceMetaTagContent$1(doc$2);
          if (nonce != null) {
            styleElm.setAttribute("nonce", nonce);
          }
          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
        }
        if (appliedStyles) {
          appliedStyles.add(scopeId2);
        }
      }
    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
    }
  }
  return scopeId2;
};
const attachStyles$1 = (hostRef) => {
  const cmpMeta = hostRef.$cmpMeta$;
  const elm = hostRef.$hostElement$;
  const flags2 = cmpMeta.$flags$;
  const endAttachStyles = createTime$1("attachStyles", cmpMeta.$tagName$);
  const scopeId2 = addStyle$1(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$);
  if (flags2 & 10) {
    elm["s-sc"] = scopeId2;
    elm.classList.add(scopeId2 + "-h");
    if (flags2 & 2) {
      elm.classList.add(scopeId2 + "-s");
    }
  }
  endAttachStyles();
};
const getScopeId$1 = (cmp, mode) => "sc-" + (mode && cmp.$flags$ & 32 ? cmp.$tagName$ + "-" + mode : cmp.$tagName$);
const setAccessor$1 = (elm, memberName, oldValue, newValue, isSvg, flags2) => {
  if (oldValue !== newValue) {
    let isProp = isMemberInElement$1(elm, memberName);
    let ln2 = memberName.toLowerCase();
    if (memberName === "class") {
      const classList = elm.classList;
      const oldClasses = parseClassList$1(oldValue);
      const newClasses = parseClassList$1(newValue);
      classList.remove(...oldClasses.filter((c2) => c2 && !newClasses.includes(c2)));
      classList.add(...newClasses.filter((c2) => c2 && !oldClasses.includes(c2)));
    } else if (memberName === "style") {
      {
        for (const prop3 in oldValue) {
          if (!newValue || newValue[prop3] == null) {
            if (prop3.includes("-")) {
              elm.style.removeProperty(prop3);
            } else {
              elm.style[prop3] = "";
            }
          }
        }
      }
      for (const prop3 in newValue) {
        if (!oldValue || newValue[prop3] !== oldValue[prop3]) {
          if (prop3.includes("-")) {
            elm.style.setProperty(prop3, newValue[prop3]);
          } else {
            elm.style[prop3] = newValue[prop3];
          }
        }
      }
    } else if (memberName === "key")
      ;
    else if (memberName === "ref") {
      if (newValue) {
        newValue(elm);
      }
    } else if (!elm.__lookupSetter__(memberName) && memberName[0] === "o" && memberName[1] === "n") {
      if (memberName[2] === "-") {
        memberName = memberName.slice(3);
      } else if (isMemberInElement$1(win$3, ln2)) {
        memberName = ln2.slice(2);
      } else {
        memberName = ln2[2] + memberName.slice(3);
      }
      if (oldValue) {
        plt$1.rel(elm, memberName, oldValue, false);
      }
      if (newValue) {
        plt$1.ael(elm, memberName, newValue, false);
      }
    } else {
      const isComplex = isComplexType$1(newValue);
      if ((isProp || isComplex && newValue !== null) && !isSvg) {
        try {
          if (!elm.tagName.includes("-")) {
            const n2 = newValue == null ? "" : newValue;
            if (memberName === "list") {
              isProp = false;
            } else if (oldValue == null || elm[memberName] != n2) {
              elm[memberName] = n2;
            }
          } else {
            elm[memberName] = newValue;
          }
        } catch (e3) {
        }
      }
      let xlink = false;
      {
        if (ln2 !== (ln2 = ln2.replace(/^xlink\:?/, ""))) {
          memberName = ln2;
          xlink = true;
        }
      }
      if (newValue == null || newValue === false) {
        if (newValue !== false || elm.getAttribute(memberName) === "") {
          if (xlink) {
            elm.removeAttributeNS(XLINK_NS$1, memberName);
          } else {
            elm.removeAttribute(memberName);
          }
        }
      } else if ((!isProp || flags2 & 4 || isSvg) && !isComplex) {
        newValue = newValue === true ? "" : newValue;
        if (xlink) {
          elm.setAttributeNS(XLINK_NS$1, memberName, newValue);
        } else {
          elm.setAttribute(memberName, newValue);
        }
      }
    }
  }
};
const parseClassListRegex$1 = /\s/;
const parseClassList$1 = (value) => !value ? [] : value.split(parseClassListRegex$1);
const updateElement$1 = (oldVnode, newVnode, isSvgMode2, memberName) => {
  const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ$1;
  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ$1;
  {
    for (memberName in oldVnodeAttrs) {
      if (!(memberName in newVnodeAttrs)) {
        setAccessor$1(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
      }
    }
  }
  for (memberName in newVnodeAttrs) {
    setAccessor$1(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
  }
};
const createElm$1 = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
  const newVNode2 = newParentVNode.$children$[childIndex];
  let i = 0;
  let elm;
  let childNode;
  let oldVNode;
  if (!useNativeShadowDom$1) {
    checkSlotRelocate$1 = true;
    if (newVNode2.$tag$ === "slot") {
      if (scopeId$1) {
        parentElm.classList.add(scopeId$1 + "-s");
      }
      newVNode2.$flags$ |= newVNode2.$children$ ? (
        // slot element has fallback content
        2
      ) : (
        // slot element does not have fallback content
        1
      );
    }
  }
  if (newVNode2.$text$ !== null) {
    elm = newVNode2.$elm$ = doc$2.createTextNode(newVNode2.$text$);
  } else if (newVNode2.$flags$ & 1) {
    elm = newVNode2.$elm$ = doc$2.createTextNode("");
  } else {
    if (!isSvgMode$1) {
      isSvgMode$1 = newVNode2.$tag$ === "svg";
    }
    elm = newVNode2.$elm$ = doc$2.createElementNS(isSvgMode$1 ? SVG_NS$1 : HTML_NS$1, newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$);
    if (isSvgMode$1 && newVNode2.$tag$ === "foreignObject") {
      isSvgMode$1 = false;
    }
    {
      updateElement$1(null, newVNode2, isSvgMode$1);
    }
    if (isDef$1(scopeId$1) && elm["s-si"] !== scopeId$1) {
      elm.classList.add(elm["s-si"] = scopeId$1);
    }
    if (newVNode2.$children$) {
      for (i = 0; i < newVNode2.$children$.length; ++i) {
        childNode = createElm$1(oldParentVNode, newVNode2, i, elm);
        if (childNode) {
          elm.appendChild(childNode);
        }
      }
    }
    {
      if (newVNode2.$tag$ === "svg") {
        isSvgMode$1 = false;
      } else if (elm.tagName === "foreignObject") {
        isSvgMode$1 = true;
      }
    }
  }
  {
    elm["s-hn"] = hostTagName$1;
    if (newVNode2.$flags$ & (2 | 1)) {
      elm["s-sr"] = true;
      elm["s-cr"] = contentRef$1;
      elm["s-sn"] = newVNode2.$name$ || "";
      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
        putBackInOriginalLocation$1(oldParentVNode.$elm$, false);
      }
    }
  }
  return elm;
};
const putBackInOriginalLocation$1 = (parentElm, recursive) => {
  plt$1.$flags$ |= 1;
  const oldSlotChildNodes = parentElm.childNodes;
  for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {
    const childNode = oldSlotChildNodes[i];
    if (childNode["s-hn"] !== hostTagName$1 && childNode["s-ol"]) {
      parentReferenceNode$1(childNode).insertBefore(childNode, referenceNode$1(childNode));
      childNode["s-ol"].remove();
      childNode["s-ol"] = void 0;
      checkSlotRelocate$1 = true;
    }
    if (recursive) {
      putBackInOriginalLocation$1(childNode, recursive);
    }
  }
  plt$1.$flags$ &= ~1;
};
const addVnodes$1 = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
  let containerElm = parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
  let childNode;
  if (containerElm.shadowRoot && containerElm.tagName === hostTagName$1) {
    containerElm = containerElm.shadowRoot;
  }
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnodes[startIdx]) {
      childNode = createElm$1(null, parentVNode, startIdx, parentElm);
      if (childNode) {
        vnodes[startIdx].$elm$ = childNode;
        containerElm.insertBefore(childNode, referenceNode$1(before));
      }
    }
  }
};
const removeVnodes$1 = (vnodes, startIdx, endIdx) => {
  for (let index3 = startIdx; index3 <= endIdx; ++index3) {
    const vnode = vnodes[index3];
    if (vnode) {
      const elm = vnode.$elm$;
      nullifyVNodeRefs(vnode);
      if (elm) {
        {
          checkSlotFallbackVisibility$1 = true;
          if (elm["s-ol"]) {
            elm["s-ol"].remove();
          } else {
            putBackInOriginalLocation$1(elm, true);
          }
        }
        elm.remove();
      }
    }
  }
};
const updateChildren$1 = (parentElm, oldCh, newVNode2, newCh) => {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let idxInOld = 0;
  let i = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let node;
  let elmToMove;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode$1(oldStartVnode, newStartVnode)) {
      patch$1(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (isSameVnode$1(oldEndVnode, newEndVnode)) {
      patch$1(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode$1(oldStartVnode, newEndVnode)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation$1(oldStartVnode.$elm$.parentNode, false);
      }
      patch$1(oldStartVnode, newEndVnode);
      parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode$1(oldEndVnode, newStartVnode)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation$1(oldEndVnode.$elm$.parentNode, false);
      }
      patch$1(oldEndVnode, newStartVnode);
      parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      idxInOld = -1;
      {
        for (i = oldStartIdx; i <= oldEndIdx; ++i) {
          if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
            idxInOld = i;
            break;
          }
        }
      }
      if (idxInOld >= 0) {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.$tag$ !== newStartVnode.$tag$) {
          node = createElm$1(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);
        } else {
          patch$1(elmToMove, newStartVnode);
          oldCh[idxInOld] = void 0;
          node = elmToMove.$elm$;
        }
        newStartVnode = newCh[++newStartIdx];
      } else {
        node = createElm$1(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);
        newStartVnode = newCh[++newStartIdx];
      }
      if (node) {
        {
          parentReferenceNode$1(oldStartVnode.$elm$).insertBefore(node, referenceNode$1(oldStartVnode.$elm$));
        }
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    addVnodes$1(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);
  } else if (newStartIdx > newEndIdx) {
    removeVnodes$1(oldCh, oldStartIdx, oldEndIdx);
  }
};
const isSameVnode$1 = (leftVNode, rightVNode) => {
  if (leftVNode.$tag$ === rightVNode.$tag$) {
    if (leftVNode.$tag$ === "slot") {
      return leftVNode.$name$ === rightVNode.$name$;
    }
    {
      return leftVNode.$key$ === rightVNode.$key$;
    }
  }
  return false;
};
const referenceNode$1 = (node) => {
  return node && node["s-ol"] || node;
};
const parentReferenceNode$1 = (node) => (node["s-ol"] ? node["s-ol"] : node).parentNode;
const patch$1 = (oldVNode, newVNode2) => {
  const elm = newVNode2.$elm$ = oldVNode.$elm$;
  const oldChildren = oldVNode.$children$;
  const newChildren = newVNode2.$children$;
  const tag = newVNode2.$tag$;
  const text = newVNode2.$text$;
  let defaultHolder;
  if (text === null) {
    {
      isSvgMode$1 = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode$1;
    }
    {
      if (tag === "slot")
        ;
      else {
        updateElement$1(oldVNode, newVNode2, isSvgMode$1);
      }
    }
    if (oldChildren !== null && newChildren !== null) {
      updateChildren$1(elm, oldChildren, newVNode2, newChildren);
    } else if (newChildren !== null) {
      if (oldVNode.$text$ !== null) {
        elm.textContent = "";
      }
      addVnodes$1(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
    } else if (oldChildren !== null) {
      removeVnodes$1(oldChildren, 0, oldChildren.length - 1);
    }
    if (isSvgMode$1 && tag === "svg") {
      isSvgMode$1 = false;
    }
  } else if (defaultHolder = elm["s-cr"]) {
    defaultHolder.parentNode.textContent = text;
  } else if (oldVNode.$text$ !== text) {
    elm.data = text;
  }
};
const updateFallbackSlotVisibility$1 = (elm) => {
  const childNodes = elm.childNodes;
  let childNode;
  let i;
  let ilen;
  let j2;
  let slotNameAttr;
  let nodeType;
  for (i = 0, ilen = childNodes.length; i < ilen; i++) {
    childNode = childNodes[i];
    if (childNode.nodeType === 1) {
      if (childNode["s-sr"]) {
        slotNameAttr = childNode["s-sn"];
        childNode.hidden = false;
        for (j2 = 0; j2 < ilen; j2++) {
          nodeType = childNodes[j2].nodeType;
          if (childNodes[j2]["s-hn"] !== childNode["s-hn"] || slotNameAttr !== "") {
            if (nodeType === 1 && slotNameAttr === childNodes[j2].getAttribute("slot")) {
              childNode.hidden = true;
              break;
            }
          } else {
            if (nodeType === 1 || nodeType === 3 && childNodes[j2].textContent.trim() !== "") {
              childNode.hidden = true;
              break;
            }
          }
        }
      }
      updateFallbackSlotVisibility$1(childNode);
    }
  }
};
const relocateNodes$1 = [];
const relocateSlotContent$1 = (elm) => {
  let childNode;
  let node;
  let hostContentNodes;
  let slotNameAttr;
  let relocateNodeData;
  let j2;
  let i = 0;
  const childNodes = elm.childNodes;
  const ilen = childNodes.length;
  for (; i < ilen; i++) {
    childNode = childNodes[i];
    if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
      hostContentNodes = node.parentNode.childNodes;
      slotNameAttr = childNode["s-sn"];
      for (j2 = hostContentNodes.length - 1; j2 >= 0; j2--) {
        node = hostContentNodes[j2];
        if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"]) {
          if (isNodeLocatedInSlot$1(node, slotNameAttr)) {
            relocateNodeData = relocateNodes$1.find((r2) => r2.$nodeToRelocate$ === node);
            checkSlotFallbackVisibility$1 = true;
            node["s-sn"] = node["s-sn"] || slotNameAttr;
            if (relocateNodeData) {
              relocateNodeData.$slotRefNode$ = childNode;
            } else {
              relocateNodes$1.push({
                $slotRefNode$: childNode,
                $nodeToRelocate$: node
              });
            }
            if (node["s-sr"]) {
              relocateNodes$1.map((relocateNode) => {
                if (isNodeLocatedInSlot$1(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                  relocateNodeData = relocateNodes$1.find((r2) => r2.$nodeToRelocate$ === node);
                  if (relocateNodeData && !relocateNode.$slotRefNode$) {
                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                  }
                }
              });
            }
          } else if (!relocateNodes$1.some((r2) => r2.$nodeToRelocate$ === node)) {
            relocateNodes$1.push({
              $nodeToRelocate$: node
            });
          }
        }
      }
    }
    if (childNode.nodeType === 1) {
      relocateSlotContent$1(childNode);
    }
  }
};
const isNodeLocatedInSlot$1 = (nodeToRelocate, slotNameAttr) => {
  if (nodeToRelocate.nodeType === 1) {
    if (nodeToRelocate.getAttribute("slot") === null && slotNameAttr === "") {
      return true;
    }
    if (nodeToRelocate.getAttribute("slot") === slotNameAttr) {
      return true;
    }
    return false;
  }
  if (nodeToRelocate["s-sn"] === slotNameAttr) {
    return true;
  }
  return slotNameAttr === "";
};
const nullifyVNodeRefs = (vNode) => {
  {
    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
  }
};
const renderVdom$1 = (hostRef, renderFnResults) => {
  const hostElm = hostRef.$hostElement$;
  const cmpMeta = hostRef.$cmpMeta$;
  const oldVNode = hostRef.$vnode$ || newVNode$1(null, null);
  const rootVnode = isHost$1(renderFnResults) ? renderFnResults : h$5(null, null, renderFnResults);
  hostTagName$1 = hostElm.tagName;
  if (cmpMeta.$attrsToReflect$) {
    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
    cmpMeta.$attrsToReflect$.map(([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]);
  }
  rootVnode.$tag$ = null;
  rootVnode.$flags$ |= 4;
  hostRef.$vnode$ = rootVnode;
  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
  {
    scopeId$1 = hostElm["s-sc"];
  }
  {
    contentRef$1 = hostElm["s-cr"];
    useNativeShadowDom$1 = (cmpMeta.$flags$ & 1) !== 0;
    checkSlotFallbackVisibility$1 = false;
  }
  patch$1(oldVNode, rootVnode);
  {
    plt$1.$flags$ |= 1;
    if (checkSlotRelocate$1) {
      relocateSlotContent$1(rootVnode.$elm$);
      let relocateData;
      let nodeToRelocate;
      let orgLocationNode;
      let parentNodeRef;
      let insertBeforeNode;
      let refNode;
      let i = 0;
      for (; i < relocateNodes$1.length; i++) {
        relocateData = relocateNodes$1[i];
        nodeToRelocate = relocateData.$nodeToRelocate$;
        if (!nodeToRelocate["s-ol"]) {
          orgLocationNode = doc$2.createTextNode("");
          orgLocationNode["s-nr"] = nodeToRelocate;
          nodeToRelocate.parentNode.insertBefore(nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
        }
      }
      for (i = 0; i < relocateNodes$1.length; i++) {
        relocateData = relocateNodes$1[i];
        nodeToRelocate = relocateData.$nodeToRelocate$;
        if (relocateData.$slotRefNode$) {
          parentNodeRef = relocateData.$slotRefNode$.parentNode;
          insertBeforeNode = relocateData.$slotRefNode$.nextSibling;
          orgLocationNode = nodeToRelocate["s-ol"];
          while (orgLocationNode = orgLocationNode.previousSibling) {
            refNode = orgLocationNode["s-nr"];
            if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === refNode.parentNode) {
              refNode = refNode.nextSibling;
              if (!refNode || !refNode["s-nr"]) {
                insertBeforeNode = refNode;
                break;
              }
            }
          }
          if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
            if (nodeToRelocate !== insertBeforeNode) {
              if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
              }
              parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
            }
          }
        } else {
          if (nodeToRelocate.nodeType === 1) {
            nodeToRelocate.hidden = true;
          }
        }
      }
    }
    if (checkSlotFallbackVisibility$1) {
      updateFallbackSlotVisibility$1(rootVnode.$elm$);
    }
    plt$1.$flags$ &= ~1;
    relocateNodes$1.length = 0;
  }
};
const attachToAncestor$1 = (hostRef, ancestorComponent) => {
};
const scheduleUpdate$1 = (hostRef, isInitialLoad) => {
  {
    hostRef.$flags$ |= 16;
  }
  attachToAncestor$1(hostRef, hostRef.$ancestorComponent$);
  const dispatch = () => dispatchHooks$1(hostRef, isInitialLoad);
  return writeTask$1(dispatch);
};
const dispatchHooks$1 = (hostRef, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endSchedule = createTime$1("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
  const instance = elm;
  let maybePromise;
  if (isInitialLoad) {
    {
      maybePromise = safeCall$2(instance, "componentWillLoad");
    }
  } else {
    {
      maybePromise = safeCall$2(instance, "componentWillUpdate");
    }
  }
  {
    maybePromise = enqueue(maybePromise, () => safeCall$2(instance, "componentWillRender"));
  }
  endSchedule();
  return enqueue(maybePromise, () => updateComponent$1(hostRef, instance, isInitialLoad));
};
const enqueue = (maybePromise, fn2) => maybePromise instanceof Promise ? maybePromise.then(fn2) : fn2();
const updateComponent$1 = async (hostRef, instance, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endUpdate = createTime$1("update", hostRef.$cmpMeta$.$tagName$);
  elm["s-rc"];
  if (isInitialLoad) {
    attachStyles$1(hostRef);
  }
  const endRender = createTime$1("render", hostRef.$cmpMeta$.$tagName$);
  {
    callRender$1(hostRef, instance, elm);
  }
  endRender();
  endUpdate();
  {
    postUpdateComponent$1(hostRef);
  }
};
const callRender$1 = (hostRef, instance, elm) => {
  const allRenderFn = false;
  const lazyLoad = false;
  const taskQueue = true;
  const updatable = true;
  try {
    renderingRef$1 = instance;
    instance = allRenderFn ? instance.render() : instance.render && instance.render();
    if (updatable && taskQueue) {
      hostRef.$flags$ &= ~16;
    }
    if (updatable || lazyLoad) {
      hostRef.$flags$ |= 2;
    }
    if (BUILD$1.hasRenderFn || BUILD$1.reflect) {
      if (BUILD$1.vdomRender || BUILD$1.reflect) {
        if (BUILD$1.hydrateServerSide)
          ;
        else {
          renderVdom$1(hostRef, instance);
        }
      }
    }
  } catch (e3) {
    consoleError$1(e3, hostRef.$hostElement$);
  }
  renderingRef$1 = null;
  return null;
};
const postUpdateComponent$1 = (hostRef) => {
  const tagName = hostRef.$cmpMeta$.$tagName$;
  const elm = hostRef.$hostElement$;
  const endPostUpdate = createTime$1("postUpdate", tagName);
  const instance = elm;
  hostRef.$ancestorComponent$;
  {
    safeCall$2(instance, "componentDidRender");
  }
  if (!(hostRef.$flags$ & 64)) {
    hostRef.$flags$ |= 64;
    {
      safeCall$2(instance, "componentDidLoad");
    }
    endPostUpdate();
  } else {
    {
      safeCall$2(instance, "componentDidUpdate");
    }
    endPostUpdate();
  }
};
const forceUpdate = (ref) => {
  {
    const hostRef = getHostRef$1(ref);
    const isConnected = hostRef.$hostElement$.isConnected;
    if (isConnected && (hostRef.$flags$ & (2 | 16)) === 2) {
      scheduleUpdate$1(hostRef, false);
    }
    return isConnected;
  }
};
const safeCall$2 = (instance, method, arg) => {
  if (instance && instance[method]) {
    try {
      return instance[method](arg);
    } catch (e3) {
      consoleError$1(e3);
    }
  }
  return void 0;
};
const getValue$3 = (ref, propName) => getHostRef$1(ref).$instanceValues$.get(propName);
const setValue$1 = (ref, propName, newVal, cmpMeta) => {
  const hostRef = getHostRef$1(ref);
  const elm = ref;
  const oldVal = hostRef.$instanceValues$.get(propName);
  const flags2 = hostRef.$flags$;
  const instance = elm;
  newVal = parsePropertyValue$1(newVal, cmpMeta.$members$[propName][0]);
  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
  const didValueChange = newVal !== oldVal && !areBothNaN;
  if (didValueChange) {
    hostRef.$instanceValues$.set(propName, newVal);
    {
      if (cmpMeta.$watchers$ && flags2 & 128) {
        const watchMethods = cmpMeta.$watchers$[propName];
        if (watchMethods) {
          watchMethods.map((watchMethodName) => {
            try {
              instance[watchMethodName](newVal, oldVal, propName);
            } catch (e3) {
              consoleError$1(e3, elm);
            }
          });
        }
      }
      if ((flags2 & (2 | 16)) === 2) {
        if (instance.componentShouldUpdate) {
          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
            return;
          }
        }
        scheduleUpdate$1(hostRef, false);
      }
    }
  }
};
const proxyComponent$1 = (Cstr, cmpMeta, flags2) => {
  if (cmpMeta.$members$) {
    if (Cstr.watchers) {
      cmpMeta.$watchers$ = Cstr.watchers;
    }
    const members = Object.entries(cmpMeta.$members$);
    const prototype2 = Cstr.prototype;
    members.map(([memberName, [memberFlags]]) => {
      if (memberFlags & 31 || memberFlags & 32) {
        Object.defineProperty(prototype2, memberName, {
          get() {
            return getValue$3(this, memberName);
          },
          set(newValue) {
            setValue$1(this, memberName, newValue, cmpMeta);
          },
          configurable: true,
          enumerable: true
        });
      }
    });
    {
      const attrNameToPropName = /* @__PURE__ */ new Map();
      prototype2.attributeChangedCallback = function(attrName, _oldValue, newValue) {
        plt$1.jmp(() => {
          const propName = attrNameToPropName.get(attrName);
          if (this.hasOwnProperty(propName)) {
            newValue = this[propName];
            delete this[propName];
          } else if (prototype2.hasOwnProperty(propName) && typeof this[propName] === "number" && this[propName] == newValue) {
            return;
          }
          this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
        });
      };
      Cstr.observedAttributes = members.filter(
        ([_2, m2]) => m2[0] & 15
        /* MEMBER_FLAGS.HasAttribute */
      ).map(([propName, m2]) => {
        const attrName = m2[1] || propName;
        attrNameToPropName.set(attrName, propName);
        if (m2[0] & 512) {
          cmpMeta.$attrsToReflect$.push([propName, attrName]);
        }
        return attrName;
      });
    }
  }
  return Cstr;
};
const initializeComponent$1 = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
  if ((hostRef.$flags$ & 32) === 0) {
    hostRef.$flags$ |= 32;
    {
      Cstr = elm.constructor;
      customElements.whenDefined(cmpMeta.$tagName$).then(() => hostRef.$flags$ |= 128);
    }
    if (Cstr.style) {
      let style = Cstr.style;
      if (typeof style !== "string") {
        style = style[hostRef.$modeName$ = computeMode$1(elm)];
      }
      const scopeId2 = getScopeId$1(cmpMeta, hostRef.$modeName$);
      if (!styles$1.has(scopeId2)) {
        const endRegisterStyles = createTime$1("registerStyles", cmpMeta.$tagName$);
        registerStyle$1(scopeId2, style, !!(cmpMeta.$flags$ & 1));
        endRegisterStyles();
      }
    }
  }
  hostRef.$ancestorComponent$;
  const schedule = () => scheduleUpdate$1(hostRef, true);
  {
    schedule();
  }
};
const fireConnectedCallback$1 = (instance) => {
};
const connectedCallback$1 = (elm) => {
  if ((plt$1.$flags$ & 1) === 0) {
    const hostRef = getHostRef$1(elm);
    const cmpMeta = hostRef.$cmpMeta$;
    const endConnected = createTime$1("connectedCallback", cmpMeta.$tagName$);
    if (!(hostRef.$flags$ & 1)) {
      hostRef.$flags$ |= 1;
      {
        if (
          // TODO(STENCIL-662): Remove code related to deprecated shadowDomShim field
          cmpMeta.$flags$ & (4 | 8)
        ) {
          setContentReference$1(elm);
        }
      }
      if (cmpMeta.$members$) {
        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
            const value = elm[memberName];
            delete elm[memberName];
            elm[memberName] = value;
          }
        });
      }
      {
        initializeComponent$1(elm, hostRef, cmpMeta);
      }
    } else {
      addHostEventListeners$1(elm, hostRef, cmpMeta.$listeners$);
      fireConnectedCallback$1(hostRef.$lazyInstance$);
    }
    endConnected();
  }
};
const setContentReference$1 = (elm) => {
  const contentRefElm = elm["s-cr"] = doc$2.createComment("");
  contentRefElm["s-cn"] = true;
  elm.insertBefore(contentRefElm, elm.firstChild);
};
const disconnectedCallback$1 = (elm) => {
  if ((plt$1.$flags$ & 1) === 0) {
    const hostRef = getHostRef$1(elm);
    {
      if (hostRef.$rmListeners$) {
        hostRef.$rmListeners$.map((rmListener) => rmListener());
        hostRef.$rmListeners$ = void 0;
      }
    }
  }
};
const proxyCustomElement$1 = (Cstr, compactMeta) => {
  const cmpMeta = {
    $flags$: compactMeta[0],
    $tagName$: compactMeta[1]
  };
  {
    cmpMeta.$members$ = compactMeta[2];
  }
  {
    cmpMeta.$listeners$ = compactMeta[3];
  }
  {
    cmpMeta.$watchers$ = Cstr.$watchers$;
  }
  {
    cmpMeta.$attrsToReflect$ = [];
  }
  const originalConnectedCallback = Cstr.prototype.connectedCallback;
  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
  Object.assign(Cstr.prototype, {
    __registerHost() {
      registerHost$1(this, cmpMeta);
    },
    connectedCallback() {
      connectedCallback$1(this);
      if (originalConnectedCallback) {
        originalConnectedCallback.call(this);
      }
    },
    disconnectedCallback() {
      disconnectedCallback$1(this);
      if (originalDisconnectedCallback) {
        originalDisconnectedCallback.call(this);
      }
    },
    __attachShadow() {
      {
        {
          this.attachShadow({
            mode: "open",
            delegatesFocus: !!(cmpMeta.$flags$ & 16)
          });
        }
      }
    }
  });
  Cstr.is = cmpMeta.$tagName$;
  return proxyComponent$1(Cstr, cmpMeta);
};
const addHostEventListeners$1 = (elm, hostRef, listeners2, attachParentListeners) => {
  if (listeners2) {
    listeners2.map(([flags2, name, method]) => {
      const target = getHostListenerTarget$1(elm, flags2);
      const handler = hostListenerProxy$1(hostRef, method);
      const opts = hostListenerOpts$1(flags2);
      plt$1.ael(target, name, handler, opts);
      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt$1.rel(target, name, handler, opts));
    });
  }
};
const hostListenerProxy$1 = (hostRef, methodName) => (ev) => {
  try {
    if (BUILD$1.lazyLoad)
      ;
    else {
      hostRef.$hostElement$[methodName](ev);
    }
  } catch (e3) {
    consoleError$1(e3);
  }
};
const getHostListenerTarget$1 = (elm, flags2) => {
  if (flags2 & 4)
    return doc$2;
  if (flags2 & 8)
    return win$3;
  if (flags2 & 16)
    return doc$2.body;
  return elm;
};
const hostListenerOpts$1 = (flags2) => supportsListenerOptions$1 ? {
  passive: (flags2 & 1) !== 0,
  capture: (flags2 & 2) !== 0
} : (flags2 & 2) !== 0;
const hostRefs$1 = /* @__PURE__ */ new WeakMap();
const getHostRef$1 = (ref) => hostRefs$1.get(ref);
const registerHost$1 = (elm, cmpMeta) => {
  const hostRef = {
    $flags$: 0,
    $hostElement$: elm,
    $cmpMeta$: cmpMeta,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  addHostEventListeners$1(elm, hostRef, cmpMeta.$listeners$);
  return hostRefs$1.set(elm, hostRef);
};
const isMemberInElement$1 = (elm, memberName) => memberName in elm;
const consoleError$1 = (e3, el2) => (0, console.error)(e3, el2);
const styles$1 = /* @__PURE__ */ new Map();
const modeResolutionChain$1 = [];
const win$3 = typeof window !== "undefined" ? window : {};
const doc$2 = win$3.document || { head: {} };
const H$1 = win$3.HTMLElement || class {
};
const plt$1 = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (h2) => h2(),
  raf: (h2) => requestAnimationFrame(h2),
  ael: (el2, eventName, listener, opts) => el2.addEventListener(eventName, listener, opts),
  rel: (el2, eventName, listener, opts) => el2.removeEventListener(eventName, listener, opts),
  ce: (eventName, opts) => new CustomEvent(eventName, opts)
};
const setPlatformHelpers = (helpers) => {
  Object.assign(plt$1, helpers);
};
const supportsListenerOptions$1 = /* @__PURE__ */ (() => {
  let supportsListenerOptions2 = false;
  try {
    doc$2.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        supportsListenerOptions2 = true;
      }
    }));
  } catch (e3) {
  }
  return supportsListenerOptions2;
})();
const promiseResolve$1 = (v2) => Promise.resolve(v2);
const supportsConstructableStylesheets$1 = /* @__PURE__ */ (() => {
  try {
    new CSSStyleSheet();
    return typeof new CSSStyleSheet().replaceSync === "function";
  } catch (e3) {
  }
  return false;
})();
const queueDomReads$1 = [];
const queueDomWrites$1 = [];
const queueTask$1 = (queue2, write) => (cb2) => {
  queue2.push(cb2);
  if (!queuePending$1) {
    queuePending$1 = true;
    if (write && plt$1.$flags$ & 4) {
      nextTick$2(flush$2);
    } else {
      plt$1.raf(flush$2);
    }
  }
};
const consume$1 = (queue2) => {
  for (let i = 0; i < queue2.length; i++) {
    try {
      queue2[i](performance.now());
    } catch (e3) {
      consoleError$1(e3);
    }
  }
  queue2.length = 0;
};
const flush$2 = () => {
  consume$1(queueDomReads$1);
  {
    consume$1(queueDomWrites$1);
    if (queuePending$1 = queueDomReads$1.length > 0) {
      plt$1.raf(flush$2);
    }
  }
};
const nextTick$2 = (cb2) => promiseResolve$1().then(cb2);
const readTask = /* @__PURE__ */ queueTask$1(queueDomReads$1, false);
const writeTask$1 = /* @__PURE__ */ queueTask$1(queueDomWrites$1, true);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const win$2 = typeof window !== "undefined" ? window : void 0;
const doc$1 = typeof document !== "undefined" ? document : void 0;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const transitionEndAsync = (el2, expectedDuration = 0) => {
  return new Promise((resolve) => {
    transitionEnd$1(el2, expectedDuration, resolve);
  });
};
const transitionEnd$1 = (el2, expectedDuration = 0, callback) => {
  let unRegTrans;
  let animationTimeout;
  const opts = { passive: true };
  const ANIMATION_FALLBACK_TIMEOUT = 500;
  const unregister = () => {
    if (unRegTrans) {
      unRegTrans();
    }
  };
  const onTransitionEnd = (ev) => {
    if (ev === void 0 || el2 === ev.target) {
      unregister();
      callback(ev);
    }
  };
  if (el2) {
    el2.addEventListener("webkitTransitionEnd", onTransitionEnd, opts);
    el2.addEventListener("transitionend", onTransitionEnd, opts);
    animationTimeout = setTimeout(onTransitionEnd, expectedDuration + ANIMATION_FALLBACK_TIMEOUT);
    unRegTrans = () => {
      if (animationTimeout) {
        clearTimeout(animationTimeout);
        animationTimeout = void 0;
      }
      el2.removeEventListener("webkitTransitionEnd", onTransitionEnd, opts);
      el2.removeEventListener("transitionend", onTransitionEnd, opts);
    };
  }
  return unregister;
};
const componentOnReady = (el2, callback) => {
  if (el2.componentOnReady) {
    el2.componentOnReady().then((resolvedEl) => callback(resolvedEl));
  } else {
    raf(() => callback(el2));
  }
};
const hasLazyBuild = (stencilEl) => {
  return stencilEl.componentOnReady !== void 0;
};
const inheritAttributes$2 = (el2, attributes = []) => {
  const attributeObject = {};
  attributes.forEach((attr) => {
    if (el2.hasAttribute(attr)) {
      const value = el2.getAttribute(attr);
      if (value !== null) {
        attributeObject[attr] = el2.getAttribute(attr);
      }
      el2.removeAttribute(attr);
    }
  });
  return attributeObject;
};
const ariaAttributes = [
  "role",
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-braillelabel",
  "aria-brailleroledescription",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colindextext",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-description",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowindextext",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext"
];
const inheritAriaAttributes = (el2, ignoreList) => {
  let attributesToInherit = ariaAttributes;
  if (ignoreList && ignoreList.length > 0) {
    attributesToInherit = attributesToInherit.filter((attr) => !ignoreList.includes(attr));
  }
  return inheritAttributes$2(el2, attributesToInherit);
};
const addEventListener$1 = (el2, eventName, callback, opts) => {
  var _a2;
  if (typeof window !== "undefined") {
    const win2 = window;
    const config2 = (_a2 = win2 === null || win2 === void 0 ? void 0 : win2.Ionic) === null || _a2 === void 0 ? void 0 : _a2.config;
    if (config2) {
      const ael = config2.get("_ael");
      if (ael) {
        return ael(el2, eventName, callback, opts);
      } else if (config2._ael) {
        return config2._ael(el2, eventName, callback, opts);
      }
    }
  }
  return el2.addEventListener(eventName, callback, opts);
};
const removeEventListener = (el2, eventName, callback, opts) => {
  var _a2;
  if (typeof window !== "undefined") {
    const win2 = window;
    const config2 = (_a2 = win2 === null || win2 === void 0 ? void 0 : win2.Ionic) === null || _a2 === void 0 ? void 0 : _a2.config;
    if (config2) {
      const rel = config2.get("_rel");
      if (rel) {
        return rel(el2, eventName, callback, opts);
      } else if (config2._rel) {
        return config2._rel(el2, eventName, callback, opts);
      }
    }
  }
  return el2.removeEventListener(eventName, callback, opts);
};
const getElementRoot = (el2, fallback = el2) => {
  return el2.shadowRoot || fallback;
};
const raf = (h2) => {
  if (typeof __zone_symbol__requestAnimationFrame === "function") {
    return __zone_symbol__requestAnimationFrame(h2);
  }
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame(h2);
  }
  return setTimeout(h2);
};
const hasShadowDom = (el2) => {
  return !!el2.shadowRoot && !!el2.attachShadow;
};
const findItemLabel = (componentEl) => {
  const itemEl = componentEl.closest("ion-item");
  if (itemEl) {
    return itemEl.querySelector("ion-label");
  }
  return null;
};
const focusElement = (el2) => {
  el2.focus();
  if (el2.classList.contains("ion-focusable")) {
    const app = el2.closest("ion-app");
    if (app) {
      app.setFocus([el2]);
    }
  }
};
const getAriaLabel = (componentEl, inputId) => {
  let labelText;
  const labelledBy = componentEl.getAttribute("aria-labelledby");
  const componentId = componentEl.id;
  let labelId = labelledBy !== null && labelledBy.trim() !== "" ? labelledBy : inputId + "-lbl";
  let label = labelledBy !== null && labelledBy.trim() !== "" ? document.getElementById(labelledBy) : findItemLabel(componentEl);
  if (label) {
    if (labelledBy === null) {
      label.id = labelId;
    }
    labelText = label.textContent;
    label.setAttribute("aria-hidden", "true");
  } else if (componentId.trim() !== "") {
    label = document.querySelector(`label[for="${componentId}"]`);
    if (label) {
      if (label.id !== "") {
        labelId = label.id;
      } else {
        label.id = labelId = `${componentId}-lbl`;
      }
      labelText = label.textContent;
    }
  }
  return { label, labelId, labelText };
};
const renderHiddenInput = (always3, container, name, value, disabled) => {
  if (always3 || hasShadowDom(container)) {
    let input = container.querySelector("input.aux-input");
    if (!input) {
      input = container.ownerDocument.createElement("input");
      input.type = "hidden";
      input.classList.add("aux-input");
      container.appendChild(input);
    }
    input.disabled = disabled;
    input.name = name;
    input.value = value || "";
  }
};
const clamp$1 = (min3, n2, max3) => {
  return Math.max(min3, Math.min(n2, max3));
};
const assert$1 = (actual, reason) => {
  if (!actual) {
    const message = "ASSERT: " + reason;
    console.error(message);
    debugger;
    throw new Error(message);
  }
};
const now$5 = (ev) => {
  return ev.timeStamp || Date.now();
};
const pointerCoord = (ev) => {
  if (ev) {
    const changedTouches = ev.changedTouches;
    if (changedTouches && changedTouches.length > 0) {
      const touch = changedTouches[0];
      return { x: touch.clientX, y: touch.clientY };
    }
    if (ev.pageX !== void 0) {
      return { x: ev.pageX, y: ev.pageY };
    }
  }
  return { x: 0, y: 0 };
};
const isEndSide = (side) => {
  const isRTL2 = document.dir === "rtl";
  switch (side) {
    case "start":
      return isRTL2;
    case "end":
      return !isRTL2;
    default:
      throw new Error(`"${side}" is not a valid value for [side]. Use "start" or "end" instead.`);
  }
};
const debounceEvent = (event, wait) => {
  const original = event._original || event;
  return {
    _original: event,
    emit: debounce$3(original.emit.bind(original), wait)
  };
};
const debounce$3 = (func3, wait = 0) => {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(func3, wait, ...args);
  };
};
const shallowEqualStringMap = (map1, map22) => {
  map1 !== null && map1 !== void 0 ? map1 : map1 = {};
  map22 !== null && map22 !== void 0 ? map22 : map22 = {};
  if (map1 === map22) {
    return true;
  }
  const keys1 = Object.keys(map1);
  if (keys1.length !== Object.keys(map22).length) {
    return false;
  }
  for (const k1 of keys1) {
    if (!(k1 in map22)) {
      return false;
    }
    if (map1[k1] !== map22[k1]) {
      return false;
    }
  }
  return true;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
let animationPrefix;
const processKeyframes = (keyframes) => {
  keyframes.forEach((keyframe) => {
    for (const key in keyframe) {
      if (keyframe.hasOwnProperty(key)) {
        const value = keyframe[key];
        if (key === "easing") {
          const newKey = "animation-timing-function";
          keyframe[newKey] = value;
          delete keyframe[key];
        } else {
          const newKey = convertCamelCaseToHypen(key);
          if (newKey !== key) {
            keyframe[newKey] = value;
            delete keyframe[key];
          }
        }
      }
    }
  });
  return keyframes;
};
const convertCamelCaseToHypen = (str) => {
  return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
};
const getAnimationPrefix = (el2) => {
  if (animationPrefix === void 0) {
    const supportsUnprefixed = el2.style.animationName !== void 0;
    const supportsWebkitPrefix = el2.style.webkitAnimationName !== void 0;
    animationPrefix = !supportsUnprefixed && supportsWebkitPrefix ? "-webkit-" : "";
  }
  return animationPrefix;
};
const setStyleProperty = (element, propertyName, value) => {
  const prefix2 = propertyName.startsWith("animation") ? getAnimationPrefix(element) : "";
  element.style.setProperty(prefix2 + propertyName, value);
};
const removeStyleProperty = (element, propertyName) => {
  const prefix2 = propertyName.startsWith("animation") ? getAnimationPrefix(element) : "";
  element.style.removeProperty(prefix2 + propertyName);
};
const animationEnd = (el2, callback) => {
  let unRegTrans;
  const opts = { passive: true };
  const unregister = () => {
    if (unRegTrans) {
      unRegTrans();
    }
  };
  const onTransitionEnd = (ev) => {
    if (el2 === ev.target) {
      unregister();
      callback(ev);
    }
  };
  if (el2) {
    el2.addEventListener("webkitAnimationEnd", onTransitionEnd, opts);
    el2.addEventListener("animationend", onTransitionEnd, opts);
    unRegTrans = () => {
      el2.removeEventListener("webkitAnimationEnd", onTransitionEnd, opts);
      el2.removeEventListener("animationend", onTransitionEnd, opts);
    };
  }
  return unregister;
};
const generateKeyframeRules = (keyframes = []) => {
  return keyframes.map((keyframe) => {
    const offset2 = keyframe.offset;
    const frameString = [];
    for (const property2 in keyframe) {
      if (keyframe.hasOwnProperty(property2) && property2 !== "offset") {
        frameString.push(`${property2}: ${keyframe[property2]};`);
      }
    }
    return `${offset2 * 100}% { ${frameString.join(" ")} }`;
  }).join(" ");
};
const keyframeIds = [];
const generateKeyframeName = (keyframeRules) => {
  let index3 = keyframeIds.indexOf(keyframeRules);
  if (index3 < 0) {
    index3 = keyframeIds.push(keyframeRules) - 1;
  }
  return `ion-animation-${index3}`;
};
const getStyleContainer = (element) => {
  const rootNode = element.getRootNode !== void 0 ? element.getRootNode() : element;
  return rootNode.head || rootNode;
};
const createKeyframeStylesheet = (keyframeName, keyframeRules, element) => {
  var _a2;
  const styleContainer = getStyleContainer(element);
  const keyframePrefix = getAnimationPrefix(element);
  const existingStylesheet = styleContainer.querySelector("#" + keyframeName);
  if (existingStylesheet) {
    return existingStylesheet;
  }
  const stylesheet = ((_a2 = element.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document).createElement("style");
  stylesheet.id = keyframeName;
  stylesheet.textContent = `@${keyframePrefix}keyframes ${keyframeName} { ${keyframeRules} } @${keyframePrefix}keyframes ${keyframeName}-alt { ${keyframeRules} }`;
  styleContainer.appendChild(stylesheet);
  return stylesheet;
};
const addClassToArray = (classes2 = [], className) => {
  if (className !== void 0) {
    const classNameToAppend = Array.isArray(className) ? className : [className];
    return [...classes2, ...classNameToAppend];
  }
  return classes2;
};
const createAnimation = (animationId) => {
  let _delay;
  let _duration;
  let _easing;
  let _iterations;
  let _fill;
  let _direction;
  let _keyframes = [];
  let beforeAddClasses = [];
  let beforeRemoveClasses = [];
  let initialized = false;
  let parentAnimation;
  let beforeStylesValue = {};
  let afterAddClasses = [];
  let afterRemoveClasses = [];
  let afterStylesValue = {};
  let numAnimationsRunning = 0;
  let shouldForceLinearEasing = false;
  let shouldForceSyncPlayback = false;
  let cssAnimationsTimerFallback;
  let forceDirectionValue;
  let forceDurationValue;
  let forceDelayValue;
  let willComplete = true;
  let finished = false;
  let shouldCalculateNumAnimations = true;
  let keyframeName;
  let ani;
  let paused = false;
  const id2 = animationId;
  const onFinishCallbacks = [];
  const onFinishOneTimeCallbacks = [];
  const elements = [];
  const childAnimations = [];
  const stylesheets = [];
  const _beforeAddReadFunctions = [];
  const _beforeAddWriteFunctions = [];
  const _afterAddReadFunctions = [];
  const _afterAddWriteFunctions = [];
  const webAnimations = [];
  const supportsAnimationEffect = typeof AnimationEffect === "function" || win$2 !== void 0 && typeof win$2.AnimationEffect === "function";
  const supportsWebAnimations = typeof Element === "function" && typeof Element.prototype.animate === "function" && supportsAnimationEffect;
  const ANIMATION_END_FALLBACK_PADDING_MS = 100;
  const getWebAnimations = () => {
    return webAnimations;
  };
  const destroy = (clearStyleSheets) => {
    childAnimations.forEach((childAnimation) => {
      childAnimation.destroy(clearStyleSheets);
    });
    cleanUp(clearStyleSheets);
    elements.length = 0;
    childAnimations.length = 0;
    _keyframes.length = 0;
    clearOnFinish();
    initialized = false;
    shouldCalculateNumAnimations = true;
    return ani;
  };
  const cleanUp = (clearStyleSheets) => {
    cleanUpElements();
    if (clearStyleSheets) {
      cleanUpStyleSheets();
    }
  };
  const resetFlags = () => {
    shouldForceLinearEasing = false;
    shouldForceSyncPlayback = false;
    shouldCalculateNumAnimations = true;
    forceDirectionValue = void 0;
    forceDurationValue = void 0;
    forceDelayValue = void 0;
    numAnimationsRunning = 0;
    finished = false;
    willComplete = true;
    paused = false;
  };
  const isRunning = () => {
    return numAnimationsRunning !== 0 && !paused;
  };
  const onFinish = (callback, opts) => {
    const callbacks = (opts === null || opts === void 0 ? void 0 : opts.oneTimeCallback) ? onFinishOneTimeCallbacks : onFinishCallbacks;
    callbacks.push({ c: callback, o: opts });
    return ani;
  };
  const clearOnFinish = () => {
    onFinishCallbacks.length = 0;
    onFinishOneTimeCallbacks.length = 0;
    return ani;
  };
  const cleanUpElements = () => {
    if (supportsWebAnimations) {
      webAnimations.forEach((animation2) => {
        animation2.cancel();
      });
      webAnimations.length = 0;
    } else {
      const elementsArray = elements.slice();
      raf(() => {
        elementsArray.forEach((element) => {
          removeStyleProperty(element, "animation-name");
          removeStyleProperty(element, "animation-duration");
          removeStyleProperty(element, "animation-timing-function");
          removeStyleProperty(element, "animation-iteration-count");
          removeStyleProperty(element, "animation-delay");
          removeStyleProperty(element, "animation-play-state");
          removeStyleProperty(element, "animation-fill-mode");
          removeStyleProperty(element, "animation-direction");
        });
      });
    }
  };
  const cleanUpStyleSheets = () => {
    stylesheets.forEach((stylesheet) => {
      if (stylesheet === null || stylesheet === void 0 ? void 0 : stylesheet.parentNode) {
        stylesheet.parentNode.removeChild(stylesheet);
      }
    });
    stylesheets.length = 0;
  };
  const beforeAddRead = (readFn) => {
    _beforeAddReadFunctions.push(readFn);
    return ani;
  };
  const beforeAddWrite = (writeFn) => {
    _beforeAddWriteFunctions.push(writeFn);
    return ani;
  };
  const afterAddRead = (readFn) => {
    _afterAddReadFunctions.push(readFn);
    return ani;
  };
  const afterAddWrite = (writeFn) => {
    _afterAddWriteFunctions.push(writeFn);
    return ani;
  };
  const beforeAddClass = (className) => {
    beforeAddClasses = addClassToArray(beforeAddClasses, className);
    return ani;
  };
  const beforeRemoveClass = (className) => {
    beforeRemoveClasses = addClassToArray(beforeRemoveClasses, className);
    return ani;
  };
  const beforeStyles = (styles2 = {}) => {
    beforeStylesValue = styles2;
    return ani;
  };
  const beforeClearStyles = (propertyNames = []) => {
    for (const property2 of propertyNames) {
      beforeStylesValue[property2] = "";
    }
    return ani;
  };
  const afterAddClass = (className) => {
    afterAddClasses = addClassToArray(afterAddClasses, className);
    return ani;
  };
  const afterRemoveClass = (className) => {
    afterRemoveClasses = addClassToArray(afterRemoveClasses, className);
    return ani;
  };
  const afterStyles = (styles2 = {}) => {
    afterStylesValue = styles2;
    return ani;
  };
  const afterClearStyles = (propertyNames = []) => {
    for (const property2 of propertyNames) {
      afterStylesValue[property2] = "";
    }
    return ani;
  };
  const getFill = () => {
    if (_fill !== void 0) {
      return _fill;
    }
    if (parentAnimation) {
      return parentAnimation.getFill();
    }
    return "both";
  };
  const getDirection = () => {
    if (forceDirectionValue !== void 0) {
      return forceDirectionValue;
    }
    if (_direction !== void 0) {
      return _direction;
    }
    if (parentAnimation) {
      return parentAnimation.getDirection();
    }
    return "normal";
  };
  const getEasing = () => {
    if (shouldForceLinearEasing) {
      return "linear";
    }
    if (_easing !== void 0) {
      return _easing;
    }
    if (parentAnimation) {
      return parentAnimation.getEasing();
    }
    return "linear";
  };
  const getDuration = () => {
    if (shouldForceSyncPlayback) {
      return 0;
    }
    if (forceDurationValue !== void 0) {
      return forceDurationValue;
    }
    if (_duration !== void 0) {
      return _duration;
    }
    if (parentAnimation) {
      return parentAnimation.getDuration();
    }
    return 0;
  };
  const getIterations = () => {
    if (_iterations !== void 0) {
      return _iterations;
    }
    if (parentAnimation) {
      return parentAnimation.getIterations();
    }
    return 1;
  };
  const getDelay = () => {
    if (forceDelayValue !== void 0) {
      return forceDelayValue;
    }
    if (_delay !== void 0) {
      return _delay;
    }
    if (parentAnimation) {
      return parentAnimation.getDelay();
    }
    return 0;
  };
  const getKeyframes = () => {
    return _keyframes;
  };
  const direction = (animationDirection) => {
    _direction = animationDirection;
    update3(true);
    return ani;
  };
  const fill = (animationFill) => {
    _fill = animationFill;
    update3(true);
    return ani;
  };
  const delay2 = (animationDelay) => {
    _delay = animationDelay;
    update3(true);
    return ani;
  };
  const easing = (animationEasing) => {
    _easing = animationEasing;
    update3(true);
    return ani;
  };
  const duration = (animationDuration) => {
    if (!supportsWebAnimations && animationDuration === 0) {
      animationDuration = 1;
    }
    _duration = animationDuration;
    update3(true);
    return ani;
  };
  const iterations = (animationIterations) => {
    _iterations = animationIterations;
    update3(true);
    return ani;
  };
  const parent = (animation2) => {
    parentAnimation = animation2;
    return ani;
  };
  const addElement = (el2) => {
    if (el2 != null) {
      if (el2.nodeType === 1) {
        elements.push(el2);
      } else if (el2.length >= 0) {
        for (let i = 0; i < el2.length; i++) {
          elements.push(el2[i]);
        }
      } else {
        console.error("Invalid addElement value");
      }
    }
    return ani;
  };
  const addAnimation = (animationToAdd) => {
    if (animationToAdd != null) {
      if (Array.isArray(animationToAdd)) {
        for (const animation2 of animationToAdd) {
          animation2.parent(ani);
          childAnimations.push(animation2);
        }
      } else {
        animationToAdd.parent(ani);
        childAnimations.push(animationToAdd);
      }
    }
    return ani;
  };
  const keyframes = (keyframeValues) => {
    const different = _keyframes !== keyframeValues;
    _keyframes = keyframeValues;
    if (different) {
      updateKeyframes(_keyframes);
    }
    return ani;
  };
  const updateKeyframes = (keyframeValues) => {
    if (supportsWebAnimations) {
      getWebAnimations().forEach((animation2) => {
        if (animation2.effect.setKeyframes) {
          animation2.effect.setKeyframes(keyframeValues);
        } else {
          const newEffect = new KeyframeEffect(animation2.effect.target, keyframeValues, animation2.effect.getTiming());
          animation2.effect = newEffect;
        }
      });
    } else {
      initializeCSSAnimation();
    }
  };
  const beforeAnimation = () => {
    _beforeAddReadFunctions.forEach((callback) => callback());
    _beforeAddWriteFunctions.forEach((callback) => callback());
    const addClasses2 = beforeAddClasses;
    const removeClasses2 = beforeRemoveClasses;
    const styles2 = beforeStylesValue;
    elements.forEach((el2) => {
      const elementClassList = el2.classList;
      addClasses2.forEach((c2) => elementClassList.add(c2));
      removeClasses2.forEach((c2) => elementClassList.remove(c2));
      for (const property2 in styles2) {
        if (styles2.hasOwnProperty(property2)) {
          setStyleProperty(el2, property2, styles2[property2]);
        }
      }
    });
  };
  const afterAnimation = () => {
    clearCSSAnimationsTimeout();
    _afterAddReadFunctions.forEach((callback) => callback());
    _afterAddWriteFunctions.forEach((callback) => callback());
    const currentStep = willComplete ? 1 : 0;
    const addClasses2 = afterAddClasses;
    const removeClasses2 = afterRemoveClasses;
    const styles2 = afterStylesValue;
    elements.forEach((el2) => {
      const elementClassList = el2.classList;
      addClasses2.forEach((c2) => elementClassList.add(c2));
      removeClasses2.forEach((c2) => elementClassList.remove(c2));
      for (const property2 in styles2) {
        if (styles2.hasOwnProperty(property2)) {
          setStyleProperty(el2, property2, styles2[property2]);
        }
      }
    });
    onFinishCallbacks.forEach((onFinishCallback) => {
      return onFinishCallback.c(currentStep, ani);
    });
    onFinishOneTimeCallbacks.forEach((onFinishCallback) => {
      return onFinishCallback.c(currentStep, ani);
    });
    onFinishOneTimeCallbacks.length = 0;
    shouldCalculateNumAnimations = true;
    if (willComplete) {
      finished = true;
    }
    willComplete = true;
  };
  const animationFinish = () => {
    if (numAnimationsRunning === 0) {
      return;
    }
    numAnimationsRunning--;
    if (numAnimationsRunning === 0) {
      afterAnimation();
      if (parentAnimation) {
        parentAnimation.animationFinish();
      }
    }
  };
  const initializeCSSAnimation = (toggleAnimationName = true) => {
    cleanUpStyleSheets();
    const processedKeyframes = processKeyframes(_keyframes);
    elements.forEach((element) => {
      if (processedKeyframes.length > 0) {
        const keyframeRules = generateKeyframeRules(processedKeyframes);
        keyframeName = animationId !== void 0 ? animationId : generateKeyframeName(keyframeRules);
        const stylesheet = createKeyframeStylesheet(keyframeName, keyframeRules, element);
        stylesheets.push(stylesheet);
        setStyleProperty(element, "animation-duration", `${getDuration()}ms`);
        setStyleProperty(element, "animation-timing-function", getEasing());
        setStyleProperty(element, "animation-delay", `${getDelay()}ms`);
        setStyleProperty(element, "animation-fill-mode", getFill());
        setStyleProperty(element, "animation-direction", getDirection());
        const iterationsCount = getIterations() === Infinity ? "infinite" : getIterations().toString();
        setStyleProperty(element, "animation-iteration-count", iterationsCount);
        setStyleProperty(element, "animation-play-state", "paused");
        if (toggleAnimationName) {
          setStyleProperty(element, "animation-name", `${stylesheet.id}-alt`);
        }
        raf(() => {
          setStyleProperty(element, "animation-name", stylesheet.id || null);
        });
      }
    });
  };
  const initializeWebAnimation = () => {
    elements.forEach((element) => {
      const animation2 = element.animate(_keyframes, {
        id: id2,
        delay: getDelay(),
        duration: getDuration(),
        easing: getEasing(),
        iterations: getIterations(),
        fill: getFill(),
        direction: getDirection()
      });
      animation2.pause();
      webAnimations.push(animation2);
    });
    if (webAnimations.length > 0) {
      webAnimations[0].onfinish = () => {
        animationFinish();
      };
    }
  };
  const initializeAnimation = (toggleAnimationName = true) => {
    beforeAnimation();
    if (_keyframes.length > 0) {
      if (supportsWebAnimations) {
        initializeWebAnimation();
      } else {
        initializeCSSAnimation(toggleAnimationName);
      }
    }
    initialized = true;
  };
  const setAnimationStep = (step) => {
    step = Math.min(Math.max(step, 0), 0.9999);
    if (supportsWebAnimations) {
      webAnimations.forEach((animation2) => {
        animation2.currentTime = animation2.effect.getComputedTiming().delay + getDuration() * step;
        animation2.pause();
      });
    } else {
      const animationDuration = `-${getDuration() * step}ms`;
      elements.forEach((element) => {
        if (_keyframes.length > 0) {
          setStyleProperty(element, "animation-delay", animationDuration);
          setStyleProperty(element, "animation-play-state", "paused");
        }
      });
    }
  };
  const updateWebAnimation = (step) => {
    webAnimations.forEach((animation2) => {
      animation2.effect.updateTiming({
        delay: getDelay(),
        duration: getDuration(),
        easing: getEasing(),
        iterations: getIterations(),
        fill: getFill(),
        direction: getDirection()
      });
    });
    if (step !== void 0) {
      setAnimationStep(step);
    }
  };
  const updateCSSAnimation = (toggleAnimationName = true, step) => {
    raf(() => {
      elements.forEach((element) => {
        setStyleProperty(element, "animation-name", keyframeName || null);
        setStyleProperty(element, "animation-duration", `${getDuration()}ms`);
        setStyleProperty(element, "animation-timing-function", getEasing());
        setStyleProperty(element, "animation-delay", step !== void 0 ? `-${step * getDuration()}ms` : `${getDelay()}ms`);
        setStyleProperty(element, "animation-fill-mode", getFill() || null);
        setStyleProperty(element, "animation-direction", getDirection() || null);
        const iterationsCount = getIterations() === Infinity ? "infinite" : getIterations().toString();
        setStyleProperty(element, "animation-iteration-count", iterationsCount);
        if (toggleAnimationName) {
          setStyleProperty(element, "animation-name", `${keyframeName}-alt`);
        }
        raf(() => {
          setStyleProperty(element, "animation-name", keyframeName || null);
        });
      });
    });
  };
  const update3 = (deep = false, toggleAnimationName = true, step) => {
    if (deep) {
      childAnimations.forEach((animation2) => {
        animation2.update(deep, toggleAnimationName, step);
      });
    }
    if (supportsWebAnimations) {
      updateWebAnimation(step);
    } else {
      updateCSSAnimation(toggleAnimationName, step);
    }
    return ani;
  };
  const progressStart = (forceLinearEasing = false, step) => {
    childAnimations.forEach((animation2) => {
      animation2.progressStart(forceLinearEasing, step);
    });
    pauseAnimation();
    shouldForceLinearEasing = forceLinearEasing;
    if (!initialized) {
      initializeAnimation();
    }
    update3(false, true, step);
    return ani;
  };
  const progressStep = (step) => {
    childAnimations.forEach((animation2) => {
      animation2.progressStep(step);
    });
    setAnimationStep(step);
    return ani;
  };
  const progressEnd = (playTo, step, dur) => {
    shouldForceLinearEasing = false;
    childAnimations.forEach((animation2) => {
      animation2.progressEnd(playTo, step, dur);
    });
    if (dur !== void 0) {
      forceDurationValue = dur;
    }
    finished = false;
    willComplete = true;
    if (playTo === 0) {
      forceDirectionValue = getDirection() === "reverse" ? "normal" : "reverse";
      if (forceDirectionValue === "reverse") {
        willComplete = false;
      }
      if (supportsWebAnimations) {
        update3();
        setAnimationStep(1 - step);
      } else {
        forceDelayValue = (1 - step) * getDuration() * -1;
        update3(false, false);
      }
    } else if (playTo === 1) {
      if (supportsWebAnimations) {
        update3();
        setAnimationStep(step);
      } else {
        forceDelayValue = step * getDuration() * -1;
        update3(false, false);
      }
    }
    if (playTo !== void 0) {
      onFinish(() => {
        forceDurationValue = void 0;
        forceDirectionValue = void 0;
        forceDelayValue = void 0;
      }, {
        oneTimeCallback: true
      });
      if (!parentAnimation) {
        play();
      }
    }
    return ani;
  };
  const pauseAnimation = () => {
    if (initialized) {
      if (supportsWebAnimations) {
        webAnimations.forEach((animation2) => {
          animation2.pause();
        });
      } else {
        elements.forEach((element) => {
          setStyleProperty(element, "animation-play-state", "paused");
        });
      }
      paused = true;
    }
  };
  const pause = () => {
    childAnimations.forEach((animation2) => {
      animation2.pause();
    });
    pauseAnimation();
    return ani;
  };
  const onAnimationEndFallback = () => {
    cssAnimationsTimerFallback = void 0;
    animationFinish();
  };
  const clearCSSAnimationsTimeout = () => {
    if (cssAnimationsTimerFallback) {
      clearTimeout(cssAnimationsTimerFallback);
    }
  };
  const playCSSAnimations = () => {
    clearCSSAnimationsTimeout();
    raf(() => {
      elements.forEach((element) => {
        if (_keyframes.length > 0) {
          setStyleProperty(element, "animation-play-state", "running");
        }
      });
    });
    if (_keyframes.length === 0 || elements.length === 0) {
      animationFinish();
    } else {
      const animationDelay = getDelay() || 0;
      const animationDuration = getDuration() || 0;
      const animationIterations = getIterations() || 1;
      if (isFinite(animationIterations)) {
        cssAnimationsTimerFallback = setTimeout(onAnimationEndFallback, animationDelay + animationDuration * animationIterations + ANIMATION_END_FALLBACK_PADDING_MS);
      }
      animationEnd(elements[0], () => {
        clearCSSAnimationsTimeout();
        raf(() => {
          clearCSSAnimationPlayState();
          raf(animationFinish);
        });
      });
    }
  };
  const clearCSSAnimationPlayState = () => {
    elements.forEach((element) => {
      removeStyleProperty(element, "animation-duration");
      removeStyleProperty(element, "animation-delay");
      removeStyleProperty(element, "animation-play-state");
    });
  };
  const playWebAnimations = () => {
    webAnimations.forEach((animation2) => {
      animation2.play();
    });
    if (_keyframes.length === 0 || elements.length === 0) {
      animationFinish();
    }
  };
  const resetAnimation = () => {
    if (supportsWebAnimations) {
      setAnimationStep(0);
      updateWebAnimation();
    } else {
      updateCSSAnimation();
    }
  };
  const play = (opts) => {
    return new Promise((resolve) => {
      if (opts === null || opts === void 0 ? void 0 : opts.sync) {
        shouldForceSyncPlayback = true;
        onFinish(() => shouldForceSyncPlayback = false, { oneTimeCallback: true });
      }
      if (!initialized) {
        initializeAnimation();
      }
      if (finished) {
        resetAnimation();
        finished = false;
      }
      if (shouldCalculateNumAnimations) {
        numAnimationsRunning = childAnimations.length + 1;
        shouldCalculateNumAnimations = false;
      }
      onFinish(() => resolve(), { oneTimeCallback: true });
      childAnimations.forEach((animation2) => {
        animation2.play();
      });
      if (supportsWebAnimations) {
        playWebAnimations();
      } else {
        playCSSAnimations();
      }
      paused = false;
    });
  };
  const stop = () => {
    childAnimations.forEach((animation2) => {
      animation2.stop();
    });
    if (initialized) {
      cleanUpElements();
      initialized = false;
    }
    resetFlags();
  };
  const from2 = (property2, value) => {
    const firstFrame = _keyframes[0];
    if (firstFrame !== void 0 && (firstFrame.offset === void 0 || firstFrame.offset === 0)) {
      firstFrame[property2] = value;
    } else {
      _keyframes = [{ offset: 0, [property2]: value }, ..._keyframes];
    }
    return ani;
  };
  const to2 = (property2, value) => {
    const lastFrame = _keyframes[_keyframes.length - 1];
    if (lastFrame !== void 0 && (lastFrame.offset === void 0 || lastFrame.offset === 1)) {
      lastFrame[property2] = value;
    } else {
      _keyframes = [..._keyframes, { offset: 1, [property2]: value }];
    }
    return ani;
  };
  const fromTo = (property2, fromValue, toValue) => {
    return from2(property2, fromValue).to(property2, toValue);
  };
  return ani = {
    parentAnimation,
    elements,
    childAnimations,
    id: id2,
    animationFinish,
    from: from2,
    to: to2,
    fromTo,
    parent,
    play,
    pause,
    stop,
    destroy,
    keyframes,
    addAnimation,
    addElement,
    update: update3,
    fill,
    direction,
    iterations,
    duration,
    easing,
    delay: delay2,
    getWebAnimations,
    getKeyframes,
    getFill,
    getDirection,
    getDelay,
    getIterations,
    getEasing,
    getDuration,
    afterAddRead,
    afterAddWrite,
    afterClearStyles,
    afterStyles,
    afterRemoveClass,
    afterAddClass,
    beforeAddRead,
    beforeAddWrite,
    beforeClearStyles,
    beforeStyles,
    beforeRemoveClass,
    beforeAddClass,
    onFinish,
    isRunning,
    progressStart,
    progressStep,
    progressEnd
  };
};
const LIFECYCLE_WILL_ENTER = "ionViewWillEnter";
const LIFECYCLE_DID_ENTER = "ionViewDidEnter";
const LIFECYCLE_WILL_LEAVE = "ionViewWillLeave";
const LIFECYCLE_DID_LEAVE = "ionViewDidLeave";
const LIFECYCLE_WILL_UNLOAD = "ionViewWillUnload";
const iosTransitionAnimation$1 = () => __vitePreload(() => Promise.resolve().then(() => ios_transition), true ? void 0 : void 0);
const mdTransitionAnimation$1 = () => __vitePreload(() => Promise.resolve().then(() => md_transition), true ? void 0 : void 0);
const transition$1 = (opts) => {
  return new Promise((resolve, reject3) => {
    writeTask$1(() => {
      beforeTransition(opts);
      runTransition(opts).then((result) => {
        if (result.animation) {
          result.animation.destroy();
        }
        afterTransition(opts);
        resolve(result);
      }, (error) => {
        afterTransition(opts);
        reject3(error);
      });
    });
  });
};
const beforeTransition = (opts) => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  setZIndex(enteringEl, leavingEl, opts.direction);
  if (opts.showGoBack) {
    enteringEl.classList.add("can-go-back");
  } else {
    enteringEl.classList.remove("can-go-back");
  }
  setPageHidden(enteringEl, false);
  enteringEl.style.setProperty("pointer-events", "none");
  if (leavingEl) {
    setPageHidden(leavingEl, false);
    leavingEl.style.setProperty("pointer-events", "none");
  }
};
const runTransition = async (opts) => {
  const animationBuilder = await getAnimationBuilder(opts);
  const ani = animationBuilder && Build.isBrowser ? animation(animationBuilder, opts) : noAnimation(opts);
  return ani;
};
const afterTransition = (opts) => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  enteringEl.classList.remove("ion-page-invisible");
  enteringEl.style.removeProperty("pointer-events");
  if (leavingEl !== void 0) {
    leavingEl.classList.remove("ion-page-invisible");
    leavingEl.style.removeProperty("pointer-events");
  }
};
const getAnimationBuilder = async (opts) => {
  if (!opts.leavingEl || !opts.animated || opts.duration === 0) {
    return void 0;
  }
  if (opts.animationBuilder) {
    return opts.animationBuilder;
  }
  const getAnimation = opts.mode === "ios" ? (await iosTransitionAnimation$1()).iosTransitionAnimation : (await mdTransitionAnimation$1()).mdTransitionAnimation;
  return getAnimation;
};
const animation = async (animationBuilder, opts) => {
  await waitForReady(opts, true);
  const trans = animationBuilder(opts.baseEl, opts);
  fireWillEvents(opts.enteringEl, opts.leavingEl);
  const didComplete = await playTransition(trans, opts);
  if (opts.progressCallback) {
    opts.progressCallback(void 0);
  }
  if (didComplete) {
    fireDidEvents(opts.enteringEl, opts.leavingEl);
  }
  return {
    hasCompleted: didComplete,
    animation: trans
  };
};
const noAnimation = async (opts) => {
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  await waitForReady(opts, false);
  fireWillEvents(enteringEl, leavingEl);
  fireDidEvents(enteringEl, leavingEl);
  return {
    hasCompleted: true
  };
};
const waitForReady = async (opts, defaultDeep) => {
  const deep = opts.deepWait !== void 0 ? opts.deepWait : defaultDeep;
  if (deep) {
    await Promise.all([deepReady(opts.enteringEl), deepReady(opts.leavingEl)]);
  }
  await notifyViewReady(opts.viewIsReady, opts.enteringEl);
};
const notifyViewReady = async (viewIsReady, enteringEl) => {
  if (viewIsReady) {
    await viewIsReady(enteringEl);
  }
};
const playTransition = (trans, opts) => {
  const progressCallback = opts.progressCallback;
  const promise3 = new Promise((resolve) => {
    trans.onFinish((currentStep) => resolve(currentStep === 1));
  });
  if (progressCallback) {
    trans.progressStart(true);
    progressCallback(trans);
  } else {
    trans.play();
  }
  return promise3;
};
const fireWillEvents = (enteringEl, leavingEl) => {
  lifecycle(leavingEl, LIFECYCLE_WILL_LEAVE);
  lifecycle(enteringEl, LIFECYCLE_WILL_ENTER);
};
const fireDidEvents = (enteringEl, leavingEl) => {
  lifecycle(enteringEl, LIFECYCLE_DID_ENTER);
  lifecycle(leavingEl, LIFECYCLE_DID_LEAVE);
};
const lifecycle = (el2, eventName) => {
  if (el2) {
    const ev = new CustomEvent(eventName, {
      bubbles: false,
      cancelable: false
    });
    el2.dispatchEvent(ev);
  }
};
const waitForMount = () => {
  return new Promise((resolve) => raf(() => raf(() => resolve())));
};
const deepReady = async (el2) => {
  const element = el2;
  if (element) {
    if (element.componentOnReady != null) {
      const stencilEl = await element.componentOnReady();
      if (stencilEl != null) {
        return;
      }
    } else if (element.__registerHost != null) {
      const waitForCustomElement = new Promise((resolve) => raf(resolve));
      await waitForCustomElement;
      return;
    }
    await Promise.all(Array.from(element.children).map(deepReady));
  }
};
const setPageHidden = (el2, hidden) => {
  if (hidden) {
    el2.setAttribute("aria-hidden", "true");
    el2.classList.add("ion-page-hidden");
  } else {
    el2.hidden = false;
    el2.removeAttribute("aria-hidden");
    el2.classList.remove("ion-page-hidden");
  }
};
const setZIndex = (enteringEl, leavingEl, direction) => {
  if (enteringEl !== void 0) {
    enteringEl.style.zIndex = direction === "back" ? "99" : "101";
  }
  if (leavingEl !== void 0) {
    leavingEl.style.zIndex = "100";
  }
};
const getIonPageElement = (element) => {
  if (element.classList.contains("ion-page")) {
    return element;
  }
  const ionPage = element.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs");
  if (ionPage) {
    return ionPage;
  }
  return element;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const DURATION = 540;
const getClonedElement = (tagName) => {
  return document.querySelector(`${tagName}.ion-cloned-element`);
};
const shadow = (el2) => {
  return el2.shadowRoot || el2;
};
const getLargeTitle = (refEl) => {
  const tabs = refEl.tagName === "ION-TABS" ? refEl : refEl.querySelector("ion-tabs");
  const query = "ion-content ion-header:not(.header-collapse-condense-inactive) ion-title.title-large";
  if (tabs != null) {
    const activeTab = tabs.querySelector("ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)");
    return activeTab != null ? activeTab.querySelector(query) : null;
  }
  return refEl.querySelector(query);
};
const getBackButton = (refEl, backDirection) => {
  const tabs = refEl.tagName === "ION-TABS" ? refEl : refEl.querySelector("ion-tabs");
  let buttonsList = [];
  if (tabs != null) {
    const activeTab = tabs.querySelector("ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)");
    if (activeTab != null) {
      buttonsList = activeTab.querySelectorAll("ion-buttons");
    }
  } else {
    buttonsList = refEl.querySelectorAll("ion-buttons");
  }
  for (const buttons of buttonsList) {
    const parentHeader = buttons.closest("ion-header");
    const activeHeader = parentHeader && !parentHeader.classList.contains("header-collapse-condense-inactive");
    const backButton = buttons.querySelector("ion-back-button");
    const buttonsCollapse = buttons.classList.contains("buttons-collapse");
    const startSlot = buttons.slot === "start" || buttons.slot === "";
    if (backButton !== null && startSlot && (buttonsCollapse && activeHeader && backDirection || !buttonsCollapse)) {
      return backButton;
    }
  }
  return null;
};
const createLargeTitleTransition = (rootAnimation, rtl, backDirection, enteringEl, leavingEl) => {
  const enteringBackButton = getBackButton(enteringEl, backDirection);
  const leavingLargeTitle = getLargeTitle(leavingEl);
  const enteringLargeTitle = getLargeTitle(enteringEl);
  const leavingBackButton = getBackButton(leavingEl, backDirection);
  const shouldAnimationForward = enteringBackButton !== null && leavingLargeTitle !== null && !backDirection;
  const shouldAnimationBackward = enteringLargeTitle !== null && leavingBackButton !== null && backDirection;
  if (shouldAnimationForward) {
    const leavingLargeTitleBox = leavingLargeTitle.getBoundingClientRect();
    const enteringBackButtonBox = enteringBackButton.getBoundingClientRect();
    animateLargeTitle(rootAnimation, rtl, backDirection, leavingLargeTitle, leavingLargeTitleBox, enteringBackButtonBox);
    animateBackButton(rootAnimation, rtl, backDirection, enteringBackButton, leavingLargeTitleBox, enteringBackButtonBox);
  } else if (shouldAnimationBackward) {
    const enteringLargeTitleBox = enteringLargeTitle.getBoundingClientRect();
    const leavingBackButtonBox = leavingBackButton.getBoundingClientRect();
    animateLargeTitle(rootAnimation, rtl, backDirection, enteringLargeTitle, enteringLargeTitleBox, leavingBackButtonBox);
    animateBackButton(rootAnimation, rtl, backDirection, leavingBackButton, enteringLargeTitleBox, leavingBackButtonBox);
  }
  return {
    forward: shouldAnimationForward,
    backward: shouldAnimationBackward
  };
};
const animateBackButton = (rootAnimation, rtl, backDirection, backButtonEl, largeTitleBox, backButtonBox) => {
  const BACK_BUTTON_START_OFFSET = rtl ? `calc(100% - ${backButtonBox.right + 4}px)` : `${backButtonBox.left - 4}px`;
  const START_TEXT_TRANSLATE = rtl ? "7px" : "-7px";
  const END_TEXT_TRANSLATE = rtl ? "-4px" : "4px";
  const ICON_TRANSLATE = rtl ? "-4px" : "4px";
  const TEXT_ORIGIN_X = rtl ? "right" : "left";
  const ICON_ORIGIN_X = rtl ? "left" : "right";
  const FORWARD_TEXT_KEYFRAMES = [
    {
      offset: 0,
      opacity: 0,
      transform: `translate3d(${START_TEXT_TRANSLATE}, ${largeTitleBox.top - 40}px, 0) scale(2.1)`
    },
    { offset: 1, opacity: 1, transform: `translate3d(${END_TEXT_TRANSLATE}, ${backButtonBox.top - 46}px, 0) scale(1)` }
  ];
  const BACKWARD_TEXT_KEYFRAMES = [
    { offset: 0, opacity: 1, transform: `translate3d(${END_TEXT_TRANSLATE}, ${backButtonBox.top - 46}px, 0) scale(1)` },
    { offset: 0.6, opacity: 0 },
    {
      offset: 1,
      opacity: 0,
      transform: `translate3d(${START_TEXT_TRANSLATE}, ${largeTitleBox.top - 40}px, 0) scale(2.1)`
    }
  ];
  const TEXT_KEYFRAMES = backDirection ? BACKWARD_TEXT_KEYFRAMES : FORWARD_TEXT_KEYFRAMES;
  const FORWARD_ICON_KEYFRAMES = [
    { offset: 0, opacity: 0, transform: `translate3d(${ICON_TRANSLATE}, ${backButtonBox.top - 41}px, 0) scale(0.6)` },
    { offset: 1, opacity: 1, transform: `translate3d(${ICON_TRANSLATE}, ${backButtonBox.top - 46}px, 0) scale(1)` }
  ];
  const BACKWARD_ICON_KEYFRAMES = [
    { offset: 0, opacity: 1, transform: `translate3d(${ICON_TRANSLATE}, ${backButtonBox.top - 46}px, 0) scale(1)` },
    { offset: 0.2, opacity: 0, transform: `translate3d(${ICON_TRANSLATE}, ${backButtonBox.top - 41}px, 0) scale(0.6)` },
    { offset: 1, opacity: 0, transform: `translate3d(${ICON_TRANSLATE}, ${backButtonBox.top - 41}px, 0) scale(0.6)` }
  ];
  const ICON_KEYFRAMES = backDirection ? BACKWARD_ICON_KEYFRAMES : FORWARD_ICON_KEYFRAMES;
  const enteringBackButtonTextAnimation = createAnimation();
  const enteringBackButtonIconAnimation = createAnimation();
  const clonedBackButtonEl = getClonedElement("ion-back-button");
  const backButtonTextEl = shadow(clonedBackButtonEl).querySelector(".button-text");
  const backButtonIconEl = shadow(clonedBackButtonEl).querySelector("ion-icon");
  clonedBackButtonEl.text = backButtonEl.text;
  clonedBackButtonEl.mode = backButtonEl.mode;
  clonedBackButtonEl.icon = backButtonEl.icon;
  clonedBackButtonEl.color = backButtonEl.color;
  clonedBackButtonEl.disabled = backButtonEl.disabled;
  clonedBackButtonEl.style.setProperty("display", "block");
  clonedBackButtonEl.style.setProperty("position", "fixed");
  enteringBackButtonIconAnimation.addElement(backButtonIconEl);
  enteringBackButtonTextAnimation.addElement(backButtonTextEl);
  enteringBackButtonTextAnimation.beforeStyles({
    "transform-origin": `${TEXT_ORIGIN_X} center`
  }).beforeAddWrite(() => {
    backButtonEl.style.setProperty("display", "none");
    clonedBackButtonEl.style.setProperty(TEXT_ORIGIN_X, BACK_BUTTON_START_OFFSET);
  }).afterAddWrite(() => {
    backButtonEl.style.setProperty("display", "");
    clonedBackButtonEl.style.setProperty("display", "none");
    clonedBackButtonEl.style.removeProperty(TEXT_ORIGIN_X);
  }).keyframes(TEXT_KEYFRAMES);
  enteringBackButtonIconAnimation.beforeStyles({
    "transform-origin": `${ICON_ORIGIN_X} center`
  }).keyframes(ICON_KEYFRAMES);
  rootAnimation.addAnimation([enteringBackButtonTextAnimation, enteringBackButtonIconAnimation]);
};
const animateLargeTitle = (rootAnimation, rtl, backDirection, largeTitleEl, largeTitleBox, backButtonBox) => {
  const TITLE_START_OFFSET = rtl ? `calc(100% - ${largeTitleBox.right}px)` : `${largeTitleBox.left}px`;
  const START_TRANSLATE = rtl ? "-18px" : "18px";
  const ORIGIN_X = rtl ? "right" : "left";
  const BACKWARDS_KEYFRAMES = [
    { offset: 0, opacity: 0, transform: `translate3d(${START_TRANSLATE}, ${backButtonBox.top - 4}px, 0) scale(0.49)` },
    { offset: 0.1, opacity: 0 },
    { offset: 1, opacity: 1, transform: `translate3d(0, ${largeTitleBox.top - 2}px, 0) scale(1)` }
  ];
  const FORWARDS_KEYFRAMES = [
    { offset: 0, opacity: 0.99, transform: `translate3d(0, ${largeTitleBox.top - 2}px, 0) scale(1)` },
    { offset: 0.6, opacity: 0 },
    { offset: 1, opacity: 0, transform: `translate3d(${START_TRANSLATE}, ${backButtonBox.top - 4}px, 0) scale(0.5)` }
  ];
  const KEYFRAMES = backDirection ? BACKWARDS_KEYFRAMES : FORWARDS_KEYFRAMES;
  const clonedTitleEl = getClonedElement("ion-title");
  const clonedLargeTitleAnimation = createAnimation();
  clonedTitleEl.innerText = largeTitleEl.innerText;
  clonedTitleEl.size = largeTitleEl.size;
  clonedTitleEl.color = largeTitleEl.color;
  clonedLargeTitleAnimation.addElement(clonedTitleEl);
  clonedLargeTitleAnimation.beforeStyles({
    "transform-origin": `${ORIGIN_X} center`,
    height: "46px",
    display: "",
    position: "relative",
    [ORIGIN_X]: TITLE_START_OFFSET
  }).beforeAddWrite(() => {
    largeTitleEl.style.setProperty("display", "none");
  }).afterAddWrite(() => {
    largeTitleEl.style.setProperty("display", "");
    clonedTitleEl.style.setProperty("display", "none");
  }).keyframes(KEYFRAMES);
  rootAnimation.addAnimation(clonedLargeTitleAnimation);
};
const iosTransitionAnimation = (navEl, opts) => {
  var _a2;
  try {
    const EASING = "cubic-bezier(0.32,0.72,0,1)";
    const OPACITY = "opacity";
    const TRANSFORM = "transform";
    const CENTER = "0%";
    const OFF_OPACITY = 0.8;
    const isRTL2 = navEl.ownerDocument.dir === "rtl";
    const OFF_RIGHT = isRTL2 ? "-99.5%" : "99.5%";
    const OFF_LEFT = isRTL2 ? "33%" : "-33%";
    const enteringEl = opts.enteringEl;
    const leavingEl = opts.leavingEl;
    const backDirection = opts.direction === "back";
    const contentEl = enteringEl.querySelector(":scope > ion-content");
    const headerEls = enteringEl.querySelectorAll(":scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *");
    const enteringToolBarEls = enteringEl.querySelectorAll(":scope > ion-header > ion-toolbar");
    const rootAnimation = createAnimation();
    const enteringContentAnimation = createAnimation();
    rootAnimation.addElement(enteringEl).duration(((_a2 = opts.duration) !== null && _a2 !== void 0 ? _a2 : 0) || DURATION).easing(opts.easing || EASING).fill("both").beforeRemoveClass("ion-page-invisible");
    if (leavingEl && navEl !== null && navEl !== void 0) {
      const navDecorAnimation = createAnimation();
      navDecorAnimation.addElement(navEl);
      rootAnimation.addAnimation(navDecorAnimation);
    }
    if (!contentEl && enteringToolBarEls.length === 0 && headerEls.length === 0) {
      enteringContentAnimation.addElement(enteringEl.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs"));
    } else {
      enteringContentAnimation.addElement(contentEl);
      enteringContentAnimation.addElement(headerEls);
    }
    rootAnimation.addAnimation(enteringContentAnimation);
    if (backDirection) {
      enteringContentAnimation.beforeClearStyles([OPACITY]).fromTo("transform", `translateX(${OFF_LEFT})`, `translateX(${CENTER})`).fromTo(OPACITY, OFF_OPACITY, 1);
    } else {
      enteringContentAnimation.beforeClearStyles([OPACITY]).fromTo("transform", `translateX(${OFF_RIGHT})`, `translateX(${CENTER})`);
    }
    if (contentEl) {
      const enteringTransitionEffectEl = shadow(contentEl).querySelector(".transition-effect");
      if (enteringTransitionEffectEl) {
        const enteringTransitionCoverEl = enteringTransitionEffectEl.querySelector(".transition-cover");
        const enteringTransitionShadowEl = enteringTransitionEffectEl.querySelector(".transition-shadow");
        const enteringTransitionEffect = createAnimation();
        const enteringTransitionCover = createAnimation();
        const enteringTransitionShadow = createAnimation();
        enteringTransitionEffect.addElement(enteringTransitionEffectEl).beforeStyles({ opacity: "1", display: "block" }).afterStyles({ opacity: "", display: "" });
        enteringTransitionCover.addElement(enteringTransitionCoverEl).beforeClearStyles([OPACITY]).fromTo(OPACITY, 0, 0.1);
        enteringTransitionShadow.addElement(enteringTransitionShadowEl).beforeClearStyles([OPACITY]).fromTo(OPACITY, 0.03, 0.7);
        enteringTransitionEffect.addAnimation([enteringTransitionCover, enteringTransitionShadow]);
        enteringContentAnimation.addAnimation([enteringTransitionEffect]);
      }
    }
    const enteringContentHasLargeTitle = enteringEl.querySelector("ion-header.header-collapse-condense");
    const { forward, backward } = createLargeTitleTransition(rootAnimation, isRTL2, backDirection, enteringEl, leavingEl);
    enteringToolBarEls.forEach((enteringToolBarEl) => {
      const enteringToolBar = createAnimation();
      enteringToolBar.addElement(enteringToolBarEl);
      rootAnimation.addAnimation(enteringToolBar);
      const enteringTitle = createAnimation();
      enteringTitle.addElement(enteringToolBarEl.querySelector("ion-title"));
      const enteringToolBarButtons = createAnimation();
      const buttons = Array.from(enteringToolBarEl.querySelectorAll("ion-buttons,[menuToggle]"));
      const parentHeader = enteringToolBarEl.closest("ion-header");
      const inactiveHeader = parentHeader === null || parentHeader === void 0 ? void 0 : parentHeader.classList.contains("header-collapse-condense-inactive");
      let buttonsToAnimate;
      if (backDirection) {
        buttonsToAnimate = buttons.filter((button) => {
          const isCollapseButton = button.classList.contains("buttons-collapse");
          return isCollapseButton && !inactiveHeader || !isCollapseButton;
        });
      } else {
        buttonsToAnimate = buttons.filter((button) => !button.classList.contains("buttons-collapse"));
      }
      enteringToolBarButtons.addElement(buttonsToAnimate);
      const enteringToolBarItems = createAnimation();
      enteringToolBarItems.addElement(enteringToolBarEl.querySelectorAll(":scope > *:not(ion-title):not(ion-buttons):not([menuToggle])"));
      const enteringToolBarBg = createAnimation();
      enteringToolBarBg.addElement(shadow(enteringToolBarEl).querySelector(".toolbar-background"));
      const enteringBackButton = createAnimation();
      const backButtonEl = enteringToolBarEl.querySelector("ion-back-button");
      if (backButtonEl) {
        enteringBackButton.addElement(backButtonEl);
      }
      enteringToolBar.addAnimation([
        enteringTitle,
        enteringToolBarButtons,
        enteringToolBarItems,
        enteringToolBarBg,
        enteringBackButton
      ]);
      enteringToolBarButtons.fromTo(OPACITY, 0.01, 1);
      enteringToolBarItems.fromTo(OPACITY, 0.01, 1);
      if (backDirection) {
        if (!inactiveHeader) {
          enteringTitle.fromTo("transform", `translateX(${OFF_LEFT})`, `translateX(${CENTER})`).fromTo(OPACITY, 0.01, 1);
        }
        enteringToolBarItems.fromTo("transform", `translateX(${OFF_LEFT})`, `translateX(${CENTER})`);
        enteringBackButton.fromTo(OPACITY, 0.01, 1);
      } else {
        if (!enteringContentHasLargeTitle) {
          enteringTitle.fromTo("transform", `translateX(${OFF_RIGHT})`, `translateX(${CENTER})`).fromTo(OPACITY, 0.01, 1);
        }
        enteringToolBarItems.fromTo("transform", `translateX(${OFF_RIGHT})`, `translateX(${CENTER})`);
        enteringToolBarBg.beforeClearStyles([OPACITY, "transform"]);
        const translucentHeader = parentHeader === null || parentHeader === void 0 ? void 0 : parentHeader.translucent;
        if (!translucentHeader) {
          enteringToolBarBg.fromTo(OPACITY, 0.01, "var(--opacity)");
        } else {
          enteringToolBarBg.fromTo("transform", isRTL2 ? "translateX(-100%)" : "translateX(100%)", "translateX(0px)");
        }
        if (!forward) {
          enteringBackButton.fromTo(OPACITY, 0.01, 1);
        }
        if (backButtonEl && !forward) {
          const enteringBackBtnText = createAnimation();
          enteringBackBtnText.addElement(shadow(backButtonEl).querySelector(".button-text")).fromTo(`transform`, isRTL2 ? "translateX(-100px)" : "translateX(100px)", "translateX(0px)");
          enteringToolBar.addAnimation(enteringBackBtnText);
        }
      }
    });
    if (leavingEl) {
      const leavingContent = createAnimation();
      const leavingContentEl = leavingEl.querySelector(":scope > ion-content");
      const leavingToolBarEls = leavingEl.querySelectorAll(":scope > ion-header > ion-toolbar");
      const leavingHeaderEls = leavingEl.querySelectorAll(":scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *");
      if (!leavingContentEl && leavingToolBarEls.length === 0 && leavingHeaderEls.length === 0) {
        leavingContent.addElement(leavingEl.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs"));
      } else {
        leavingContent.addElement(leavingContentEl);
        leavingContent.addElement(leavingHeaderEls);
      }
      rootAnimation.addAnimation(leavingContent);
      if (backDirection) {
        leavingContent.beforeClearStyles([OPACITY]).fromTo("transform", `translateX(${CENTER})`, isRTL2 ? "translateX(-100%)" : "translateX(100%)");
        const leavingPage = getIonPageElement(leavingEl);
        rootAnimation.afterAddWrite(() => {
          if (rootAnimation.getDirection() === "normal") {
            leavingPage.style.setProperty("display", "none");
          }
        });
      } else {
        leavingContent.fromTo("transform", `translateX(${CENTER})`, `translateX(${OFF_LEFT})`).fromTo(OPACITY, 1, OFF_OPACITY);
      }
      if (leavingContentEl) {
        const leavingTransitionEffectEl = shadow(leavingContentEl).querySelector(".transition-effect");
        if (leavingTransitionEffectEl) {
          const leavingTransitionCoverEl = leavingTransitionEffectEl.querySelector(".transition-cover");
          const leavingTransitionShadowEl = leavingTransitionEffectEl.querySelector(".transition-shadow");
          const leavingTransitionEffect = createAnimation();
          const leavingTransitionCover = createAnimation();
          const leavingTransitionShadow = createAnimation();
          leavingTransitionEffect.addElement(leavingTransitionEffectEl).beforeStyles({ opacity: "1", display: "block" }).afterStyles({ opacity: "", display: "" });
          leavingTransitionCover.addElement(leavingTransitionCoverEl).beforeClearStyles([OPACITY]).fromTo(OPACITY, 0.1, 0);
          leavingTransitionShadow.addElement(leavingTransitionShadowEl).beforeClearStyles([OPACITY]).fromTo(OPACITY, 0.7, 0.03);
          leavingTransitionEffect.addAnimation([leavingTransitionCover, leavingTransitionShadow]);
          leavingContent.addAnimation([leavingTransitionEffect]);
        }
      }
      leavingToolBarEls.forEach((leavingToolBarEl) => {
        const leavingToolBar = createAnimation();
        leavingToolBar.addElement(leavingToolBarEl);
        const leavingTitle = createAnimation();
        leavingTitle.addElement(leavingToolBarEl.querySelector("ion-title"));
        const leavingToolBarButtons = createAnimation();
        const buttons = leavingToolBarEl.querySelectorAll("ion-buttons,[menuToggle]");
        const parentHeader = leavingToolBarEl.closest("ion-header");
        const inactiveHeader = parentHeader === null || parentHeader === void 0 ? void 0 : parentHeader.classList.contains("header-collapse-condense-inactive");
        const buttonsToAnimate = Array.from(buttons).filter((button) => {
          const isCollapseButton = button.classList.contains("buttons-collapse");
          return isCollapseButton && !inactiveHeader || !isCollapseButton;
        });
        leavingToolBarButtons.addElement(buttonsToAnimate);
        const leavingToolBarItems = createAnimation();
        const leavingToolBarItemEls = leavingToolBarEl.querySelectorAll(":scope > *:not(ion-title):not(ion-buttons):not([menuToggle])");
        if (leavingToolBarItemEls.length > 0) {
          leavingToolBarItems.addElement(leavingToolBarItemEls);
        }
        const leavingToolBarBg = createAnimation();
        leavingToolBarBg.addElement(shadow(leavingToolBarEl).querySelector(".toolbar-background"));
        const leavingBackButton = createAnimation();
        const backButtonEl = leavingToolBarEl.querySelector("ion-back-button");
        if (backButtonEl) {
          leavingBackButton.addElement(backButtonEl);
        }
        leavingToolBar.addAnimation([
          leavingTitle,
          leavingToolBarButtons,
          leavingToolBarItems,
          leavingBackButton,
          leavingToolBarBg
        ]);
        rootAnimation.addAnimation(leavingToolBar);
        leavingBackButton.fromTo(OPACITY, 0.99, 0);
        leavingToolBarButtons.fromTo(OPACITY, 0.99, 0);
        leavingToolBarItems.fromTo(OPACITY, 0.99, 0);
        if (backDirection) {
          if (!inactiveHeader) {
            leavingTitle.fromTo("transform", `translateX(${CENTER})`, isRTL2 ? "translateX(-100%)" : "translateX(100%)").fromTo(OPACITY, 0.99, 0);
          }
          leavingToolBarItems.fromTo("transform", `translateX(${CENTER})`, isRTL2 ? "translateX(-100%)" : "translateX(100%)");
          leavingToolBarBg.beforeClearStyles([OPACITY, "transform"]);
          const translucentHeader = parentHeader === null || parentHeader === void 0 ? void 0 : parentHeader.translucent;
          if (!translucentHeader) {
            leavingToolBarBg.fromTo(OPACITY, "var(--opacity)", 0);
          } else {
            leavingToolBarBg.fromTo("transform", "translateX(0px)", isRTL2 ? "translateX(-100%)" : "translateX(100%)");
          }
          if (backButtonEl && !backward) {
            const leavingBackBtnText = createAnimation();
            leavingBackBtnText.addElement(shadow(backButtonEl).querySelector(".button-text")).fromTo("transform", `translateX(${CENTER})`, `translateX(${(isRTL2 ? -124 : 124) + "px"})`);
            leavingToolBar.addAnimation(leavingBackBtnText);
          }
        } else {
          if (!inactiveHeader) {
            leavingTitle.fromTo("transform", `translateX(${CENTER})`, `translateX(${OFF_LEFT})`).fromTo(OPACITY, 0.99, 0).afterClearStyles([TRANSFORM, OPACITY]);
          }
          leavingToolBarItems.fromTo("transform", `translateX(${CENTER})`, `translateX(${OFF_LEFT})`).afterClearStyles([TRANSFORM, OPACITY]);
          leavingBackButton.afterClearStyles([OPACITY]);
          leavingTitle.afterClearStyles([OPACITY]);
          leavingToolBarButtons.afterClearStyles([OPACITY]);
        }
      });
    }
    return rootAnimation;
  } catch (err) {
    throw err;
  }
};
const ios_transition = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  iosTransitionAnimation,
  shadow
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const mdTransitionAnimation = (_2, opts) => {
  var _a2, _b, _c;
  const OFF_BOTTOM = "40px";
  const CENTER = "0px";
  const backDirection = opts.direction === "back";
  const enteringEl = opts.enteringEl;
  const leavingEl = opts.leavingEl;
  const ionPageElement = getIonPageElement(enteringEl);
  const enteringToolbarEle = ionPageElement.querySelector("ion-toolbar");
  const rootTransition = createAnimation();
  rootTransition.addElement(ionPageElement).fill("both").beforeRemoveClass("ion-page-invisible");
  if (backDirection) {
    rootTransition.duration(((_a2 = opts.duration) !== null && _a2 !== void 0 ? _a2 : 0) || 200).easing("cubic-bezier(0.47,0,0.745,0.715)");
  } else {
    rootTransition.duration(((_b = opts.duration) !== null && _b !== void 0 ? _b : 0) || 280).easing("cubic-bezier(0.36,0.66,0.04,1)").fromTo("transform", `translateY(${OFF_BOTTOM})`, `translateY(${CENTER})`).fromTo("opacity", 0.01, 1);
  }
  if (enteringToolbarEle) {
    const enteringToolBar = createAnimation();
    enteringToolBar.addElement(enteringToolbarEle);
    rootTransition.addAnimation(enteringToolBar);
  }
  if (leavingEl && backDirection) {
    rootTransition.duration(((_c = opts.duration) !== null && _c !== void 0 ? _c : 0) || 200).easing("cubic-bezier(0.47,0,0.745,0.715)");
    const leavingPage = createAnimation();
    leavingPage.addElement(getIonPageElement(leavingEl)).onFinish((currentStep) => {
      if (currentStep === 1 && leavingPage.elements.length > 0) {
        leavingPage.elements[0].style.setProperty("display", "none");
      }
    }).fromTo("transform", `translateY(${CENTER})`, `translateY(${OFF_BOTTOM})`).fromTo("opacity", 1, 0);
    rootTransition.addAnimation(leavingPage);
  }
  return rootTransition;
};
const md_transition = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  mdTransitionAnimation
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const getTimeGivenProgression = (p0, p1, p2, p3, progression) => {
  return solveCubicBezier(p0[1], p1[1], p2[1], p3[1], progression).map((tValue) => {
    return solveCubicParametricEquation(p0[0], p1[0], p2[0], p3[0], tValue);
  });
};
const solveCubicParametricEquation = (p0, p1, p2, p3, t2) => {
  const partA = 3 * p1 * Math.pow(t2 - 1, 2);
  const partB = -3 * p2 * t2 + 3 * p2 + p3 * t2;
  const partC = p0 * Math.pow(t2 - 1, 3);
  return t2 * (partA + t2 * partB) - partC;
};
const solveCubicBezier = (p0, p1, p2, p3, refPoint) => {
  p0 -= refPoint;
  p1 -= refPoint;
  p2 -= refPoint;
  p3 -= refPoint;
  const roots = solveCubicEquation(p3 - 3 * p2 + 3 * p1 - p0, 3 * p2 - 6 * p1 + 3 * p0, 3 * p1 - 3 * p0, p0);
  return roots.filter((root2) => root2 >= 0 && root2 <= 1);
};
const solveQuadraticEquation = (a2, b2, c2) => {
  const discriminant = b2 * b2 - 4 * a2 * c2;
  if (discriminant < 0) {
    return [];
  } else {
    return [(-b2 + Math.sqrt(discriminant)) / (2 * a2), (-b2 - Math.sqrt(discriminant)) / (2 * a2)];
  }
};
const solveCubicEquation = (a2, b2, c2, d2) => {
  if (a2 === 0) {
    return solveQuadraticEquation(b2, c2, d2);
  }
  b2 /= a2;
  c2 /= a2;
  d2 /= a2;
  const p2 = (3 * c2 - b2 * b2) / 3;
  const q2 = (2 * b2 * b2 * b2 - 9 * b2 * c2 + 27 * d2) / 27;
  if (p2 === 0) {
    return [Math.pow(-q2, 1 / 3)];
  } else if (q2 === 0) {
    return [Math.sqrt(-p2), -Math.sqrt(-p2)];
  }
  const discriminant = Math.pow(q2 / 2, 2) + Math.pow(p2 / 3, 3);
  if (discriminant === 0) {
    return [Math.pow(q2 / 2, 1 / 2) - b2 / 3];
  } else if (discriminant > 0) {
    return [
      Math.pow(-(q2 / 2) + Math.sqrt(discriminant), 1 / 3) - Math.pow(q2 / 2 + Math.sqrt(discriminant), 1 / 3) - b2 / 3
    ];
  }
  const r2 = Math.sqrt(Math.pow(-(p2 / 3), 3));
  const phi = Math.acos(-(q2 / (2 * Math.sqrt(Math.pow(-(p2 / 3), 3)))));
  const s2 = 2 * Math.pow(r2, 1 / 3);
  return [
    s2 * Math.cos(phi / 3) - b2 / 3,
    s2 * Math.cos((phi + 2 * Math.PI) / 3) - b2 / 3,
    s2 * Math.cos((phi + 4 * Math.PI) / 3) - b2 / 3
  ];
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
class GestureController {
  constructor() {
    this.gestureId = 0;
    this.requestedStart = /* @__PURE__ */ new Map();
    this.disabledGestures = /* @__PURE__ */ new Map();
    this.disabledScroll = /* @__PURE__ */ new Set();
  }
  /**
   * Creates a gesture delegate based on the GestureConfig passed
   */
  createGesture(config2) {
    var _a2;
    return new GestureDelegate(this, this.newID(), config2.name, (_a2 = config2.priority) !== null && _a2 !== void 0 ? _a2 : 0, !!config2.disableScroll);
  }
  /**
   * Creates a blocker that will block any other gesture events from firing. Set in the ion-gesture component.
   */
  createBlocker(opts = {}) {
    return new BlockerDelegate(this, this.newID(), opts.disable, !!opts.disableScroll);
  }
  start(gestureName, id2, priority) {
    if (!this.canStart(gestureName)) {
      this.requestedStart.delete(id2);
      return false;
    }
    this.requestedStart.set(id2, priority);
    return true;
  }
  capture(gestureName, id2, priority) {
    if (!this.start(gestureName, id2, priority)) {
      return false;
    }
    const requestedStart = this.requestedStart;
    let maxPriority = -1e4;
    requestedStart.forEach((value) => {
      maxPriority = Math.max(maxPriority, value);
    });
    if (maxPriority === priority) {
      this.capturedId = id2;
      requestedStart.clear();
      const event = new CustomEvent("ionGestureCaptured", { detail: { gestureName } });
      document.dispatchEvent(event);
      return true;
    }
    requestedStart.delete(id2);
    return false;
  }
  release(id2) {
    this.requestedStart.delete(id2);
    if (this.capturedId === id2) {
      this.capturedId = void 0;
    }
  }
  disableGesture(gestureName, id2) {
    let set4 = this.disabledGestures.get(gestureName);
    if (set4 === void 0) {
      set4 = /* @__PURE__ */ new Set();
      this.disabledGestures.set(gestureName, set4);
    }
    set4.add(id2);
  }
  enableGesture(gestureName, id2) {
    const set4 = this.disabledGestures.get(gestureName);
    if (set4 !== void 0) {
      set4.delete(id2);
    }
  }
  disableScroll(id2) {
    this.disabledScroll.add(id2);
    if (this.disabledScroll.size === 1) {
      document.body.classList.add(BACKDROP_NO_SCROLL);
    }
  }
  enableScroll(id2) {
    this.disabledScroll.delete(id2);
    if (this.disabledScroll.size === 0) {
      document.body.classList.remove(BACKDROP_NO_SCROLL);
    }
  }
  canStart(gestureName) {
    if (this.capturedId !== void 0) {
      return false;
    }
    if (this.isDisabled(gestureName)) {
      return false;
    }
    return true;
  }
  isCaptured() {
    return this.capturedId !== void 0;
  }
  isScrollDisabled() {
    return this.disabledScroll.size > 0;
  }
  isDisabled(gestureName) {
    const disabled = this.disabledGestures.get(gestureName);
    if (disabled && disabled.size > 0) {
      return true;
    }
    return false;
  }
  newID() {
    this.gestureId++;
    return this.gestureId;
  }
}
class GestureDelegate {
  constructor(ctrl, id2, name, priority, disableScroll) {
    this.id = id2;
    this.name = name;
    this.disableScroll = disableScroll;
    this.priority = priority * 1e6 + id2;
    this.ctrl = ctrl;
  }
  canStart() {
    if (!this.ctrl) {
      return false;
    }
    return this.ctrl.canStart(this.name);
  }
  start() {
    if (!this.ctrl) {
      return false;
    }
    return this.ctrl.start(this.name, this.id, this.priority);
  }
  capture() {
    if (!this.ctrl) {
      return false;
    }
    const captured = this.ctrl.capture(this.name, this.id, this.priority);
    if (captured && this.disableScroll) {
      this.ctrl.disableScroll(this.id);
    }
    return captured;
  }
  release() {
    if (this.ctrl) {
      this.ctrl.release(this.id);
      if (this.disableScroll) {
        this.ctrl.enableScroll(this.id);
      }
    }
  }
  destroy() {
    this.release();
    this.ctrl = void 0;
  }
}
class BlockerDelegate {
  constructor(ctrl, id2, disable, disableScroll) {
    this.id = id2;
    this.disable = disable;
    this.disableScroll = disableScroll;
    this.ctrl = ctrl;
  }
  block() {
    if (!this.ctrl) {
      return;
    }
    if (this.disable) {
      for (const gesture of this.disable) {
        this.ctrl.disableGesture(gesture, this.id);
      }
    }
    if (this.disableScroll) {
      this.ctrl.disableScroll(this.id);
    }
  }
  unblock() {
    if (!this.ctrl) {
      return;
    }
    if (this.disable) {
      for (const gesture of this.disable) {
        this.ctrl.enableGesture(gesture, this.id);
      }
    }
    if (this.disableScroll) {
      this.ctrl.enableScroll(this.id);
    }
  }
  destroy() {
    this.unblock();
    this.ctrl = void 0;
  }
}
const BACKDROP_NO_SCROLL = "backdrop-no-scroll";
const GESTURE_CONTROLLER = new GestureController();
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const addEventListener = (el2, eventName, callback, opts) => {
  const listenerOpts = supportsPassive(el2) ? {
    capture: !!opts.capture,
    passive: !!opts.passive
  } : !!opts.capture;
  let add3;
  let remove3;
  if (el2["__zone_symbol__addEventListener"]) {
    add3 = "__zone_symbol__addEventListener";
    remove3 = "__zone_symbol__removeEventListener";
  } else {
    add3 = "addEventListener";
    remove3 = "removeEventListener";
  }
  el2[add3](eventName, callback, listenerOpts);
  return () => {
    el2[remove3](eventName, callback, listenerOpts);
  };
};
const supportsPassive = (node) => {
  if (_sPassive === void 0) {
    try {
      const opts = Object.defineProperty({}, "passive", {
        get: () => {
          _sPassive = true;
        }
      });
      node.addEventListener("optsTest", () => {
        return;
      }, opts);
    } catch (e3) {
      _sPassive = false;
    }
  }
  return !!_sPassive;
};
let _sPassive;
const MOUSE_WAIT = 2e3;
const createPointerEvents = (el2, pointerDown, pointerMove, pointerUp, options) => {
  let rmTouchStart;
  let rmTouchMove;
  let rmTouchEnd;
  let rmTouchCancel;
  let rmMouseStart;
  let rmMouseMove;
  let rmMouseUp;
  let lastTouchEvent = 0;
  const handleTouchStart = (ev) => {
    lastTouchEvent = Date.now() + MOUSE_WAIT;
    if (!pointerDown(ev)) {
      return;
    }
    if (!rmTouchMove && pointerMove) {
      rmTouchMove = addEventListener(el2, "touchmove", pointerMove, options);
    }
    if (!rmTouchEnd) {
      rmTouchEnd = addEventListener(ev.target, "touchend", handleTouchEnd, options);
    }
    if (!rmTouchCancel) {
      rmTouchCancel = addEventListener(ev.target, "touchcancel", handleTouchEnd, options);
    }
  };
  const handleMouseDown = (ev) => {
    if (lastTouchEvent > Date.now()) {
      return;
    }
    if (!pointerDown(ev)) {
      return;
    }
    if (!rmMouseMove && pointerMove) {
      rmMouseMove = addEventListener(getDocument$1(el2), "mousemove", pointerMove, options);
    }
    if (!rmMouseUp) {
      rmMouseUp = addEventListener(getDocument$1(el2), "mouseup", handleMouseUp, options);
    }
  };
  const handleTouchEnd = (ev) => {
    stopTouch();
    if (pointerUp) {
      pointerUp(ev);
    }
  };
  const handleMouseUp = (ev) => {
    stopMouse();
    if (pointerUp) {
      pointerUp(ev);
    }
  };
  const stopTouch = () => {
    if (rmTouchMove) {
      rmTouchMove();
    }
    if (rmTouchEnd) {
      rmTouchEnd();
    }
    if (rmTouchCancel) {
      rmTouchCancel();
    }
    rmTouchMove = rmTouchEnd = rmTouchCancel = void 0;
  };
  const stopMouse = () => {
    if (rmMouseMove) {
      rmMouseMove();
    }
    if (rmMouseUp) {
      rmMouseUp();
    }
    rmMouseMove = rmMouseUp = void 0;
  };
  const stop = () => {
    stopTouch();
    stopMouse();
  };
  const enable = (isEnabled = true) => {
    if (!isEnabled) {
      if (rmTouchStart) {
        rmTouchStart();
      }
      if (rmMouseStart) {
        rmMouseStart();
      }
      rmTouchStart = rmMouseStart = void 0;
      stop();
    } else {
      if (!rmTouchStart) {
        rmTouchStart = addEventListener(el2, "touchstart", handleTouchStart, options);
      }
      if (!rmMouseStart) {
        rmMouseStart = addEventListener(el2, "mousedown", handleMouseDown, options);
      }
    }
  };
  const destroy = () => {
    enable(false);
    pointerUp = pointerMove = pointerDown = void 0;
  };
  return {
    enable,
    stop,
    destroy
  };
};
const getDocument$1 = (node) => {
  return node instanceof Document ? node : node.ownerDocument;
};
const createPanRecognizer = (direction, thresh, maxAngle) => {
  const radians = maxAngle * (Math.PI / 180);
  const isDirX = direction === "x";
  const maxCosine = Math.cos(radians);
  const threshold2 = thresh * thresh;
  let startX = 0;
  let startY = 0;
  let dirty = false;
  let isPan = 0;
  return {
    start(x2, y2) {
      startX = x2;
      startY = y2;
      isPan = 0;
      dirty = true;
    },
    detect(x2, y2) {
      if (!dirty) {
        return false;
      }
      const deltaX = x2 - startX;
      const deltaY = y2 - startY;
      const distance = deltaX * deltaX + deltaY * deltaY;
      if (distance < threshold2) {
        return false;
      }
      const hypotenuse = Math.sqrt(distance);
      const cosine = (isDirX ? deltaX : deltaY) / hypotenuse;
      if (cosine > maxCosine) {
        isPan = 1;
      } else if (cosine < -maxCosine) {
        isPan = -1;
      } else {
        isPan = 0;
      }
      dirty = false;
      return true;
    },
    isGesture() {
      return isPan !== 0;
    },
    getDirection() {
      return isPan;
    }
  };
};
const createGesture = (config2) => {
  let hasCapturedPan = false;
  let hasStartedPan = false;
  let hasFiredStart = true;
  let isMoveQueued = false;
  const finalConfig = Object.assign({ disableScroll: false, direction: "x", gesturePriority: 0, passive: true, maxAngle: 40, threshold: 10 }, config2);
  const canStart = finalConfig.canStart;
  const onWillStart = finalConfig.onWillStart;
  const onStart = finalConfig.onStart;
  const onEnd = finalConfig.onEnd;
  const notCaptured = finalConfig.notCaptured;
  const onMove = finalConfig.onMove;
  const threshold2 = finalConfig.threshold;
  const passive = finalConfig.passive;
  const blurOnStart = finalConfig.blurOnStart;
  const detail = {
    type: "pan",
    startX: 0,
    startY: 0,
    startTime: 0,
    currentX: 0,
    currentY: 0,
    velocityX: 0,
    velocityY: 0,
    deltaX: 0,
    deltaY: 0,
    currentTime: 0,
    event: void 0,
    data: void 0
  };
  const pan = createPanRecognizer(finalConfig.direction, finalConfig.threshold, finalConfig.maxAngle);
  const gesture = GESTURE_CONTROLLER.createGesture({
    name: config2.gestureName,
    priority: config2.gesturePriority,
    disableScroll: config2.disableScroll
  });
  const pointerDown = (ev) => {
    const timeStamp = now$4(ev);
    if (hasStartedPan || !hasFiredStart) {
      return false;
    }
    updateDetail(ev, detail);
    detail.startX = detail.currentX;
    detail.startY = detail.currentY;
    detail.startTime = detail.currentTime = timeStamp;
    detail.velocityX = detail.velocityY = detail.deltaX = detail.deltaY = 0;
    detail.event = ev;
    if (canStart && canStart(detail) === false) {
      return false;
    }
    gesture.release();
    if (!gesture.start()) {
      return false;
    }
    hasStartedPan = true;
    if (threshold2 === 0) {
      return tryToCapturePan();
    }
    pan.start(detail.startX, detail.startY);
    return true;
  };
  const pointerMove = (ev) => {
    if (hasCapturedPan) {
      if (!isMoveQueued && hasFiredStart) {
        isMoveQueued = true;
        calcGestureData(detail, ev);
        requestAnimationFrame(fireOnMove);
      }
      return;
    }
    calcGestureData(detail, ev);
    if (pan.detect(detail.currentX, detail.currentY)) {
      if (!pan.isGesture() || !tryToCapturePan()) {
        abortGesture();
      }
    }
  };
  const fireOnMove = () => {
    if (!hasCapturedPan) {
      return;
    }
    isMoveQueued = false;
    if (onMove) {
      onMove(detail);
    }
  };
  const tryToCapturePan = () => {
    if (!gesture.capture()) {
      return false;
    }
    hasCapturedPan = true;
    hasFiredStart = false;
    detail.startX = detail.currentX;
    detail.startY = detail.currentY;
    detail.startTime = detail.currentTime;
    if (onWillStart) {
      onWillStart(detail).then(fireOnStart);
    } else {
      fireOnStart();
    }
    return true;
  };
  const blurActiveElement = () => {
    if (typeof document !== "undefined") {
      const activeElement = document.activeElement;
      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur) {
        activeElement.blur();
      }
    }
  };
  const fireOnStart = () => {
    if (blurOnStart) {
      blurActiveElement();
    }
    if (onStart) {
      onStart(detail);
    }
    hasFiredStart = true;
  };
  const reset = () => {
    hasCapturedPan = false;
    hasStartedPan = false;
    isMoveQueued = false;
    hasFiredStart = true;
    gesture.release();
  };
  const pointerUp = (ev) => {
    const tmpHasCaptured = hasCapturedPan;
    const tmpHasFiredStart = hasFiredStart;
    reset();
    if (!tmpHasFiredStart) {
      return;
    }
    calcGestureData(detail, ev);
    if (tmpHasCaptured) {
      if (onEnd) {
        onEnd(detail);
      }
      return;
    }
    if (notCaptured) {
      notCaptured(detail);
    }
  };
  const pointerEvents = createPointerEvents(finalConfig.el, pointerDown, pointerMove, pointerUp, {
    capture: false,
    passive
  });
  const abortGesture = () => {
    reset();
    pointerEvents.stop();
    if (notCaptured) {
      notCaptured(detail);
    }
  };
  return {
    enable(enable = true) {
      if (!enable) {
        if (hasCapturedPan) {
          pointerUp(void 0);
        }
        reset();
      }
      pointerEvents.enable(enable);
    },
    destroy() {
      gesture.destroy();
      pointerEvents.destroy();
    }
  };
};
const calcGestureData = (detail, ev) => {
  if (!ev) {
    return;
  }
  const prevX = detail.currentX;
  const prevY = detail.currentY;
  const prevT = detail.currentTime;
  updateDetail(ev, detail);
  const currentX = detail.currentX;
  const currentY = detail.currentY;
  const timestamp = detail.currentTime = now$4(ev);
  const timeDelta = timestamp - prevT;
  if (timeDelta > 0 && timeDelta < 100) {
    const velocityX = (currentX - prevX) / timeDelta;
    const velocityY = (currentY - prevY) / timeDelta;
    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;
    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;
  }
  detail.deltaX = currentX - detail.startX;
  detail.deltaY = currentY - detail.startY;
  detail.event = ev;
};
const updateDetail = (ev, detail) => {
  let x2 = 0;
  let y2 = 0;
  if (ev) {
    const changedTouches = ev.changedTouches;
    if (changedTouches && changedTouches.length > 0) {
      const touch = changedTouches[0];
      x2 = touch.clientX;
      y2 = touch.clientY;
    } else if (ev.pageX !== void 0) {
      x2 = ev.pageX;
      y2 = ev.pageY;
    }
  }
  detail.currentX = x2;
  detail.currentY = y2;
};
const now$4 = (ev) => {
  return ev.timeStamp || Date.now();
};
const index2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GESTURE_CONTROLLER,
  createGesture
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
class Config {
  constructor() {
    this.m = /* @__PURE__ */ new Map();
  }
  reset(configObj) {
    this.m = new Map(Object.entries(configObj));
  }
  get(key, fallback) {
    const value = this.m.get(key);
    return value !== void 0 ? value : fallback;
  }
  getBoolean(key, fallback = false) {
    const val = this.m.get(key);
    if (val === void 0) {
      return fallback;
    }
    if (typeof val === "string") {
      return val === "true";
    }
    return !!val;
  }
  getNumber(key, fallback) {
    const val = parseFloat(this.m.get(key));
    return isNaN(val) ? fallback !== void 0 ? fallback : NaN : val;
  }
  set(key, value) {
    this.m.set(key, value);
  }
}
const config$1 = /* @__PURE__ */ new Config();
const configFromSession = (win2) => {
  try {
    const configStr = win2.sessionStorage.getItem(IONIC_SESSION_KEY);
    return configStr !== null ? JSON.parse(configStr) : {};
  } catch (e3) {
    return {};
  }
};
const saveConfig = (win2, c2) => {
  try {
    win2.sessionStorage.setItem(IONIC_SESSION_KEY, JSON.stringify(c2));
  } catch (e3) {
    return;
  }
};
const configFromURL = (win2) => {
  const configObj = {};
  win2.location.search.slice(1).split("&").map((entry) => entry.split("=")).map(([key, value]) => [decodeURIComponent(key), decodeURIComponent(value)]).filter(([key]) => startsWith(key, IONIC_PREFIX)).map(([key, value]) => [key.slice(IONIC_PREFIX.length), value]).forEach(([key, value]) => {
    configObj[key] = value;
  });
  return configObj;
};
const startsWith = (input, search2) => {
  return input.substr(0, search2.length) === search2;
};
const IONIC_PREFIX = "ionic:";
const IONIC_SESSION_KEY = "ionic-persist-config";
const getPlatforms = (win2) => setupPlatforms(win2);
const isPlatform = (winOrPlatform, platform) => {
  if (typeof winOrPlatform === "string") {
    platform = winOrPlatform;
    winOrPlatform = void 0;
  }
  return getPlatforms(winOrPlatform).includes(platform);
};
const setupPlatforms = (win2 = window) => {
  if (typeof win2 === "undefined") {
    return [];
  }
  win2.Ionic = win2.Ionic || {};
  let platforms = win2.Ionic.platforms;
  if (platforms == null) {
    platforms = win2.Ionic.platforms = detectPlatforms(win2);
    platforms.forEach((p2) => win2.document.documentElement.classList.add(`plt-${p2}`));
  }
  return platforms;
};
const detectPlatforms = (win2) => {
  const customPlatformMethods = config$1.get("platform");
  return Object.keys(PLATFORMS_MAP).filter((p2) => {
    const customMethod = customPlatformMethods === null || customPlatformMethods === void 0 ? void 0 : customPlatformMethods[p2];
    return typeof customMethod === "function" ? customMethod(win2) : PLATFORMS_MAP[p2](win2);
  });
};
const isMobileWeb = (win2) => isMobile(win2) && !isHybrid(win2);
const isIpad = (win2) => {
  if (testUserAgent(win2, /iPad/i)) {
    return true;
  }
  if (testUserAgent(win2, /Macintosh/i) && isMobile(win2)) {
    return true;
  }
  return false;
};
const isIphone = (win2) => testUserAgent(win2, /iPhone/i);
const isIOS = (win2) => testUserAgent(win2, /iPhone|iPod/i) || isIpad(win2);
const isAndroid = (win2) => testUserAgent(win2, /android|sink/i);
const isAndroidTablet = (win2) => {
  return isAndroid(win2) && !testUserAgent(win2, /mobile/i);
};
const isPhablet = (win2) => {
  const width = win2.innerWidth;
  const height = win2.innerHeight;
  const smallest = Math.min(width, height);
  const largest = Math.max(width, height);
  return smallest > 390 && smallest < 520 && largest > 620 && largest < 800;
};
const isTablet = (win2) => {
  const width = win2.innerWidth;
  const height = win2.innerHeight;
  const smallest = Math.min(width, height);
  const largest = Math.max(width, height);
  return isIpad(win2) || isAndroidTablet(win2) || smallest > 460 && smallest < 820 && largest > 780 && largest < 1400;
};
const isMobile = (win2) => matchMedia$1(win2, "(any-pointer:coarse)");
const isDesktop = (win2) => !isMobile(win2);
const isHybrid = (win2) => isCordova(win2) || isCapacitorNative(win2);
const isCordova = (win2) => !!(win2["cordova"] || win2["phonegap"] || win2["PhoneGap"]);
const isCapacitorNative = (win2) => {
  const capacitor = win2["Capacitor"];
  return !!(capacitor === null || capacitor === void 0 ? void 0 : capacitor.isNative);
};
const isElectron = (win2) => testUserAgent(win2, /electron/i);
const isPWA = (win2) => {
  var _a2;
  return !!(((_a2 = win2.matchMedia) === null || _a2 === void 0 ? void 0 : _a2.call(win2, "(display-mode: standalone)").matches) || win2.navigator.standalone);
};
const testUserAgent = (win2, expr) => expr.test(win2.navigator.userAgent);
const matchMedia$1 = (win2, query) => {
  var _a2;
  return (_a2 = win2.matchMedia) === null || _a2 === void 0 ? void 0 : _a2.call(win2, query).matches;
};
const PLATFORMS_MAP = {
  ipad: isIpad,
  iphone: isIphone,
  ios: isIOS,
  android: isAndroid,
  phablet: isPhablet,
  tablet: isTablet,
  cordova: isCordova,
  capacitor: isCapacitorNative,
  electron: isElectron,
  pwa: isPWA,
  mobile: isMobile,
  mobileweb: isMobileWeb,
  desktop: isDesktop,
  hybrid: isHybrid
};
let defaultMode;
const getIonMode$2 = (ref) => {
  return ref && getMode(ref) || defaultMode;
};
const initialize = (userConfig = {}) => {
  if (typeof window === "undefined") {
    return;
  }
  const doc2 = window.document;
  const win2 = window;
  const Ionic = win2.Ionic = win2.Ionic || {};
  const platformHelpers = {};
  if (userConfig._ael) {
    platformHelpers.ael = userConfig._ael;
  }
  if (userConfig._rel) {
    platformHelpers.rel = userConfig._rel;
  }
  if (userConfig._ce) {
    platformHelpers.ce = userConfig._ce;
  }
  setPlatformHelpers(platformHelpers);
  const configObj = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, configFromSession(win2)), { persistConfig: false }), Ionic.config), configFromURL(win2)), userConfig);
  config$1.reset(configObj);
  if (config$1.getBoolean("persistConfig")) {
    saveConfig(win2, configObj);
  }
  setupPlatforms(win2);
  Ionic.config = config$1;
  Ionic.mode = defaultMode = config$1.get("mode", doc2.documentElement.getAttribute("mode") || (isPlatform(win2, "ios") ? "ios" : "md"));
  config$1.set("mode", defaultMode);
  doc2.documentElement.setAttribute("mode", defaultMode);
  doc2.documentElement.classList.add(defaultMode);
  if (config$1.getBoolean("_testing")) {
    config$1.set("animated", false);
  }
  const isIonicElement = (elm) => {
    var _a2;
    return (_a2 = elm.tagName) === null || _a2 === void 0 ? void 0 : _a2.startsWith("ION-");
  };
  const isAllowedIonicModeValue = (elmMode) => ["ios", "md"].includes(elmMode);
  setMode((elm) => {
    while (elm) {
      const elmMode = elm.mode || elm.getAttribute("mode");
      if (elmMode) {
        if (isAllowedIonicModeValue(elmMode)) {
          return elmMode;
        } else if (isIonicElement(elm)) {
          console.warn('Invalid ionic mode: "' + elmMode + '", expected: "ios" or "md"');
        }
      }
      elm = elm.parentElement;
    }
    return defaultMode;
  });
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const sanitizeDOMString = (untrustedString) => {
  try {
    if (untrustedString instanceof IonicSafeString) {
      return untrustedString.value;
    }
    if (!isSanitizerEnabled() || typeof untrustedString !== "string" || untrustedString === "") {
      return untrustedString;
    }
    if (untrustedString.includes("onload=")) {
      return "";
    }
    const documentFragment = document.createDocumentFragment();
    const workingDiv = document.createElement("div");
    documentFragment.appendChild(workingDiv);
    workingDiv.innerHTML = untrustedString;
    blockedTags.forEach((blockedTag) => {
      const getElementsToRemove = documentFragment.querySelectorAll(blockedTag);
      for (let elementIndex2 = getElementsToRemove.length - 1; elementIndex2 >= 0; elementIndex2--) {
        const element = getElementsToRemove[elementIndex2];
        if (element.parentNode) {
          element.parentNode.removeChild(element);
        } else {
          documentFragment.removeChild(element);
        }
        const childElements = getElementChildren(element);
        for (let childIndex = 0; childIndex < childElements.length; childIndex++) {
          sanitizeElement(childElements[childIndex]);
        }
      }
    });
    const dfChildren = getElementChildren(documentFragment);
    for (let childIndex = 0; childIndex < dfChildren.length; childIndex++) {
      sanitizeElement(dfChildren[childIndex]);
    }
    const fragmentDiv = document.createElement("div");
    fragmentDiv.appendChild(documentFragment);
    const getInnerDiv = fragmentDiv.querySelector("div");
    return getInnerDiv !== null ? getInnerDiv.innerHTML : fragmentDiv.innerHTML;
  } catch (err) {
    console.error(err);
    return "";
  }
};
const sanitizeElement = (element) => {
  if (element.nodeType && element.nodeType !== 1) {
    return;
  }
  if (typeof NamedNodeMap !== "undefined" && !(element.attributes instanceof NamedNodeMap)) {
    element.remove();
    return;
  }
  for (let i = element.attributes.length - 1; i >= 0; i--) {
    const attribute = element.attributes.item(i);
    const attributeName = attribute.name;
    if (!allowedAttributes.includes(attributeName.toLowerCase())) {
      element.removeAttribute(attributeName);
      continue;
    }
    const attributeValue = attribute.value;
    const propertyValue = element[attributeName];
    if (attributeValue != null && attributeValue.toLowerCase().includes("javascript:") || propertyValue != null && propertyValue.toLowerCase().includes("javascript:")) {
      element.removeAttribute(attributeName);
    }
  }
  const childElements = getElementChildren(element);
  for (let i = 0; i < childElements.length; i++) {
    sanitizeElement(childElements[i]);
  }
};
const getElementChildren = (el2) => {
  return el2.children != null ? el2.children : el2.childNodes;
};
const isSanitizerEnabled = () => {
  var _a2;
  const win2 = window;
  const config2 = (_a2 = win2 === null || win2 === void 0 ? void 0 : win2.Ionic) === null || _a2 === void 0 ? void 0 : _a2.config;
  if (config2) {
    if (config2.get) {
      return config2.get("sanitizerEnabled", true);
    } else {
      return config2.sanitizerEnabled === true || config2.sanitizerEnabled === void 0;
    }
  }
  return true;
};
const allowedAttributes = ["class", "id", "href", "src", "name", "slot"];
const blockedTags = ["script", "style", "iframe", "meta", "link", "object", "embed"];
class IonicSafeString {
  constructor(value) {
    this.value = value;
  }
}
const ENABLE_HTML_CONTENT_DEFAULT = false;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const blockHardwareBackButton = () => {
  document.addEventListener("backbutton", () => {
  });
};
const startHardwareBackButton = () => {
  const doc2 = document;
  let busy = false;
  doc2.addEventListener("backbutton", () => {
    if (busy) {
      return;
    }
    let index3 = 0;
    let handlers = [];
    const ev = new CustomEvent("ionBackButton", {
      bubbles: false,
      detail: {
        register(priority, handler) {
          handlers.push({ priority, handler, id: index3++ });
        }
      }
    });
    doc2.dispatchEvent(ev);
    const executeAction = async (handlerRegister) => {
      try {
        if (handlerRegister === null || handlerRegister === void 0 ? void 0 : handlerRegister.handler) {
          const result = handlerRegister.handler(processHandlers);
          if (result != null) {
            await result;
          }
        }
      } catch (e3) {
        console.error(e3);
      }
    };
    const processHandlers = () => {
      if (handlers.length > 0) {
        let selectedHandler = {
          priority: Number.MIN_SAFE_INTEGER,
          handler: () => void 0,
          id: -1
        };
        handlers.forEach((handler) => {
          if (handler.priority >= selectedHandler.priority) {
            selectedHandler = handler;
          }
        });
        busy = true;
        handlers = handlers.filter((handler) => handler.id !== selectedHandler.id);
        executeAction(selectedHandler).then(() => busy = false);
      }
    };
    processHandlers();
  });
};
const OVERLAY_BACK_BUTTON_PRIORITY = 100;
const MENU_BACK_BUTTON_PRIORITY = 99;
const hardwareBackButton = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MENU_BACK_BUTTON_PRIORITY,
  OVERLAY_BACK_BUTTON_PRIORITY,
  blockHardwareBackButton,
  startHardwareBackButton
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const baseAnimation = (isIos) => {
  return createAnimation().duration(isIos ? 400 : 300);
};
const menuOverlayAnimation = (menu2) => {
  let closedX;
  let openedX;
  const width = menu2.width + 8;
  const menuAnimation = createAnimation();
  const backdropAnimation = createAnimation();
  if (menu2.isEndSide) {
    closedX = width + "px";
    openedX = "0px";
  } else {
    closedX = -width + "px";
    openedX = "0px";
  }
  menuAnimation.addElement(menu2.menuInnerEl).fromTo("transform", `translateX(${closedX})`, `translateX(${openedX})`);
  const mode = getIonMode$2(menu2);
  const isIos = mode === "ios";
  const opacity = isIos ? 0.2 : 0.25;
  backdropAnimation.addElement(menu2.backdropEl).fromTo("opacity", 0.01, opacity);
  return baseAnimation(isIos).addAnimation([menuAnimation, backdropAnimation]);
};
const menuPushAnimation = (menu2) => {
  let contentOpenedX;
  let menuClosedX;
  const mode = getIonMode$2(menu2);
  const width = menu2.width;
  if (menu2.isEndSide) {
    contentOpenedX = -width + "px";
    menuClosedX = width + "px";
  } else {
    contentOpenedX = width + "px";
    menuClosedX = -width + "px";
  }
  const menuAnimation = createAnimation().addElement(menu2.menuInnerEl).fromTo("transform", `translateX(${menuClosedX})`, "translateX(0px)");
  const contentAnimation = createAnimation().addElement(menu2.contentEl).fromTo("transform", "translateX(0px)", `translateX(${contentOpenedX})`);
  const backdropAnimation = createAnimation().addElement(menu2.backdropEl).fromTo("opacity", 0.01, 0.32);
  return baseAnimation(mode === "ios").addAnimation([menuAnimation, contentAnimation, backdropAnimation]);
};
const menuRevealAnimation = (menu2) => {
  const mode = getIonMode$2(menu2);
  const openedX = menu2.width * (menu2.isEndSide ? -1 : 1) + "px";
  const contentOpen = createAnimation().addElement(menu2.contentEl).fromTo("transform", "translateX(0px)", `translateX(${openedX})`);
  return baseAnimation(mode === "ios").addAnimation(contentOpen);
};
const createMenuController = () => {
  const menuAnimations = /* @__PURE__ */ new Map();
  const menus = [];
  const open = async (menu2) => {
    const menuEl = await get3(menu2);
    if (menuEl) {
      return menuEl.open();
    }
    return false;
  };
  const close2 = async (menu2) => {
    const menuEl = await (menu2 !== void 0 ? get3(menu2) : getOpen());
    if (menuEl !== void 0) {
      return menuEl.close();
    }
    return false;
  };
  const toggle = async (menu2) => {
    const menuEl = await get3(menu2);
    if (menuEl) {
      return menuEl.toggle();
    }
    return false;
  };
  const enable = async (shouldEnable, menu2) => {
    const menuEl = await get3(menu2);
    if (menuEl) {
      menuEl.disabled = !shouldEnable;
    }
    return menuEl;
  };
  const swipeGesture = async (shouldEnable, menu2) => {
    const menuEl = await get3(menu2);
    if (menuEl) {
      menuEl.swipeGesture = shouldEnable;
    }
    return menuEl;
  };
  const isOpen = async (menu2) => {
    if (menu2 != null) {
      const menuEl = await get3(menu2);
      return menuEl !== void 0 && menuEl.isOpen();
    } else {
      const menuEl = await getOpen();
      return menuEl !== void 0;
    }
  };
  const isEnabled = async (menu2) => {
    const menuEl = await get3(menu2);
    if (menuEl) {
      return !menuEl.disabled;
    }
    return false;
  };
  const get3 = async (menu2) => {
    await waitUntilReady();
    if (menu2 === "start" || menu2 === "end") {
      const menuRef = find3((m2) => m2.side === menu2 && !m2.disabled);
      if (menuRef) {
        return menuRef;
      }
      return find3((m2) => m2.side === menu2);
    } else if (menu2 != null) {
      return find3((m2) => m2.menuId === menu2);
    }
    const menuEl = find3((m2) => !m2.disabled);
    if (menuEl) {
      return menuEl;
    }
    return menus.length > 0 ? menus[0].el : void 0;
  };
  const getOpen = async () => {
    await waitUntilReady();
    return _getOpenSync();
  };
  const getMenus = async () => {
    await waitUntilReady();
    return getMenusSync();
  };
  const isAnimating = async () => {
    await waitUntilReady();
    return isAnimatingSync();
  };
  const registerAnimation = (name, animation2) => {
    menuAnimations.set(name, animation2);
  };
  const _register = (menu2) => {
    if (menus.indexOf(menu2) < 0) {
      if (!menu2.disabled) {
        _setActiveMenu(menu2);
      }
      menus.push(menu2);
    }
  };
  const _unregister = (menu2) => {
    const index3 = menus.indexOf(menu2);
    if (index3 > -1) {
      menus.splice(index3, 1);
    }
  };
  const _setActiveMenu = (menu2) => {
    const side = menu2.side;
    menus.filter((m2) => m2.side === side && m2 !== menu2).forEach((m2) => m2.disabled = true);
  };
  const _setOpen = async (menu2, shouldOpen, animated) => {
    if (isAnimatingSync()) {
      return false;
    }
    if (shouldOpen) {
      const openedMenu = await getOpen();
      if (openedMenu && menu2.el !== openedMenu) {
        await openedMenu.setOpen(false, false);
      }
    }
    return menu2._setOpen(shouldOpen, animated);
  };
  const _createAnimation = (type3, menuCmp) => {
    const animationBuilder = menuAnimations.get(type3);
    if (!animationBuilder) {
      throw new Error("animation not registered");
    }
    const animation2 = animationBuilder(menuCmp);
    return animation2;
  };
  const _getOpenSync = () => {
    return find3((m2) => m2._isOpen);
  };
  const getMenusSync = () => {
    return menus.map((menu2) => menu2.el);
  };
  const isAnimatingSync = () => {
    return menus.some((menu2) => menu2.isAnimating);
  };
  const find3 = (predicate3) => {
    const instance = menus.find(predicate3);
    if (instance !== void 0) {
      return instance.el;
    }
    return void 0;
  };
  const waitUntilReady = () => {
    return Promise.all(Array.from(document.querySelectorAll("ion-menu")).map((menu2) => new Promise((resolve) => componentOnReady(menu2, resolve))));
  };
  registerAnimation("reveal", menuRevealAnimation);
  registerAnimation("push", menuPushAnimation);
  registerAnimation("overlay", menuOverlayAnimation);
  if (typeof document !== "undefined") {
    document.addEventListener("ionBackButton", (ev) => {
      const openMenu = _getOpenSync();
      if (openMenu) {
        ev.detail.register(MENU_BACK_BUTTON_PRIORITY, () => {
          return openMenu.close();
        });
      }
    });
  }
  return {
    registerAnimation,
    get: get3,
    getMenus,
    getOpen,
    isEnabled,
    swipeGesture,
    isAnimating,
    isOpen,
    enable,
    toggle,
    close: close2,
    open,
    _getOpenSync,
    _createAnimation,
    _register,
    _unregister,
    _setOpen,
    _setActiveMenu
  };
};
const menuController = /* @__PURE__ */ createMenuController();
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const attachComponent = async (delegate, container, component, cssClasses, componentProps, inline) => {
  var _a2;
  if (delegate) {
    return delegate.attachViewToDom(container, component, componentProps, cssClasses);
  }
  if (!inline && typeof component !== "string" && !(component instanceof HTMLElement)) {
    throw new Error("framework delegate is missing");
  }
  const el2 = typeof component === "string" ? (_a2 = container.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.createElement(component) : component;
  if (cssClasses) {
    cssClasses.forEach((c2) => el2.classList.add(c2));
  }
  if (componentProps) {
    Object.assign(el2, componentProps);
  }
  container.appendChild(el2);
  await new Promise((resolve) => componentOnReady(el2, resolve));
  return el2;
};
const detachComponent = (delegate, element) => {
  if (element) {
    if (delegate) {
      const container = element.parentElement;
      return delegate.removeViewFromDom(container, element);
    }
    element.remove();
  }
  return Promise.resolve();
};
const CoreDelegate = () => {
  let BaseComponent;
  let Reference;
  const attachViewToDom = async (parentElement, userComponent, userComponentProps = {}, cssClasses = []) => {
    var _a2, _b;
    BaseComponent = parentElement;
    if (userComponent) {
      const el2 = typeof userComponent === "string" ? (_a2 = BaseComponent.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.createElement(userComponent) : userComponent;
      cssClasses.forEach((c2) => el2.classList.add(c2));
      Object.assign(el2, userComponentProps);
      BaseComponent.appendChild(el2);
      await new Promise((resolve) => componentOnReady(el2, resolve));
    } else if (BaseComponent.children.length > 0 && (BaseComponent.tagName === "ION-MODAL" || BaseComponent.tagName === "ION-POPOVER")) {
      const root2 = BaseComponent.children[0];
      if (!root2.classList.contains("ion-delegate-host")) {
        const el2 = (_b = BaseComponent.ownerDocument) === null || _b === void 0 ? void 0 : _b.createElement("div");
        el2.classList.add("ion-delegate-host");
        cssClasses.forEach((c2) => el2.classList.add(c2));
        el2.append(...BaseComponent.children);
        BaseComponent.appendChild(el2);
      }
    }
    const app = document.querySelector("ion-app") || document.body;
    Reference = document.createComment("ionic teleport");
    BaseComponent.parentNode.insertBefore(Reference, BaseComponent);
    app.appendChild(BaseComponent);
    return BaseComponent;
  };
  const removeViewFromDom = () => {
    if (BaseComponent && Reference) {
      Reference.parentNode.insertBefore(BaseComponent, Reference);
      Reference.remove();
    }
    return Promise.resolve();
  };
  return { attachViewToDom, removeViewFromDom };
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const printIonWarning = (message, ...params) => {
  return console.warn(`[Ionic Warning]: ${message}`, ...params);
};
const printIonError = (message, ...params) => {
  return console.error(`[Ionic Error]: ${message}`, ...params);
};
const printRequiredElementError = (el2, ...targetSelectors) => {
  return console.error(`<${el2.tagName.toLowerCase()}> must be used inside ${targetSelectors.join(" or ")}.`);
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
let lastOverlayIndex = 0;
let lastId = 0;
const activeAnimations = /* @__PURE__ */ new WeakMap();
const createController = (tagName) => {
  return {
    create(options) {
      return createOverlay(tagName, options);
    },
    dismiss(data2, role, id2) {
      return dismissOverlay(document, data2, role, tagName, id2);
    },
    async getTop() {
      return getOverlay(document, tagName);
    }
  };
};
const alertController = /* @__PURE__ */ createController("ion-alert");
const actionSheetController = /* @__PURE__ */ createController("ion-action-sheet");
const loadingController = /* @__PURE__ */ createController("ion-loading");
const popoverController = /* @__PURE__ */ createController("ion-popover");
const toastController = /* @__PURE__ */ createController("ion-toast");
const prepareOverlay = (el2) => {
  if (typeof document !== "undefined") {
    connectListeners(document);
  }
  const overlayIndex = lastOverlayIndex++;
  el2.overlayIndex = overlayIndex;
};
const setOverlayId = (el2) => {
  if (!el2.hasAttribute("id")) {
    el2.id = `ion-overlay-${++lastId}`;
  }
  return el2.id;
};
const createOverlay = (tagName, opts) => {
  if (typeof window !== "undefined" && typeof window.customElements !== "undefined") {
    return window.customElements.whenDefined(tagName).then(() => {
      const element = document.createElement(tagName);
      element.classList.add("overlay-hidden");
      Object.assign(element, Object.assign(Object.assign({}, opts), { hasController: true }));
      getAppRoot(document).appendChild(element);
      return new Promise((resolve) => componentOnReady(element, resolve));
    });
  }
  return Promise.resolve();
};
const focusableQueryString$1 = '[tabindex]:not([tabindex^="-"]):not([hidden]):not([disabled]), input:not([type=hidden]):not([tabindex^="-"]):not([hidden]):not([disabled]), textarea:not([tabindex^="-"]):not([hidden]):not([disabled]), button:not([tabindex^="-"]):not([hidden]):not([disabled]), select:not([tabindex^="-"]):not([hidden]):not([disabled]), .ion-focusable:not([tabindex^="-"]):not([hidden]):not([disabled]), .ion-focusable[disabled="false"]:not([tabindex^="-"]):not([hidden])';
const focusFirstDescendant = (ref, overlay) => {
  let firstInput = ref.querySelector(focusableQueryString$1);
  const shadowRoot = firstInput === null || firstInput === void 0 ? void 0 : firstInput.shadowRoot;
  if (shadowRoot) {
    firstInput = shadowRoot.querySelector(focusableQueryString$1) || firstInput;
  }
  if (firstInput) {
    focusElement(firstInput);
  } else {
    overlay.focus();
  }
};
const isOverlayHidden = (overlay) => overlay.classList.contains("overlay-hidden");
const focusLastDescendant = (ref, overlay) => {
  const inputs = Array.from(ref.querySelectorAll(focusableQueryString$1));
  let lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;
  const shadowRoot = lastInput === null || lastInput === void 0 ? void 0 : lastInput.shadowRoot;
  if (shadowRoot) {
    lastInput = shadowRoot.querySelector(focusableQueryString$1) || lastInput;
  }
  if (lastInput) {
    lastInput.focus();
  } else {
    overlay.focus();
  }
};
const trapKeyboardFocus = (ev, doc2) => {
  const lastOverlay = getOverlay(doc2, "ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover");
  const target = ev.target;
  if (!lastOverlay || !target) {
    return;
  }
  if (lastOverlay.classList.contains("ion-disable-focus-trap")) {
    return;
  }
  const trapScopedFocus = () => {
    if (lastOverlay === target) {
      lastOverlay.lastFocus = void 0;
    } else {
      const overlayRoot = getElementRoot(lastOverlay);
      if (!overlayRoot.contains(target)) {
        return;
      }
      const overlayWrapper = overlayRoot.querySelector(".ion-overlay-wrapper");
      if (!overlayWrapper) {
        return;
      }
      if (overlayWrapper.contains(target)) {
        lastOverlay.lastFocus = target;
      } else {
        const lastFocus = lastOverlay.lastFocus;
        focusFirstDescendant(overlayWrapper, lastOverlay);
        if (lastFocus === doc2.activeElement) {
          focusLastDescendant(overlayWrapper, lastOverlay);
        }
        lastOverlay.lastFocus = doc2.activeElement;
      }
    }
  };
  const trapShadowFocus = () => {
    if (lastOverlay.contains(target)) {
      lastOverlay.lastFocus = target;
    } else {
      const lastFocus = lastOverlay.lastFocus;
      focusFirstDescendant(lastOverlay, lastOverlay);
      if (lastFocus === doc2.activeElement) {
        focusLastDescendant(lastOverlay, lastOverlay);
      }
      lastOverlay.lastFocus = doc2.activeElement;
    }
  };
  if (lastOverlay.shadowRoot) {
    trapShadowFocus();
  } else {
    trapScopedFocus();
  }
};
const connectListeners = (doc2) => {
  if (lastOverlayIndex === 0) {
    lastOverlayIndex = 1;
    doc2.addEventListener("focus", (ev) => {
      trapKeyboardFocus(ev, doc2);
    }, true);
    doc2.addEventListener("ionBackButton", (ev) => {
      const lastOverlay = getOverlay(doc2);
      if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {
        ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {
          return lastOverlay.dismiss(void 0, BACKDROP);
        });
      }
    });
    doc2.addEventListener("keydown", (ev) => {
      if (ev.key === "Escape") {
        const lastOverlay = getOverlay(doc2);
        if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {
          lastOverlay.dismiss(void 0, BACKDROP);
        }
      }
    });
  }
};
const dismissOverlay = (doc2, data2, role, overlayTag, id2) => {
  const overlay = getOverlay(doc2, overlayTag, id2);
  if (!overlay) {
    return Promise.reject("overlay does not exist");
  }
  return overlay.dismiss(data2, role);
};
const getOverlays = (doc2, selector) => {
  if (selector === void 0) {
    selector = "ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast";
  }
  return Array.from(doc2.querySelectorAll(selector)).filter((c2) => c2.overlayIndex > 0);
};
const getOverlay = (doc2, overlayTag, id2) => {
  const overlays = getOverlays(doc2, overlayTag).filter((o3) => !isOverlayHidden(o3));
  return id2 === void 0 ? overlays[overlays.length - 1] : overlays.find((o3) => o3.id === id2);
};
const setRootAriaHidden = (hidden = false) => {
  const root2 = getAppRoot(document);
  const viewContainer = root2.querySelector("ion-router-outlet, ion-nav, #ion-view-container-root");
  if (!viewContainer) {
    return;
  }
  if (hidden) {
    viewContainer.setAttribute("aria-hidden", "true");
  } else {
    viewContainer.removeAttribute("aria-hidden");
  }
};
const present = async (overlay, name, iosEnterAnimation2, mdEnterAnimation2, opts) => {
  var _a2, _b;
  if (overlay.presented) {
    return;
  }
  setRootAriaHidden(true);
  overlay.presented = true;
  overlay.willPresent.emit();
  (_a2 = overlay.willPresentShorthand) === null || _a2 === void 0 ? void 0 : _a2.emit();
  const mode = getIonMode$2(overlay);
  const animationBuilder = overlay.enterAnimation ? overlay.enterAnimation : config$1.get(name, mode === "ios" ? iosEnterAnimation2 : mdEnterAnimation2);
  const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);
  if (completed) {
    overlay.didPresent.emit();
    (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();
  }
  if (overlay.el.tagName !== "ION-TOAST") {
    focusPreviousElementOnDismiss(overlay.el);
  }
  if (overlay.keyboardClose && (document.activeElement === null || !overlay.el.contains(document.activeElement))) {
    overlay.el.focus();
  }
};
const focusPreviousElementOnDismiss = async (overlayEl) => {
  let previousElement = document.activeElement;
  if (!previousElement) {
    return;
  }
  const shadowRoot = previousElement === null || previousElement === void 0 ? void 0 : previousElement.shadowRoot;
  if (shadowRoot) {
    previousElement = shadowRoot.querySelector(focusableQueryString$1) || previousElement;
  }
  await overlayEl.onDidDismiss();
  previousElement.focus();
};
const dismiss = async (overlay, data2, role, name, iosLeaveAnimation2, mdLeaveAnimation2, opts) => {
  var _a2, _b;
  if (!overlay.presented) {
    return false;
  }
  setRootAriaHidden(false);
  overlay.presented = false;
  try {
    overlay.el.style.setProperty("pointer-events", "none");
    overlay.willDismiss.emit({ data: data2, role });
    (_a2 = overlay.willDismissShorthand) === null || _a2 === void 0 ? void 0 : _a2.emit({ data: data2, role });
    const mode = getIonMode$2(overlay);
    const animationBuilder = overlay.leaveAnimation ? overlay.leaveAnimation : config$1.get(name, mode === "ios" ? iosLeaveAnimation2 : mdLeaveAnimation2);
    if (role !== GESTURE) {
      await overlayAnimation(overlay, animationBuilder, overlay.el, opts);
    }
    overlay.didDismiss.emit({ data: data2, role });
    (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data: data2, role });
    activeAnimations.delete(overlay);
    overlay.el.classList.add("overlay-hidden");
    overlay.el.style.removeProperty("pointer-events");
    if (overlay.el.lastFocus !== void 0) {
      overlay.el.lastFocus = void 0;
    }
  } catch (err) {
    console.error(err);
  }
  overlay.el.remove();
  return true;
};
const getAppRoot = (doc2) => {
  return doc2.querySelector("ion-app") || doc2.body;
};
const overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {
  baseEl.classList.remove("overlay-hidden");
  const aniRoot = overlay.el;
  const animation2 = animationBuilder(aniRoot, opts);
  if (!overlay.animated || !config$1.getBoolean("animated", true)) {
    animation2.duration(0);
  }
  if (overlay.keyboardClose) {
    animation2.beforeAddWrite(() => {
      const activeElement = baseEl.ownerDocument.activeElement;
      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.matches("input,ion-input, ion-textarea")) {
        activeElement.blur();
      }
    });
  }
  const activeAni = activeAnimations.get(overlay) || [];
  activeAnimations.set(overlay, [...activeAni, animation2]);
  await animation2.play();
  return true;
};
const eventMethod = (element, eventName) => {
  let resolve;
  const promise3 = new Promise((r2) => resolve = r2);
  onceEvent(element, eventName, (event) => {
    resolve(event.detail);
  });
  return promise3;
};
const onceEvent = (element, eventName, callback) => {
  const handler = (ev) => {
    removeEventListener(element, eventName, handler);
    callback(ev);
  };
  addEventListener$1(element, eventName, handler);
};
const isCancel$2 = (role) => {
  return role === "cancel" || role === BACKDROP;
};
const defaultGate = (h2) => h2();
const safeCall$1 = (handler, arg) => {
  if (typeof handler === "function") {
    const jmp = config$1.get("_zoneGate", defaultGate);
    return jmp(() => {
      try {
        return handler(arg);
      } catch (e3) {
        throw e3;
      }
    });
  }
  return void 0;
};
const BACKDROP = "backdrop";
const GESTURE = "gesture";
const createDelegateController = (ref) => {
  let inline = false;
  let workingDelegate;
  const coreDelegate = CoreDelegate();
  const getDelegate = (force = false) => {
    if (workingDelegate && !force) {
      return {
        delegate: workingDelegate,
        inline
      };
    }
    const { el: el2, hasController, delegate } = ref;
    const parentEl = el2.parentNode;
    inline = parentEl !== null && !hasController;
    workingDelegate = inline ? delegate || coreDelegate : delegate;
    return { inline, delegate: workingDelegate };
  };
  const attachViewToDom = async (component) => {
    const { delegate } = getDelegate(true);
    if (delegate) {
      return await delegate.attachViewToDom(ref.el, component);
    }
    const { hasController } = ref;
    if (hasController && component !== void 0) {
      throw new Error("framework delegate is missing");
    }
    return null;
  };
  const removeViewFromDom = () => {
    const { delegate } = getDelegate();
    if (delegate && ref.el !== void 0) {
      delegate.removeViewFromDom(ref.el.parentElement, ref.el);
    }
  };
  return {
    attachViewToDom,
    removeViewFromDom
  };
};
const createTriggerController = () => {
  let destroyTriggerInteraction;
  const removeClickListener = () => {
    if (destroyTriggerInteraction) {
      destroyTriggerInteraction();
      destroyTriggerInteraction = void 0;
    }
  };
  const addClickListener = (el2, trigger) => {
    removeClickListener();
    const triggerEl = trigger !== void 0 ? document.getElementById(trigger) : null;
    if (!triggerEl) {
      printIonWarning(`A trigger element with the ID "${trigger}" was not found in the DOM. The trigger element must be in the DOM when the "trigger" property is set on an overlay component.`, el2);
      return;
    }
    const configureTriggerInteraction2 = (targetEl, overlayEl) => {
      const openOverlay = () => {
        overlayEl.present();
      };
      targetEl.addEventListener("click", openOverlay);
      return () => {
        targetEl.removeEventListener("click", openOverlay);
      };
    };
    destroyTriggerInteraction = configureTriggerInteraction2(triggerEl, el2);
  };
  return {
    addClickListener,
    removeClickListener
  };
};
function __rest$1(s2, e3) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const arrowBackSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='square' stroke-miterlimit='10' stroke-width='48' d='M244 400L100 256l144-144M120 256h292' class='ionicon-fill-none'/></svg>";
const caretDownSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M64 144l192 224 192-224H64z'/></svg>";
const caretUpSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M448 368L256 144 64 368h384z'/></svg>";
const checkmarkOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' d='M416 128L192 384l-96-96' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const chevronBack = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M328 112L184 256l144 144' class='ionicon-fill-none'/></svg>";
const chevronDown = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M112 184l144 144 144-144' class='ionicon-fill-none'/></svg>";
const chevronExpand = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M136 208l120-104 120 104M136 304l120 104 120-104' stroke-width='48' stroke-linecap='round' stroke-linejoin='round' class='ionicon-fill-none'/></svg>";
const chevronForward = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M184 112l144 144-144 144' class='ionicon-fill-none'/></svg>";
const close$1 = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z'/></svg>";
const closeCircle$1 = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm75.31 260.69a16 16 0 11-22.62 22.62L256 278.63l-52.69 52.68a16 16 0 01-22.62-22.62L233.37 256l-52.68-52.69a16 16 0 0122.62-22.62L256 233.37l52.69-52.68a16 16 0 0122.62 22.62L278.63 256z'/></svg>";
const closeSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M400 145.49L366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49z'/></svg>";
const ellipseOutline$1 = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><circle cx='256' cy='256' r='192' stroke-linecap='round' stroke-linejoin='round' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const removeOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' d='M400 256H112' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const searchOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M221.09 64a157.09 157.09 0 10157.09 157.09A157.1 157.1 0 00221.09 64z' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><path stroke-linecap='round' stroke-miterlimit='10' d='M338.29 338.29L448 448' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const searchSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M464 428L339.92 303.9a160.48 160.48 0 0030.72-94.58C370.64 120.37 298.27 48 209.32 48S48 120.37 48 209.32s72.37 161.32 161.32 161.32a160.48 160.48 0 0094.58-30.72L428 464zM209.32 319.69a110.38 110.38 0 11110.37-110.37 110.5 110.5 0 01-110.37 110.37z'/></svg>";
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
let CACHED_MAP$1;
const getIconMap$1 = () => {
  if (typeof window === "undefined") {
    return /* @__PURE__ */ new Map();
  } else {
    if (!CACHED_MAP$1) {
      const win2 = window;
      win2.Ionicons = win2.Ionicons || {};
      CACHED_MAP$1 = win2.Ionicons.map = win2.Ionicons.map || /* @__PURE__ */ new Map();
    }
    return CACHED_MAP$1;
  }
};
const getUrl$1 = (i) => {
  let url = getSrc$1(i.src);
  if (url) {
    return url;
  }
  url = getName$1(i.name, i.icon, i.mode, i.ios, i.md);
  if (url) {
    return getNamedUrl$1(url);
  }
  if (i.icon) {
    url = getSrc$1(i.icon);
    if (url) {
      return url;
    }
    url = getSrc$1(i.icon[i.mode]);
    if (url) {
      return url;
    }
  }
  return null;
};
const getNamedUrl$1 = (iconName) => {
  const url = getIconMap$1().get(iconName);
  if (url) {
    return url;
  }
  return getAssetPath$1(`svg/${iconName}.svg`);
};
const getName$1 = (iconName, icon, mode, ios, md2) => {
  mode = (mode && toLower$1(mode)) === "ios" ? "ios" : "md";
  if (ios && mode === "ios") {
    iconName = toLower$1(ios);
  } else if (md2 && mode === "md") {
    iconName = toLower$1(md2);
  } else {
    if (!iconName && icon && !isSrc$1(icon)) {
      iconName = icon;
    }
    if (isStr$1(iconName)) {
      iconName = toLower$1(iconName);
    }
  }
  if (!isStr$1(iconName) || iconName.trim() === "") {
    return null;
  }
  const invalidChars = iconName.replace(/[a-z]|-|\d/gi, "");
  if (invalidChars !== "") {
    return null;
  }
  return iconName;
};
const getSrc$1 = (src) => {
  if (isStr$1(src)) {
    src = src.trim();
    if (isSrc$1(src)) {
      return src;
    }
  }
  return null;
};
const isSrc$1 = (str) => str.length > 0 && /(\/|\.)/.test(str);
const isStr$1 = (val) => typeof val === "string";
const toLower$1 = (val) => val.toLowerCase();
const inheritAttributes$1 = (el2, attributes = []) => {
  const attributeObject = {};
  attributes.forEach((attr) => {
    if (el2.hasAttribute(attr)) {
      const value = el2.getAttribute(attr);
      if (value !== null) {
        attributeObject[attr] = el2.getAttribute(attr);
      }
      el2.removeAttribute(attr);
    }
  });
  return attributeObject;
};
const isRTL$2 = (hostEl) => {
  if (hostEl) {
    if (hostEl.dir !== "") {
      return hostEl.dir.toLowerCase() === "rtl";
    }
  }
  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === "rtl";
};
const validateContent$1 = (svgContent) => {
  const div = document.createElement("div");
  div.innerHTML = svgContent;
  for (let i = div.childNodes.length - 1; i >= 0; i--) {
    if (div.childNodes[i].nodeName.toLowerCase() !== "svg") {
      div.removeChild(div.childNodes[i]);
    }
  }
  const svgElm = div.firstElementChild;
  if (svgElm && svgElm.nodeName.toLowerCase() === "svg") {
    const svgClass = svgElm.getAttribute("class") || "";
    svgElm.setAttribute("class", (svgClass + " s-ion-icon").trim());
    if (isValid$4(svgElm)) {
      return div.innerHTML;
    }
  }
  return "";
};
const isValid$4 = (elm) => {
  if (elm.nodeType === 1) {
    if (elm.nodeName.toLowerCase() === "script") {
      return false;
    }
    for (let i = 0; i < elm.attributes.length; i++) {
      const name = elm.attributes[i].name;
      if (isStr$1(name) && name.toLowerCase().indexOf("on") === 0) {
        return false;
      }
    }
    for (let i = 0; i < elm.childNodes.length; i++) {
      if (!isValid$4(elm.childNodes[i])) {
        return false;
      }
    }
  }
  return true;
};
const isSvgDataUrl$1 = (url) => url.startsWith("data:image/svg+xml");
const isEncodedDataUrl$1 = (url) => url.indexOf(";utf8,") !== -1;
const ioniconContent$1 = /* @__PURE__ */ new Map();
const requests$1 = /* @__PURE__ */ new Map();
let parser$2;
const getSvgContent$1 = (url, sanitize) => {
  let req = requests$1.get(url);
  if (!req) {
    if (typeof fetch !== "undefined" && typeof document !== "undefined") {
      if (isSvgDataUrl$1(url) && isEncodedDataUrl$1(url)) {
        if (!parser$2) {
          parser$2 = new DOMParser();
        }
        const doc2 = parser$2.parseFromString(url, "text/html");
        const svg = doc2.querySelector("svg");
        if (svg) {
          ioniconContent$1.set(url, svg.outerHTML);
        }
        return Promise.resolve();
      } else {
        req = fetch(url).then((rsp) => {
          if (rsp.ok) {
            return rsp.text().then((svgContent) => {
              if (svgContent && sanitize !== false) {
                svgContent = validateContent$1(svgContent);
              }
              ioniconContent$1.set(url, svgContent || "");
            });
          }
          ioniconContent$1.set(url, "");
        });
        requests$1.set(url, req);
      }
    } else {
      ioniconContent$1.set(url, "");
      return Promise.resolve();
    }
  }
  return req;
};
const iconCss$1 = ":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}:host(.flip-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.icon-small){font-size:18px !important}:host(.icon-large){font-size:32px !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}";
const Icon$1 = /* @__PURE__ */ proxyCustomElement$1(class Icon extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.iconName = null;
    this.inheritedAttributes = {};
    this.isVisible = false;
    this.mode = getIonMode$1();
    this.lazy = false;
    this.sanitize = true;
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAttributes$1(this.el, ["aria-label"]);
  }
  connectedCallback() {
    this.waitUntilVisible(this.el, "50px", () => {
      this.isVisible = true;
      this.loadIcon();
    });
  }
  disconnectedCallback() {
    if (this.io) {
      this.io.disconnect();
      this.io = void 0;
    }
  }
  waitUntilVisible(el2, rootMargin, cb2) {
    if (this.lazy && typeof window !== "undefined" && window.IntersectionObserver) {
      const io = this.io = new window.IntersectionObserver((data2) => {
        if (data2[0].isIntersecting) {
          io.disconnect();
          this.io = void 0;
          cb2();
        }
      }, { rootMargin });
      io.observe(el2);
    } else {
      cb2();
    }
  }
  loadIcon() {
    if (this.isVisible) {
      const url = getUrl$1(this);
      if (url) {
        if (ioniconContent$1.has(url)) {
          this.svgContent = ioniconContent$1.get(url);
        } else {
          getSvgContent$1(url, this.sanitize).then(() => this.svgContent = ioniconContent$1.get(url));
        }
      }
    }
    this.iconName = getName$1(this.name, this.icon, this.mode, this.ios, this.md);
  }
  render() {
    const { iconName, el: el2, inheritedAttributes } = this;
    const mode = this.mode || "md";
    const flipRtl = this.flipRtl || iconName && (iconName.indexOf("arrow") > -1 || iconName.indexOf("chevron") > -1) && this.flipRtl !== false;
    return h$5(Host$1, Object.assign({ role: "img", class: Object.assign(Object.assign({ [mode]: true }, createColorClasses$2(this.color)), { [`icon-${this.size}`]: !!this.size, "flip-rtl": !!flipRtl && isRTL$2(el2) }) }, inheritedAttributes), this.svgContent ? h$5("div", { class: "icon-inner", innerHTML: this.svgContent }) : h$5("div", { class: "icon-inner" }));
  }
  static get assetsDirs() {
    return ["svg"];
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "name": ["loadIcon"],
      "src": ["loadIcon"],
      "icon": ["loadIcon"],
      "ios": ["loadIcon"],
      "md": ["loadIcon"]
    };
  }
  static get style() {
    return iconCss$1;
  }
}, [1, "ion-icon", {
  "mode": [1025],
  "color": [1],
  "ios": [1],
  "md": [1],
  "flipRtl": [4, "flip-rtl"],
  "name": [513],
  "src": [1],
  "icon": [8],
  "size": [1],
  "lazy": [4],
  "sanitize": [4],
  "svgContent": [32],
  "isVisible": [32]
}]);
const getIonMode$1 = () => typeof document !== "undefined" && document.documentElement.getAttribute("mode") || "md";
const createColorClasses$2 = (color2) => {
  return color2 ? {
    "ion-color": true,
    [`ion-color-${color2}`]: true
  } : null;
};
function defineCustomElement$1b() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-icon":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Icon$1);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const accordionIosCss = ":host{display:block;position:relative;width:100%;background-color:var(--ion-background-color, #ffffff);overflow:hidden;z-index:0}:host(.accordion-expanding) ::slotted(ion-item[slot=header]),:host(.accordion-expanded) ::slotted(ion-item[slot=header]){--border-width:0px}:host(.accordion-animated){-webkit-transition:all 300ms cubic-bezier(0.25, 0.8, 0.5, 1);transition:all 300ms cubic-bezier(0.25, 0.8, 0.5, 1)}:host(.accordion-animated) #content{-webkit-transition:max-height 300ms cubic-bezier(0.25, 0.8, 0.5, 1);transition:max-height 300ms cubic-bezier(0.25, 0.8, 0.5, 1)}#content{overflow:hidden;will-change:max-height}:host(.accordion-collapsing) #content{max-height:0 !important}:host(.accordion-collapsed) #content{display:none}:host(.accordion-expanding) #content{max-height:0}:host(.accordion-expanding) #content-wrapper{overflow:auto}:host(.accordion-disabled) #header,:host(.accordion-readonly) #header,:host(.accordion-disabled) #content,:host(.accordion-readonly) #content{pointer-events:none}:host(.accordion-disabled) #header,:host(.accordion-disabled) #content{opacity:0.4}@media (prefers-reduced-motion: reduce){:host,#content{-webkit-transition:none !important;transition:none !important}}:host(.accordion-next) ::slotted(ion-item[slot=header]){--border-width:0.55px 0px 0.55px 0px}";
const accordionMdCss = ":host{display:block;position:relative;width:100%;background-color:var(--ion-background-color, #ffffff);overflow:hidden;z-index:0}:host(.accordion-expanding) ::slotted(ion-item[slot=header]),:host(.accordion-expanded) ::slotted(ion-item[slot=header]){--border-width:0px}:host(.accordion-animated){-webkit-transition:all 300ms cubic-bezier(0.25, 0.8, 0.5, 1);transition:all 300ms cubic-bezier(0.25, 0.8, 0.5, 1)}:host(.accordion-animated) #content{-webkit-transition:max-height 300ms cubic-bezier(0.25, 0.8, 0.5, 1);transition:max-height 300ms cubic-bezier(0.25, 0.8, 0.5, 1)}#content{overflow:hidden;will-change:max-height}:host(.accordion-collapsing) #content{max-height:0 !important}:host(.accordion-collapsed) #content{display:none}:host(.accordion-expanding) #content{max-height:0}:host(.accordion-expanding) #content-wrapper{overflow:auto}:host(.accordion-disabled) #header,:host(.accordion-readonly) #header,:host(.accordion-disabled) #content,:host(.accordion-readonly) #content{pointer-events:none}:host(.accordion-disabled) #header,:host(.accordion-disabled) #content{opacity:0.4}@media (prefers-reduced-motion: reduce){:host,#content{-webkit-transition:none !important;transition:none !important}}";
const Accordion = /* @__PURE__ */ proxyCustomElement$1(class Accordion2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.updateListener = () => this.updateState(false);
    this.setItemDefaults = () => {
      const ionItem = this.getSlottedHeaderIonItem();
      if (!ionItem) {
        return;
      }
      ionItem.button = true;
      ionItem.detail = false;
      if (ionItem.lines === void 0) {
        ionItem.lines = "full";
      }
    };
    this.getSlottedHeaderIonItem = () => {
      const { headerEl } = this;
      if (!headerEl) {
        return;
      }
      const slot = headerEl.querySelector("slot");
      if (!slot) {
        return;
      }
      if (slot.assignedElements === void 0)
        return;
      return slot.assignedElements().find((el2) => el2.tagName === "ION-ITEM");
    };
    this.setAria = (expanded = false) => {
      const ionItem = this.getSlottedHeaderIonItem();
      if (!ionItem) {
        return;
      }
      const root2 = getElementRoot(ionItem);
      const button = root2.querySelector("button");
      if (!button) {
        return;
      }
      button.setAttribute("aria-expanded", `${expanded}`);
    };
    this.slotToggleIcon = () => {
      const ionItem = this.getSlottedHeaderIonItem();
      if (!ionItem) {
        return;
      }
      const { toggleIconSlot, toggleIcon } = this;
      const existingToggleIcon = ionItem.querySelector(".ion-accordion-toggle-icon");
      if (existingToggleIcon) {
        return;
      }
      const iconEl = document.createElement("ion-icon");
      iconEl.slot = toggleIconSlot;
      iconEl.lazy = false;
      iconEl.classList.add("ion-accordion-toggle-icon");
      iconEl.icon = toggleIcon;
      iconEl.setAttribute("aria-hidden", "true");
      ionItem.appendChild(iconEl);
    };
    this.expandAccordion = (initialUpdate = false) => {
      const { contentEl, contentElWrapper } = this;
      if (initialUpdate || contentEl === void 0 || contentElWrapper === void 0) {
        this.state = 4;
        return;
      }
      if (this.state === 4) {
        return;
      }
      if (this.currentRaf !== void 0) {
        cancelAnimationFrame(this.currentRaf);
      }
      if (this.shouldAnimate()) {
        raf(() => {
          this.state = 8;
          this.currentRaf = raf(async () => {
            const contentHeight = contentElWrapper.offsetHeight;
            const waitForTransition = transitionEndAsync(contentEl, 2e3);
            contentEl.style.setProperty("max-height", `${contentHeight}px`);
            await waitForTransition;
            this.state = 4;
            contentEl.style.removeProperty("max-height");
          });
        });
      } else {
        this.state = 4;
      }
    };
    this.collapseAccordion = (initialUpdate = false) => {
      const { contentEl } = this;
      if (initialUpdate || contentEl === void 0) {
        this.state = 1;
        return;
      }
      if (this.state === 1) {
        return;
      }
      if (this.currentRaf !== void 0) {
        cancelAnimationFrame(this.currentRaf);
      }
      if (this.shouldAnimate()) {
        this.currentRaf = raf(async () => {
          const contentHeight = contentEl.offsetHeight;
          contentEl.style.setProperty("max-height", `${contentHeight}px`);
          raf(async () => {
            const waitForTransition = transitionEndAsync(contentEl, 2e3);
            this.state = 2;
            await waitForTransition;
            this.state = 1;
            contentEl.style.removeProperty("max-height");
          });
        });
      } else {
        this.state = 1;
      }
    };
    this.shouldAnimate = () => {
      if (typeof window === "undefined") {
        return false;
      }
      const prefersReducedMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;
      if (prefersReducedMotion) {
        return false;
      }
      const animated = config$1.get("animated", true);
      if (!animated) {
        return false;
      }
      if (this.accordionGroupEl && !this.accordionGroupEl.animated) {
        return false;
      }
      return true;
    };
    this.updateState = async (initialUpdate = false) => {
      const accordionGroup = this.accordionGroupEl;
      const accordionValue = this.value;
      if (!accordionGroup) {
        return;
      }
      const value = accordionGroup.value;
      const shouldExpand = Array.isArray(value) ? value.includes(accordionValue) : value === accordionValue;
      if (shouldExpand) {
        this.expandAccordion(initialUpdate);
        this.isNext = this.isPrevious = false;
      } else {
        this.collapseAccordion(initialUpdate);
        const nextAccordion = this.getNextSibling();
        const nextAccordionValue = nextAccordion === null || nextAccordion === void 0 ? void 0 : nextAccordion.value;
        if (nextAccordionValue !== void 0) {
          this.isPrevious = Array.isArray(value) ? value.includes(nextAccordionValue) : value === nextAccordionValue;
        }
        const previousAccordion = this.getPreviousSibling();
        const previousAccordionValue = previousAccordion === null || previousAccordion === void 0 ? void 0 : previousAccordion.value;
        if (previousAccordionValue !== void 0) {
          this.isNext = Array.isArray(value) ? value.includes(previousAccordionValue) : value === previousAccordionValue;
        }
      }
    };
    this.getNextSibling = () => {
      if (!this.el) {
        return;
      }
      const nextSibling = this.el.nextElementSibling;
      if ((nextSibling === null || nextSibling === void 0 ? void 0 : nextSibling.tagName) !== "ION-ACCORDION") {
        return;
      }
      return nextSibling;
    };
    this.getPreviousSibling = () => {
      if (!this.el) {
        return;
      }
      const previousSibling = this.el.previousElementSibling;
      if ((previousSibling === null || previousSibling === void 0 ? void 0 : previousSibling.tagName) !== "ION-ACCORDION") {
        return;
      }
      return previousSibling;
    };
    this.state = 1;
    this.isNext = false;
    this.isPrevious = false;
    this.value = `ion-accordion-${accordionIds++}`;
    this.disabled = false;
    this.readonly = false;
    this.toggleIcon = chevronDown;
    this.toggleIconSlot = "end";
  }
  valueChanged() {
    this.updateState();
  }
  connectedCallback() {
    var _a2;
    const accordionGroupEl = this.accordionGroupEl = (_a2 = this.el) === null || _a2 === void 0 ? void 0 : _a2.closest("ion-accordion-group");
    if (accordionGroupEl) {
      this.updateState(true);
      addEventListener$1(accordionGroupEl, "ionValueChange", this.updateListener);
    }
  }
  disconnectedCallback() {
    const accordionGroupEl = this.accordionGroupEl;
    if (accordionGroupEl) {
      removeEventListener(accordionGroupEl, "ionValueChange", this.updateListener);
    }
  }
  componentDidLoad() {
    this.setItemDefaults();
    this.slotToggleIcon();
    raf(() => {
      const expanded = this.state === 4 || this.state === 8;
      this.setAria(expanded);
    });
  }
  toggleExpanded() {
    const { accordionGroupEl, value, state } = this;
    if (accordionGroupEl) {
      const expand = state === 1 || state === 2;
      accordionGroupEl.requestAccordionToggle(value, expand);
    }
  }
  render() {
    const { disabled, readonly } = this;
    const mode = getIonMode$2(this);
    const expanded = this.state === 4 || this.state === 8;
    const headerPart = expanded ? "header expanded" : "header";
    const contentPart = expanded ? "content expanded" : "content";
    this.setAria(expanded);
    return h$5(Host$1, { class: {
      [mode]: true,
      "accordion-expanding": this.state === 8,
      "accordion-expanded": this.state === 4,
      "accordion-collapsing": this.state === 2,
      "accordion-collapsed": this.state === 1,
      "accordion-next": this.isNext,
      "accordion-previous": this.isPrevious,
      "accordion-disabled": disabled,
      "accordion-readonly": readonly,
      "accordion-animated": this.shouldAnimate()
    } }, h$5("div", { onClick: () => this.toggleExpanded(), id: "header", part: headerPart, "aria-controls": "content", ref: (headerEl) => this.headerEl = headerEl }, h$5("slot", { name: "header" })), h$5("div", { id: "content", part: contentPart, role: "region", "aria-labelledby": "header", ref: (contentEl) => this.contentEl = contentEl }, h$5("div", { id: "content-wrapper", ref: (contentElWrapper) => this.contentElWrapper = contentElWrapper }, h$5("slot", { name: "content" }))));
  }
  static get delegatesFocus() {
    return true;
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "value": ["valueChanged"]
    };
  }
  static get style() {
    return {
      ios: accordionIosCss,
      md: accordionMdCss
    };
  }
}, [49, "ion-accordion", {
  "value": [1],
  "disabled": [4],
  "readonly": [4],
  "toggleIcon": [1, "toggle-icon"],
  "toggleIconSlot": [1, "toggle-icon-slot"],
  "state": [32],
  "isNext": [32],
  "isPrevious": [32]
}]);
let accordionIds = 0;
function defineCustomElement$1$I() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-accordion", "ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-accordion":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Accordion);
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$1b();
        }
        break;
    }
  });
}
const defineCustomElement$1a = defineCustomElement$1$I;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const accordionGroupIosCss = ":host{display:block}:host(.accordion-group-expand-inset){-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:16px;margin-bottom:16px}:host(.accordion-group-expand-inset) ::slotted(ion-accordion.accordion-expanding),:host(.accordion-group-expand-inset) ::slotted(ion-accordion.accordion-expanded){border-bottom:none}";
const accordionGroupMdCss = ":host{display:block}:host(.accordion-group-expand-inset){-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:16px;margin-bottom:16px}:host(.accordion-group-expand-inset) ::slotted(ion-accordion){-webkit-box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12)}:host(.accordion-group-expand-inset) ::slotted(ion-accordion.accordion-expanding),:host(.accordion-group-expand-inset) ::slotted(ion-accordion.accordion-expanded){margin-left:0;margin-right:0;margin-top:16px;margin-bottom:16px;border-radius:6px}:host(.accordion-group-expand-inset) ::slotted(ion-accordion.accordion-previous){border-bottom-right-radius:6px;border-bottom-left-radius:6px}:host-context([dir=rtl]):host(.accordion-group-expand-inset) ::slotted(ion-accordion.accordion-previous),:host-context([dir=rtl]).accordion-group-expand-inset ::slotted(ion-accordion.accordion-previous){border-bottom-right-radius:6px;border-bottom-left-radius:6px}@supports selector(:dir(rtl)){:host(.accordion-group-expand-inset) ::slotted(ion-accordion.accordion-previous):dir(rtl){border-bottom-right-radius:6px;border-bottom-left-radius:6px}}:host(.accordion-group-expand-inset) ::slotted(ion-accordion.accordion-next){border-top-left-radius:6px;border-top-right-radius:6px}:host-context([dir=rtl]):host(.accordion-group-expand-inset) ::slotted(ion-accordion.accordion-next),:host-context([dir=rtl]).accordion-group-expand-inset ::slotted(ion-accordion.accordion-next){border-top-left-radius:6px;border-top-right-radius:6px}@supports selector(:dir(rtl)){:host(.accordion-group-expand-inset) ::slotted(ion-accordion.accordion-next):dir(rtl){border-top-left-radius:6px;border-top-right-radius:6px}}:host(.accordion-group-expand-inset) ::slotted(ion-accordion):first-of-type{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}";
const AccordionGroup = /* @__PURE__ */ proxyCustomElement$1(class AccordionGroup2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionValueChange = createEvent(this, "ionValueChange", 7);
    this.animated = true;
    this.multiple = void 0;
    this.value = void 0;
    this.disabled = false;
    this.readonly = false;
    this.expand = "compact";
  }
  valueChanged() {
    const { value, multiple } = this;
    if (!multiple && Array.isArray(value)) {
      printIonWarning(`ion-accordion-group was passed an array of values, but multiple="false". This is incorrect usage and may result in unexpected behaviors. To dismiss this warning, pass a string to the "value" property when multiple="false".

  Value Passed: [${value.map((v2) => `'${v2}'`).join(", ")}]
`, this.el);
    }
    this.ionValueChange.emit({ value: this.value });
  }
  async disabledChanged() {
    const { disabled } = this;
    const accordions = await this.getAccordions();
    for (const accordion of accordions) {
      accordion.disabled = disabled;
    }
  }
  async readonlyChanged() {
    const { readonly } = this;
    const accordions = await this.getAccordions();
    for (const accordion of accordions) {
      accordion.readonly = readonly;
    }
  }
  async onKeydown(ev) {
    const activeElement = document.activeElement;
    if (!activeElement) {
      return;
    }
    const activeAccordionHeader = activeElement.closest('ion-accordion [slot="header"]');
    if (!activeAccordionHeader) {
      return;
    }
    const accordionEl = activeElement.tagName === "ION-ACCORDION" ? activeElement : activeElement.closest("ion-accordion");
    if (!accordionEl) {
      return;
    }
    const closestGroup = accordionEl.closest("ion-accordion-group");
    if (closestGroup !== this.el) {
      return;
    }
    const accordions = await this.getAccordions();
    const startingIndex = accordions.findIndex((a2) => a2 === accordionEl);
    if (startingIndex === -1) {
      return;
    }
    let accordion;
    if (ev.key === "ArrowDown") {
      accordion = this.findNextAccordion(accordions, startingIndex);
    } else if (ev.key === "ArrowUp") {
      accordion = this.findPreviousAccordion(accordions, startingIndex);
    } else if (ev.key === "Home") {
      accordion = accordions[0];
    } else if (ev.key === "End") {
      accordion = accordions[accordions.length - 1];
    }
    if (accordion !== void 0 && accordion !== activeElement) {
      accordion.focus();
    }
  }
  async componentDidLoad() {
    if (this.disabled) {
      this.disabledChanged();
    }
    if (this.readonly) {
      this.readonlyChanged();
    }
  }
  /**
   * Sets the value property and emits ionChange.
   * This should only be called when the user interacts
   * with the accordion and not for any update
   * to the value property. The exception is when
   * the app sets the value of a single-select
   * accordion group to an array.
   */
  setValue(accordionValue) {
    const value = this.value = accordionValue;
    this.ionChange.emit({ value });
  }
  /**
   * This method is used to ensure that the value
   * of ion-accordion-group is being set in a valid
   * way. This method should only be called in
   * response to a user generated action.
   * @internal
   */
  async requestAccordionToggle(accordionValue, accordionExpand) {
    const { multiple, value, readonly, disabled } = this;
    if (readonly || disabled) {
      return;
    }
    if (accordionExpand) {
      if (multiple) {
        const groupValue = value !== null && value !== void 0 ? value : [];
        const processedValue = Array.isArray(groupValue) ? groupValue : [groupValue];
        const valueExists = processedValue.find((v2) => v2 === accordionValue);
        if (valueExists === void 0 && accordionValue !== void 0) {
          this.setValue([...processedValue, accordionValue]);
        }
      } else {
        this.setValue(accordionValue);
      }
    } else {
      if (multiple) {
        const groupValue = value !== null && value !== void 0 ? value : [];
        const processedValue = Array.isArray(groupValue) ? groupValue : [groupValue];
        this.setValue(processedValue.filter((v2) => v2 !== accordionValue));
      } else {
        this.setValue(void 0);
      }
    }
  }
  findNextAccordion(accordions, startingIndex) {
    const nextAccordion = accordions[startingIndex + 1];
    if (nextAccordion === void 0) {
      return accordions[0];
    }
    return nextAccordion;
  }
  findPreviousAccordion(accordions, startingIndex) {
    const prevAccordion = accordions[startingIndex - 1];
    if (prevAccordion === void 0) {
      return accordions[accordions.length - 1];
    }
    return prevAccordion;
  }
  /**
   * @internal
   */
  async getAccordions() {
    return Array.from(this.el.querySelectorAll(":scope > ion-accordion"));
  }
  render() {
    const { disabled, readonly, expand } = this;
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: {
      [mode]: true,
      "accordion-group-disabled": disabled,
      "accordion-group-readonly": readonly,
      [`accordion-group-expand-${expand}`]: true
    }, role: "presentation" }, h$5("slot", null));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "value": ["valueChanged"],
      "disabled": ["disabledChanged"],
      "readonly": ["readonlyChanged"]
    };
  }
  static get style() {
    return {
      ios: accordionGroupIosCss,
      md: accordionGroupMdCss
    };
  }
}, [33, "ion-accordion-group", {
  "animated": [4],
  "multiple": [4],
  "value": [1025],
  "disabled": [4],
  "readonly": [4],
  "expand": [1],
  "requestAccordionToggle": [64],
  "getAccordions": [64]
}, [[0, "keydown", "onKeydown"]]]);
function defineCustomElement$1$H() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-accordion-group"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-accordion-group":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, AccordionGroup);
        }
        break;
    }
  });
}
const defineCustomElement$19 = defineCustomElement$1$H;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const avatarIosCss = ":host{border-radius:var(--border-radius);display:block}::slotted(ion-img),::slotted(img){border-radius:var(--border-radius);width:100%;height:100%;-o-object-fit:cover;object-fit:cover;overflow:hidden}:host{--border-radius:50%;width:48px;height:48px}";
const avatarMdCss = ":host{border-radius:var(--border-radius);display:block}::slotted(ion-img),::slotted(img){border-radius:var(--border-radius);width:100%;height:100%;-o-object-fit:cover;object-fit:cover;overflow:hidden}:host{--border-radius:50%;width:64px;height:64px}";
const Avatar = /* @__PURE__ */ proxyCustomElement$1(class Avatar2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
  }
  render() {
    return h$5(Host$1, { class: getIonMode$2(this) }, h$5("slot", null));
  }
  static get style() {
    return {
      ios: avatarIosCss,
      md: avatarMdCss
    };
  }
}, [33, "ion-avatar"]);
function defineCustomElement$1$G() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-avatar"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-avatar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Avatar);
        }
        break;
    }
  });
}
const defineCustomElement$18 = defineCustomElement$1$G;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const backdropIosCss = ":host{left:0;right:0;top:0;bottom:0;display:block;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);contain:strict;cursor:pointer;opacity:0.01;-ms-touch-action:none;touch-action:none;z-index:2}:host(.backdrop-hide){background:transparent}:host(.backdrop-no-tappable){cursor:auto}:host{background-color:var(--ion-backdrop-color, #000)}";
const backdropMdCss = ":host{left:0;right:0;top:0;bottom:0;display:block;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);contain:strict;cursor:pointer;opacity:0.01;-ms-touch-action:none;touch-action:none;z-index:2}:host(.backdrop-hide){background:transparent}:host(.backdrop-no-tappable){cursor:auto}:host{background-color:var(--ion-backdrop-color, #000)}";
const Backdrop = /* @__PURE__ */ proxyCustomElement$1(class Backdrop2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionBackdropTap = createEvent(this, "ionBackdropTap", 7);
    this.blocker = GESTURE_CONTROLLER.createBlocker({
      disableScroll: true
    });
    this.visible = true;
    this.tappable = true;
    this.stopPropagation = true;
  }
  connectedCallback() {
    if (this.stopPropagation) {
      this.blocker.block();
    }
  }
  disconnectedCallback() {
    this.blocker.unblock();
  }
  onMouseDown(ev) {
    this.emitTap(ev);
  }
  emitTap(ev) {
    if (this.stopPropagation) {
      ev.preventDefault();
      ev.stopPropagation();
    }
    if (this.tappable) {
      this.ionBackdropTap.emit();
    }
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { tabindex: "-1", "aria-hidden": "true", class: {
      [mode]: true,
      "backdrop-hide": !this.visible,
      "backdrop-no-tappable": !this.tappable
    } });
  }
  static get style() {
    return {
      ios: backdropIosCss,
      md: backdropMdCss
    };
  }
}, [33, "ion-backdrop", {
  "visible": [4],
  "tappable": [4],
  "stopPropagation": [4, "stop-propagation"]
}, [[2, "click", "onMouseDown"]]]);
function defineCustomElement$17() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-backdrop"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Backdrop);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const hostContext = (selector, el2) => {
  return el2.closest(selector) !== null;
};
const createColorClasses$1 = (color2, cssClassMap) => {
  return typeof color2 === "string" && color2.length > 0 ? Object.assign({ "ion-color": true, [`ion-color-${color2}`]: true }, cssClassMap) : cssClassMap;
};
const getClassList = (classes2) => {
  if (classes2 !== void 0) {
    const array3 = Array.isArray(classes2) ? classes2 : classes2.split(" ");
    return array3.filter((c2) => c2 != null).map((c2) => c2.trim()).filter((c2) => c2 !== "");
  }
  return [];
};
const getClassMap = (classes2) => {
  const map3 = {};
  getClassList(classes2).forEach((c2) => map3[c2] = true);
  return map3;
};
const SCHEME = /^[a-z][a-z0-9+\-.]*:/;
const openURL = async (url, ev, direction, animation2) => {
  if (url != null && url[0] !== "#" && !SCHEME.test(url)) {
    const router = document.querySelector("ion-router");
    if (router) {
      if (ev != null) {
        ev.preventDefault();
      }
      return router.push(url, direction, animation2);
    }
  }
  return false;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const badgeIosCss = ":host{--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff);--padding-top:3px;--padding-end:8px;--padding-bottom:3px;--padding-start:8px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:inline-block;min-width:10px;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);font-size:13px;font-weight:bold;line-height:1;text-align:center;white-space:nowrap;contain:content;vertical-align:baseline}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(:empty){display:none}:host{border-radius:10px}";
const badgeMdCss = ":host{--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff);--padding-top:3px;--padding-end:8px;--padding-bottom:3px;--padding-start:8px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:inline-block;min-width:10px;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);font-size:13px;font-weight:bold;line-height:1;text-align:center;white-space:nowrap;contain:content;vertical-align:baseline}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(:empty){display:none}:host{--padding-top:3px;--padding-end:4px;--padding-bottom:4px;--padding-start:4px;border-radius:4px}";
const Badge = /* @__PURE__ */ proxyCustomElement$1(class Badge2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.color = void 0;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: createColorClasses$1(this.color, {
      [mode]: true
    }) }, h$5("slot", null));
  }
  static get style() {
    return {
      ios: badgeIosCss,
      md: badgeMdCss
    };
  }
}, [33, "ion-badge", {
  "color": [513]
}]);
function defineCustomElement$1$F() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-badge"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-badge":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Badge);
        }
        break;
    }
  });
}
const defineCustomElement$16 = defineCustomElement$1$F;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const buttonsIosCss = ".sc-ion-buttons-ios-h{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);z-index:99}.sc-ion-buttons-ios-s ion-button{--padding-top:0;--padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.sc-ion-buttons-ios-s ion-button{--padding-start:5px;--padding-end:5px;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;height:32px}.sc-ion-buttons-ios-s ion-button:not(.button-round){--border-radius:4px}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button{--color:initial;--border-color:initial;--background-focused:var(--ion-color-contrast)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-solid,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-solid{--background:var(--ion-color-contrast);--background-focused:#000;--background-focused-opacity:.12;--background-activated:#000;--background-activated-opacity:.12;--background-hover:var(--ion-color-base);--background-hover-opacity:0.45;--color:var(--ion-color-base);--color-focused:var(--ion-color-base)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-clear,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-clear{--color-activated:var(--ion-color-contrast);--color-focused:var(--ion-color-contrast)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-outline,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-outline{--color-activated:var(--ion-color-base);--color-focused:var(--ion-color-contrast);--background-activated:var(--ion-color-contrast)}.sc-ion-buttons-ios-s .button-clear,.sc-ion-buttons-ios-s .button-outline{--background-activated:transparent;--background-focused:currentColor;--background-hover:transparent}.sc-ion-buttons-ios-s .button-solid:not(.ion-color){--background-focused:#000;--background-focused-opacity:.12;--background-activated:#000;--background-activated-opacity:.12}.sc-ion-buttons-ios-s ion-icon[slot=start]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-end:0.3em;margin-inline-end:0.3em;font-size:24px;line-height:0.67}.sc-ion-buttons-ios-s ion-icon[slot=end]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-start:0.4em;margin-inline-start:0.4em;font-size:24px;line-height:0.67}.sc-ion-buttons-ios-s ion-icon[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-size:28px;line-height:0.67}";
const buttonsMdCss = ".sc-ion-buttons-md-h{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);z-index:99}.sc-ion-buttons-md-s ion-button{--padding-top:0;--padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.sc-ion-buttons-md-s ion-button{--padding-top:0;--padding-bottom:0;--padding-start:8px;--padding-end:8px;--box-shadow:none;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;height:32px}.sc-ion-buttons-md-s ion-button:not(.button-round){--border-radius:2px}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button{--color:initial;--color-focused:var(--ion-color-contrast);--color-hover:var(--ion-color-contrast);--background-activated:transparent;--background-focused:var(--ion-color-contrast);--background-hover:var(--ion-color-contrast)}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button-solid,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button-solid{--background:var(--ion-color-contrast);--background-activated:transparent;--background-focused:var(--ion-color-shade);--background-hover:var(--ion-color-base);--color:var(--ion-color-base);--color-focused:var(--ion-color-base);--color-hover:var(--ion-color-base)}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button-outline,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button-outline{--border-color:var(--ion-color-contrast)}.sc-ion-buttons-md-s .button-has-icon-only.button-clear{--padding-top:12px;--padding-end:12px;--padding-bottom:12px;--padding-start:12px;--border-radius:50%;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;width:48px;height:48px}.sc-ion-buttons-md-s .button{--background-hover:currentColor}.sc-ion-buttons-md-s .button-solid{--color:var(--ion-toolbar-background, var(--ion-background-color, #fff));--background:var(--ion-toolbar-color, var(--ion-text-color, #424242));--background-activated:transparent;--background-focused:currentColor}.sc-ion-buttons-md-s .button-outline{--color:initial;--background:transparent;--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor;--border-color:currentColor}.sc-ion-buttons-md-s .button-clear{--color:initial;--background:transparent;--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor}.sc-ion-buttons-md-s ion-icon[slot=start]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-end:0.3em;margin-inline-end:0.3em;font-size:1.4em}.sc-ion-buttons-md-s ion-icon[slot=end]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-start:0.4em;margin-inline-start:0.4em;font-size:1.4em}.sc-ion-buttons-md-s ion-icon[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-size:1.8em}";
const Buttons = /* @__PURE__ */ proxyCustomElement$1(class Buttons2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.collapse = false;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: {
      [mode]: true,
      ["buttons-collapse"]: this.collapse
    } });
  }
  static get style() {
    return {
      ios: buttonsIosCss,
      md: buttonsMdCss
    };
  }
}, [34, "ion-buttons", {
  "collapse": [4]
}]);
function defineCustomElement$15() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-buttons"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-buttons":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Buttons);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$14 = defineCustomElement$15;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const cardContentIosCss = "ion-card-content{display:block;position:relative}.card-content-ios{-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:20px;padding-inline-end:20px;padding-top:20px;padding-bottom:20px;font-size:16px;line-height:1.4}.card-content-ios h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}.card-content-ios h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:16px;font-weight:normal}.card-content-ios h3,.card-content-ios h4,.card-content-ios h5,.card-content-ios h6{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:14px;font-weight:normal}.card-content-ios p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px}ion-card-header+.card-content-ios{padding-top:0}";
const cardContentMdCss = "ion-card-content{display:block;position:relative}.card-content-md{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:13px;padding-bottom:13px;font-size:14px;line-height:1.5}.card-content-md h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}.card-content-md h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:16px;font-weight:normal}.card-content-md h3,.card-content-md h4,.card-content-md h5,.card-content-md h6{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:14px;font-weight:normal}.card-content-md p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px;font-weight:normal;line-height:1.5}ion-card-header+.card-content-md{padding-top:0}";
const CardContent = /* @__PURE__ */ proxyCustomElement$1(class CardContent2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: {
      [mode]: true,
      // Used internally for styling
      [`card-content-${mode}`]: true
    } });
  }
  static get style() {
    return {
      ios: cardContentIosCss,
      md: cardContentMdCss
    };
  }
}, [32, "ion-card-content"]);
function defineCustomElement$1$E() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-card-content"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-card-content":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, CardContent);
        }
        break;
    }
  });
}
const defineCustomElement$13 = defineCustomElement$1$E;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const cardHeaderIosCss = ":host{--background:transparent;--color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:column;flex-direction:column;background:var(--background);color:var(--color)}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}:host{-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:20px;padding-inline-end:20px;padding-top:20px;padding-bottom:16px;-ms-flex-direction:column-reverse;flex-direction:column-reverse}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.card-header-translucent){background-color:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.9);-webkit-backdrop-filter:saturate(180%) blur(30px);backdrop-filter:saturate(180%) blur(30px)}}";
const cardHeaderMdCss = ":host{--background:transparent;--color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:column;flex-direction:column;background:var(--background);color:var(--color)}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}:host{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:16px;padding-bottom:16px}::slotted(ion-card-title:not(:first-child)),::slotted(ion-card-subtitle:not(:first-child)){margin-top:8px}";
const CardHeader = /* @__PURE__ */ proxyCustomElement$1(class CardHeader2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.color = void 0;
    this.translucent = false;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: createColorClasses$1(this.color, {
      "card-header-translucent": this.translucent,
      "ion-inherit-color": true,
      [mode]: true
    }) }, h$5("slot", null));
  }
  static get style() {
    return {
      ios: cardHeaderIosCss,
      md: cardHeaderMdCss
    };
  }
}, [33, "ion-card-header", {
  "color": [513],
  "translucent": [4]
}]);
function defineCustomElement$1$D() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-card-header"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-card-header":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, CardHeader);
        }
        break;
    }
  });
}
const defineCustomElement$12 = defineCustomElement$1$D;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const cardSubtitleIosCss = ":host{display:block;position:relative;color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}:host{--color:var(--ion-color-step-600, #666666);margin-left:0;margin-right:0;margin-top:0;margin-bottom:4px;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-size:12px;font-weight:700;letter-spacing:0.4px;text-transform:uppercase}";
const cardSubtitleMdCss = ":host{display:block;position:relative;color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}:host{--color:var(--ion-color-step-550, #737373);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-size:14px;font-weight:500}";
const CardSubtitle = /* @__PURE__ */ proxyCustomElement$1(class CardSubtitle2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.color = void 0;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { role: "heading", "aria-level": "3", class: createColorClasses$1(this.color, {
      "ion-inherit-color": true,
      [mode]: true
    }) }, h$5("slot", null));
  }
  static get style() {
    return {
      ios: cardSubtitleIosCss,
      md: cardSubtitleMdCss
    };
  }
}, [33, "ion-card-subtitle", {
  "color": [513]
}]);
function defineCustomElement$1$C() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-card-subtitle"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-card-subtitle":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, CardSubtitle);
        }
        break;
    }
  });
}
const defineCustomElement$11 = defineCustomElement$1$C;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const cardTitleIosCss = ":host{display:block;position:relative;color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}:host{--color:var(--ion-text-color, #000);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-size:28px;font-weight:700;line-height:1.2}";
const cardTitleMdCss = ":host{display:block;position:relative;color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}:host{--color:var(--ion-color-step-850, #262626);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-size:20px;font-weight:500;line-height:1.2}";
const CardTitle = /* @__PURE__ */ proxyCustomElement$1(class CardTitle2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.color = void 0;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { role: "heading", "aria-level": "2", class: createColorClasses$1(this.color, {
      "ion-inherit-color": true,
      [mode]: true
    }) }, h$5("slot", null));
  }
  static get style() {
    return {
      ios: cardTitleIosCss,
      md: cardTitleMdCss
    };
  }
}, [33, "ion-card-title", {
  "color": [513]
}]);
function defineCustomElement$1$B() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-card-title"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-card-title":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, CardTitle);
        }
        break;
    }
  });
}
const defineCustomElement$10 = defineCustomElement$1$B;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const createLegacyFormController = (el2) => {
  const controlEl = el2;
  let legacyControl;
  const hasLegacyControl = () => {
    if (legacyControl === void 0) {
      const hasLabelProp = controlEl.label !== void 0 || hasLabelSlot(controlEl);
      const hasAriaLabelAttribute = controlEl.hasAttribute("aria-label") || // Shadow DOM form controls cannot use aria-labelledby
      controlEl.hasAttribute("aria-labelledby") && controlEl.shadowRoot === null;
      const legacyItemLabel = findItemLabel(controlEl);
      legacyControl = controlEl.legacy === true || !hasLabelProp && !hasAriaLabelAttribute && legacyItemLabel !== null;
    }
    return legacyControl;
  };
  return { hasLegacyControl };
};
const hasLabelSlot = (controlEl) => {
  const root2 = controlEl.shadowRoot;
  if (root2 === null) {
    return false;
  }
  if (NAMED_LABEL_SLOT_COMPONENTS.includes(controlEl.tagName) && controlEl.querySelector('[slot="label"]') !== null) {
    return true;
  }
  if (UNNAMED_LABEL_SLOT_COMPONENTS.includes(controlEl.tagName) && controlEl.textContent !== "") {
    return true;
  }
  return false;
};
const NAMED_LABEL_SLOT_COMPONENTS = ["ION-RANGE"];
const UNNAMED_LABEL_SLOT_COMPONENTS = ["ION-TOGGLE", "ION-CHECKBOX", "ION-RADIO"];
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const checkboxIosCss = ":host{--checkbox-background-checked:var(--ion-color-primary, #3880ff);--border-color-checked:var(--ion-color-primary, #3880ff);--checkmark-color:var(--ion-color-primary-contrast, #fff);--checkmark-width:1;--transition:none;display:inline-block;position:relative;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.in-item){width:100%;height:100%}:host([slot=start]:not(.legacy-checkbox)),:host([slot=end]:not(.legacy-checkbox)){width:auto}:host(.legacy-checkbox){width:var(--size);height:var(--size)}:host(.ion-color){--checkbox-background-checked:var(--ion-color-base);--border-color-checked:var(--ion-color-base);--checkmark-color:var(--ion-color-contrast)}:host(.legacy-checkbox) label{top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;opacity:0}@supports (inset-inline-start: 0){:host(.legacy-checkbox) label{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host(.legacy-checkbox) label{left:0}:host-context([dir=rtl]):host(.legacy-checkbox) label,:host-context([dir=rtl]).legacy-checkbox label{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(.legacy-checkbox) label:dir(rtl){left:unset;right:unset;right:0}}}:host(.legacy-checkbox) label::-moz-focus-inner{border:0}.checkbox-wrapper{display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;height:inherit;cursor:inherit}.label-text-wrapper{pointer-events:none;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.label-text-wrapper-hidden{display:none}input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.checkbox-icon{border-radius:var(--border-radius);position:relative;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--checkbox-background);-webkit-box-sizing:border-box;box-sizing:border-box}:host(.legacy-checkbox) .checkbox-icon{display:block;width:100%;height:100%}:host(:not(.legacy-checkbox)) .checkbox-icon{width:var(--size);height:var(--size)}.checkbox-icon path{fill:none;stroke:var(--checkmark-color);stroke-width:var(--checkmark-width);opacity:0}:host(.checkbox-justify-space-between) .checkbox-wrapper{-ms-flex-pack:justify;justify-content:space-between}:host(.checkbox-justify-start) .checkbox-wrapper{-ms-flex-pack:start;justify-content:start}:host(.checkbox-justify-end) .checkbox-wrapper{-ms-flex-pack:end;justify-content:end}:host(.checkbox-label-placement-start) .checkbox-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.checkbox-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.checkbox-label-placement-end) .checkbox-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.checkbox-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}:host(.checkbox-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.checkbox-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}:host(.checkbox-checked) .checkbox-icon,:host(.checkbox-indeterminate) .checkbox-icon{border-color:var(--border-color-checked);background:var(--checkbox-background-checked)}:host(.checkbox-checked) .checkbox-icon path,:host(.checkbox-indeterminate) .checkbox-icon path{opacity:1}:host(.checkbox-disabled){pointer-events:none}:host{--border-radius:50%;--border-width:1px;--border-style:solid;--border-color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.23);--checkbox-background:var(--ion-item-background, var(--ion-background-color, #fff));--size:26px}:host(.checkbox-disabled){opacity:0.3}:host(.in-item.legacy-checkbox){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px;margin-top:10px;margin-bottom:9px;display:block;position:static}:host(.in-item.legacy-checkbox[slot=start]){-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:8px;margin-bottom:8px}";
const checkboxMdCss = ":host{--checkbox-background-checked:var(--ion-color-primary, #3880ff);--border-color-checked:var(--ion-color-primary, #3880ff);--checkmark-color:var(--ion-color-primary-contrast, #fff);--checkmark-width:1;--transition:none;display:inline-block;position:relative;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.in-item){width:100%;height:100%}:host([slot=start]:not(.legacy-checkbox)),:host([slot=end]:not(.legacy-checkbox)){width:auto}:host(.legacy-checkbox){width:var(--size);height:var(--size)}:host(.ion-color){--checkbox-background-checked:var(--ion-color-base);--border-color-checked:var(--ion-color-base);--checkmark-color:var(--ion-color-contrast)}:host(.legacy-checkbox) label{top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;opacity:0}@supports (inset-inline-start: 0){:host(.legacy-checkbox) label{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host(.legacy-checkbox) label{left:0}:host-context([dir=rtl]):host(.legacy-checkbox) label,:host-context([dir=rtl]).legacy-checkbox label{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(.legacy-checkbox) label:dir(rtl){left:unset;right:unset;right:0}}}:host(.legacy-checkbox) label::-moz-focus-inner{border:0}.checkbox-wrapper{display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;height:inherit;cursor:inherit}.label-text-wrapper{pointer-events:none;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.label-text-wrapper-hidden{display:none}input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.checkbox-icon{border-radius:var(--border-radius);position:relative;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--checkbox-background);-webkit-box-sizing:border-box;box-sizing:border-box}:host(.legacy-checkbox) .checkbox-icon{display:block;width:100%;height:100%}:host(:not(.legacy-checkbox)) .checkbox-icon{width:var(--size);height:var(--size)}.checkbox-icon path{fill:none;stroke:var(--checkmark-color);stroke-width:var(--checkmark-width);opacity:0}:host(.checkbox-justify-space-between) .checkbox-wrapper{-ms-flex-pack:justify;justify-content:space-between}:host(.checkbox-justify-start) .checkbox-wrapper{-ms-flex-pack:start;justify-content:start}:host(.checkbox-justify-end) .checkbox-wrapper{-ms-flex-pack:end;justify-content:end}:host(.checkbox-label-placement-start) .checkbox-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.checkbox-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.checkbox-label-placement-end) .checkbox-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.checkbox-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}:host(.checkbox-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.checkbox-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}:host(.checkbox-checked) .checkbox-icon,:host(.checkbox-indeterminate) .checkbox-icon{border-color:var(--border-color-checked);background:var(--checkbox-background-checked)}:host(.checkbox-checked) .checkbox-icon path,:host(.checkbox-indeterminate) .checkbox-icon path{opacity:1}:host(.checkbox-disabled){pointer-events:none}:host{--border-radius:calc(var(--size) * .125);--border-width:2px;--border-style:solid;--border-color:rgb(var(--ion-text-color-rgb, 0, 0, 0), 0.6);--checkmark-width:3;--checkbox-background:var(--ion-item-background, var(--ion-background-color, #fff));--transition:background 180ms cubic-bezier(0.4, 0, 0.2, 1);--size:18px}.checkbox-icon path{stroke-dasharray:30;stroke-dashoffset:30}:host(.checkbox-checked) .checkbox-icon path,:host(.checkbox-indeterminate) .checkbox-icon path{stroke-dashoffset:0;-webkit-transition:stroke-dashoffset 90ms linear 90ms;transition:stroke-dashoffset 90ms linear 90ms}:host(.checkbox-disabled){opacity:0.3}:host(.in-item.legacy-checkbox){margin-left:0;margin-right:0;margin-top:18px;margin-bottom:18px;display:block;position:static}:host(.in-item.legacy-checkbox[slot=start]){-webkit-margin-start:4px;margin-inline-start:4px;-webkit-margin-end:36px;margin-inline-end:36px;margin-top:18px;margin-bottom:18px}";
const Checkbox = /* @__PURE__ */ proxyCustomElement$1(class Checkbox2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.inputId = `ion-cb-${checkboxIds++}`;
    this.inheritedAttributes = {};
    this.hasLoggedDeprecationWarning = false;
    this.setChecked = (state) => {
      const isChecked = this.checked = state;
      this.ionChange.emit({
        checked: isChecked,
        value: this.value
      });
    };
    this.toggleChecked = (ev) => {
      ev.preventDefault();
      this.setFocus();
      this.setChecked(!this.checked);
      this.indeterminate = false;
    };
    this.onFocus = () => {
      this.ionFocus.emit();
    };
    this.onBlur = () => {
      this.ionBlur.emit();
    };
    this.color = void 0;
    this.name = this.inputId;
    this.checked = false;
    this.indeterminate = false;
    this.disabled = false;
    this.value = "on";
    this.labelPlacement = "start";
    this.justify = "space-between";
    this.legacy = void 0;
  }
  // TODO(FW-3100): remove this
  connectedCallback() {
    this.legacyFormController = createLegacyFormController(this.el);
  }
  componentWillLoad() {
    this.emitStyle();
    if (!this.legacyFormController.hasLegacyControl()) {
      this.inheritedAttributes = Object.assign({}, inheritAriaAttributes(this.el));
    }
  }
  styleChanged() {
    this.emitStyle();
  }
  emitStyle() {
    const style = {
      "interactive-disabled": this.disabled
    };
    if (this.legacyFormController.hasLegacyControl()) {
      style["checkbox-checked"] = this.checked;
    }
    this.ionStyle.emit(style);
  }
  setFocus() {
    if (this.focusEl) {
      this.focusEl.focus();
    }
  }
  // TODO(FW-3100): run contents of renderCheckbox directly instead
  render() {
    const { legacyFormController } = this;
    return legacyFormController.hasLegacyControl() ? this.renderLegacyCheckbox() : this.renderCheckbox();
  }
  renderCheckbox() {
    const { color: color2, checked, disabled, el: el2, getSVGPath, indeterminate, inheritedAttributes, inputId, justify, labelPlacement, name, value } = this;
    const mode = getIonMode$2(this);
    const path3 = getSVGPath(mode, indeterminate);
    renderHiddenInput(true, el2, name, checked ? value : "", disabled);
    return h$5(Host$1, { class: createColorClasses$1(color2, {
      [mode]: true,
      "in-item": hostContext("ion-item", el2),
      "checkbox-checked": checked,
      "checkbox-disabled": disabled,
      "checkbox-indeterminate": indeterminate,
      interactive: true,
      [`checkbox-justify-${justify}`]: true,
      [`checkbox-label-placement-${labelPlacement}`]: true
    }) }, h$5("label", { class: "checkbox-wrapper" }, h$5("input", Object.assign({ type: "checkbox", checked: checked ? true : void 0, disabled, id: inputId, onChange: this.toggleChecked, onFocus: () => this.onFocus(), onBlur: () => this.onBlur(), ref: (focusEl) => this.focusEl = focusEl }, inheritedAttributes)), h$5("div", { class: {
      "label-text-wrapper": true,
      "label-text-wrapper-hidden": el2.textContent === ""
    } }, h$5("slot", null)), h$5("div", { class: "native-wrapper" }, h$5("svg", { class: "checkbox-icon", viewBox: "0 0 24 24", part: "container" }, path3))));
  }
  // TODO(FW-3100): remove this
  renderLegacyCheckbox() {
    if (!this.hasLoggedDeprecationWarning) {
      printIonWarning(`ion-checkbox now requires providing a label with either the default slot or the "aria-label" attribute. To migrate, remove any usage of "ion-label" and pass the label text to either the component or the "aria-label" attribute.

Example: <ion-checkbox>Label</ion-checkbox>
Example with aria-label: <ion-checkbox aria-label="Label"></ion-checkbox>

Developers can use the "legacy" property to continue using the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.`, this.el);
      if (this.legacy) {
        printIonWarning(`ion-checkbox is being used with the "legacy" property enabled which will forcibly enable the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.
Developers can dismiss this warning by removing their usage of the "legacy" property and using the new checkbox syntax.`, this.el);
      }
      this.hasLoggedDeprecationWarning = true;
    }
    const { color: color2, checked, disabled, el: el2, getSVGPath, indeterminate, inputId, name, value } = this;
    const mode = getIonMode$2(this);
    const { label, labelId, labelText } = getAriaLabel(el2, inputId);
    const path3 = getSVGPath(mode, indeterminate);
    renderHiddenInput(true, el2, name, checked ? value : "", disabled);
    return h$5(Host$1, { "aria-labelledby": label ? labelId : null, "aria-checked": `${checked}`, "aria-hidden": disabled ? "true" : null, role: "checkbox", class: createColorClasses$1(color2, {
      [mode]: true,
      "in-item": hostContext("ion-item", el2),
      "checkbox-checked": checked,
      "checkbox-disabled": disabled,
      "checkbox-indeterminate": indeterminate,
      "legacy-checkbox": true,
      interactive: true
    }) }, h$5("svg", { class: "checkbox-icon", viewBox: "0 0 24 24", part: "container" }, path3), h$5("label", { htmlFor: inputId }, labelText), h$5("input", { type: "checkbox", "aria-checked": `${checked}`, disabled, id: inputId, onChange: this.toggleChecked, onFocus: () => this.onFocus(), onBlur: () => this.onBlur(), ref: (focusEl) => this.focusEl = focusEl }));
  }
  getSVGPath(mode, indeterminate) {
    let path3 = indeterminate ? h$5("path", { d: "M6 12L18 12", part: "mark" }) : h$5("path", { d: "M5.9,12.5l3.8,3.8l8.8-8.8", part: "mark" });
    if (mode === "md") {
      path3 = indeterminate ? h$5("path", { d: "M2 12H22", part: "mark" }) : h$5("path", { d: "M1.73,12.91 8.1,19.28 22.79,4.59", part: "mark" });
    }
    return path3;
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "checked": ["styleChanged"],
      "disabled": ["styleChanged"]
    };
  }
  static get style() {
    return {
      ios: checkboxIosCss,
      md: checkboxMdCss
    };
  }
}, [33, "ion-checkbox", {
  "color": [513],
  "name": [1],
  "checked": [1028],
  "indeterminate": [1028],
  "disabled": [4],
  "value": [8],
  "labelPlacement": [1, "label-placement"],
  "justify": [1],
  "legacy": [4]
}]);
let checkboxIds = 0;
function defineCustomElement$$() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-checkbox"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-checkbox":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Checkbox);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$_ = defineCustomElement$$;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const rippleEffectCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:strict;pointer-events:none}:host(.unbounded){contain:layout size style}.ripple-effect{border-radius:50%;position:absolute;background-color:currentColor;color:inherit;contain:strict;opacity:0;-webkit-animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;will-change:transform, opacity;pointer-events:none}.fade-out{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1));-webkit-animation:150ms fadeOutAnimation forwards;animation:150ms fadeOutAnimation forwards}@-webkit-keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@-webkit-keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@-webkit-keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}@keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}";
const RippleEffect = /* @__PURE__ */ proxyCustomElement$1(class RippleEffect2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.type = "bounded";
  }
  /**
   * Adds the ripple effect to the parent element.
   *
   * @param x The horizontal coordinate of where the ripple should start.
   * @param y The vertical coordinate of where the ripple should start.
   */
  async addRipple(x2, y2) {
    return new Promise((resolve) => {
      readTask(() => {
        const rect = this.el.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        const hypotenuse = Math.sqrt(width * width + height * height);
        const maxDim = Math.max(height, width);
        const maxRadius = this.unbounded ? maxDim : hypotenuse + PADDING;
        const initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);
        const finalScale = maxRadius / initialSize;
        let posX = x2 - rect.left;
        let posY = y2 - rect.top;
        if (this.unbounded) {
          posX = width * 0.5;
          posY = height * 0.5;
        }
        const styleX = posX - initialSize * 0.5;
        const styleY = posY - initialSize * 0.5;
        const moveX = width * 0.5 - posX;
        const moveY = height * 0.5 - posY;
        writeTask$1(() => {
          const div = document.createElement("div");
          div.classList.add("ripple-effect");
          const style = div.style;
          style.top = styleY + "px";
          style.left = styleX + "px";
          style.width = style.height = initialSize + "px";
          style.setProperty("--final-scale", `${finalScale}`);
          style.setProperty("--translate-end", `${moveX}px, ${moveY}px`);
          const container = this.el.shadowRoot || this.el;
          container.appendChild(div);
          setTimeout(() => {
            resolve(() => {
              removeRipple(div);
            });
          }, 225 + 100);
        });
      });
    });
  }
  get unbounded() {
    return this.type === "unbounded";
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { role: "presentation", class: {
      [mode]: true,
      unbounded: this.unbounded
    } });
  }
  get el() {
    return this;
  }
  static get style() {
    return rippleEffectCss;
  }
}, [1, "ion-ripple-effect", {
  "type": [1],
  "addRipple": [64]
}]);
const removeRipple = (ripple) => {
  ripple.classList.add("fade-out");
  setTimeout(() => {
    ripple.remove();
  }, 200);
};
const PADDING = 10;
const INITIAL_ORIGIN_SCALE = 0.5;
function defineCustomElement$Z() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, RippleEffect);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const SIZE_TO_MEDIA = {
  xs: "(min-width: 0px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)"
};
const matchBreakpoint = (breakpoint) => {
  if (breakpoint === void 0 || breakpoint === "") {
    return true;
  }
  if (window.matchMedia) {
    const mediaQuery = SIZE_TO_MEDIA[breakpoint];
    return window.matchMedia(mediaQuery).matches;
  }
  return false;
};
const colCss = ":host{-webkit-padding-start:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-box-sizing:border-box;box-sizing:border-box;position:relative;-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;width:100%;max-width:100%;min-height:1px}@media (min-width: 576px){:host{-webkit-padding-start:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px))}}@media (min-width: 768px){:host{-webkit-padding-start:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px))}}@media (min-width: 992px){:host{-webkit-padding-start:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px))}}@media (min-width: 1200px){:host{-webkit-padding-start:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px))}}";
const win$1 = typeof window !== "undefined" ? window : void 0;
const SUPPORTS_VARS = win$1 && !!(win$1.CSS && win$1.CSS.supports && win$1.CSS.supports("--a: 0"));
const BREAKPOINTS = ["", "xs", "sm", "md", "lg", "xl"];
const Col = /* @__PURE__ */ proxyCustomElement$1(class Col2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.offset = void 0;
    this.offsetXs = void 0;
    this.offsetSm = void 0;
    this.offsetMd = void 0;
    this.offsetLg = void 0;
    this.offsetXl = void 0;
    this.pull = void 0;
    this.pullXs = void 0;
    this.pullSm = void 0;
    this.pullMd = void 0;
    this.pullLg = void 0;
    this.pullXl = void 0;
    this.push = void 0;
    this.pushXs = void 0;
    this.pushSm = void 0;
    this.pushMd = void 0;
    this.pushLg = void 0;
    this.pushXl = void 0;
    this.size = void 0;
    this.sizeXs = void 0;
    this.sizeSm = void 0;
    this.sizeMd = void 0;
    this.sizeLg = void 0;
    this.sizeXl = void 0;
  }
  onResize() {
    forceUpdate(this);
  }
  // Loop through all of the breakpoints to see if the media query
  // matches and grab the column value from the relevant prop if so
  getColumns(property2) {
    let matched;
    for (const breakpoint of BREAKPOINTS) {
      const matches2 = matchBreakpoint(breakpoint);
      const columns = this[property2 + breakpoint.charAt(0).toUpperCase() + breakpoint.slice(1)];
      if (matches2 && columns !== void 0) {
        matched = columns;
      }
    }
    return matched;
  }
  calculateSize() {
    const columns = this.getColumns("size");
    if (!columns || columns === "") {
      return;
    }
    const colSize = columns === "auto" ? "auto" : (
      // If CSS supports variables we should use the grid columns var
      SUPPORTS_VARS ? `calc(calc(${columns} / var(--ion-grid-columns, 12)) * 100%)` : (
        // Convert the columns to a percentage by dividing by the total number
        // of columns (12) and then multiplying by 100
        columns / 12 * 100 + "%"
      )
    );
    return {
      flex: `0 0 ${colSize}`,
      width: `${colSize}`,
      "max-width": `${colSize}`
    };
  }
  // Called by push, pull, and offset since they use the same calculations
  calculatePosition(property2, modifier) {
    const columns = this.getColumns(property2);
    if (!columns) {
      return;
    }
    const amount = SUPPORTS_VARS ? (
      // If CSS supports variables we should use the grid columns var
      `calc(calc(${columns} / var(--ion-grid-columns, 12)) * 100%)`
    ) : (
      // Convert the columns to a percentage by dividing by the total number
      // of columns (12) and then multiplying by 100
      columns > 0 && columns < 12 ? columns / 12 * 100 + "%" : "auto"
    );
    return {
      [modifier]: amount
    };
  }
  calculateOffset(isRTL2) {
    return this.calculatePosition("offset", isRTL2 ? "margin-right" : "margin-left");
  }
  calculatePull(isRTL2) {
    return this.calculatePosition("pull", isRTL2 ? "left" : "right");
  }
  calculatePush(isRTL2) {
    return this.calculatePosition("push", isRTL2 ? "right" : "left");
  }
  render() {
    const isRTL2 = document.dir === "rtl";
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: {
      [mode]: true
    }, style: Object.assign(Object.assign(Object.assign(Object.assign({}, this.calculateOffset(isRTL2)), this.calculatePull(isRTL2)), this.calculatePush(isRTL2)), this.calculateSize()) }, h$5("slot", null));
  }
  static get style() {
    return colCss;
  }
}, [1, "ion-col", {
  "offset": [1],
  "offsetXs": [1, "offset-xs"],
  "offsetSm": [1, "offset-sm"],
  "offsetMd": [1, "offset-md"],
  "offsetLg": [1, "offset-lg"],
  "offsetXl": [1, "offset-xl"],
  "pull": [1],
  "pullXs": [1, "pull-xs"],
  "pullSm": [1, "pull-sm"],
  "pullMd": [1, "pull-md"],
  "pullLg": [1, "pull-lg"],
  "pullXl": [1, "pull-xl"],
  "push": [1],
  "pushXs": [1, "push-xs"],
  "pushSm": [1, "push-sm"],
  "pushMd": [1, "push-md"],
  "pushLg": [1, "push-lg"],
  "pushXl": [1, "push-xl"],
  "size": [1],
  "sizeXs": [1, "size-xs"],
  "sizeSm": [1, "size-sm"],
  "sizeMd": [1, "size-md"],
  "sizeLg": [1, "size-lg"],
  "sizeXl": [1, "size-xl"]
}, [[9, "resize", "onResize"]]]);
function defineCustomElement$1$A() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-col"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-col":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Col);
        }
        break;
    }
  });
}
const defineCustomElement$Y = defineCustomElement$1$A;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const isRTL$1 = (hostEl) => {
  if (hostEl) {
    if (hostEl.dir !== "") {
      return hostEl.dir.toLowerCase() === "rtl";
    }
  }
  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === "rtl";
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const contentCss = ':host{--background:var(--ion-background-color, #fff);--color:var(--ion-text-color, #000);--padding-top:0px;--padding-bottom:0px;--padding-start:0px;--padding-end:0px;--keyboard-offset:0px;--offset-top:0px;--offset-bottom:0px;--overflow:auto;display:block;position:relative;-ms-flex:1;flex:1;width:100%;height:100%;margin:0 !important;padding:0 !important;font-family:var(--ion-font-family, inherit);contain:size style}:host(.ion-color) .inner-scroll{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.outer-content){--background:var(--ion-color-step-50, #f2f2f2)}#background-content{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);position:absolute;background:var(--background)}.inner-scroll{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:calc(var(--padding-top) + var(--offset-top));padding-bottom:calc(var(--padding-bottom) + var(--keyboard-offset) + var(--offset-bottom));position:absolute;color:var(--color);-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;-ms-touch-action:pan-x pan-y pinch-zoom;touch-action:pan-x pan-y pinch-zoom}.scroll-y,.scroll-x{-webkit-overflow-scrolling:touch;z-index:0;will-change:scroll-position}.scroll-y{overflow-y:var(--overflow);overscroll-behavior-y:contain}.scroll-x{overflow-x:var(--overflow);overscroll-behavior-x:contain}.overscroll::before,.overscroll::after{position:absolute;width:1px;height:1px;content:""}.overscroll::before{bottom:-1px}.overscroll::after{top:-1px}:host(.content-sizing){display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;min-height:0;contain:none}:host(.content-sizing) .inner-scroll{position:relative;top:0;bottom:0;margin-top:calc(var(--offset-top) * -1);margin-bottom:calc(var(--offset-bottom) * -1)}.transition-effect{display:none;position:absolute;width:100%;height:100vh;opacity:0;pointer-events:none}:host(.content-ltr) .transition-effect{left:-100%;}:host(.content-rtl) .transition-effect{right:-100%;}.transition-cover{position:absolute;right:0;width:100%;height:100%;background:black;opacity:0.1}.transition-shadow{display:block;position:absolute;width:100%;height:100%;-webkit-box-shadow:inset -9px 0 9px 0 rgba(0, 0, 100, 0.03);box-shadow:inset -9px 0 9px 0 rgba(0, 0, 100, 0.03)}:host(.content-ltr) .transition-shadow{right:0;}:host(.content-rtl) .transition-shadow{left:0;-webkit-transform:scaleX(-1);transform:scaleX(-1)}::slotted([slot=fixed]){position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0)}';
const Content = /* @__PURE__ */ proxyCustomElement$1(class Content2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionScrollStart = createEvent(this, "ionScrollStart", 7);
    this.ionScroll = createEvent(this, "ionScroll", 7);
    this.ionScrollEnd = createEvent(this, "ionScrollEnd", 7);
    this.watchDog = null;
    this.isScrolling = false;
    this.lastScroll = 0;
    this.queued = false;
    this.cTop = -1;
    this.cBottom = -1;
    this.isMainContent = true;
    this.resizeTimeout = null;
    this.detail = {
      scrollTop: 0,
      scrollLeft: 0,
      type: "scroll",
      event: void 0,
      startX: 0,
      startY: 0,
      startTime: 0,
      currentX: 0,
      currentY: 0,
      velocityX: 0,
      velocityY: 0,
      deltaX: 0,
      deltaY: 0,
      currentTime: 0,
      data: void 0,
      isScrolling: true
    };
    this.color = void 0;
    this.fullscreen = false;
    this.forceOverscroll = void 0;
    this.scrollX = false;
    this.scrollY = true;
    this.scrollEvents = false;
  }
  connectedCallback() {
    this.isMainContent = this.el.closest("ion-menu, ion-popover, ion-modal") === null;
  }
  disconnectedCallback() {
    this.onScrollEnd();
  }
  onAppLoad() {
    this.resize();
  }
  /**
   * Rotating certain devices can update
   * the safe area insets. As a result,
   * the fullscreen feature on ion-content
   * needs to be recalculated.
   *
   * We listen for "resize" because we
   * do not care what the orientation of
   * the device is. Other APIs
   * such as ScreenOrientation or
   * the deviceorientation event must have
   * permission from the user first whereas
   * the "resize" event does not.
   *
   * We also throttle the callback to minimize
   * thrashing when quickly resizing a window.
   */
  onResize() {
    if (this.resizeTimeout) {
      clearTimeout(this.resizeTimeout);
      this.resizeTimeout = null;
    }
    this.resizeTimeout = setTimeout(() => {
      if (this.el.offsetParent === null) {
        return;
      }
      this.resize();
    }, 100);
  }
  shouldForceOverscroll() {
    const { forceOverscroll } = this;
    const mode = getIonMode$2(this);
    return forceOverscroll === void 0 ? mode === "ios" && isPlatform("ios") : forceOverscroll;
  }
  resize() {
    {
      if (this.fullscreen) {
        readTask(() => this.readDimensions());
      } else if (this.cTop !== 0 || this.cBottom !== 0) {
        this.cTop = this.cBottom = 0;
        forceUpdate(this);
      }
    }
  }
  readDimensions() {
    const page = getPageElement(this.el);
    const top = Math.max(this.el.offsetTop, 0);
    const bottom = Math.max(page.offsetHeight - top - this.el.offsetHeight, 0);
    const dirty = top !== this.cTop || bottom !== this.cBottom;
    if (dirty) {
      this.cTop = top;
      this.cBottom = bottom;
      forceUpdate(this);
    }
  }
  onScroll(ev) {
    const timeStamp = Date.now();
    const shouldStart = !this.isScrolling;
    this.lastScroll = timeStamp;
    if (shouldStart) {
      this.onScrollStart();
    }
    if (!this.queued && this.scrollEvents) {
      this.queued = true;
      readTask((ts2) => {
        this.queued = false;
        this.detail.event = ev;
        updateScrollDetail(this.detail, this.scrollEl, ts2, shouldStart);
        this.ionScroll.emit(this.detail);
      });
    }
  }
  /**
   * Get the element where the actual scrolling takes place.
   * This element can be used to subscribe to `scroll` events or manually modify
   * `scrollTop`. However, it's recommended to use the API provided by `ion-content`:
   *
   * i.e. Using `ionScroll`, `ionScrollStart`, `ionScrollEnd` for scrolling events
   * and `scrollToPoint()` to scroll the content into a certain point.
   */
  async getScrollElement() {
    if (!this.scrollEl) {
      await new Promise((resolve) => componentOnReady(this.el, resolve));
    }
    return Promise.resolve(this.scrollEl);
  }
  /**
   * Returns the background content element.
   * @internal
   */
  async getBackgroundElement() {
    if (!this.backgroundContentEl) {
      await new Promise((resolve) => componentOnReady(this.el, resolve));
    }
    return Promise.resolve(this.backgroundContentEl);
  }
  /**
   * Scroll to the top of the component.
   *
   * @param duration The amount of time to take scrolling to the top. Defaults to `0`.
   */
  scrollToTop(duration = 0) {
    return this.scrollToPoint(void 0, 0, duration);
  }
  /**
   * Scroll to the bottom of the component.
   *
   * @param duration The amount of time to take scrolling to the bottom. Defaults to `0`.
   */
  async scrollToBottom(duration = 0) {
    const scrollEl = await this.getScrollElement();
    const y2 = scrollEl.scrollHeight - scrollEl.clientHeight;
    return this.scrollToPoint(void 0, y2, duration);
  }
  /**
   * Scroll by a specified X/Y distance in the component.
   *
   * @param x The amount to scroll by on the horizontal axis.
   * @param y The amount to scroll by on the vertical axis.
   * @param duration The amount of time to take scrolling by that amount.
   */
  async scrollByPoint(x2, y2, duration) {
    const scrollEl = await this.getScrollElement();
    return this.scrollToPoint(x2 + scrollEl.scrollLeft, y2 + scrollEl.scrollTop, duration);
  }
  /**
   * Scroll to a specified X/Y location in the component.
   *
   * @param x The point to scroll to on the horizontal axis.
   * @param y The point to scroll to on the vertical axis.
   * @param duration The amount of time to take scrolling to that point. Defaults to `0`.
   */
  async scrollToPoint(x2, y2, duration = 0) {
    const el2 = await this.getScrollElement();
    if (duration < 32) {
      if (y2 != null) {
        el2.scrollTop = y2;
      }
      if (x2 != null) {
        el2.scrollLeft = x2;
      }
      return;
    }
    let resolve;
    let startTime = 0;
    const promise3 = new Promise((r2) => resolve = r2);
    const fromY = el2.scrollTop;
    const fromX = el2.scrollLeft;
    const deltaY = y2 != null ? y2 - fromY : 0;
    const deltaX = x2 != null ? x2 - fromX : 0;
    const step = (timeStamp) => {
      const linearTime = Math.min(1, (timeStamp - startTime) / duration) - 1;
      const easedT = Math.pow(linearTime, 3) + 1;
      if (deltaY !== 0) {
        el2.scrollTop = Math.floor(easedT * deltaY + fromY);
      }
      if (deltaX !== 0) {
        el2.scrollLeft = Math.floor(easedT * deltaX + fromX);
      }
      if (easedT < 1) {
        requestAnimationFrame(step);
      } else {
        resolve();
      }
    };
    requestAnimationFrame((ts2) => {
      startTime = ts2;
      step(ts2);
    });
    return promise3;
  }
  onScrollStart() {
    this.isScrolling = true;
    this.ionScrollStart.emit({
      isScrolling: true
    });
    if (this.watchDog) {
      clearInterval(this.watchDog);
    }
    this.watchDog = setInterval(() => {
      if (this.lastScroll < Date.now() - 120) {
        this.onScrollEnd();
      }
    }, 100);
  }
  onScrollEnd() {
    if (this.watchDog)
      clearInterval(this.watchDog);
    this.watchDog = null;
    if (this.isScrolling) {
      this.isScrolling = false;
      this.ionScrollEnd.emit({
        isScrolling: false
      });
    }
  }
  render() {
    const { isMainContent, scrollX, scrollY, el: el2 } = this;
    const rtl = isRTL$1(el2) ? "rtl" : "ltr";
    const mode = getIonMode$2(this);
    const forceOverscroll = this.shouldForceOverscroll();
    const transitionShadow = mode === "ios";
    const TagType = isMainContent ? "main" : "div";
    this.resize();
    return h$5(Host$1, { class: createColorClasses$1(this.color, {
      [mode]: true,
      "content-sizing": hostContext("ion-popover", this.el),
      overscroll: forceOverscroll,
      [`content-${rtl}`]: true
    }), style: {
      "--offset-top": `${this.cTop}px`,
      "--offset-bottom": `${this.cBottom}px`
    } }, h$5("div", { ref: (el3) => this.backgroundContentEl = el3, id: "background-content", part: "background" }), h$5(TagType, { class: {
      "inner-scroll": true,
      "scroll-x": scrollX,
      "scroll-y": scrollY,
      overscroll: (scrollX || scrollY) && forceOverscroll
    }, ref: (scrollEl) => this.scrollEl = scrollEl, onScroll: this.scrollEvents ? (ev) => this.onScroll(ev) : void 0, part: "scroll" }, h$5("slot", null)), transitionShadow ? h$5("div", { class: "transition-effect" }, h$5("div", { class: "transition-cover" }), h$5("div", { class: "transition-shadow" })) : null, h$5("slot", { name: "fixed" }));
  }
  get el() {
    return this;
  }
  static get style() {
    return contentCss;
  }
}, [1, "ion-content", {
  "color": [513],
  "fullscreen": [4],
  "forceOverscroll": [1028, "force-overscroll"],
  "scrollX": [4, "scroll-x"],
  "scrollY": [4, "scroll-y"],
  "scrollEvents": [4, "scroll-events"],
  "getScrollElement": [64],
  "getBackgroundElement": [64],
  "scrollToTop": [64],
  "scrollToBottom": [64],
  "scrollByPoint": [64],
  "scrollToPoint": [64]
}, [[8, "appload", "onAppLoad"], [9, "resize", "onResize"]]]);
const getParentElement = (el2) => {
  var _a2;
  if (el2.parentElement) {
    return el2.parentElement;
  }
  if ((_a2 = el2.parentNode) === null || _a2 === void 0 ? void 0 : _a2.host) {
    return el2.parentNode.host;
  }
  return null;
};
const getPageElement = (el2) => {
  const tabs = el2.closest("ion-tabs");
  if (tabs) {
    return tabs;
  }
  const page = el2.closest("ion-app, ion-page, .ion-page, page-inner, .popover-content");
  if (page) {
    return page;
  }
  return getParentElement(el2);
};
const updateScrollDetail = (detail, el2, timestamp, shouldStart) => {
  const prevX = detail.currentX;
  const prevY = detail.currentY;
  const prevT = detail.currentTime;
  const currentX = el2.scrollLeft;
  const currentY = el2.scrollTop;
  const timeDelta = timestamp - prevT;
  if (shouldStart) {
    detail.startTime = timestamp;
    detail.startX = currentX;
    detail.startY = currentY;
    detail.velocityX = detail.velocityY = 0;
  }
  detail.currentTime = timestamp;
  detail.currentX = detail.scrollLeft = currentX;
  detail.currentY = detail.scrollTop = currentY;
  detail.deltaX = currentX - detail.startX;
  detail.deltaY = currentY - detail.startY;
  if (timeDelta > 0 && timeDelta < 100) {
    const velocityX = (currentX - prevX) / timeDelta;
    const velocityY = (currentY - prevY) / timeDelta;
    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;
    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;
  }
};
function defineCustomElement$1$z() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-content"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-content":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Content);
        }
        break;
    }
  });
}
const defineCustomElement$X = defineCustomElement$1$z;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const ION_FOCUSED = "ion-focused";
const ION_FOCUSABLE = "ion-focusable";
const FOCUS_KEYS = [
  "Tab",
  "ArrowDown",
  "Space",
  "Escape",
  " ",
  "Shift",
  "Enter",
  "ArrowLeft",
  "ArrowRight",
  "ArrowUp",
  "Home",
  "End"
];
const startFocusVisible = (rootEl) => {
  let currentFocus = [];
  let keyboardMode = true;
  const ref = rootEl ? rootEl.shadowRoot : document;
  const root2 = rootEl ? rootEl : document.body;
  const setFocus = (elements) => {
    currentFocus.forEach((el2) => el2.classList.remove(ION_FOCUSED));
    elements.forEach((el2) => el2.classList.add(ION_FOCUSED));
    currentFocus = elements;
  };
  const pointerDown = () => {
    keyboardMode = false;
    setFocus([]);
  };
  const onKeydown = (ev) => {
    keyboardMode = FOCUS_KEYS.includes(ev.key);
    if (!keyboardMode) {
      setFocus([]);
    }
  };
  const onFocusin = (ev) => {
    if (keyboardMode && ev.composedPath !== void 0) {
      const toFocus = ev.composedPath().filter((el2) => {
        if (el2.classList) {
          return el2.classList.contains(ION_FOCUSABLE);
        }
        return false;
      });
      setFocus(toFocus);
    }
  };
  const onFocusout = () => {
    if (ref.activeElement === root2) {
      setFocus([]);
    }
  };
  ref.addEventListener("keydown", onKeydown);
  ref.addEventListener("focusin", onFocusin);
  ref.addEventListener("focusout", onFocusout);
  ref.addEventListener("touchstart", pointerDown);
  ref.addEventListener("mousedown", pointerDown);
  const destroy = () => {
    ref.removeEventListener("keydown", onKeydown);
    ref.removeEventListener("focusin", onFocusin);
    ref.removeEventListener("focusout", onFocusout);
    ref.removeEventListener("touchstart", pointerDown);
    ref.removeEventListener("mousedown", pointerDown);
  };
  return {
    destroy,
    setFocus
  };
};
const focusVisible = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  startFocusVisible
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const isSameDay = (baseParts, compareParts) => {
  return baseParts.month === compareParts.month && baseParts.day === compareParts.day && baseParts.year === compareParts.year;
};
const isBefore$1 = (baseParts, compareParts) => {
  return !!(baseParts.year < compareParts.year || baseParts.year === compareParts.year && baseParts.month < compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day < compareParts.day);
};
const isAfter$1 = (baseParts, compareParts) => {
  return !!(baseParts.year > compareParts.year || baseParts.year === compareParts.year && baseParts.month > compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day > compareParts.day);
};
const warnIfValueOutOfBounds = (value, min3, max3) => {
  const valueArray = Array.isArray(value) ? value : [value];
  for (const val of valueArray) {
    if (min3 !== void 0 && isBefore$1(val, min3) || max3 !== void 0 && isAfter$1(val, max3)) {
      printIonWarning(`The value provided to ion-datetime is out of bounds.

Min: ${JSON.stringify(min3)}
Max: ${JSON.stringify(max3)}
Value: ${JSON.stringify(value)}`);
      break;
    }
  }
};
const isLeapYear$1 = (year) => {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
const is24Hour = (locale2, hourCycle) => {
  if (hourCycle !== void 0) {
    return hourCycle === "h23";
  }
  const formatted = new Intl.DateTimeFormat(locale2, { hour: "numeric" });
  const options = formatted.resolvedOptions();
  if (options.hourCycle !== void 0) {
    return options.hourCycle === "h23";
  }
  const date2 = /* @__PURE__ */ new Date("5/18/2021 00:00");
  const parts = formatted.formatToParts(date2);
  const hour = parts.find((p2) => p2.type === "hour");
  if (!hour) {
    throw new Error("Hour value not found from DateTimeFormat");
  }
  return hour.value === "00";
};
const getNumDaysInMonth = (month, year) => {
  return month === 4 || month === 6 || month === 9 || month === 11 ? 30 : month === 2 ? isLeapYear$1(year) ? 29 : 28 : 31;
};
const isMonthFirstLocale = (locale2, formatOptions = {
  month: "numeric",
  year: "numeric"
}) => {
  const parts = new Intl.DateTimeFormat(locale2, formatOptions).formatToParts(/* @__PURE__ */ new Date());
  return parts[0].type === "month";
};
const isLocaleDayPeriodRTL = (locale2) => {
  const parts = new Intl.DateTimeFormat(locale2, { hour: "numeric" }).formatToParts(/* @__PURE__ */ new Date());
  return parts[0].type === "dayPeriod";
};
const ISO_8601_REGEXP = (
  // eslint-disable-next-line no-useless-escape
  /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/
);
const TIME_REGEXP = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
const convertToArrayOfNumbers = (input) => {
  if (input === void 0) {
    return;
  }
  let processedInput = input;
  if (typeof input === "string") {
    processedInput = input.replace(/\[|\]|\s/g, "").split(",");
  }
  let values3;
  if (Array.isArray(processedInput)) {
    values3 = processedInput.map((num) => parseInt(num, 10)).filter(isFinite);
  } else {
    values3 = [processedInput];
  }
  return values3;
};
const getPartsFromCalendarDay = (el2) => {
  return {
    month: parseInt(el2.getAttribute("data-month"), 10),
    day: parseInt(el2.getAttribute("data-day"), 10),
    year: parseInt(el2.getAttribute("data-year"), 10),
    dayOfWeek: parseInt(el2.getAttribute("data-day-of-week"), 10)
  };
};
function parseDate(val) {
  if (Array.isArray(val)) {
    return val.map((valStr) => parseDate(valStr));
  }
  let parse2 = null;
  if (val != null && val !== "") {
    parse2 = TIME_REGEXP.exec(val);
    if (parse2) {
      parse2.unshift(void 0, void 0);
      parse2[2] = parse2[3] = void 0;
    } else {
      parse2 = ISO_8601_REGEXP.exec(val);
    }
  }
  if (parse2 === null) {
    return void 0;
  }
  for (let i = 1; i < 8; i++) {
    parse2[i] = parse2[i] !== void 0 ? parseInt(parse2[i], 10) : void 0;
  }
  return {
    year: parse2[1],
    month: parse2[2],
    day: parse2[3],
    hour: parse2[4],
    minute: parse2[5],
    ampm: parse2[4] < 12 ? "am" : "pm"
  };
}
const clampDate = (dateParts, minParts, maxParts) => {
  if (minParts && isBefore$1(dateParts, minParts)) {
    return minParts;
  } else if (maxParts && isAfter$1(dateParts, maxParts)) {
    return maxParts;
  }
  return dateParts;
};
const parseAmPm = (hour) => {
  return hour >= 12 ? "pm" : "am";
};
const parseMaxParts = (max3, todayParts) => {
  const { month, day, year, hour, minute } = parseDate(max3);
  const yearValue = year !== null && year !== void 0 ? year : todayParts.year;
  const monthValue = month !== null && month !== void 0 ? month : 12;
  return {
    month: monthValue,
    day: day !== null && day !== void 0 ? day : getNumDaysInMonth(monthValue, yearValue),
    /**
     * Passing in "HH:mm" is a valid ISO-8601
     * string, so we just default to the current year
     * in this case.
     */
    year: yearValue,
    hour: hour !== null && hour !== void 0 ? hour : 23,
    minute: minute !== null && minute !== void 0 ? minute : 59
  };
};
const parseMinParts = (min3, todayParts) => {
  const { month, day, year, hour, minute } = parseDate(min3);
  return {
    month: month !== null && month !== void 0 ? month : 1,
    day: day !== null && day !== void 0 ? day : 1,
    /**
     * Passing in "HH:mm" is a valid ISO-8601
     * string, so we just default to the current year
     * in this case.
     */
    year: year !== null && year !== void 0 ? year : todayParts.year,
    hour: hour !== null && hour !== void 0 ? hour : 0,
    minute: minute !== null && minute !== void 0 ? minute : 0
  };
};
const twoDigit = (val) => {
  return ("0" + (val !== void 0 ? Math.abs(val) : "0")).slice(-2);
};
const fourDigit = (val) => {
  return ("000" + (val !== void 0 ? Math.abs(val) : "0")).slice(-4);
};
function convertDataToISO(data2) {
  if (Array.isArray(data2)) {
    return data2.map((parts) => convertDataToISO(parts));
  }
  let rtn = "";
  if (data2.year !== void 0) {
    rtn = fourDigit(data2.year);
    if (data2.month !== void 0) {
      rtn += "-" + twoDigit(data2.month);
      if (data2.day !== void 0) {
        rtn += "-" + twoDigit(data2.day);
        if (data2.hour !== void 0) {
          rtn += `T${twoDigit(data2.hour)}:${twoDigit(data2.minute)}:00`;
        }
      }
    }
  } else if (data2.hour !== void 0) {
    rtn = twoDigit(data2.hour) + ":" + twoDigit(data2.minute);
  }
  return rtn;
}
const convert12HourTo24Hour = (hour, ampm) => {
  if (ampm === void 0) {
    return hour;
  }
  if (ampm === "am") {
    if (hour === 12) {
      return 0;
    }
    return hour;
  }
  if (hour === 12) {
    return 12;
  }
  return hour + 12;
};
const getStartOfWeek = (refParts) => {
  const { dayOfWeek: dayOfWeek2 } = refParts;
  if (dayOfWeek2 === null || dayOfWeek2 === void 0) {
    throw new Error("No day of week provided");
  }
  return subtractDays(refParts, dayOfWeek2);
};
const getEndOfWeek = (refParts) => {
  const { dayOfWeek: dayOfWeek2 } = refParts;
  if (dayOfWeek2 === null || dayOfWeek2 === void 0) {
    throw new Error("No day of week provided");
  }
  return addDays(refParts, 6 - dayOfWeek2);
};
const getNextDay = (refParts) => {
  return addDays(refParts, 1);
};
const getPreviousDay = (refParts) => {
  return subtractDays(refParts, 1);
};
const getPreviousWeek = (refParts) => {
  return subtractDays(refParts, 7);
};
const getNextWeek = (refParts) => {
  return addDays(refParts, 7);
};
const subtractDays = (refParts, numDays) => {
  const { month, day, year } = refParts;
  if (day === null) {
    throw new Error("No day provided");
  }
  const workingParts = {
    month,
    day,
    year
  };
  workingParts.day = day - numDays;
  if (workingParts.day < 1) {
    workingParts.month -= 1;
  }
  if (workingParts.month < 1) {
    workingParts.month = 12;
    workingParts.year -= 1;
  }
  if (workingParts.day < 1) {
    const daysInMonth2 = getNumDaysInMonth(workingParts.month, workingParts.year);
    workingParts.day = daysInMonth2 + workingParts.day;
  }
  return workingParts;
};
const addDays = (refParts, numDays) => {
  const { month, day, year } = refParts;
  if (day === null) {
    throw new Error("No day provided");
  }
  const workingParts = {
    month,
    day,
    year
  };
  const daysInMonth2 = getNumDaysInMonth(month, year);
  workingParts.day = day + numDays;
  if (workingParts.day > daysInMonth2) {
    workingParts.day -= daysInMonth2;
    workingParts.month += 1;
  }
  if (workingParts.month > 12) {
    workingParts.month = 1;
    workingParts.year += 1;
  }
  return workingParts;
};
const getPreviousMonth = (refParts) => {
  const month = refParts.month === 1 ? 12 : refParts.month - 1;
  const year = refParts.month === 1 ? refParts.year - 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return { month, year, day };
};
const getNextMonth = (refParts) => {
  const month = refParts.month === 12 ? 1 : refParts.month + 1;
  const year = refParts.month === 12 ? refParts.year + 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return { month, year, day };
};
const changeYear = (refParts, yearDelta) => {
  const month = refParts.month;
  const year = refParts.year + yearDelta;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return { month, year, day };
};
const getPreviousYear = (refParts) => {
  return changeYear(refParts, -1);
};
const getNextYear = (refParts) => {
  return changeYear(refParts, 1);
};
const getInternalHourValue = (hour, use24Hour, ampm) => {
  if (use24Hour) {
    return hour;
  }
  return convert12HourTo24Hour(hour, ampm);
};
const calculateHourFromAMPM = (currentParts, newAMPM) => {
  const { ampm: currentAMPM, hour } = currentParts;
  let newHour = hour;
  if (currentAMPM === "am" && newAMPM === "pm") {
    newHour = convert12HourTo24Hour(newHour, "pm");
  } else if (currentAMPM === "pm" && newAMPM === "am") {
    newHour = Math.abs(newHour - 12);
  }
  return newHour;
};
const validateParts = (parts, minParts, maxParts) => {
  const { month, day, year } = parts;
  const partsCopy = clampDate(Object.assign({}, parts), minParts, maxParts);
  const numDays = getNumDaysInMonth(month, year);
  if (day !== null && numDays < day) {
    partsCopy.day = numDays;
  }
  if (minParts !== void 0 && isSameDay(partsCopy, minParts)) {
    if (partsCopy.hour !== void 0 && minParts.hour !== void 0) {
      if (partsCopy.hour < minParts.hour) {
        partsCopy.hour = minParts.hour;
        partsCopy.minute = minParts.minute;
      } else if (partsCopy.hour === minParts.hour && partsCopy.minute !== void 0 && minParts.minute !== void 0 && partsCopy.minute < minParts.minute) {
        partsCopy.minute = minParts.minute;
      }
    }
  }
  if (maxParts !== void 0 && isSameDay(parts, maxParts)) {
    if (partsCopy.hour !== void 0 && maxParts.hour !== void 0) {
      if (partsCopy.hour > maxParts.hour) {
        partsCopy.hour = maxParts.hour;
        partsCopy.minute = maxParts.minute;
      } else if (partsCopy.hour === maxParts.hour && partsCopy.minute !== void 0 && maxParts.minute !== void 0 && partsCopy.minute > maxParts.minute) {
        partsCopy.minute = maxParts.minute;
      }
    }
  }
  return partsCopy;
};
const getClosestValidDate = (refParts, monthValues, dayValues, yearValues, hourValues, minuteValues) => {
  const { hour, minute, day, month, year } = refParts;
  const copyParts = Object.assign(Object.assign({}, refParts), { dayOfWeek: void 0 });
  if (monthValues !== void 0) {
    copyParts.month = findClosestValue(month, monthValues);
  }
  if (day !== null && dayValues !== void 0) {
    copyParts.day = findClosestValue(day, dayValues);
  }
  if (yearValues !== void 0) {
    copyParts.year = findClosestValue(year, yearValues);
  }
  if (hour !== void 0 && hourValues !== void 0) {
    copyParts.hour = findClosestValue(hour, hourValues);
    copyParts.ampm = parseAmPm(copyParts.hour);
  }
  if (minute !== void 0 && minuteValues !== void 0) {
    copyParts.minute = findClosestValue(minute, minuteValues);
  }
  return copyParts;
};
const findClosestValue = (reference, values3) => {
  let closestValue = values3[0];
  let rank = Math.abs(closestValue - reference);
  for (let i = 1; i < values3.length; i++) {
    const value = values3[i];
    const valueRank = Math.abs(value - reference);
    if (valueRank < rank) {
      closestValue = value;
      rank = valueRank;
    }
  }
  return closestValue;
};
const getFormattedDayPeriod = (dayPeriod) => {
  if (dayPeriod === void 0) {
    return "";
  }
  return dayPeriod.toUpperCase();
};
const getLocalizedTime = (locale2, refParts, use24Hour) => {
  const timeParts = {
    hour: refParts.hour,
    minute: refParts.minute
  };
  if (timeParts.hour === void 0 || timeParts.minute === void 0) {
    return "Invalid Time";
  }
  return new Intl.DateTimeFormat(locale2, {
    hour: "numeric",
    minute: "numeric",
    /**
     * Setting the timeZone to UTC prevents
     * new Intl.DatetimeFormat from subtracting
     * the user's current timezone offset
     * when formatting the time.
     */
    timeZone: "UTC",
    /**
     * We use hourCycle here instead of hour12 due to:
     * https://bugs.chromium.org/p/chromium/issues/detail?id=1347316&q=hour12&can=2
     */
    hourCycle: use24Hour ? "h23" : "h12"
    /**
     * Setting Z at the end indicates that this
     * date string is in the UTC time zone. This
     * prevents new Date from adding the time zone
     * offset when getting the ISO string.
     */
  }).format(/* @__PURE__ */ new Date(convertDataToISO(Object.assign({
    /**
     * JS uses a simplified ISO 8601 format which allows for
     * date-only formats and date-time formats, but not
     * time-only formats: https://tc39.es/ecma262/#sec-date-time-string-format
     * As a result, developers who only pass a time will get
     * an "Invalid Date" error. To account for this, we make sure that
     * year/day/month values are set when passing to new Date().
     * The Intl.DateTimeFormat call above only uses the hour/minute
     * values, so passing these date values should have no impact
     * on the time output.
     */
    year: 2023,
    day: 1,
    month: 1
  }, timeParts)) + "Z"));
};
const addTimePadding = (value) => {
  const valueToString = value.toString();
  if (valueToString.length > 1) {
    return valueToString;
  }
  return `0${valueToString}`;
};
const getFormattedHour = (hour, use24Hour) => {
  if (use24Hour) {
    return addTimePadding(hour);
  }
  if (hour === 0) {
    return "12";
  }
  return hour.toString();
};
const generateDayAriaLabel = (locale2, today, refParts) => {
  if (refParts.day === null) {
    return null;
  }
  const date2 = /* @__PURE__ */ new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  const labelString = new Intl.DateTimeFormat(locale2, {
    weekday: "long",
    month: "long",
    day: "numeric",
    timeZone: "UTC"
  }).format(date2);
  return today ? `Today, ${labelString}` : labelString;
};
const getMonthAndDay = (locale2, refParts) => {
  const date2 = /* @__PURE__ */ new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  return new Intl.DateTimeFormat(locale2, { weekday: "short", month: "short", day: "numeric", timeZone: "UTC" }).format(date2);
};
const getMonthAndYear = (locale2, refParts) => {
  const date2 = /* @__PURE__ */ new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  return new Intl.DateTimeFormat(locale2, { month: "long", year: "numeric", timeZone: "UTC" }).format(date2);
};
const getDay = (locale2, refParts) => {
  return getLocalizedDateTimeParts(locale2, refParts, { day: "numeric" }).find((obj) => obj.type === "day").value;
};
const getYear = (locale2, refParts) => {
  return getLocalizedDateTime(locale2, refParts, { year: "numeric" });
};
const getNormalizedDate = (refParts) => {
  const timeString = refParts.hour !== void 0 && refParts.minute !== void 0 ? ` ${refParts.hour}:${refParts.minute}` : "";
  return /* @__PURE__ */ new Date(`${refParts.month}/${refParts.day}/${refParts.year}${timeString} GMT+0000`);
};
const getLocalizedDateTime = (locale2, refParts, options) => {
  const date2 = getNormalizedDate(refParts);
  return getDateTimeFormat(locale2, options).format(date2);
};
const getLocalizedDateTimeParts = (locale2, refParts, options) => {
  const date2 = getNormalizedDate(refParts);
  return getDateTimeFormat(locale2, options).formatToParts(date2);
};
const getDateTimeFormat = (locale2, options) => {
  return new Intl.DateTimeFormat(locale2, Object.assign(Object.assign({}, options), { timeZone: "UTC" }));
};
const getTodayLabel = (locale2) => {
  if ("RelativeTimeFormat" in Intl) {
    const label = new Intl.RelativeTimeFormat(locale2, { numeric: "auto" }).format(0, "day");
    return label.charAt(0).toUpperCase() + label.slice(1);
  } else {
    return "Today";
  }
};
const removeDateTzOffset = (date2) => {
  const tzOffset = date2.getTimezoneOffset();
  date2.setMinutes(date2.getMinutes() - tzOffset);
  return date2;
};
const DATE_AM = removeDateTzOffset(/* @__PURE__ */ new Date("2022T01:00"));
const DATE_PM = removeDateTzOffset(/* @__PURE__ */ new Date("2022T13:00"));
const getLocalizedDayPeriod = (locale2, dayPeriod) => {
  const date2 = dayPeriod === "am" ? DATE_AM : DATE_PM;
  const localizedDayPeriod = new Intl.DateTimeFormat(locale2, {
    hour: "numeric",
    timeZone: "UTC"
  }).formatToParts(date2).find((part) => part.type === "dayPeriod");
  if (localizedDayPeriod) {
    return localizedDayPeriod.value;
  }
  return getFormattedDayPeriod(dayPeriod);
};
const formatValue = (value) => {
  return Array.isArray(value) ? value.join(",") : value;
};
const getToday = () => {
  return removeDateTzOffset(/* @__PURE__ */ new Date()).toISOString();
};
const minutes$1 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59
];
const hour12 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
const hour23 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
const getDaysOfWeek = (locale2, mode, firstDayOfWeek = 0) => {
  const weekdayFormat = mode === "ios" ? "short" : "narrow";
  const intl = new Intl.DateTimeFormat(locale2, { weekday: weekdayFormat });
  const startDate = /* @__PURE__ */ new Date("11/01/2020");
  const daysOfWeek = [];
  for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {
    const currentDate = new Date(startDate);
    currentDate.setDate(currentDate.getDate() + i);
    daysOfWeek.push(intl.format(currentDate));
  }
  return daysOfWeek;
};
const getDaysOfMonth = (month, year, firstDayOfWeek) => {
  const numDays = getNumDaysInMonth(month, year);
  const firstOfMonth = (/* @__PURE__ */ new Date(`${month}/1/${year}`)).getDay();
  const offset2 = firstOfMonth >= firstDayOfWeek ? firstOfMonth - (firstDayOfWeek + 1) : 6 - (firstDayOfWeek - firstOfMonth);
  let days2 = [];
  for (let i = 1; i <= numDays; i++) {
    days2.push({ day: i, dayOfWeek: (offset2 + i) % 7 });
  }
  for (let i = 0; i <= offset2; i++) {
    days2 = [{ day: null, dayOfWeek: null }, ...days2];
  }
  return days2;
};
const generateTime = (refParts, hourCycle = "h12", minParts, maxParts, hourValues, minuteValues) => {
  const use24Hour = hourCycle === "h23";
  let processedHours = use24Hour ? hour23 : hour12;
  let processedMinutes = minutes$1;
  let isAMAllowed = true;
  let isPMAllowed = true;
  if (hourValues) {
    processedHours = processedHours.filter((hour) => hourValues.includes(hour));
  }
  if (minuteValues) {
    processedMinutes = processedMinutes.filter((minute) => minuteValues.includes(minute));
  }
  if (minParts) {
    if (isSameDay(refParts, minParts)) {
      if (minParts.hour !== void 0) {
        processedHours = processedHours.filter((hour) => {
          const convertedHour = refParts.ampm === "pm" ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) >= minParts.hour;
        });
        isAMAllowed = minParts.hour < 13;
      }
      if (minParts.minute !== void 0) {
        let isPastMinHour = false;
        if (minParts.hour !== void 0 && refParts.hour !== void 0) {
          if (refParts.hour > minParts.hour) {
            isPastMinHour = true;
          }
        }
        processedMinutes = processedMinutes.filter((minute) => {
          if (isPastMinHour) {
            return true;
          }
          return minute >= minParts.minute;
        });
      }
    } else if (isBefore$1(refParts, minParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }
  if (maxParts) {
    if (isSameDay(refParts, maxParts)) {
      if (maxParts.hour !== void 0) {
        processedHours = processedHours.filter((hour) => {
          const convertedHour = refParts.ampm === "pm" ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) <= maxParts.hour;
        });
        isPMAllowed = maxParts.hour >= 12;
      }
      if (maxParts.minute !== void 0 && refParts.hour === maxParts.hour) {
        processedMinutes = processedMinutes.filter((minute) => minute <= maxParts.minute);
      }
    } else if (isAfter$1(refParts, maxParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }
  return {
    hours: processedHours,
    minutes: processedMinutes,
    am: isAMAllowed,
    pm: isPMAllowed
  };
};
const generateMonths = (refParts) => {
  return [
    getPreviousMonth(refParts),
    { month: refParts.month, year: refParts.year, day: refParts.day },
    getNextMonth(refParts)
  ];
};
const getMonthColumnData = (locale2, refParts, minParts, maxParts, monthValues, formatOptions = {
  month: "long"
}) => {
  const { year } = refParts;
  const months2 = [];
  if (monthValues !== void 0) {
    let processedMonths = monthValues;
    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.month) !== void 0) {
      processedMonths = processedMonths.filter((month) => month <= maxParts.month);
    }
    if ((minParts === null || minParts === void 0 ? void 0 : minParts.month) !== void 0) {
      processedMonths = processedMonths.filter((month) => month >= minParts.month);
    }
    processedMonths.forEach((processedMonth) => {
      const date2 = /* @__PURE__ */ new Date(`${processedMonth}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale2, Object.assign(Object.assign({}, formatOptions), { timeZone: "UTC" })).format(date2);
      months2.push({ text: monthString, value: processedMonth });
    });
  } else {
    const maxMonth = maxParts && maxParts.year === year ? maxParts.month : 12;
    const minMonth = minParts && minParts.year === year ? minParts.month : 1;
    for (let i = minMonth; i <= maxMonth; i++) {
      const date2 = /* @__PURE__ */ new Date(`${i}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale2, Object.assign(Object.assign({}, formatOptions), { timeZone: "UTC" })).format(date2);
      months2.push({ text: monthString, value: i });
    }
  }
  return months2;
};
const getDayColumnData = (locale2, refParts, minParts, maxParts, dayValues, formatOptions = {
  day: "numeric"
}) => {
  const { month, year } = refParts;
  const days2 = [];
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const maxDay = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== null && (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== void 0 && maxParts.year === year && maxParts.month === month ? maxParts.day : numDaysInMonth;
  const minDay = (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== null && (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== void 0 && minParts.year === year && minParts.month === month ? minParts.day : 1;
  if (dayValues !== void 0) {
    let processedDays = dayValues;
    processedDays = processedDays.filter((day) => day >= minDay && day <= maxDay);
    processedDays.forEach((processedDay) => {
      const date2 = /* @__PURE__ */ new Date(`${month}/${processedDay}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale2, Object.assign(Object.assign({}, formatOptions), { timeZone: "UTC" })).format(date2);
      days2.push({ text: dayString, value: processedDay });
    });
  } else {
    for (let i = minDay; i <= maxDay; i++) {
      const date2 = /* @__PURE__ */ new Date(`${month}/${i}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale2, Object.assign(Object.assign({}, formatOptions), { timeZone: "UTC" })).format(date2);
      days2.push({ text: dayString, value: i });
    }
  }
  return days2;
};
const getYearColumnData = (locale2, refParts, minParts, maxParts, yearValues) => {
  var _a2, _b;
  let processedYears = [];
  if (yearValues !== void 0) {
    processedYears = yearValues;
    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== void 0) {
      processedYears = processedYears.filter((year) => year <= maxParts.year);
    }
    if ((minParts === null || minParts === void 0 ? void 0 : minParts.year) !== void 0) {
      processedYears = processedYears.filter((year) => year >= minParts.year);
    }
  } else {
    const { year } = refParts;
    const maxYear = (_a2 = maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== null && _a2 !== void 0 ? _a2 : year;
    const minYear = (_b = minParts === null || minParts === void 0 ? void 0 : minParts.year) !== null && _b !== void 0 ? _b : year - 100;
    for (let i = maxYear; i >= minYear; i--) {
      processedYears.push(i);
    }
  }
  return processedYears.map((year) => ({
    text: getYear(locale2, { year, month: refParts.month, day: refParts.day }),
    value: year
  }));
};
const getAllMonthsInRange = (currentParts, maxParts) => {
  if (currentParts.month === maxParts.month && currentParts.year === maxParts.year) {
    return [currentParts];
  }
  return [currentParts, ...getAllMonthsInRange(getNextMonth(currentParts), maxParts)];
};
const getCombinedDateColumnData = (locale2, todayParts, minParts, maxParts, dayValues, monthValues) => {
  let items = [];
  let parts = [];
  let months2 = getAllMonthsInRange(minParts, maxParts);
  if (monthValues) {
    months2 = months2.filter(({ month }) => monthValues.includes(month));
  }
  months2.forEach((monthObject) => {
    const referenceMonth = { month: monthObject.month, day: null, year: monthObject.year };
    const monthDays = getDayColumnData(locale2, referenceMonth, minParts, maxParts, dayValues, {
      month: "short",
      day: "numeric",
      weekday: "short"
    });
    const dateParts = [];
    const dateColumnItems = [];
    monthDays.forEach((dayObject) => {
      const isToday = isSameDay(Object.assign(Object.assign({}, referenceMonth), { day: dayObject.value }), todayParts);
      dateColumnItems.push({
        text: isToday ? getTodayLabel(locale2) : dayObject.text,
        value: `${referenceMonth.year}-${referenceMonth.month}-${dayObject.value}`
      });
      dateParts.push({
        month: referenceMonth.month,
        year: referenceMonth.year,
        day: dayObject.value
      });
    });
    parts = [...parts, ...dateParts];
    items = [...items, ...dateColumnItems];
  });
  return {
    parts,
    items
  };
};
const getTimeColumnsData = (locale2, refParts, hourCycle, minParts, maxParts, allowedHourValues, allowedMinuteValues) => {
  const use24Hour = is24Hour(locale2, hourCycle);
  const { hours: hours2, minutes: minutes2, am, pm } = generateTime(refParts, use24Hour ? "h23" : "h12", minParts, maxParts, allowedHourValues, allowedMinuteValues);
  const hoursItems = hours2.map((hour) => {
    return {
      text: getFormattedHour(hour, use24Hour),
      value: getInternalHourValue(hour, use24Hour, refParts.ampm)
    };
  });
  const minutesItems = minutes2.map((minute) => {
    return {
      text: addTimePadding(minute),
      value: minute
    };
  });
  const dayPeriodItems = [];
  if (am && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale2, "am"),
      value: "am"
    });
  }
  if (pm && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale2, "pm"),
      value: "pm"
    });
  }
  return {
    minutesData: minutesItems,
    hoursData: hoursItems,
    dayPeriodData: dayPeriodItems
  };
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const buttonIosCss = ':host{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;-webkit-font-kerning:none;font-kerning:none}:host(.button-disabled){cursor:default;opacity:0.5;pointer-events:none}:host(.button-solid){--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff)}:host(.button-outline){--border-color:var(--ion-color-primary, #3880ff);--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-clear){--border-width:0;--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-block){display:block}:host(.button-block) .button-native{margin-left:0;margin-right:0;display:block;width:100%;clear:both;contain:content}:host(.button-block) .button-native::after{clear:both}:host(.button-full){display:block}:host(.button-full) .button-native{margin-left:0;margin-right:0;display:block;width:100%;contain:content}:host(.button-full:not(.button-round)) .button-native{border-radius:0;border-right-width:0;border-left-width:0}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.button-native::-moz-focus-inner{border:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}::slotted(ion-icon){font-size:1.4em;pointer-events:none}::slotted(ion-icon[slot=start]){-webkit-margin-start:-0.3em;margin-inline-start:-0.3em;-webkit-margin-end:0.3em;margin-inline-end:0.3em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=end]){-webkit-margin-start:0.3em;margin-inline-start:0.3em;-webkit-margin-end:-0.2em;margin-inline-end:-0.2em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=icon-only]){font-size:1.8em}ion-ripple-effect{color:var(--ripple-color)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}:host(.ion-focused){color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){:host(:hover){color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-activated){color:var(--color-activated)}:host(.ion-activated) .button-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.button-solid.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.button-outline.ion-color) .button-native{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}:host(.button-clear.ion-color) .button-native{background:transparent;color:var(--ion-color-base)}:host(.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{color:var(--ion-toolbar-color, var(--color))}:host(.button-outline.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{border-color:var(--ion-toolbar-color, var(--color, var(--border-color)))}:host(.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--background));color:var(--ion-toolbar-background, var(--color))}:host(.button-outline.ion-activated.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--color));color:var(--ion-toolbar-background, var(--background), var(--ion-color-primary-contrast, #fff))}:host{--border-radius:14px;--padding-top:0;--padding-bottom:0;--padding-start:1em;--padding-end:1em;--transition:background-color, opacity 100ms linear;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;margin-top:4px;margin-bottom:4px;height:3.1em;font-size:16px;font-weight:500;letter-spacing:0}:host(.in-buttons){font-size:17px;font-weight:400}:host(.button-solid){--background-activated:var(--ion-color-primary-shade, #3171e0);--background-focused:var(--ion-color-primary-shade, #3171e0);--background-hover:var(--ion-color-primary-tint, #4c8dff);--background-activated-opacity:1;--background-focused-opacity:1;--background-hover-opacity:1}:host(.button-outline){--border-radius:14px;--border-width:1px;--border-style:solid;--background-activated:var(--ion-color-primary, #3880ff);--background-focused:var(--ion-color-primary, #3880ff);--background-hover:transparent;--background-focused-opacity:.1;--color-activated:var(--ion-color-primary-contrast, #fff)}:host(.button-clear){--background-activated:transparent;--background-activated-opacity:0;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:transparent;--background-focused-opacity:.1;font-size:17px;font-weight:normal}:host(.button-large){--border-radius:16px;--padding-top:0;--padding-start:1em;--padding-end:1em;--padding-bottom:0;height:3.1em;font-size:20px}:host(.button-small){--border-radius:6px;--padding-top:0;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:0;height:2.1em;font-size:13px}:host(.button-round){--border-radius:64px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}:host(.button-strong){font-weight:600}:host(.button-outline.ion-focused.ion-color) .button-native,:host(.button-clear.ion-focused.ion-color) .button-native{color:var(--ion-color-base)}:host(.button-outline.ion-focused.ion-color) .button-native::after,:host(.button-clear.ion-focused.ion-color) .button-native::after{background:var(--ion-color-base)}:host(.button-solid.ion-color.ion-focused) .button-native::after{background:var(--ion-color-shade)}@media (any-hover: hover){:host(.button-clear:not(.ion-activated):hover),:host(.button-outline:not(.ion-activated):hover){opacity:0.6}:host(.button-clear.ion-color:hover) .button-native,:host(.button-outline.ion-color:hover) .button-native{color:var(--ion-color-base)}:host(.button-clear.ion-color:hover) .button-native::after,:host(.button-outline.ion-color:hover) .button-native::after{background:transparent}:host(.button-solid.ion-color:hover) .button-native::after{background:var(--ion-color-tint)}:host(:hover.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color):not(.ion-activated)) .button-native::after{background:#fff;opacity:0.1}}:host(.button-clear.ion-activated){opacity:0.4}:host(.button-outline.ion-activated.ion-color) .button-native{color:var(--ion-color-contrast)}:host(.button-outline.ion-activated.ion-color) .button-native::after{background:var(--ion-color-base)}:host(.button-solid.ion-color.ion-activated) .button-native::after{background:var(--ion-color-shade)}';
const buttonMdCss = ':host{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;-webkit-font-kerning:none;font-kerning:none}:host(.button-disabled){cursor:default;opacity:0.5;pointer-events:none}:host(.button-solid){--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff)}:host(.button-outline){--border-color:var(--ion-color-primary, #3880ff);--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-clear){--border-width:0;--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-block){display:block}:host(.button-block) .button-native{margin-left:0;margin-right:0;display:block;width:100%;clear:both;contain:content}:host(.button-block) .button-native::after{clear:both}:host(.button-full){display:block}:host(.button-full) .button-native{margin-left:0;margin-right:0;display:block;width:100%;contain:content}:host(.button-full:not(.button-round)) .button-native{border-radius:0;border-right-width:0;border-left-width:0}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.button-native::-moz-focus-inner{border:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}::slotted(ion-icon){font-size:1.4em;pointer-events:none}::slotted(ion-icon[slot=start]){-webkit-margin-start:-0.3em;margin-inline-start:-0.3em;-webkit-margin-end:0.3em;margin-inline-end:0.3em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=end]){-webkit-margin-start:0.3em;margin-inline-start:0.3em;-webkit-margin-end:-0.2em;margin-inline-end:-0.2em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=icon-only]){font-size:1.8em}ion-ripple-effect{color:var(--ripple-color)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}:host(.ion-focused){color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){:host(:hover){color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-activated){color:var(--color-activated)}:host(.ion-activated) .button-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.button-solid.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.button-outline.ion-color) .button-native{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}:host(.button-clear.ion-color) .button-native{background:transparent;color:var(--ion-color-base)}:host(.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{color:var(--ion-toolbar-color, var(--color))}:host(.button-outline.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{border-color:var(--ion-toolbar-color, var(--color, var(--border-color)))}:host(.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--background));color:var(--ion-toolbar-background, var(--color))}:host(.button-outline.ion-activated.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--color));color:var(--ion-toolbar-background, var(--background), var(--ion-color-primary-contrast, #fff))}:host{--border-radius:4px;--padding-top:0;--padding-bottom:0;--padding-start:1.1em;--padding-end:1.1em;--transition:box-shadow 280ms cubic-bezier(.4, 0, .2, 1),\n                background-color 15ms linear,\n                color 15ms linear;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;margin-top:4px;margin-bottom:4px;height:36px;font-size:14px;font-weight:500;letter-spacing:0.06em;text-transform:uppercase}:host(.button-solid){--background-activated:transparent;--background-hover:var(--ion-color-primary-contrast, #fff);--background-focused:var(--ion-color-primary-contrast, #fff);--background-activated-opacity:0;--background-focused-opacity:.24;--background-hover-opacity:.08;--box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)}:host(.button-solid.ion-activated){--box-shadow:0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12)}:host(.button-outline){--border-width:2px;--border-style:solid;--box-shadow:none;--background-activated:transparent;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:var(--ion-color-primary, #3880ff);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04}:host(.button-outline.ion-activated.ion-color) .button-native{background:transparent}:host(.button-clear){--background-activated:transparent;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:var(--ion-color-primary, #3880ff);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04}:host(.button-round){--border-radius:64px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}:host(.button-large){--padding-top:0;--padding-start:1em;--padding-end:1em;--padding-bottom:0;height:2.8em;font-size:20px}:host(.button-small){--padding-top:0;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:0;height:2.1em;font-size:13px}:host(.button-strong){font-weight:bold}::slotted(ion-icon[slot=icon-only]){padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}:host(.button-solid.ion-color.ion-focused) .button-native::after{background:var(--ion-color-contrast)}:host(.button-clear.ion-color.ion-focused) .button-native::after,:host(.button-outline.ion-color.ion-focused) .button-native::after{background:var(--ion-color-base)}@media (any-hover: hover){:host(.button-solid.ion-color:hover) .button-native::after{background:var(--ion-color-contrast)}:host(.button-clear.ion-color:hover) .button-native::after,:host(.button-outline.ion-color:hover) .button-native::after{background:var(--ion-color-base)}}';
const Button = /* @__PURE__ */ proxyCustomElement$1(class Button2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.inItem = false;
    this.inListHeader = false;
    this.inToolbar = false;
    this.inheritedAttributes = {};
    this.handleClick = (ev) => {
      const { el: el2 } = this;
      if (this.type === "button") {
        openURL(this.href, ev, this.routerDirection, this.routerAnimation);
      } else if (hasShadowDom(el2)) {
        let formEl = this.findForm();
        const { form } = this;
        if (!formEl && form !== void 0) {
          if (typeof form === "string") {
            printIonWarning(`Form with selector: "#${form}" could not be found. Verify that the id is correct and the form is rendered in the DOM.`, el2);
          } else {
            printIonWarning(`The provided "form" element is invalid. Verify that the form is a HTMLFormElement and rendered in the DOM.`, el2);
          }
          return;
        }
        if (!formEl) {
          formEl = el2.closest("form");
        }
        if (formEl) {
          ev.preventDefault();
          const fakeButton = document.createElement("button");
          fakeButton.type = this.type;
          fakeButton.style.display = "none";
          formEl.appendChild(fakeButton);
          fakeButton.click();
          fakeButton.remove();
        }
      }
    };
    this.onFocus = () => {
      this.ionFocus.emit();
    };
    this.onBlur = () => {
      this.ionBlur.emit();
    };
    this.color = void 0;
    this.buttonType = "button";
    this.disabled = false;
    this.expand = void 0;
    this.fill = void 0;
    this.routerDirection = "forward";
    this.routerAnimation = void 0;
    this.download = void 0;
    this.href = void 0;
    this.rel = void 0;
    this.shape = void 0;
    this.size = void 0;
    this.strong = false;
    this.target = void 0;
    this.type = "button";
    this.form = void 0;
  }
  componentWillLoad() {
    this.inToolbar = !!this.el.closest("ion-buttons");
    this.inListHeader = !!this.el.closest("ion-list-header");
    this.inItem = !!this.el.closest("ion-item") || !!this.el.closest("ion-item-divider");
    this.inheritedAttributes = inheritAriaAttributes(this.el);
  }
  get hasIconOnly() {
    return !!this.el.querySelector('[slot="icon-only"]');
  }
  get rippleType() {
    const hasClearFill = this.fill === void 0 || this.fill === "clear";
    if (hasClearFill && this.hasIconOnly && this.inToolbar) {
      return "unbounded";
    }
    return "bounded";
  }
  /**
   * Finds the form element based on the provided `form` selector
   * or element reference provided.
   */
  findForm() {
    const { form } = this;
    if (form instanceof HTMLFormElement) {
      return form;
    }
    if (typeof form === "string") {
      const el2 = document.getElementById(form);
      if (el2 instanceof HTMLFormElement) {
        return el2;
      }
    }
    return null;
  }
  render() {
    const mode = getIonMode$2(this);
    const { buttonType, type: type3, disabled, rel, target, size, href, color: color2, expand, hasIconOnly, shape, strong, inheritedAttributes } = this;
    const finalSize = size === void 0 && this.inItem ? "small" : size;
    const TagType = href === void 0 ? "button" : "a";
    const attrs = TagType === "button" ? { type: type3 } : {
      download: this.download,
      href,
      rel,
      target
    };
    let fill = this.fill;
    if (fill == null) {
      fill = this.inToolbar || this.inListHeader ? "clear" : "solid";
    }
    return h$5(Host$1, { onClick: this.handleClick, "aria-disabled": disabled ? "true" : null, class: createColorClasses$1(color2, {
      [mode]: true,
      [buttonType]: true,
      [`${buttonType}-${expand}`]: expand !== void 0,
      [`${buttonType}-${finalSize}`]: finalSize !== void 0,
      [`${buttonType}-${shape}`]: shape !== void 0,
      [`${buttonType}-${fill}`]: true,
      [`${buttonType}-strong`]: strong,
      "in-toolbar": hostContext("ion-toolbar", this.el),
      "in-toolbar-color": hostContext("ion-toolbar[color]", this.el),
      "in-buttons": hostContext("ion-buttons", this.el),
      "button-has-icon-only": hasIconOnly,
      "button-disabled": disabled,
      "ion-activatable": true,
      "ion-focusable": true
    }) }, h$5(TagType, Object.assign({}, attrs, { class: "button-native", part: "native", disabled, onFocus: this.onFocus, onBlur: this.onBlur }, inheritedAttributes), h$5("span", { class: "button-inner" }, h$5("slot", { name: "icon-only" }), h$5("slot", { name: "start" }), h$5("slot", null), h$5("slot", { name: "end" })), mode === "md" && h$5("ion-ripple-effect", { type: this.rippleType })));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: buttonIosCss,
      md: buttonMdCss
    };
  }
}, [33, "ion-button", {
  "color": [513],
  "buttonType": [1025, "button-type"],
  "disabled": [516],
  "expand": [513],
  "fill": [1537],
  "routerDirection": [1, "router-direction"],
  "routerAnimation": [16],
  "download": [1],
  "href": [1],
  "rel": [1],
  "shape": [513],
  "size": [513],
  "strong": [4],
  "target": [1],
  "type": [1],
  "form": [1]
}]);
function defineCustomElement$W() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-button", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-button":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Button);
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$Z();
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const noteIosCss = ":host{color:var(--color);font-family:var(--ion-font-family, inherit);-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){color:var(--ion-color-base)}:host{--color:var(--ion-color-step-350, #a6a6a6)}";
const noteMdCss = ":host{color:var(--color);font-family:var(--ion-font-family, inherit);-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){color:var(--ion-color-base)}:host{--color:var(--ion-color-step-600, #666666);font-size:14px}";
const Note = /* @__PURE__ */ proxyCustomElement$1(class Note2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.color = void 0;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: createColorClasses$1(this.color, {
      [mode]: true
    }) }, h$5("slot", null));
  }
  static get style() {
    return {
      ios: noteIosCss,
      md: noteMdCss
    };
  }
}, [33, "ion-note", {
  "color": [513]
}]);
function defineCustomElement$V() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-note"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-note":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Note);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const itemIosCss = ':host{--border-radius:0px;--border-width:0px;--border-style:solid;--padding-top:0px;--padding-bottom:0px;--padding-end:0px;--padding-start:0px;--inner-border-width:0px;--inner-padding-top:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;--inner-padding-end:0px;--inner-box-shadow:none;--show-full-highlight:0;--show-inset-highlight:0;--detail-icon-color:initial;--detail-icon-font-size:20px;--detail-icon-opacity:0.25;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:initial;text-decoration:none;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-native,:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-inner{border-color:var(--ion-color-shade)}:host(.ion-activated) .item-native{color:var(--color-activated)}:host(.ion-activated) .item-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.ion-color.ion-activated) .item-native{color:var(--ion-color-contrast)}:host(.ion-focused) .item-native{color:var(--color-focused)}:host(.ion-focused) .item-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(.ion-color.ion-focused) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-focused) .item-native::after{background:var(--ion-color-contrast)}@media (any-hover: hover){:host(.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--color-hover)}:host(.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--ion-color-contrast)}}:host(.item-interactive-disabled:not(.item-multiple-inputs)){cursor:default;pointer-events:none}:host(.item-disabled){cursor:default;opacity:0.3;pointer-events:none}.item-native{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.item-native::-moz-focus-inner{border:0}.item-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0;-webkit-transition:var(--transition);transition:var(--transition);z-index:-1}button,a{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}.item-inner{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--inner-padding-start);padding-inline-start:var(--inner-padding-start);-webkit-padding-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-inline-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);-webkit-box-shadow:var(--inner-box-shadow);box-shadow:var(--inner-box-shadow);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.item-bottom{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--inner-padding-end);padding-inline-end:var(--inner-padding-end);padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}.item-detail-icon{-webkit-margin-start:calc(var(--inner-padding-end) / 2);margin-inline-start:calc(var(--inner-padding-end) / 2);-webkit-margin-end:-6px;margin-inline-end:-6px;color:var(--detail-icon-color);font-size:var(--detail-icon-font-size);opacity:var(--detail-icon-opacity)}::slotted(ion-icon){font-size:1.6em}::slotted(ion-button){--margin-top:0;--margin-bottom:0;--margin-start:0;--margin-end:0;z-index:1}::slotted(ion-label:not([slot=end])){-ms-flex:1;flex:1}:host(.item-input){-ms-flex-align:center;align-items:center}.input-wrapper{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;text-overflow:ellipsis;overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.item-label-stacked),:host(.item-label-floating){-ms-flex-align:start;align-items:start}:host(.item-label-stacked) .input-wrapper,:host(.item-label-floating) .input-wrapper{-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column}.item-highlight,.item-inner-highlight{left:0;right:0;top:0;bottom:0;border-radius:inherit;position:absolute;width:100%;height:100%;-webkit-transform:scaleX(0);transform:scaleX(0);-webkit-transition:border-bottom-width 200ms, -webkit-transform 200ms;transition:border-bottom-width 200ms, -webkit-transform 200ms;transition:transform 200ms, border-bottom-width 200ms;transition:transform 200ms, border-bottom-width 200ms, -webkit-transform 200ms;z-index:2;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}:host(.item-interactive.ion-focused),:host(.item-interactive.item-has-focus),:host(.item-interactive.ion-touched.ion-invalid){--full-highlight-height:calc(var(--highlight-height) * var(--show-full-highlight));--inset-highlight-height:calc(var(--highlight-height) * var(--show-inset-highlight))}:host(.ion-focused) .item-highlight,:host(.ion-focused) .item-inner-highlight,:host(.item-has-focus) .item-highlight,:host(.item-has-focus) .item-inner-highlight{-webkit-transform:scaleX(1);transform:scaleX(1);border-style:var(--border-style);border-color:var(--highlight-background)}:host(.ion-focused) .item-highlight,:host(.item-has-focus) .item-highlight{border-width:var(--full-highlight-height);opacity:var(--show-full-highlight)}:host(.ion-focused) .item-inner-highlight,:host(.item-has-focus) .item-inner-highlight{border-bottom-width:var(--inset-highlight-height);opacity:var(--show-inset-highlight)}:host(.ion-focused.item-fill-solid) .item-highlight,:host(.item-has-focus.item-fill-solid) .item-highlight{border-width:calc(var(--full-highlight-height) - 1px)}:host(.ion-focused) .item-inner-highlight,:host(.ion-focused:not(.item-fill-outline)) .item-highlight,:host(.item-has-focus) .item-inner-highlight,:host(.item-has-focus:not(.item-fill-outline)) .item-highlight{border-top:none;border-right:none;border-left:none}:host(.item-interactive.ion-focused),:host(.item-interactive.item-has-focus){--highlight-background:var(--highlight-color-focused)}:host(.item-interactive.ion-valid){--highlight-background:var(--highlight-color-valid)}:host(.item-interactive.ion-invalid){--highlight-background:var(--highlight-color-invalid)}:host(.item-interactive.ion-invalid) ::slotted([slot=helper]){display:none}::slotted([slot=error]){display:none;color:var(--highlight-color-invalid)}:host(.item-interactive.ion-invalid) ::slotted([slot=error]){display:block}:host(:not(.item-label)) ::slotted(ion-select.legacy-select){--padding-start:0;max-width:none}:host(.item-label-stacked) ::slotted(ion-select.legacy-select),:host(.item-label-floating) ::slotted(ion-select.legacy-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0;-ms-flex-item-align:stretch;align-self:stretch;width:100%;max-width:100%}:host(:not(.item-label)) ::slotted(ion-datetime){--padding-start:0}:host(.item-label-stacked) ::slotted(ion-datetime),:host(.item-label-floating) ::slotted(ion-datetime){--padding-start:0;width:100%}:host(.item-multiple-inputs) ::slotted(ion-checkbox),:host(.item-multiple-inputs) ::slotted(ion-datetime),:host(.item-multiple-inputs) ::slotted(ion-radio),:host(.item-multiple-inputs) ::slotted(ion-select.legacy-select){position:relative}:host(.item-textarea){-ms-flex-align:stretch;align-items:stretch}::slotted(ion-reorder[slot]){margin-top:0;margin-bottom:0}ion-ripple-effect{color:var(--ripple-color)}:host(.item-fill-solid) ::slotted([slot=start]),:host(.item-fill-solid) ::slotted([slot=end]),:host(.item-fill-outline) ::slotted([slot=start]),:host(.item-fill-outline) ::slotted([slot=end]){-ms-flex-item-align:center;align-self:center}::slotted([slot=helper]),::slotted([slot=error]),.item-counter{padding-top:5px;font-size:12px;z-index:1}.item-counter{-webkit-margin-start:auto;margin-inline-start:auto;color:var(--ion-color-step-550, #737373);white-space:nowrap;-webkit-padding-start:16px;padding-inline-start:16px}@media (prefers-reduced-motion: reduce){.item-highlight,.item-inner-highlight{-webkit-transition:none;transition:none}}:host{--min-height:44px;--transition:background-color 200ms linear, opacity 200ms linear;--padding-start:16px;--inner-padding-end:16px;--inner-border-width:0px 0px 0.55px 0px;--background:var(--ion-item-background, var(--ion-background-color, #fff));--background-activated:var(--ion-text-color, #000);--background-focused:var(--ion-text-color, #000);--background-hover:currentColor;--background-activated-opacity:.12;--background-focused-opacity:.15;--background-hover-opacity:.04;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));--color:var(--ion-item-color, var(--ion-text-color, #000));--highlight-height:0px;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);--bottom-padding-start:0px;font-size:16px}:host(.ion-activated){--transition:none}:host(.ion-color.ion-focused) .item-native::after{background:#000;opacity:0.15}:host(.ion-color.ion-activated) .item-native::after{background:#000;opacity:0.12}:host(.item-interactive){--show-full-highlight:0;--show-inset-highlight:1}:host(.item-lines-full){--border-width:0px 0px 0.55px 0px;--show-full-highlight:1;--show-inset-highlight:0}:host(.item-lines-inset){--inner-border-width:0px 0px 0.55px 0px;--show-full-highlight:0;--show-inset-highlight:1}:host(.item-lines-inset),:host(.item-lines-none){--border-width:0px;--show-full-highlight:0}:host(.item-lines-full),:host(.item-lines-none){--inner-border-width:0px;--show-inset-highlight:0}.item-highlight,.item-inner-highlight{-webkit-transition:none;transition:none}:host(.item-has-focus) .item-inner-highlight,:host(.item-has-focus) .item-highlight{border-top:none;border-right:none;border-left:none}::slotted([slot=start]){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:2px;margin-bottom:2px}::slotted(ion-icon[slot=start]),::slotted(ion-icon[slot=end]){margin-top:7px;margin-bottom:7px}::slotted(ion-toggle[slot=start]),::slotted(ion-toggle[slot=end]){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}:host(.item-label-stacked) ::slotted([slot=end]),:host(.item-label-floating) ::slotted([slot=end]){margin-top:7px;margin-bottom:7px}::slotted(.button-small){--padding-top:0px;--padding-bottom:0px;--padding-start:.5em;--padding-end:.5em;height:24px;font-size:13px}::slotted(ion-avatar){width:36px;height:36px}::slotted(ion-thumbnail){--size:56px}::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:8px;margin-inline-end:8px;margin-top:8px;margin-bottom:8px}:host(.item-radio) ::slotted(ion-label),:host(.item-toggle) ::slotted(ion-label){-webkit-margin-start:0px;margin-inline-start:0px}::slotted(ion-label){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px;margin-top:10px;margin-bottom:10px}:host(.item-label-floating),:host(.item-label-stacked){--min-height:68px}:host(.item-label-stacked) ::slotted(ion-select.legacy-select),:host(.item-label-floating) ::slotted(ion-select.legacy-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0px}:host(.item-label-fixed) ::slotted(ion-select.legacy-select),:host(.item-label-fixed) ::slotted(ion-datetime){--padding-start:0}';
const itemMdCss = ':host{--border-radius:0px;--border-width:0px;--border-style:solid;--padding-top:0px;--padding-bottom:0px;--padding-end:0px;--padding-start:0px;--inner-border-width:0px;--inner-padding-top:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;--inner-padding-end:0px;--inner-box-shadow:none;--show-full-highlight:0;--show-inset-highlight:0;--detail-icon-color:initial;--detail-icon-font-size:20px;--detail-icon-opacity:0.25;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:initial;text-decoration:none;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-native,:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-inner{border-color:var(--ion-color-shade)}:host(.ion-activated) .item-native{color:var(--color-activated)}:host(.ion-activated) .item-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.ion-color.ion-activated) .item-native{color:var(--ion-color-contrast)}:host(.ion-focused) .item-native{color:var(--color-focused)}:host(.ion-focused) .item-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(.ion-color.ion-focused) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-focused) .item-native::after{background:var(--ion-color-contrast)}@media (any-hover: hover){:host(.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--color-hover)}:host(.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--ion-color-contrast)}}:host(.item-interactive-disabled:not(.item-multiple-inputs)){cursor:default;pointer-events:none}:host(.item-disabled){cursor:default;opacity:0.3;pointer-events:none}.item-native{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.item-native::-moz-focus-inner{border:0}.item-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0;-webkit-transition:var(--transition);transition:var(--transition);z-index:-1}button,a{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}.item-inner{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--inner-padding-start);padding-inline-start:var(--inner-padding-start);-webkit-padding-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-inline-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);-webkit-box-shadow:var(--inner-box-shadow);box-shadow:var(--inner-box-shadow);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.item-bottom{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--inner-padding-end);padding-inline-end:var(--inner-padding-end);padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}.item-detail-icon{-webkit-margin-start:calc(var(--inner-padding-end) / 2);margin-inline-start:calc(var(--inner-padding-end) / 2);-webkit-margin-end:-6px;margin-inline-end:-6px;color:var(--detail-icon-color);font-size:var(--detail-icon-font-size);opacity:var(--detail-icon-opacity)}::slotted(ion-icon){font-size:1.6em}::slotted(ion-button){--margin-top:0;--margin-bottom:0;--margin-start:0;--margin-end:0;z-index:1}::slotted(ion-label:not([slot=end])){-ms-flex:1;flex:1}:host(.item-input){-ms-flex-align:center;align-items:center}.input-wrapper{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;text-overflow:ellipsis;overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.item-label-stacked),:host(.item-label-floating){-ms-flex-align:start;align-items:start}:host(.item-label-stacked) .input-wrapper,:host(.item-label-floating) .input-wrapper{-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column}.item-highlight,.item-inner-highlight{left:0;right:0;top:0;bottom:0;border-radius:inherit;position:absolute;width:100%;height:100%;-webkit-transform:scaleX(0);transform:scaleX(0);-webkit-transition:border-bottom-width 200ms, -webkit-transform 200ms;transition:border-bottom-width 200ms, -webkit-transform 200ms;transition:transform 200ms, border-bottom-width 200ms;transition:transform 200ms, border-bottom-width 200ms, -webkit-transform 200ms;z-index:2;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}:host(.item-interactive.ion-focused),:host(.item-interactive.item-has-focus),:host(.item-interactive.ion-touched.ion-invalid){--full-highlight-height:calc(var(--highlight-height) * var(--show-full-highlight));--inset-highlight-height:calc(var(--highlight-height) * var(--show-inset-highlight))}:host(.ion-focused) .item-highlight,:host(.ion-focused) .item-inner-highlight,:host(.item-has-focus) .item-highlight,:host(.item-has-focus) .item-inner-highlight{-webkit-transform:scaleX(1);transform:scaleX(1);border-style:var(--border-style);border-color:var(--highlight-background)}:host(.ion-focused) .item-highlight,:host(.item-has-focus) .item-highlight{border-width:var(--full-highlight-height);opacity:var(--show-full-highlight)}:host(.ion-focused) .item-inner-highlight,:host(.item-has-focus) .item-inner-highlight{border-bottom-width:var(--inset-highlight-height);opacity:var(--show-inset-highlight)}:host(.ion-focused.item-fill-solid) .item-highlight,:host(.item-has-focus.item-fill-solid) .item-highlight{border-width:calc(var(--full-highlight-height) - 1px)}:host(.ion-focused) .item-inner-highlight,:host(.ion-focused:not(.item-fill-outline)) .item-highlight,:host(.item-has-focus) .item-inner-highlight,:host(.item-has-focus:not(.item-fill-outline)) .item-highlight{border-top:none;border-right:none;border-left:none}:host(.item-interactive.ion-focused),:host(.item-interactive.item-has-focus){--highlight-background:var(--highlight-color-focused)}:host(.item-interactive.ion-valid){--highlight-background:var(--highlight-color-valid)}:host(.item-interactive.ion-invalid){--highlight-background:var(--highlight-color-invalid)}:host(.item-interactive.ion-invalid) ::slotted([slot=helper]){display:none}::slotted([slot=error]){display:none;color:var(--highlight-color-invalid)}:host(.item-interactive.ion-invalid) ::slotted([slot=error]){display:block}:host(:not(.item-label)) ::slotted(ion-select.legacy-select){--padding-start:0;max-width:none}:host(.item-label-stacked) ::slotted(ion-select.legacy-select),:host(.item-label-floating) ::slotted(ion-select.legacy-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0;-ms-flex-item-align:stretch;align-self:stretch;width:100%;max-width:100%}:host(:not(.item-label)) ::slotted(ion-datetime){--padding-start:0}:host(.item-label-stacked) ::slotted(ion-datetime),:host(.item-label-floating) ::slotted(ion-datetime){--padding-start:0;width:100%}:host(.item-multiple-inputs) ::slotted(ion-checkbox),:host(.item-multiple-inputs) ::slotted(ion-datetime),:host(.item-multiple-inputs) ::slotted(ion-radio),:host(.item-multiple-inputs) ::slotted(ion-select.legacy-select){position:relative}:host(.item-textarea){-ms-flex-align:stretch;align-items:stretch}::slotted(ion-reorder[slot]){margin-top:0;margin-bottom:0}ion-ripple-effect{color:var(--ripple-color)}:host(.item-fill-solid) ::slotted([slot=start]),:host(.item-fill-solid) ::slotted([slot=end]),:host(.item-fill-outline) ::slotted([slot=start]),:host(.item-fill-outline) ::slotted([slot=end]){-ms-flex-item-align:center;align-self:center}::slotted([slot=helper]),::slotted([slot=error]),.item-counter{padding-top:5px;font-size:12px;z-index:1}.item-counter{-webkit-margin-start:auto;margin-inline-start:auto;color:var(--ion-color-step-550, #737373);white-space:nowrap;-webkit-padding-start:16px;padding-inline-start:16px}@media (prefers-reduced-motion: reduce){.item-highlight,.item-inner-highlight{-webkit-transition:none;transition:none}}:host{--min-height:48px;--background:var(--ion-item-background, var(--ion-background-color, #fff));--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor;--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));--color:var(--ion-item-color, var(--ion-text-color, #000));--transition:opacity 15ms linear, background-color 15ms linear;--padding-start:16px;--inner-padding-end:16px;--inner-border-width:0 0 1px 0;--highlight-height:1px;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);font-size:16px;font-weight:normal;text-transform:none}:host(.item-fill-outline){--highlight-height:2px}:host(.item-fill-none.item-interactive.ion-focus) .item-highlight,:host(.item-fill-none.item-interactive.item-has-focus) .item-highlight,:host(.item-fill-none.item-interactive.ion-touched.ion-invalid) .item-highlight{-webkit-transform:scaleX(1);transform:scaleX(1);border-width:0 0 var(--full-highlight-height) 0;border-style:var(--border-style);border-color:var(--highlight-background)}:host(.item-fill-none.item-interactive.ion-focus) .item-native,:host(.item-fill-none.item-interactive.item-has-focus) .item-native,:host(.item-fill-none.item-interactive.ion-touched.ion-invalid) .item-native{border-bottom-color:var(--highlight-background)}:host(.item-fill-outline.item-interactive.ion-focus) .item-highlight,:host(.item-fill-outline.item-interactive.item-has-focus) .item-highlight{-webkit-transform:scaleX(1);transform:scaleX(1)}:host(.item-fill-outline.item-interactive.ion-focus) .item-highlight,:host(.item-fill-outline.item-interactive.item-has-focus) .item-highlight,:host(.item-fill-outline.item-interactive.ion-touched.ion-invalid) .item-highlight{border-width:var(--full-highlight-height);border-style:var(--border-style);border-color:var(--highlight-background)}:host(.item-fill-outline.item-interactive.ion-touched.ion-invalid) .item-native{border-color:var(--highlight-background)}:host(.item-fill-solid.item-interactive.ion-focus) .item-highlight,:host(.item-fill-solid.item-interactive.item-has-focus) .item-highlight,:host(.item-fill-solid.item-interactive.ion-touched.ion-invalid) .item-highlight{-webkit-transform:scaleX(1);transform:scaleX(1);border-width:0 0 var(--full-highlight-height) 0;border-style:var(--border-style);border-color:var(--highlight-background)}:host(.item-fill-solid.item-interactive.ion-focus) .item-native,:host(.item-fill-solid.item-interactive.item-has-focus) .item-native,:host(.item-fill-solid.item-interactive.ion-touched.ion-invalid) .item-native{border-bottom-color:var(--highlight-background)}:host(.ion-color.ion-activated) .item-native::after{background:transparent}:host(.item-has-focus) .item-native{caret-color:var(--highlight-background)}:host(.item-interactive){--border-width:0 0 1px 0;--inner-border-width:0;--show-full-highlight:1;--show-inset-highlight:0}:host(.item-lines-full){--border-width:0 0 1px 0;--show-full-highlight:1;--show-inset-highlight:0}:host(.item-lines-inset){--inner-border-width:0 0 1px 0;--show-full-highlight:0;--show-inset-highlight:1}:host(.item-lines-inset),:host(.item-lines-none){--border-width:0;--show-full-highlight:0}:host(.item-lines-full),:host(.item-lines-none){--inner-border-width:0;--show-inset-highlight:0}:host(.item-fill-outline) .item-highlight{--position-offset:calc(-1 * var(--border-width));top:var(--position-offset);width:calc(100% + 2 * var(--border-width));height:calc(100% + 2 * var(--border-width));-webkit-transition:none;transition:none}@supports (inset-inline-start: 0){:host(.item-fill-outline) .item-highlight{inset-inline-start:var(--position-offset)}}@supports not (inset-inline-start: 0){:host(.item-fill-outline) .item-highlight{left:var(--position-offset)}:host-context([dir=rtl]):host(.item-fill-outline) .item-highlight,:host-context([dir=rtl]).item-fill-outline .item-highlight{left:unset;right:unset;right:var(--position-offset)}@supports selector(:dir(rtl)){:host(.item-fill-outline) .item-highlight:dir(rtl){left:unset;right:unset;right:var(--position-offset)}}}:host(.item-fill-outline.ion-focused) .item-native,:host(.item-fill-outline.item-has-focus) .item-native{border-color:transparent}:host(.item-multi-line) ::slotted([slot=start]),:host(.item-multi-line) ::slotted([slot=end]){margin-top:16px;margin-bottom:16px;-ms-flex-item-align:start;align-self:flex-start}::slotted([slot=start]){-webkit-margin-end:32px;margin-inline-end:32px}::slotted([slot=end]){-webkit-margin-start:32px;margin-inline-start:32px}:host(.item-fill-solid) ::slotted([slot=start]),:host(.item-fill-solid) ::slotted([slot=end]),:host(.item-fill-outline) ::slotted([slot=start]),:host(.item-fill-outline) ::slotted([slot=end]){-ms-flex-item-align:center;align-self:center}::slotted(ion-icon){color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54);font-size:24px}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) ::slotted(ion-icon){color:var(--ion-color-contrast)}::slotted(ion-icon[slot]){margin-top:12px;margin-bottom:12px}::slotted(ion-icon[slot=start]){-webkit-margin-end:32px;margin-inline-end:32px}::slotted(ion-icon[slot=end]){-webkit-margin-start:16px;margin-inline-start:16px}:host(.item-fill-solid) ::slotted(ion-icon[slot=start]),:host(.item-fill-outline) ::slotted(ion-icon[slot=start]){-webkit-margin-end:8px;margin-inline-end:8px}::slotted(ion-toggle[slot=start]),::slotted(ion-toggle[slot=end]){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}::slotted(ion-note){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-ms-flex-item-align:start;align-self:flex-start;font-size:11px}::slotted(ion-note[slot]:not([slot=helper]):not([slot=error])){padding-left:0;padding-right:0;padding-top:18px;padding-bottom:10px}::slotted(ion-note[slot=start]){-webkit-padding-end:16px;padding-inline-end:16px}::slotted(ion-note[slot=end]){-webkit-padding-start:16px;padding-inline-start:16px}::slotted(ion-avatar){width:40px;height:40px}::slotted(ion-thumbnail){--size:56px}::slotted(ion-avatar),::slotted(ion-thumbnail){margin-top:8px;margin-bottom:8px}::slotted(ion-avatar[slot=start]),::slotted(ion-thumbnail[slot=start]){-webkit-margin-end:16px;margin-inline-end:16px}::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){-webkit-margin-start:16px;margin-inline-start:16px}::slotted(ion-label){margin-left:0;margin-right:0;margin-top:10px;margin-bottom:10px}:host(.item-label-stacked) ::slotted([slot=end]),:host(.item-label-floating) ::slotted([slot=end]){margin-top:7px;margin-bottom:7px}:host(.item-label-fixed) ::slotted(ion-select.legacy-select),:host(.item-label-fixed) ::slotted(ion-datetime){--padding-start:8px}:host(.item-toggle) ::slotted(ion-label),:host(.item-radio) ::slotted(ion-label){-webkit-margin-start:0;margin-inline-start:0}::slotted(.button-small){--padding-top:0;--padding-bottom:0;--padding-start:.6em;--padding-end:.6em;height:25px;font-size:12px}:host(.item-label-floating),:host(.item-label-stacked){--min-height:55px}:host(.item-label-stacked) ::slotted(ion-select.legacy-select),:host(.item-label-floating) ::slotted(ion-select.legacy-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0}:host(.ion-focused:not(.ion-color)) ::slotted(.label-stacked),:host(.ion-focused:not(.ion-color)) ::slotted(.label-floating),:host(.item-has-focus:not(.ion-color)) ::slotted(.label-stacked),:host(.item-has-focus:not(.ion-color)) ::slotted(.label-floating){color:var(--ion-color-primary, #3880ff)}:host(.ion-color){--highlight-color-focused:var(--ion-color-contrast)}:host(.item-label-color){--highlight-color-focused:var(--ion-color-base)}:host(.item-fill-solid.ion-color),:host(.item-fill-outline.ion-color){--highlight-color-focused:var(--ion-color-base)}:host(.item-fill-solid){--background:var(--ion-color-step-50, #f2f2f2);--background-hover:var(--ion-color-step-100, #e6e6e6);--background-focused:var(--ion-color-step-150, #d9d9d9);--border-width:0 0 1px 0;--inner-border-width:0;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.item-fill-solid),:host-context([dir=rtl]).item-fill-solid{border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}@supports selector(:dir(rtl)){:host(.item-fill-solid):dir(rtl){border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}}:host(.item-fill-solid) .item-native{--border-color:var(--ion-color-step-500, gray)}:host(.item-fill-solid.ion-focused) .item-native,:host(.item-fill-solid.item-has-focus) .item-native{--background:var(--background-focused)}:host(.item-fill-solid.item-shape-round){border-top-left-radius:16px;border-top-right-radius:16px;border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.item-fill-solid.item-shape-round),:host-context([dir=rtl]).item-fill-solid.item-shape-round{border-top-left-radius:16px;border-top-right-radius:16px;border-bottom-right-radius:0;border-bottom-left-radius:0}@supports selector(:dir(rtl)){:host(.item-fill-solid.item-shape-round):dir(rtl){border-top-left-radius:16px;border-top-right-radius:16px;border-bottom-right-radius:0;border-bottom-left-radius:0}}@media (any-hover: hover){:host(.item-fill-solid:hover) .item-native{--background:var(--background-hover);--border-color:var(--ion-color-step-750, #404040)}}:host(.item-fill-outline){--ripple-color:transparent;--background-focused:transparent;--background-hover:transparent;--border-color:var(--ion-color-step-500, gray);--border-width:1px;border:none;overflow:visible}:host(.item-fill-outline) .item-native{--native-padding-left:16px;border-radius:4px}:host(.item-fill-outline.item-shape-round) .item-native{--inner-padding-start:16px;border-radius:28px}:host(.item-fill-outline.item-shape-round) .item-bottom{-webkit-padding-start:32px;padding-inline-start:32px}:host(.item-fill-outline.item-label-floating.ion-focused) .item-native ::slotted(ion-input:not(:first-child)),:host(.item-fill-outline.item-label-floating.ion-focused) .item-native ::slotted(ion-textarea:not(:first-child)),:host(.item-fill-outline.item-label-floating.item-has-focus) .item-native ::slotted(ion-input:not(:first-child)),:host(.item-fill-outline.item-label-floating.item-has-focus) .item-native ::slotted(ion-textarea:not(:first-child)),:host(.item-fill-outline.item-label-floating.item-has-value) .item-native ::slotted(ion-input:not(:first-child)),:host(.item-fill-outline.item-label-floating.item-has-value) .item-native ::slotted(ion-textarea:not(:first-child)){-webkit-transform:translateY(-14px);transform:translateY(-14px)}@media (any-hover: hover){:host(.item-fill-outline:hover) .item-native{--border-color:var(--ion-color-step-750, #404040)}}.item-counter{letter-spacing:0.0333333333em}';
const Item = /* @__PURE__ */ proxyCustomElement$1(class Item2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.labelColorStyles = {};
    this.itemStyles = /* @__PURE__ */ new Map();
    this.inheritedAriaAttributes = {};
    this.multipleInputs = false;
    this.focusable = true;
    this.color = void 0;
    this.button = false;
    this.detail = void 0;
    this.detailIcon = chevronForward;
    this.disabled = false;
    this.download = void 0;
    this.fill = void 0;
    this.shape = void 0;
    this.href = void 0;
    this.rel = void 0;
    this.lines = void 0;
    this.counter = false;
    this.routerAnimation = void 0;
    this.routerDirection = "forward";
    this.target = void 0;
    this.type = "button";
    this.counterFormatter = void 0;
    this.counterString = void 0;
  }
  counterFormatterChanged() {
    this.updateCounterOutput(this.getFirstInput());
  }
  handleIonInput(ev) {
    if (this.counter && ev.target === this.getFirstInput()) {
      this.updateCounterOutput(ev.target);
    }
  }
  labelColorChanged(ev) {
    const { color: color2 } = this;
    if (color2 === void 0) {
      this.labelColorStyles = ev.detail;
    }
  }
  itemStyle(ev) {
    ev.stopPropagation();
    const tagName = ev.target.tagName;
    const updatedStyles = ev.detail;
    const newStyles = {};
    const childStyles = this.itemStyles.get(tagName) || {};
    let hasStyleChange = false;
    Object.keys(updatedStyles).forEach((key) => {
      if (updatedStyles[key]) {
        const itemKey = `item-${key}`;
        if (!childStyles[itemKey]) {
          hasStyleChange = true;
        }
        newStyles[itemKey] = true;
      }
    });
    if (!hasStyleChange && Object.keys(newStyles).length !== Object.keys(childStyles).length) {
      hasStyleChange = true;
    }
    if (hasStyleChange) {
      this.itemStyles.set(tagName, newStyles);
      forceUpdate(this);
    }
  }
  connectedCallback() {
    if (this.counter) {
      this.updateCounterOutput(this.getFirstInput());
    }
    this.hasStartEl();
  }
  componentWillLoad() {
    this.inheritedAriaAttributes = inheritAttributes$2(this.el, ["aria-label"]);
  }
  componentDidLoad() {
    const { el: el2, counter, counterFormatter, fill, shape } = this;
    const hasHelperSlot = el2.querySelector('[slot="helper"]') !== null;
    if (hasHelperSlot) {
      printIonWarning('The "helper" slot has been deprecated in favor of using the "helperText" property on ion-input or ion-textarea.', el2);
    }
    const hasErrorSlot = el2.querySelector('[slot="error"]') !== null;
    if (hasErrorSlot) {
      printIonWarning('The "error" slot has been deprecated in favor of using the "errorText" property on ion-input or ion-textarea.', el2);
    }
    if (counter === true) {
      printIonWarning('The "counter" property has been deprecated in favor of using the "counter" property on ion-input or ion-textarea.', el2);
    }
    if (counterFormatter !== void 0) {
      printIonWarning('The "counterFormatter" property has been deprecated in favor of using the "counterFormatter" property on ion-input or ion-textarea.', el2);
    }
    if (fill !== void 0) {
      printIonWarning('The "fill" property has been deprecated in favor of using the "fill" property on ion-input or ion-textarea.', el2);
    }
    if (shape !== void 0) {
      printIonWarning('The "shape" property has been deprecated in favor of using the "shape" property on ion-input or ion-textarea.', el2);
    }
    raf(() => {
      this.setMultipleInputs();
      this.focusable = this.isFocusable();
    });
  }
  // If the item contains multiple clickable elements and/or inputs, then the item
  // should not have a clickable input cover over the entire item to prevent
  // interfering with their individual click events
  setMultipleInputs() {
    const covers = this.el.querySelectorAll("ion-checkbox, ion-datetime, ion-select, ion-radio");
    const inputs = this.el.querySelectorAll("ion-input, ion-range, ion-searchbar, ion-segment, ion-textarea, ion-toggle");
    const clickables = this.el.querySelectorAll("ion-anchor, ion-button, a, button");
    this.multipleInputs = covers.length + inputs.length > 1 || covers.length + clickables.length > 1 || covers.length > 0 && this.isClickable();
  }
  // If the item contains an input including a checkbox, datetime, select, or radio
  // then the item will have a clickable input cover that covers the item
  // that should get the hover, focused and activated states UNLESS it has multiple
  // inputs, then those need to individually get each click
  hasCover() {
    const inputs = this.el.querySelectorAll("ion-checkbox, ion-datetime, ion-select, ion-radio");
    return inputs.length === 1 && !this.multipleInputs;
  }
  // If the item has an href or button property it will render a native
  // anchor or button that is clickable
  isClickable() {
    return this.href !== void 0 || this.button;
  }
  canActivate() {
    return this.isClickable() || this.hasCover();
  }
  isFocusable() {
    const focusableChild = this.el.querySelector(".ion-focusable");
    return this.canActivate() || focusableChild !== null;
  }
  getFirstInput() {
    const inputs = this.el.querySelectorAll("ion-input, ion-textarea");
    return inputs[0];
  }
  updateCounterOutput(inputEl) {
    var _a2, _b;
    const { counter, counterFormatter, defaultCounterFormatter: defaultCounterFormatter2 } = this;
    if (counter && !this.multipleInputs && (inputEl === null || inputEl === void 0 ? void 0 : inputEl.maxlength) !== void 0) {
      const length3 = (_b = (_a2 = inputEl === null || inputEl === void 0 ? void 0 : inputEl.value) === null || _a2 === void 0 ? void 0 : _a2.toString().length) !== null && _b !== void 0 ? _b : 0;
      if (counterFormatter === void 0) {
        this.counterString = defaultCounterFormatter2(length3, inputEl.maxlength);
      } else {
        try {
          this.counterString = counterFormatter(length3, inputEl.maxlength);
        } catch (e3) {
          printIonError("Exception in provided `counterFormatter`.", e3);
          this.counterString = defaultCounterFormatter2(length3, inputEl.maxlength);
        }
      }
    }
  }
  defaultCounterFormatter(length3, maxlength) {
    return `${length3} / ${maxlength}`;
  }
  hasStartEl() {
    const startEl = this.el.querySelector('[slot="start"]');
    if (startEl !== null) {
      this.el.classList.add("item-has-start-slot");
    }
  }
  render() {
    const { counterString, detail, detailIcon, download, fill, labelColorStyles, lines, disabled, href, rel, shape, target, routerAnimation, routerDirection, inheritedAriaAttributes } = this;
    const childStyles = {};
    const mode = getIonMode$2(this);
    const clickable = this.isClickable();
    const canActivate = this.canActivate();
    const TagType = clickable ? href === void 0 ? "button" : "a" : "div";
    const attrs = TagType === "button" ? { type: this.type } : {
      download,
      href,
      rel,
      target
    };
    const clickFn = clickable ? {
      onClick: (ev) => {
        openURL(href, ev, routerDirection, routerAnimation);
      }
    } : {};
    const showDetail = detail !== void 0 ? detail : mode === "ios" && clickable;
    this.itemStyles.forEach((value) => {
      Object.assign(childStyles, value);
    });
    const ariaDisabled = disabled || childStyles["item-interactive-disabled"] ? "true" : null;
    const fillValue = fill || "none";
    const inList = hostContext("ion-list", this.el);
    return h$5(Host$1, { "aria-disabled": ariaDisabled, class: Object.assign(Object.assign(Object.assign({}, childStyles), labelColorStyles), createColorClasses$1(this.color, {
      item: true,
      [mode]: true,
      "item-lines-default": lines === void 0,
      [`item-lines-${lines}`]: lines !== void 0,
      [`item-fill-${fillValue}`]: true,
      [`item-shape-${shape}`]: shape !== void 0,
      "item-disabled": disabled,
      "in-list": inList,
      "item-multiple-inputs": this.multipleInputs,
      "ion-activatable": canActivate,
      "ion-focusable": this.focusable,
      "item-rtl": document.dir === "rtl"
    })), role: inList ? "listitem" : null }, h$5(TagType, Object.assign({}, attrs, inheritedAriaAttributes, { class: "item-native", part: "native", disabled }, clickFn), h$5("slot", { name: "start" }), h$5("div", { class: "item-inner" }, h$5("div", { class: "input-wrapper" }, h$5("slot", null)), h$5("slot", { name: "end" }), showDetail && h$5("ion-icon", { icon: detailIcon, lazy: false, class: "item-detail-icon", part: "detail-icon", "aria-hidden": "true", "flip-rtl": detailIcon === chevronForward }), h$5("div", { class: "item-inner-highlight" })), canActivate && mode === "md" && h$5("ion-ripple-effect", null), h$5("div", { class: "item-highlight" })), h$5("div", { class: "item-bottom" }, h$5("slot", { name: "error" }), h$5("slot", { name: "helper" }), counterString && h$5("ion-note", { class: "item-counter" }, counterString)));
  }
  static get delegatesFocus() {
    return true;
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "counterFormatter": ["counterFormatterChanged"]
    };
  }
  static get style() {
    return {
      ios: itemIosCss,
      md: itemMdCss
    };
  }
}, [49, "ion-item", {
  "color": [513],
  "button": [4],
  "detail": [4],
  "detailIcon": [1, "detail-icon"],
  "disabled": [4],
  "download": [1],
  "fill": [1],
  "shape": [1],
  "href": [1],
  "rel": [1],
  "lines": [1],
  "counter": [4],
  "routerAnimation": [16],
  "routerDirection": [1, "router-direction"],
  "target": [1],
  "type": [1],
  "counterFormatter": [16],
  "multipleInputs": [32],
  "focusable": [32],
  "counterString": [32]
}, [[0, "ionInput", "handleIonInput"], [0, "ionColor", "labelColorChanged"], [0, "ionStyle", "itemStyle"]]]);
function defineCustomElement$U() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-item", "ion-icon", "ion-note", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-item":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Item);
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$1b();
        }
        break;
      case "ion-note":
        if (!customElements.get(tagName)) {
          defineCustomElement$V();
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$Z();
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const labelIosCss = ".item.sc-ion-label-ios-h,.item .sc-ion-label-ios-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family, inherit);font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-label-ios-h{color:var(--ion-color-base)}.ion-text-wrap.sc-ion-label-ios-h,[text-wrap].sc-ion-label-ios-h{white-space:normal}.item-interactive-disabled.sc-ion-label-ios-h:not(.item-multiple-inputs),.item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-ios-h{cursor:default;opacity:0.3;pointer-events:none}.item-input.sc-ion-label-ios-h,.item-input .sc-ion-label-ios-h{-ms-flex:initial;flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-ios-h,.item-textarea .sc-ion-label-ios-h{-ms-flex-item-align:baseline;align-self:baseline}.label-fixed.sc-ion-label-ios-h{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-stacked.sc-ion-label-ios-h,.label-floating.sc-ion-label-ios-h{margin-bottom:0;-ms-flex-item-align:stretch;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-ios-h{-webkit-transition:none;transition:none}.sc-ion-label-ios-s h1,.sc-ion-label-ios-s h2,.sc-ion-label-ios-s h3,.sc-ion-label-ios-s h4,.sc-ion-label-ios-s h5,.sc-ion-label-ios-s h6{text-overflow:inherit;overflow:inherit}.ion-text-wrap.sc-ion-label-ios-h,[text-wrap].sc-ion-label-ios-h{font-size:14px;line-height:1.5}.label-stacked.sc-ion-label-ios-h{margin-bottom:4px;font-size:14px}.label-floating.sc-ion-label-ios-h{margin-bottom:0;-webkit-transform:translate(0, 29px);transform:translate(0, 29px);-webkit-transform-origin:left top;transform-origin:left top;-webkit-transition:-webkit-transform 150ms ease-in-out;transition:-webkit-transform 150ms ease-in-out;transition:transform 150ms ease-in-out;transition:transform 150ms ease-in-out, -webkit-transform 150ms ease-in-out}[dir=rtl].sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h,[dir=rtl] .sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h,[dir=rtl].label-floating.sc-ion-label-ios-h,[dir=rtl] .label-floating.sc-ion-label-ios-h{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.label-floating.sc-ion-label-ios-h:dir(rtl){-webkit-transform-origin:right top;transform-origin:right top}}.item-textarea.label-floating.sc-ion-label-ios-h,.item-textarea .label-floating.sc-ion-label-ios-h{-webkit-transform:translate(0, 28px);transform:translate(0, 28px)}.item-has-focus.label-floating.sc-ion-label-ios-h,.item-has-focus .label-floating.sc-ion-label-ios-h,.item-has-placeholder.sc-ion-label-ios-h:not(.item-input).label-floating,.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-ios-h,.item-has-value.label-floating.sc-ion-label-ios-h,.item-has-value .label-floating.sc-ion-label-ios-h{-webkit-transform:scale(0.82);transform:scale(0.82)}.sc-ion-label-ios-s h1{margin-left:0;margin-right:0;margin-top:3px;margin-bottom:2px;font-size:22px;font-weight:normal}.sc-ion-label-ios-s h2{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:17px;font-weight:normal}.sc-ion-label-ios-s h3,.sc-ion-label-ios-s h4,.sc-ion-label-ios-s h5,.sc-ion-label-ios-s h6{margin-left:0;margin-right:0;margin-top:0;margin-bottom:3px;font-size:14px;font-weight:normal;line-height:normal}.sc-ion-label-ios-s p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px;line-height:normal;text-overflow:inherit;overflow:inherit}.sc-ion-label-ios-s>p{color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.4)}.sc-ion-label-ios-h.in-item-color.sc-ion-label-ios-s>p{color:inherit}.sc-ion-label-ios-s h2:last-child,.sc-ion-label-ios-s h3:last-child,.sc-ion-label-ios-s h4:last-child,.sc-ion-label-ios-s h5:last-child,.sc-ion-label-ios-s h6:last-child,.sc-ion-label-ios-s p:last-child{margin-bottom:0}";
const labelMdCss = '.item.sc-ion-label-md-h,.item .sc-ion-label-md-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family, inherit);font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-label-md-h{color:var(--ion-color-base)}.ion-text-wrap.sc-ion-label-md-h,[text-wrap].sc-ion-label-md-h{white-space:normal}.item-interactive-disabled.sc-ion-label-md-h:not(.item-multiple-inputs),.item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-md-h{cursor:default;opacity:0.3;pointer-events:none}.item-input.sc-ion-label-md-h,.item-input .sc-ion-label-md-h{-ms-flex:initial;flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-md-h,.item-textarea .sc-ion-label-md-h{-ms-flex-item-align:baseline;align-self:baseline}.label-fixed.sc-ion-label-md-h{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-stacked.sc-ion-label-md-h,.label-floating.sc-ion-label-md-h{margin-bottom:0;-ms-flex-item-align:stretch;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-md-h{-webkit-transition:none;transition:none}.sc-ion-label-md-s h1,.sc-ion-label-md-s h2,.sc-ion-label-md-s h3,.sc-ion-label-md-s h4,.sc-ion-label-md-s h5,.sc-ion-label-md-s h6{text-overflow:inherit;overflow:inherit}.ion-text-wrap.sc-ion-label-md-h,[text-wrap].sc-ion-label-md-h{line-height:1.5}.label-stacked.sc-ion-label-md-h,.label-floating.sc-ion-label-md-h{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-transform-origin:top left;transform-origin:top left}.label-stacked.label-rtl.sc-ion-label-md-h,.label-floating.label-rtl.sc-ion-label-md-h{-webkit-transform-origin:top right;transform-origin:top right}.label-stacked.sc-ion-label-md-h{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1)}.label-floating.sc-ion-label-md-h{-webkit-transform:translateY(96%);transform:translateY(96%);-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1)}.ion-focused.label-floating.sc-ion-label-md-h,.ion-focused .label-floating.sc-ion-label-md-h,.item-has-focus.label-floating.sc-ion-label-md-h,.item-has-focus .label-floating.sc-ion-label-md-h,.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating,.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h,.item-has-value.label-floating.sc-ion-label-md-h,.item-has-value .label-floating.sc-ion-label-md-h{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75)}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h{-webkit-transform:translateY(-6px) scale(0.75);transform:translateY(-6px) scale(0.75);position:relative;max-width:-webkit-min-content;max-width:-moz-min-content;max-width:min-content;background-color:var(--ion-item-background, var(--ion-background-color, #fff));overflow:visible;z-index:3}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::before,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::before,.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::after,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::before,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::after,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::after{position:absolute;width:4px;height:100%;background-color:var(--ion-item-background, var(--ion-background-color, #fff));content:""}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::before,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::before,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::before{left:calc(-1 * 4px)}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::after,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::after,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::after{right:calc(-1 * 4px)}.item-fill-outline.ion-focused.item-has-start-slot.label-floating.sc-ion-label-md-h,.item-fill-outline.ion-focused.item-has-start-slot .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).item-has-start-slot.label-floating,.item-fill-outline.item-has-placeholder:not(.item-input).item-has-start-slot .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot .label-floating.sc-ion-label-md-h{-webkit-transform:translateX(-32px) translateY(-6px) scale(0.75);transform:translateX(-32px) translateY(-6px) scale(0.75)}.item-fill-outline.ion-focused.item-has-start-slot.label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.ion-focused.item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot.label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).item-has-start-slot.label-floating.label-rtl,.item-fill-outline.item-has-placeholder:not(.item-input).item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot.label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h{-webkit-transform:translateX(calc(-1 * -32px)) translateY(-6px) scale(0.75);transform:translateX(calc(-1 * -32px)) translateY(-6px) scale(0.75)}.ion-focused.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-focused .label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-primary, #3880ff)}.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-contrast)}.item-fill-solid.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-base)}.ion-invalid.ion-touched.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--highlight-color-invalid)}.sc-ion-label-md-s h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}.sc-ion-label-md-s h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:16px;font-weight:normal}.sc-ion-label-md-s h3,.sc-ion-label-md-s h4,.sc-ion-label-md-s h5,.sc-ion-label-md-s h6{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:14px;font-weight:normal;line-height:normal}.sc-ion-label-md-s p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px;line-height:20px;text-overflow:inherit;overflow:inherit}.sc-ion-label-md-s>p{color:var(--ion-color-step-600, #666666)}.sc-ion-label-md-h.in-item-color.sc-ion-label-md-s>p{color:inherit}';
const Label$1 = /* @__PURE__ */ proxyCustomElement$1(class Label extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.ionColor = createEvent(this, "ionColor", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.inRange = false;
    this.color = void 0;
    this.position = void 0;
    this.noAnimate = false;
  }
  componentWillLoad() {
    this.inRange = !!this.el.closest("ion-range");
    this.noAnimate = this.position === "floating";
    this.emitStyle();
    this.emitColor();
  }
  componentDidLoad() {
    if (this.noAnimate) {
      setTimeout(() => {
        this.noAnimate = false;
      }, 1e3);
    }
  }
  colorChanged() {
    this.emitColor();
  }
  positionChanged() {
    this.emitStyle();
  }
  emitColor() {
    const { color: color2 } = this;
    this.ionColor.emit({
      "item-label-color": color2 !== void 0,
      [`ion-color-${color2}`]: color2 !== void 0
    });
  }
  emitStyle() {
    const { inRange, position } = this;
    if (!inRange) {
      this.ionStyle.emit({
        label: true,
        [`label-${position}`]: position !== void 0
      });
    }
  }
  render() {
    const position = this.position;
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: createColorClasses$1(this.color, {
      [mode]: true,
      "in-item-color": hostContext("ion-item.ion-color", this.el),
      [`label-${position}`]: position !== void 0,
      [`label-no-animate`]: this.noAnimate,
      "label-rtl": document.dir === "rtl"
    }) });
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "color": ["colorChanged"],
      "position": ["positionChanged"]
    };
  }
  static get style() {
    return {
      ios: labelIosCss,
      md: labelMdCss
    };
  }
}, [34, "ion-label", {
  "color": [513],
  "position": [1],
  "noAnimate": [32]
}]);
function defineCustomElement$T() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-label"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-label":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Label$1);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const HapticEngine = {
  getEngine() {
    var _a2;
    const win2 = window;
    return win2.TapticEngine || ((_a2 = win2.Capacitor) === null || _a2 === void 0 ? void 0 : _a2.isPluginAvailable("Haptics")) && win2.Capacitor.Plugins.Haptics;
  },
  available() {
    var _a2;
    const win2 = window;
    const engine = this.getEngine();
    if (!engine) {
      return false;
    }
    if (((_a2 = win2.Capacitor) === null || _a2 === void 0 ? void 0 : _a2.getPlatform()) === "web") {
      return typeof navigator !== "undefined" && navigator.vibrate !== void 0;
    }
    return true;
  },
  isCordova() {
    return !!window.TapticEngine;
  },
  isCapacitor() {
    const win2 = window;
    return !!win2.Capacitor;
  },
  impact(options) {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    const style = this.isCapacitor() ? options.style.toUpperCase() : options.style;
    engine.impact({ style });
  },
  notification(options) {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    const style = this.isCapacitor() ? options.style.toUpperCase() : options.style;
    engine.notification({ style });
  },
  selection() {
    this.impact({ style: "light" });
  },
  selectionStart() {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    if (this.isCapacitor()) {
      engine.selectionStart();
    } else {
      engine.gestureSelectionStart();
    }
  },
  selectionChanged() {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    if (this.isCapacitor()) {
      engine.selectionChanged();
    } else {
      engine.gestureSelectionChanged();
    }
  },
  selectionEnd() {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    if (this.isCapacitor()) {
      engine.selectionEnd();
    } else {
      engine.gestureSelectionEnd();
    }
  }
};
const hapticAvailable = () => {
  return HapticEngine.available();
};
const hapticSelection = () => {
  hapticAvailable() && HapticEngine.selection();
};
const hapticSelectionStart = () => {
  hapticAvailable() && HapticEngine.selectionStart();
};
const hapticSelectionChanged = () => {
  hapticAvailable() && HapticEngine.selectionChanged();
};
const hapticSelectionEnd = () => {
  hapticAvailable() && HapticEngine.selectionEnd();
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const pickerColumnInternalIosCss = ":host{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:0px;padding-bottom:0px;height:200px;outline:none;font-size:22px;-webkit-scroll-snap-type:y mandatory;-ms-scroll-snap-type:y mandatory;scroll-snap-type:y mandatory;overflow-x:hidden;overflow-y:scroll;scrollbar-width:none;text-align:center}:host::-webkit-scrollbar{display:none}:host .picker-item{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:100%;height:34px;border:0px;outline:none;background:transparent;color:inherit;font-family:var(--ion-font-family, inherit);font-size:inherit;line-height:34px;text-align:inherit;text-overflow:ellipsis;white-space:nowrap;cursor:pointer;overflow:hidden;scroll-snap-align:center}:host .picker-item-empty,:host .picker-item.picker-item-disabled{scroll-snap-align:none;cursor:default}:host .picker-item.picker-item-disabled{opacity:0.4}:host(.picker-column-active) .picker-item.picker-item-active{color:var(--ion-color-base)}@media (any-hover: hover){:host(:focus){outline:none;background:rgba(var(--ion-color-base-rgb), 0.2)}}";
const pickerColumnInternalMdCss = ":host{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:0px;padding-bottom:0px;height:200px;outline:none;font-size:22px;-webkit-scroll-snap-type:y mandatory;-ms-scroll-snap-type:y mandatory;scroll-snap-type:y mandatory;overflow-x:hidden;overflow-y:scroll;scrollbar-width:none;text-align:center}:host::-webkit-scrollbar{display:none}:host .picker-item{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:100%;height:34px;border:0px;outline:none;background:transparent;color:inherit;font-family:var(--ion-font-family, inherit);font-size:inherit;line-height:34px;text-align:inherit;text-overflow:ellipsis;white-space:nowrap;cursor:pointer;overflow:hidden;scroll-snap-align:center}:host .picker-item-empty,:host .picker-item.picker-item-disabled{scroll-snap-align:none;cursor:default}:host .picker-item.picker-item-disabled{opacity:0.4}:host(.picker-column-active) .picker-item.picker-item-active{color:var(--ion-color-base)}@media (any-hover: hover){:host(:focus){outline:none;background:rgba(var(--ion-color-base-rgb), 0.2)}}:host .picker-item-active{color:var(--ion-color-base)}";
const PickerColumnInternal = /* @__PURE__ */ proxyCustomElement$1(class PickerColumnInternal2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionChange = createEvent(this, "ionChange", 7);
    this.isScrolling = false;
    this.isColumnVisible = false;
    this.canExitInputMode = true;
    this.centerPickerItemInView = (target, smooth = true, canExitInputMode = true) => {
      const { el: el2, isColumnVisible } = this;
      if (isColumnVisible) {
        const top = target.offsetTop - 3 * target.clientHeight + target.clientHeight / 2;
        if (el2.scrollTop !== top) {
          this.canExitInputMode = canExitInputMode;
          el2.scroll({
            top,
            left: 0,
            behavior: smooth ? "smooth" : void 0
          });
        }
      }
    };
    this.inputModeChange = (ev) => {
      if (!this.numericInput) {
        return;
      }
      const { useInputMode, inputModeColumn } = ev.detail;
      const isColumnActive = inputModeColumn === void 0 || inputModeColumn === this.el;
      if (!useInputMode || !isColumnActive) {
        this.setInputModeActive(false);
        return;
      }
      this.setInputModeActive(true);
    };
    this.setInputModeActive = (state) => {
      if (this.isScrolling) {
        this.scrollEndCallback = () => {
          this.isActive = state;
        };
        return;
      }
      this.isActive = state;
    };
    this.initializeScrollListener = () => {
      const enableHaptics = isPlatform("ios");
      const { el: el2 } = this;
      let timeout;
      let activeEl = this.activeItem;
      const scrollCallback = () => {
        raf(() => {
          if (timeout) {
            clearTimeout(timeout);
            timeout = void 0;
          }
          if (!this.isScrolling) {
            enableHaptics && hapticSelectionStart();
            this.isScrolling = true;
          }
          const bbox = el2.getBoundingClientRect();
          const centerX = bbox.x + bbox.width / 2;
          const centerY = bbox.y + bbox.height / 2;
          const activeElement = el2.shadowRoot.elementFromPoint(centerX, centerY);
          if (activeEl !== null) {
            activeEl.classList.remove(PICKER_COL_ACTIVE);
          }
          if (activeElement === null || activeElement.disabled) {
            return;
          }
          if (activeElement !== activeEl) {
            enableHaptics && hapticSelectionChanged();
            if (this.canExitInputMode) {
              this.exitInputMode();
            }
          }
          activeEl = activeElement;
          activeElement.classList.add(PICKER_COL_ACTIVE);
          timeout = setTimeout(() => {
            this.isScrolling = false;
            enableHaptics && hapticSelectionEnd();
            const { scrollEndCallback } = this;
            if (scrollEndCallback) {
              scrollEndCallback();
              this.scrollEndCallback = void 0;
            }
            this.canExitInputMode = true;
            const dataIndex = activeElement.getAttribute("data-index");
            if (dataIndex === null) {
              return;
            }
            const index3 = parseInt(dataIndex, 10);
            const selectedItem = this.items[index3];
            if (selectedItem.value !== this.value) {
              this.setValue(selectedItem.value);
            }
          }, 250);
        });
      };
      raf(() => {
        el2.addEventListener("scroll", scrollCallback);
        this.destroyScrollListener = () => {
          el2.removeEventListener("scroll", scrollCallback);
        };
      });
    };
    this.exitInputMode = () => {
      const { parentEl } = this;
      if (parentEl == null)
        return;
      parentEl.exitInputMode();
      this.el.classList.remove("picker-column-active");
    };
    this.isActive = false;
    this.items = [];
    this.value = void 0;
    this.color = "primary";
    this.numericInput = false;
  }
  valueChange() {
    if (this.isColumnVisible) {
      this.scrollActiveItemIntoView();
    }
  }
  /**
   * Only setup scroll listeners
   * when the picker is visible, otherwise
   * the container will have a scroll
   * height of 0px.
   */
  componentWillLoad() {
    const visibleCallback = (entries) => {
      var _a2;
      const ev = entries[0];
      if (ev.isIntersecting) {
        this.isColumnVisible = true;
        const oldActive = getElementRoot(this.el).querySelector(`.${PICKER_COL_ACTIVE}`);
        oldActive === null || oldActive === void 0 ? void 0 : oldActive.classList.remove(PICKER_COL_ACTIVE);
        this.scrollActiveItemIntoView();
        (_a2 = this.activeItem) === null || _a2 === void 0 ? void 0 : _a2.classList.add(PICKER_COL_ACTIVE);
        this.initializeScrollListener();
      } else {
        this.isColumnVisible = false;
        if (this.destroyScrollListener) {
          this.destroyScrollListener();
          this.destroyScrollListener = void 0;
        }
      }
    };
    new IntersectionObserver(visibleCallback, { threshold: 1e-3 }).observe(this.el);
    const parentEl = this.parentEl = this.el.closest("ion-picker-internal");
    if (parentEl !== null) {
      parentEl.addEventListener("ionInputModeChange", (ev) => this.inputModeChange(ev));
    }
  }
  componentDidRender() {
    var _a2;
    const { activeItem, items, isColumnVisible, value } = this;
    if (isColumnVisible) {
      if (activeItem) {
        this.scrollActiveItemIntoView();
      } else if (((_a2 = items[0]) === null || _a2 === void 0 ? void 0 : _a2.value) !== value) {
        this.setValue(items[0].value);
      }
    }
  }
  /** @internal  */
  async scrollActiveItemIntoView() {
    const activeEl = this.activeItem;
    if (activeEl) {
      this.centerPickerItemInView(activeEl, false, false);
    }
  }
  /**
   * Sets the value prop and fires the ionChange event.
   * This is used when we need to fire ionChange from
   * user-generated events that cannot be caught with normal
   * input/change event listeners.
   * @internal
   */
  async setValue(value) {
    const { items } = this;
    this.value = value;
    const findItem = items.find((item) => item.value === value && item.disabled !== true);
    if (findItem) {
      this.ionChange.emit(findItem);
    }
  }
  get activeItem() {
    return getElementRoot(this.el).querySelector(`.picker-item[data-value="${this.value}"]:not([disabled])`);
  }
  render() {
    const { items, color: color2, isActive, numericInput } = this;
    const mode = getIonMode$2(this);
    return h$5(Host$1, { tabindex: 0, class: createColorClasses$1(color2, {
      [mode]: true,
      ["picker-column-active"]: isActive,
      ["picker-column-numeric-input"]: numericInput
    }) }, h$5("div", { class: "picker-item picker-item-empty", "aria-hidden": "true" }, ""), h$5("div", { class: "picker-item picker-item-empty", "aria-hidden": "true" }, ""), h$5("div", { class: "picker-item picker-item-empty", "aria-hidden": "true" }, ""), items.map((item, index3) => {
      return h$5("button", { tabindex: "-1", class: {
        "picker-item": true,
        "picker-item-disabled": item.disabled || false
      }, "data-value": item.value, "data-index": index3, onClick: (ev) => {
        this.centerPickerItemInView(ev.target, true);
      }, disabled: item.disabled }, item.text);
    }), h$5("div", { class: "picker-item picker-item-empty", "aria-hidden": "true" }, ""), h$5("div", { class: "picker-item picker-item-empty", "aria-hidden": "true" }, ""), h$5("div", { class: "picker-item picker-item-empty", "aria-hidden": "true" }, ""));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "value": ["valueChange"]
    };
  }
  static get style() {
    return {
      ios: pickerColumnInternalIosCss,
      md: pickerColumnInternalMdCss
    };
  }
}, [33, "ion-picker-column-internal", {
  "items": [16],
  "value": [1032],
  "color": [513],
  "numericInput": [4, "numeric-input"],
  "isActive": [32],
  "scrollActiveItemIntoView": [64],
  "setValue": [64]
}]);
const PICKER_COL_ACTIVE = "picker-item-active";
function defineCustomElement$S() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-picker-column-internal"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-picker-column-internal":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, PickerColumnInternal);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const pickerInternalIosCss = ":host{display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:200px;direction:ltr;z-index:0}:host .picker-before,:host .picker-after{position:absolute;width:100%;-webkit-transform:translateZ(0);transform:translateZ(0);z-index:1;pointer-events:none}:host .picker-before{top:0;height:83px}@supports (inset-inline-start: 0){:host .picker-before{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host .picker-before{left:0}:host-context([dir=rtl]) .picker-before{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host .picker-before:dir(rtl){left:unset;right:unset;right:0}}}:host .picker-after{top:116px;height:84px}@supports (inset-inline-start: 0){:host .picker-after{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host .picker-after{left:0}:host-context([dir=rtl]) .picker-after{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host .picker-after:dir(rtl){left:unset;right:unset;right:0}}}:host .picker-highlight{border-radius:8px;left:0;right:0;top:50%;bottom:0;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:0;margin-bottom:0;position:absolute;width:calc(100% - 16px);height:34px;-webkit-transform:translateY(-50%);transform:translateY(-50%);z-index:-1}:host input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}:host ::slotted(ion-picker-column-internal:first-of-type){text-align:start}:host ::slotted(ion-picker-column-internal:last-of-type){text-align:end}:host ::slotted(ion-picker-column-internal:only-child){text-align:center}:host .picker-before{background:-webkit-gradient(linear, left top, left bottom, color-stop(20%, var(--background, var(--ion-background-color, #fff))), to(rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8)));background:linear-gradient(to bottom, var(--background, var(--ion-background-color, #fff)) 20%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8) 100%)}:host .picker-after{background:-webkit-gradient(linear, left bottom, left top, color-stop(20%, var(--background, var(--ion-background-color, #fff))), to(rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8)));background:linear-gradient(to top, var(--background, var(--ion-background-color, #fff)) 20%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8) 100%)}:host .picker-highlight{background:var(--ion-color-step-150, #eeeeef)}";
const pickerInternalMdCss = ":host{display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:200px;direction:ltr;z-index:0}:host .picker-before,:host .picker-after{position:absolute;width:100%;-webkit-transform:translateZ(0);transform:translateZ(0);z-index:1;pointer-events:none}:host .picker-before{top:0;height:83px}@supports (inset-inline-start: 0){:host .picker-before{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host .picker-before{left:0}:host-context([dir=rtl]) .picker-before{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host .picker-before:dir(rtl){left:unset;right:unset;right:0}}}:host .picker-after{top:116px;height:84px}@supports (inset-inline-start: 0){:host .picker-after{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host .picker-after{left:0}:host-context([dir=rtl]) .picker-after{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host .picker-after:dir(rtl){left:unset;right:unset;right:0}}}:host .picker-highlight{border-radius:8px;left:0;right:0;top:50%;bottom:0;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:0;margin-bottom:0;position:absolute;width:calc(100% - 16px);height:34px;-webkit-transform:translateY(-50%);transform:translateY(-50%);z-index:-1}:host input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}:host ::slotted(ion-picker-column-internal:first-of-type){text-align:start}:host ::slotted(ion-picker-column-internal:last-of-type){text-align:end}:host ::slotted(ion-picker-column-internal:only-child){text-align:center}:host .picker-before{background:-webkit-gradient(linear, left top, left bottom, color-stop(20%, var(--background, var(--ion-background-color, #fff))), color-stop(90%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0)));background:linear-gradient(to bottom, var(--background, var(--ion-background-color, #fff)) 20%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0) 90%)}:host .picker-after{background:-webkit-gradient(linear, left bottom, left top, color-stop(30%, var(--background, var(--ion-background-color, #fff))), color-stop(90%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0)));background:linear-gradient(to top, var(--background, var(--ion-background-color, #fff)) 30%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0) 90%)}";
const PickerInternal = /* @__PURE__ */ proxyCustomElement$1(class PickerInternal2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionInputModeChange = createEvent(this, "ionInputModeChange", 7);
    this.useInputMode = false;
    this.isInHighlightBounds = (ev) => {
      const { highlightEl } = this;
      if (!highlightEl) {
        return false;
      }
      const bbox = highlightEl.getBoundingClientRect();
      const outsideX = ev.clientX < bbox.left || ev.clientX > bbox.right;
      const outsideY = ev.clientY < bbox.top || ev.clientY > bbox.bottom;
      if (outsideX || outsideY) {
        return false;
      }
      return true;
    };
    this.onFocusOut = (ev) => {
      const { relatedTarget } = ev;
      if (!relatedTarget || relatedTarget.tagName !== "ION-PICKER-COLUMN-INTERNAL" && relatedTarget !== this.inputEl) {
        this.exitInputMode();
      }
    };
    this.onFocusIn = (ev) => {
      const { target } = ev;
      if (target.tagName !== "ION-PICKER-COLUMN-INTERNAL") {
        return;
      }
      if (!this.actionOnClick) {
        const columnEl = target;
        const allowInput = columnEl.numericInput;
        if (allowInput) {
          this.enterInputMode(columnEl, false);
        } else {
          this.exitInputMode();
        }
      }
    };
    this.onClick = () => {
      const { actionOnClick } = this;
      if (actionOnClick) {
        actionOnClick();
        this.actionOnClick = void 0;
      }
    };
    this.onPointerDown = (ev) => {
      const { useInputMode, inputModeColumn, el: el2 } = this;
      if (this.isInHighlightBounds(ev)) {
        if (useInputMode) {
          if (ev.target.tagName === "ION-PICKER-COLUMN-INTERNAL") {
            if (inputModeColumn && inputModeColumn === ev.target) {
              this.actionOnClick = () => {
                this.enterInputMode();
              };
            } else {
              this.actionOnClick = () => {
                this.enterInputMode(ev.target);
              };
            }
          } else {
            this.actionOnClick = () => {
              this.exitInputMode();
            };
          }
        } else {
          const columns = el2.querySelectorAll("ion-picker-column-internal.picker-column-numeric-input");
          const columnEl = columns.length === 1 ? ev.target : void 0;
          this.actionOnClick = () => {
            this.enterInputMode(columnEl);
          };
        }
        return;
      }
      this.actionOnClick = () => {
        this.exitInputMode();
      };
    };
    this.enterInputMode = (columnEl, focusInput = true) => {
      const { inputEl, el: el2 } = this;
      if (!inputEl) {
        return;
      }
      const hasInputColumn = el2.querySelector("ion-picker-column-internal.picker-column-numeric-input");
      if (!hasInputColumn) {
        return;
      }
      this.useInputMode = true;
      this.inputModeColumn = columnEl;
      if (focusInput) {
        if (this.destroyKeypressListener) {
          this.destroyKeypressListener();
          this.destroyKeypressListener = void 0;
        }
        inputEl.focus();
      } else {
        el2.addEventListener("keypress", this.onKeyPress);
        this.destroyKeypressListener = () => {
          el2.removeEventListener("keypress", this.onKeyPress);
        };
      }
      this.emitInputModeChange();
    };
    this.onKeyPress = (ev) => {
      const { inputEl } = this;
      if (!inputEl) {
        return;
      }
      const parsedValue = parseInt(ev.key, 10);
      if (!Number.isNaN(parsedValue)) {
        inputEl.value += ev.key;
        this.onInputChange();
      }
    };
    this.selectSingleColumn = () => {
      const { inputEl, inputModeColumn, singleColumnSearchTimeout } = this;
      if (!inputEl || !inputModeColumn) {
        return;
      }
      const values3 = inputModeColumn.items.filter((item) => item.disabled !== true);
      if (singleColumnSearchTimeout) {
        clearTimeout(singleColumnSearchTimeout);
      }
      this.singleColumnSearchTimeout = setTimeout(() => {
        inputEl.value = "";
        this.singleColumnSearchTimeout = void 0;
      }, 1e3);
      if (inputEl.value.length >= 3) {
        const startIndex = inputEl.value.length - 2;
        const newString = inputEl.value.substring(startIndex);
        inputEl.value = newString;
        this.selectSingleColumn();
        return;
      }
      const findItemFromCompleteValue = values3.find(({ text }) => {
        const parsedText = text.replace(/^0+(?=[1-9])|0+(?=0$)/, "");
        return parsedText === inputEl.value;
      });
      if (findItemFromCompleteValue) {
        inputModeColumn.setValue(findItemFromCompleteValue.value);
        return;
      }
      if (inputEl.value.length === 2) {
        const changedCharacter = inputEl.value.substring(inputEl.value.length - 1);
        inputEl.value = changedCharacter;
        this.selectSingleColumn();
      }
    };
    this.searchColumn = (colEl, value, zeroBehavior = "start") => {
      const behavior = zeroBehavior === "start" ? /^0+/ : /0$/;
      const item = colEl.items.find(({ text, disabled }) => disabled !== true && text.replace(behavior, "") === value);
      if (item) {
        colEl.setValue(item.value);
      }
    };
    this.selectMultiColumn = () => {
      const { inputEl, el: el2 } = this;
      if (!inputEl) {
        return;
      }
      const numericPickers = Array.from(el2.querySelectorAll("ion-picker-column-internal")).filter((col) => col.numericInput);
      const firstColumn = numericPickers[0];
      const lastColumn = numericPickers[1];
      let value = inputEl.value;
      let minuteValue;
      switch (value.length) {
        case 1:
          this.searchColumn(firstColumn, value);
          break;
        case 2:
          const firstCharacter = inputEl.value.substring(0, 1);
          value = firstCharacter === "0" || firstCharacter === "1" ? inputEl.value : firstCharacter;
          this.searchColumn(firstColumn, value);
          if (value.length === 1) {
            minuteValue = inputEl.value.substring(inputEl.value.length - 1);
            this.searchColumn(lastColumn, minuteValue, "end");
          }
          break;
        case 3:
          const firstCharacterAgain = inputEl.value.substring(0, 1);
          value = firstCharacterAgain === "0" || firstCharacterAgain === "1" ? inputEl.value.substring(0, 2) : firstCharacterAgain;
          this.searchColumn(firstColumn, value);
          minuteValue = value.length === 1 ? inputEl.value.substring(1) : inputEl.value.substring(2);
          this.searchColumn(lastColumn, minuteValue, "end");
          break;
        case 4:
          const firstCharacterAgainAgain = inputEl.value.substring(0, 1);
          value = firstCharacterAgainAgain === "0" || firstCharacterAgainAgain === "1" ? inputEl.value.substring(0, 2) : firstCharacterAgainAgain;
          this.searchColumn(firstColumn, value);
          const minuteValueAgain = value.length === 1 ? inputEl.value.substring(1, inputEl.value.length) : inputEl.value.substring(2, inputEl.value.length);
          this.searchColumn(lastColumn, minuteValueAgain, "end");
          break;
        default:
          const startIndex = inputEl.value.length - 4;
          const newString = inputEl.value.substring(startIndex);
          inputEl.value = newString;
          this.selectMultiColumn();
          break;
      }
    };
    this.onInputChange = () => {
      const { useInputMode, inputEl, inputModeColumn } = this;
      if (!useInputMode || !inputEl) {
        return;
      }
      if (inputModeColumn) {
        this.selectSingleColumn();
      } else {
        this.selectMultiColumn();
      }
    };
    this.emitInputModeChange = () => {
      const { useInputMode, inputModeColumn } = this;
      this.ionInputModeChange.emit({
        useInputMode,
        inputModeColumn
      });
    };
  }
  /**
   * When the picker is interacted with
   * we need to prevent touchstart so other
   * gestures do not fire. For example,
   * scrolling on the wheel picker
   * in ion-datetime should not cause
   * a card modal to swipe to close.
   */
  preventTouchStartPropagation(ev) {
    ev.stopPropagation();
  }
  componentWillLoad() {
    getElementRoot(this.el).addEventListener("focusin", this.onFocusIn);
    getElementRoot(this.el).addEventListener("focusout", this.onFocusOut);
  }
  /**
   * @internal
   * Exits text entry mode for the picker
   * This method blurs the hidden input
   * and cause the keyboard to dismiss.
   */
  async exitInputMode() {
    const { inputEl, useInputMode } = this;
    if (!useInputMode || !inputEl) {
      return;
    }
    this.useInputMode = false;
    this.inputModeColumn = void 0;
    inputEl.blur();
    inputEl.value = "";
    if (this.destroyKeypressListener) {
      this.destroyKeypressListener();
      this.destroyKeypressListener = void 0;
    }
    this.emitInputModeChange();
  }
  render() {
    return h$5(Host$1, { onPointerDown: (ev) => this.onPointerDown(ev), onClick: () => this.onClick() }, h$5("input", { "aria-hidden": "true", tabindex: -1, inputmode: "numeric", type: "number", ref: (el2) => this.inputEl = el2, onInput: () => this.onInputChange(), onBlur: () => this.exitInputMode() }), h$5("div", { class: "picker-before" }), h$5("div", { class: "picker-after" }), h$5("div", { class: "picker-highlight", ref: (el2) => this.highlightEl = el2 }), h$5("slot", null));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: pickerInternalIosCss,
      md: pickerInternalMdCss
    };
  }
}, [33, "ion-picker-internal", {
  "exitInputMode": [64]
}, [[1, "touchstart", "preventTouchStartPropagation"]]]);
function defineCustomElement$R() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-picker-internal"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-picker-internal":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, PickerInternal);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const getArrowDimensions = (arrowEl) => {
  if (!arrowEl) {
    return { arrowWidth: 0, arrowHeight: 0 };
  }
  const { width, height } = arrowEl.getBoundingClientRect();
  return { arrowWidth: width, arrowHeight: height };
};
const getPopoverDimensions = (size, contentEl, triggerEl) => {
  const contentDimentions = contentEl.getBoundingClientRect();
  const contentHeight = contentDimentions.height;
  let contentWidth = contentDimentions.width;
  if (size === "cover" && triggerEl) {
    const triggerDimensions = triggerEl.getBoundingClientRect();
    contentWidth = triggerDimensions.width;
  }
  return {
    contentWidth,
    contentHeight
  };
};
const configureDismissInteraction = (triggerEl, triggerAction, popoverEl, parentPopoverEl) => {
  let dismissCallbacks = [];
  const root2 = getElementRoot(parentPopoverEl);
  const parentContentEl = root2.querySelector(".popover-content");
  switch (triggerAction) {
    case "hover":
      dismissCallbacks = [
        {
          /**
           * Do not use mouseover here
           * as this will causes the event to
           * be dispatched on each underlying
           * element rather than on the popover
           * content as a whole.
           */
          eventName: "mouseenter",
          callback: (ev) => {
            const element = document.elementFromPoint(ev.clientX, ev.clientY);
            if (element === triggerEl) {
              return;
            }
            popoverEl.dismiss(void 0, void 0, false);
          }
        }
      ];
      break;
    case "context-menu":
    case "click":
    default:
      dismissCallbacks = [
        {
          eventName: "click",
          callback: (ev) => {
            const target = ev.target;
            const closestTrigger = target.closest("[data-ion-popover-trigger]");
            if (closestTrigger === triggerEl) {
              ev.stopPropagation();
              return;
            }
            popoverEl.dismiss(void 0, void 0, false);
          }
        }
      ];
      break;
  }
  dismissCallbacks.forEach(({ eventName, callback }) => parentContentEl.addEventListener(eventName, callback));
  return () => {
    dismissCallbacks.forEach(({ eventName, callback }) => parentContentEl.removeEventListener(eventName, callback));
  };
};
const configureTriggerInteraction = (triggerEl, triggerAction, popoverEl) => {
  let triggerCallbacks = [];
  switch (triggerAction) {
    case "hover":
      let hoverTimeout;
      triggerCallbacks = [
        {
          eventName: "mouseenter",
          callback: async (ev) => {
            ev.stopPropagation();
            if (hoverTimeout) {
              clearTimeout(hoverTimeout);
            }
            hoverTimeout = setTimeout(() => {
              raf(() => {
                popoverEl.presentFromTrigger(ev);
                hoverTimeout = void 0;
              });
            }, 100);
          }
        },
        {
          eventName: "mouseleave",
          callback: (ev) => {
            if (hoverTimeout) {
              clearTimeout(hoverTimeout);
            }
            const target = ev.relatedTarget;
            if (!target) {
              return;
            }
            if (target.closest("ion-popover") !== popoverEl) {
              popoverEl.dismiss(void 0, void 0, false);
            }
          }
        },
        {
          /**
           * stopPropagation here prevents the popover
           * from dismissing when dismiss-on-select="true".
           */
          eventName: "click",
          callback: (ev) => ev.stopPropagation()
        },
        {
          eventName: "ionPopoverActivateTrigger",
          callback: (ev) => popoverEl.presentFromTrigger(ev, true)
        }
      ];
      break;
    case "context-menu":
      triggerCallbacks = [
        {
          eventName: "contextmenu",
          callback: (ev) => {
            ev.preventDefault();
            popoverEl.presentFromTrigger(ev);
          }
        },
        {
          eventName: "click",
          callback: (ev) => ev.stopPropagation()
        },
        {
          eventName: "ionPopoverActivateTrigger",
          callback: (ev) => popoverEl.presentFromTrigger(ev, true)
        }
      ];
      break;
    case "click":
    default:
      triggerCallbacks = [
        {
          /**
           * Do not do a stopPropagation() here
           * because if you had two click triggers
           * then clicking the first trigger and then
           * clicking the second trigger would not cause
           * the first popover to dismiss.
           */
          eventName: "click",
          callback: (ev) => popoverEl.presentFromTrigger(ev)
        },
        {
          eventName: "ionPopoverActivateTrigger",
          callback: (ev) => popoverEl.presentFromTrigger(ev, true)
        }
      ];
      break;
  }
  triggerCallbacks.forEach(({ eventName, callback }) => triggerEl.addEventListener(eventName, callback));
  triggerEl.setAttribute("data-ion-popover-trigger", "true");
  return () => {
    triggerCallbacks.forEach(({ eventName, callback }) => triggerEl.removeEventListener(eventName, callback));
    triggerEl.removeAttribute("data-ion-popover-trigger");
  };
};
const getIndexOfItem = (items, item) => {
  if (!item || item.tagName !== "ION-ITEM") {
    return -1;
  }
  return items.findIndex((el2) => el2 === item);
};
const getNextItem = (items, currentItem) => {
  const currentItemIndex = getIndexOfItem(items, currentItem);
  return items[currentItemIndex + 1];
};
const getPrevItem = (items, currentItem) => {
  const currentItemIndex = getIndexOfItem(items, currentItem);
  return items[currentItemIndex - 1];
};
const focusItem = (item) => {
  const root2 = getElementRoot(item);
  const button = root2.querySelector("button");
  if (button) {
    raf(() => button.focus());
  }
};
const isTriggerElement = (el2) => el2.hasAttribute("data-ion-popover-trigger");
const configureKeyboardInteraction = (popoverEl) => {
  const callback = async (ev) => {
    var _a2;
    const activeElement = document.activeElement;
    let items = [];
    const targetTagName = (_a2 = ev.target) === null || _a2 === void 0 ? void 0 : _a2.tagName;
    if (targetTagName !== "ION-POPOVER" && targetTagName !== "ION-ITEM") {
      return;
    }
    try {
      items = Array.from(popoverEl.querySelectorAll("ion-item:not(ion-popover ion-popover *):not([disabled])"));
    } catch (_b) {
    }
    switch (ev.key) {
      case "ArrowLeft":
        const parentPopover = await popoverEl.getParentPopover();
        if (parentPopover) {
          popoverEl.dismiss(void 0, void 0, false);
        }
        break;
      case "ArrowDown":
        ev.preventDefault();
        const nextItem = getNextItem(items, activeElement);
        if (nextItem !== void 0) {
          focusItem(nextItem);
        }
        break;
      case "ArrowUp":
        ev.preventDefault();
        const prevItem = getPrevItem(items, activeElement);
        if (prevItem !== void 0) {
          focusItem(prevItem);
        }
        break;
      case "Home":
        ev.preventDefault();
        const firstItem = items[0];
        if (firstItem !== void 0) {
          focusItem(firstItem);
        }
        break;
      case "End":
        ev.preventDefault();
        const lastItem = items[items.length - 1];
        if (lastItem !== void 0) {
          focusItem(lastItem);
        }
        break;
      case "ArrowRight":
      case " ":
      case "Enter":
        if (activeElement && isTriggerElement(activeElement)) {
          const rightEvent = new CustomEvent("ionPopoverActivateTrigger");
          activeElement.dispatchEvent(rightEvent);
        }
        break;
    }
  };
  popoverEl.addEventListener("keydown", callback);
  return () => popoverEl.removeEventListener("keydown", callback);
};
const getPopoverPosition = (isRTL2, contentWidth, contentHeight, arrowWidth, arrowHeight, reference, side, align, defaultPosition, triggerEl, event) => {
  var _a2;
  let referenceCoordinates = {
    top: 0,
    left: 0,
    width: 0,
    height: 0
  };
  switch (reference) {
    case "event":
      if (!event) {
        return defaultPosition;
      }
      const mouseEv = event;
      referenceCoordinates = {
        top: mouseEv.clientY,
        left: mouseEv.clientX,
        width: 1,
        height: 1
      };
      break;
    case "trigger":
    default:
      const customEv = event;
      const actualTriggerEl = triggerEl || ((_a2 = customEv === null || customEv === void 0 ? void 0 : customEv.detail) === null || _a2 === void 0 ? void 0 : _a2.ionShadowTarget) || (customEv === null || customEv === void 0 ? void 0 : customEv.target);
      if (!actualTriggerEl) {
        return defaultPosition;
      }
      const triggerBoundingBox = actualTriggerEl.getBoundingClientRect();
      referenceCoordinates = {
        top: triggerBoundingBox.top,
        left: triggerBoundingBox.left,
        width: triggerBoundingBox.width,
        height: triggerBoundingBox.height
      };
      break;
  }
  const coordinates = calculatePopoverSide(side, referenceCoordinates, contentWidth, contentHeight, arrowWidth, arrowHeight, isRTL2);
  const alignedCoordinates = calculatePopoverAlign(align, side, referenceCoordinates, contentWidth, contentHeight);
  const top = coordinates.top + alignedCoordinates.top;
  const left = coordinates.left + alignedCoordinates.left;
  const { arrowTop, arrowLeft } = calculateArrowPosition(side, arrowWidth, arrowHeight, top, left, contentWidth, contentHeight, isRTL2);
  const { originX, originY } = calculatePopoverOrigin(side, align, isRTL2);
  return { top, left, referenceCoordinates, arrowTop, arrowLeft, originX, originY };
};
const calculatePopoverOrigin = (side, align, isRTL2) => {
  switch (side) {
    case "top":
      return { originX: getOriginXAlignment(align), originY: "bottom" };
    case "bottom":
      return { originX: getOriginXAlignment(align), originY: "top" };
    case "left":
      return { originX: "right", originY: getOriginYAlignment(align) };
    case "right":
      return { originX: "left", originY: getOriginYAlignment(align) };
    case "start":
      return { originX: isRTL2 ? "left" : "right", originY: getOriginYAlignment(align) };
    case "end":
      return { originX: isRTL2 ? "right" : "left", originY: getOriginYAlignment(align) };
  }
};
const getOriginXAlignment = (align) => {
  switch (align) {
    case "start":
      return "left";
    case "center":
      return "center";
    case "end":
      return "right";
  }
};
const getOriginYAlignment = (align) => {
  switch (align) {
    case "start":
      return "top";
    case "center":
      return "center";
    case "end":
      return "bottom";
  }
};
const calculateArrowPosition = (side, arrowWidth, arrowHeight, top, left, contentWidth, contentHeight, isRTL2) => {
  const leftPosition = {
    arrowTop: top + contentHeight / 2 - arrowWidth / 2,
    arrowLeft: left + contentWidth - arrowWidth / 2
  };
  const rightPosition = { arrowTop: top + contentHeight / 2 - arrowWidth / 2, arrowLeft: left - arrowWidth * 1.5 };
  switch (side) {
    case "top":
      return { arrowTop: top + contentHeight, arrowLeft: left + contentWidth / 2 - arrowWidth / 2 };
    case "bottom":
      return { arrowTop: top - arrowHeight, arrowLeft: left + contentWidth / 2 - arrowWidth / 2 };
    case "left":
      return leftPosition;
    case "right":
      return rightPosition;
    case "start":
      return isRTL2 ? rightPosition : leftPosition;
    case "end":
      return isRTL2 ? leftPosition : rightPosition;
    default:
      return { arrowTop: 0, arrowLeft: 0 };
  }
};
const calculatePopoverSide = (side, triggerBoundingBox, contentWidth, contentHeight, arrowWidth, arrowHeight, isRTL2) => {
  const sideLeft = {
    top: triggerBoundingBox.top,
    left: triggerBoundingBox.left - contentWidth - arrowWidth
  };
  const sideRight = {
    top: triggerBoundingBox.top,
    left: triggerBoundingBox.left + triggerBoundingBox.width + arrowWidth
  };
  switch (side) {
    case "top":
      return {
        top: triggerBoundingBox.top - contentHeight - arrowHeight,
        left: triggerBoundingBox.left
      };
    case "right":
      return sideRight;
    case "bottom":
      return {
        top: triggerBoundingBox.top + triggerBoundingBox.height + arrowHeight,
        left: triggerBoundingBox.left
      };
    case "left":
      return sideLeft;
    case "start":
      return isRTL2 ? sideRight : sideLeft;
    case "end":
      return isRTL2 ? sideLeft : sideRight;
  }
};
const calculatePopoverAlign = (align, side, triggerBoundingBox, contentWidth, contentHeight) => {
  switch (align) {
    case "center":
      return calculatePopoverCenterAlign(side, triggerBoundingBox, contentWidth, contentHeight);
    case "end":
      return calculatePopoverEndAlign(side, triggerBoundingBox, contentWidth, contentHeight);
    case "start":
    default:
      return { top: 0, left: 0 };
  }
};
const calculatePopoverEndAlign = (side, triggerBoundingBox, contentWidth, contentHeight) => {
  switch (side) {
    case "start":
    case "end":
    case "left":
    case "right":
      return {
        top: -(contentHeight - triggerBoundingBox.height),
        left: 0
      };
    case "top":
    case "bottom":
    default:
      return {
        top: 0,
        left: -(contentWidth - triggerBoundingBox.width)
      };
  }
};
const calculatePopoverCenterAlign = (side, triggerBoundingBox, contentWidth, contentHeight) => {
  switch (side) {
    case "start":
    case "end":
    case "left":
    case "right":
      return {
        top: -(contentHeight / 2 - triggerBoundingBox.height / 2),
        left: 0
      };
    case "top":
    case "bottom":
    default:
      return {
        top: 0,
        left: -(contentWidth / 2 - triggerBoundingBox.width / 2)
      };
  }
};
const calculateWindowAdjustment = (side, coordTop, coordLeft, bodyPadding, bodyWidth, bodyHeight, contentWidth, contentHeight, safeAreaMargin, contentOriginX, contentOriginY, triggerCoordinates, coordArrowTop = 0, coordArrowLeft = 0, arrowHeight = 0) => {
  let arrowTop = coordArrowTop;
  const arrowLeft = coordArrowLeft;
  let left = coordLeft;
  let top = coordTop;
  let bottom;
  let originX = contentOriginX;
  let originY = contentOriginY;
  let checkSafeAreaLeft = false;
  let checkSafeAreaRight = false;
  const triggerTop = triggerCoordinates ? triggerCoordinates.top + triggerCoordinates.height : bodyHeight / 2 - contentHeight / 2;
  const triggerHeight = triggerCoordinates ? triggerCoordinates.height : 0;
  let addPopoverBottomClass = false;
  if (left < bodyPadding + safeAreaMargin) {
    left = bodyPadding;
    checkSafeAreaLeft = true;
    originX = "left";
  } else if (contentWidth + bodyPadding + left + safeAreaMargin > bodyWidth) {
    checkSafeAreaRight = true;
    left = bodyWidth - contentWidth - bodyPadding;
    originX = "right";
  }
  if (triggerTop + triggerHeight + contentHeight > bodyHeight && (side === "top" || side === "bottom")) {
    if (triggerTop - contentHeight > 0) {
      top = Math.max(12, triggerTop - contentHeight - triggerHeight - (arrowHeight - 1));
      arrowTop = top + contentHeight;
      originY = "bottom";
      addPopoverBottomClass = true;
    } else {
      bottom = bodyPadding;
    }
  }
  return {
    top,
    left,
    bottom,
    originX,
    originY,
    checkSafeAreaLeft,
    checkSafeAreaRight,
    arrowTop,
    arrowLeft,
    addPopoverBottomClass
  };
};
const shouldShowArrow = (side, didAdjustBounds = false, ev, trigger) => {
  if (!ev && !trigger) {
    return false;
  }
  if (side !== "top" && side !== "bottom" && didAdjustBounds) {
    return false;
  }
  return true;
};
const POPOVER_IOS_BODY_PADDING = 5;
const iosEnterAnimation$5 = (baseEl, opts) => {
  var _a2;
  const { event: ev, size, trigger, reference, side, align } = opts;
  const doc2 = baseEl.ownerDocument;
  const isRTL2 = doc2.dir === "rtl";
  const bodyWidth = doc2.defaultView.innerWidth;
  const bodyHeight = doc2.defaultView.innerHeight;
  const root2 = getElementRoot(baseEl);
  const contentEl = root2.querySelector(".popover-content");
  const arrowEl = root2.querySelector(".popover-arrow");
  const referenceSizeEl = trigger || ((_a2 = ev === null || ev === void 0 ? void 0 : ev.detail) === null || _a2 === void 0 ? void 0 : _a2.ionShadowTarget) || (ev === null || ev === void 0 ? void 0 : ev.target);
  const { contentWidth, contentHeight } = getPopoverDimensions(size, contentEl, referenceSizeEl);
  const { arrowWidth, arrowHeight } = getArrowDimensions(arrowEl);
  const defaultPosition = {
    top: bodyHeight / 2 - contentHeight / 2,
    left: bodyWidth / 2 - contentWidth / 2,
    originX: isRTL2 ? "right" : "left",
    originY: "top"
  };
  const results = getPopoverPosition(isRTL2, contentWidth, contentHeight, arrowWidth, arrowHeight, reference, side, align, defaultPosition, trigger, ev);
  const padding = size === "cover" ? 0 : POPOVER_IOS_BODY_PADDING;
  const margin = size === "cover" ? 0 : 25;
  const { originX, originY, top, left, bottom, checkSafeAreaLeft, checkSafeAreaRight, arrowTop, arrowLeft, addPopoverBottomClass } = calculateWindowAdjustment(side, results.top, results.left, padding, bodyWidth, bodyHeight, contentWidth, contentHeight, margin, results.originX, results.originY, results.referenceCoordinates, results.arrowTop, results.arrowLeft, arrowHeight);
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(root2.querySelector("ion-backdrop")).fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  wrapperAnimation.addElement(root2.querySelector(".popover-wrapper")).fromTo("opacity", 0.01, 1);
  return baseAnimation2.easing("ease").duration(100).beforeAddWrite(() => {
    if (size === "cover") {
      baseEl.style.setProperty("--width", `${contentWidth}px`);
    }
    if (addPopoverBottomClass) {
      baseEl.classList.add("popover-bottom");
    }
    if (bottom !== void 0) {
      contentEl.style.setProperty("bottom", `${bottom}px`);
    }
    const safeAreaLeft = " + var(--ion-safe-area-left, 0)";
    const safeAreaRight = " - var(--ion-safe-area-right, 0)";
    let leftValue = `${left}px`;
    if (checkSafeAreaLeft) {
      leftValue = `${left}px${safeAreaLeft}`;
    }
    if (checkSafeAreaRight) {
      leftValue = `${left}px${safeAreaRight}`;
    }
    contentEl.style.setProperty("top", `calc(${top}px + var(--offset-y, 0))`);
    contentEl.style.setProperty("left", `calc(${leftValue} + var(--offset-x, 0))`);
    contentEl.style.setProperty("transform-origin", `${originY} ${originX}`);
    if (arrowEl !== null) {
      const didAdjustBounds = results.top !== top || results.left !== left;
      const showArrow = shouldShowArrow(side, didAdjustBounds, ev, trigger);
      if (showArrow) {
        arrowEl.style.setProperty("top", `calc(${arrowTop}px + var(--offset-y, 0))`);
        arrowEl.style.setProperty("left", `calc(${arrowLeft}px + var(--offset-x, 0))`);
      } else {
        arrowEl.style.setProperty("display", "none");
      }
    }
  }).addAnimation([backdropAnimation, wrapperAnimation]);
};
const iosLeaveAnimation$5 = (baseEl) => {
  const root2 = getElementRoot(baseEl);
  const contentEl = root2.querySelector(".popover-content");
  const arrowEl = root2.querySelector(".popover-arrow");
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(root2.querySelector("ion-backdrop")).fromTo("opacity", "var(--backdrop-opacity)", 0);
  wrapperAnimation.addElement(root2.querySelector(".popover-wrapper")).fromTo("opacity", 0.99, 0);
  return baseAnimation2.easing("ease").afterAddWrite(() => {
    baseEl.style.removeProperty("--width");
    baseEl.classList.remove("popover-bottom");
    contentEl.style.removeProperty("top");
    contentEl.style.removeProperty("left");
    contentEl.style.removeProperty("bottom");
    contentEl.style.removeProperty("transform-origin");
    if (arrowEl) {
      arrowEl.style.removeProperty("top");
      arrowEl.style.removeProperty("left");
      arrowEl.style.removeProperty("display");
    }
  }).duration(300).addAnimation([backdropAnimation, wrapperAnimation]);
};
const POPOVER_MD_BODY_PADDING = 12;
const mdEnterAnimation$5 = (baseEl, opts) => {
  var _a2;
  const { event: ev, size, trigger, reference, side, align } = opts;
  const doc2 = baseEl.ownerDocument;
  const isRTL2 = doc2.dir === "rtl";
  const bodyWidth = doc2.defaultView.innerWidth;
  const bodyHeight = doc2.defaultView.innerHeight;
  const root2 = getElementRoot(baseEl);
  const contentEl = root2.querySelector(".popover-content");
  const referenceSizeEl = trigger || ((_a2 = ev === null || ev === void 0 ? void 0 : ev.detail) === null || _a2 === void 0 ? void 0 : _a2.ionShadowTarget) || (ev === null || ev === void 0 ? void 0 : ev.target);
  const { contentWidth, contentHeight } = getPopoverDimensions(size, contentEl, referenceSizeEl);
  const defaultPosition = {
    top: bodyHeight / 2 - contentHeight / 2,
    left: bodyWidth / 2 - contentWidth / 2,
    originX: isRTL2 ? "right" : "left",
    originY: "top"
  };
  const results = getPopoverPosition(isRTL2, contentWidth, contentHeight, 0, 0, reference, side, align, defaultPosition, trigger, ev);
  const padding = size === "cover" ? 0 : POPOVER_MD_BODY_PADDING;
  const { originX, originY, top, left, bottom } = calculateWindowAdjustment(side, results.top, results.left, padding, bodyWidth, bodyHeight, contentWidth, contentHeight, 0, results.originX, results.originY, results.referenceCoordinates);
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  const contentAnimation = createAnimation();
  const viewportAnimation = createAnimation();
  backdropAnimation.addElement(root2.querySelector("ion-backdrop")).fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  wrapperAnimation.addElement(root2.querySelector(".popover-wrapper")).duration(150).fromTo("opacity", 0.01, 1);
  contentAnimation.addElement(contentEl).beforeStyles({
    top: `calc(${top}px + var(--offset-y, 0px))`,
    left: `calc(${left}px + var(--offset-x, 0px))`,
    "transform-origin": `${originY} ${originX}`
  }).beforeAddWrite(() => {
    if (bottom !== void 0) {
      contentEl.style.setProperty("bottom", `${bottom}px`);
    }
  }).fromTo("transform", "scale(0.8)", "scale(1)");
  viewportAnimation.addElement(root2.querySelector(".popover-viewport")).fromTo("opacity", 0.01, 1);
  return baseAnimation2.easing("cubic-bezier(0.36,0.66,0.04,1)").duration(300).beforeAddWrite(() => {
    if (size === "cover") {
      baseEl.style.setProperty("--width", `${contentWidth}px`);
    }
    if (originY === "bottom") {
      baseEl.classList.add("popover-bottom");
    }
  }).addAnimation([backdropAnimation, wrapperAnimation, contentAnimation, viewportAnimation]);
};
const mdLeaveAnimation$5 = (baseEl) => {
  const root2 = getElementRoot(baseEl);
  const contentEl = root2.querySelector(".popover-content");
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(root2.querySelector("ion-backdrop")).fromTo("opacity", "var(--backdrop-opacity)", 0);
  wrapperAnimation.addElement(root2.querySelector(".popover-wrapper")).fromTo("opacity", 0.99, 0);
  return baseAnimation2.easing("ease").afterAddWrite(() => {
    baseEl.style.removeProperty("--width");
    baseEl.classList.remove("popover-bottom");
    contentEl.style.removeProperty("top");
    contentEl.style.removeProperty("left");
    contentEl.style.removeProperty("bottom");
    contentEl.style.removeProperty("transform-origin");
  }).duration(150).addAnimation([backdropAnimation, wrapperAnimation]);
};
const popoverIosCss = ':host{--background:var(--ion-background-color, #fff);--min-width:0;--min-height:0;--max-width:auto;--height:auto;--offset-x:0px;--offset-y:0px;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:fixed;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);z-index:1001}:host(.popover-nested){pointer-events:none}:host(.popover-nested) .popover-wrapper{pointer-events:auto}:host(.overlay-hidden){display:none}.popover-wrapper{opacity:0;z-index:10}.popover-content{display:-ms-flexbox;display:flex;position:absolute;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:auto;z-index:10}.popover-viewport{--ion-safe-area-top:0px;--ion-safe-area-right:0px;--ion-safe-area-bottom:0px;--ion-safe-area-left:0px;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;overflow:hidden}:host(.popover-nested.popover-side-left){--offset-x:5px}:host(.popover-nested.popover-side-right){--offset-x:-5px}:host(.popover-nested.popover-side-start){--offset-x:5px}:host-context([dir=rtl]):host(.popover-nested.popover-side-start),:host-context([dir=rtl]).popover-nested.popover-side-start{--offset-x:-5px}@supports selector(:dir(rtl)){:host(.popover-nested.popover-side-start):dir(rtl){--offset-x:-5px}}:host(.popover-nested.popover-side-end){--offset-x:-5px}:host-context([dir=rtl]):host(.popover-nested.popover-side-end),:host-context([dir=rtl]).popover-nested.popover-side-end{--offset-x:5px}@supports selector(:dir(rtl)){:host(.popover-nested.popover-side-end):dir(rtl){--offset-x:5px}}:host{--width:200px;--max-height:90%;--box-shadow:none;--backdrop-opacity:var(--ion-backdrop-opacity, 0.08)}:host(.popover-desktop){--box-shadow:0px 4px 16px 0px rgba(0, 0, 0, 0.12)}.popover-content{border-radius:10px}:host(.popover-desktop) .popover-content{border:0.5px solid var(--ion-color-step-100, #e6e6e6)}.popover-arrow{display:block;position:absolute;width:20px;height:10px;overflow:hidden}.popover-arrow::after{top:3px;border-radius:3px;position:absolute;width:14px;height:14px;-webkit-transform:rotate(45deg);transform:rotate(45deg);background:var(--background);content:"";z-index:10}@supports (inset-inline-start: 0){.popover-arrow::after{inset-inline-start:3px}}@supports not (inset-inline-start: 0){.popover-arrow::after{left:3px}:host-context([dir=rtl]) .popover-arrow::after{left:unset;right:unset;right:3px}[dir=rtl] .popover-arrow::after{left:unset;right:unset;right:3px}@supports selector(:dir(rtl)){.popover-arrow::after:dir(rtl){left:unset;right:unset;right:3px}}}:host(.popover-bottom) .popover-arrow{top:auto;bottom:-10px}:host(.popover-bottom) .popover-arrow::after{top:-6px}:host(.popover-side-left) .popover-arrow{-webkit-transform:rotate(90deg);transform:rotate(90deg)}:host(.popover-side-right) .popover-arrow{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}:host(.popover-side-top) .popover-arrow{-webkit-transform:rotate(180deg);transform:rotate(180deg)}:host(.popover-side-start) .popover-arrow{-webkit-transform:rotate(90deg);transform:rotate(90deg)}:host-context([dir=rtl]):host(.popover-side-start) .popover-arrow,:host-context([dir=rtl]).popover-side-start .popover-arrow{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}@supports selector(:dir(rtl)){:host(.popover-side-start) .popover-arrow:dir(rtl){-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}}:host(.popover-side-end) .popover-arrow{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}:host-context([dir=rtl]):host(.popover-side-end) .popover-arrow,:host-context([dir=rtl]).popover-side-end .popover-arrow{-webkit-transform:rotate(90deg);transform:rotate(90deg)}@supports selector(:dir(rtl)){:host(.popover-side-end) .popover-arrow:dir(rtl){-webkit-transform:rotate(90deg);transform:rotate(90deg)}}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.popover-translucent) .popover-content,:host(.popover-translucent) .popover-arrow::after{background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}}';
const popoverMdCss = ":host{--background:var(--ion-background-color, #fff);--min-width:0;--min-height:0;--max-width:auto;--height:auto;--offset-x:0px;--offset-y:0px;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:fixed;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);z-index:1001}:host(.popover-nested){pointer-events:none}:host(.popover-nested) .popover-wrapper{pointer-events:auto}:host(.overlay-hidden){display:none}.popover-wrapper{opacity:0;z-index:10}.popover-content{display:-ms-flexbox;display:flex;position:absolute;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:auto;z-index:10}.popover-viewport{--ion-safe-area-top:0px;--ion-safe-area-right:0px;--ion-safe-area-bottom:0px;--ion-safe-area-left:0px;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;overflow:hidden}:host(.popover-nested.popover-side-left){--offset-x:5px}:host(.popover-nested.popover-side-right){--offset-x:-5px}:host(.popover-nested.popover-side-start){--offset-x:5px}:host-context([dir=rtl]):host(.popover-nested.popover-side-start),:host-context([dir=rtl]).popover-nested.popover-side-start{--offset-x:-5px}@supports selector(:dir(rtl)){:host(.popover-nested.popover-side-start):dir(rtl){--offset-x:-5px}}:host(.popover-nested.popover-side-end){--offset-x:-5px}:host-context([dir=rtl]):host(.popover-nested.popover-side-end),:host-context([dir=rtl]).popover-nested.popover-side-end{--offset-x:5px}@supports selector(:dir(rtl)){:host(.popover-nested.popover-side-end):dir(rtl){--offset-x:5px}}:host{--width:250px;--max-height:90%;--box-shadow:0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}.popover-content{border-radius:4px;-webkit-transform-origin:left top;transform-origin:left top}:host-context([dir=rtl]) .popover-content{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .popover-content{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.popover-content:dir(rtl){-webkit-transform-origin:right top;transform-origin:right top}}.popover-viewport{-webkit-transition-delay:100ms;transition-delay:100ms}";
const Popover = /* @__PURE__ */ proxyCustomElement$1(class Popover2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.didPresent = createEvent(this, "ionPopoverDidPresent", 7);
    this.willPresent = createEvent(this, "ionPopoverWillPresent", 7);
    this.willDismiss = createEvent(this, "ionPopoverWillDismiss", 7);
    this.didDismiss = createEvent(this, "ionPopoverDidDismiss", 7);
    this.didPresentShorthand = createEvent(this, "didPresent", 7);
    this.willPresentShorthand = createEvent(this, "willPresent", 7);
    this.willDismissShorthand = createEvent(this, "willDismiss", 7);
    this.didDismissShorthand = createEvent(this, "didDismiss", 7);
    this.ionMount = createEvent(this, "ionMount", 7);
    this.parentPopover = null;
    this.coreDelegate = CoreDelegate();
    this.inline = false;
    this.focusDescendantOnPresent = false;
    this.onBackdropTap = () => {
      this.dismiss(void 0, BACKDROP);
    };
    this.onLifecycle = (modalEvent) => {
      const el2 = this.usersElement;
      const name = LIFECYCLE_MAP$1[modalEvent.type];
      if (el2 && name) {
        const event = new CustomEvent(name, {
          bubbles: false,
          cancelable: false,
          detail: modalEvent.detail
        });
        el2.dispatchEvent(event);
      }
    };
    this.configureTriggerInteraction = () => {
      const { trigger, triggerAction, el: el2, destroyTriggerInteraction } = this;
      if (destroyTriggerInteraction) {
        destroyTriggerInteraction();
      }
      if (trigger === void 0) {
        return;
      }
      const triggerEl = this.triggerEl = trigger !== void 0 ? document.getElementById(trigger) : null;
      if (!triggerEl) {
        printIonWarning(`A trigger element with the ID "${trigger}" was not found in the DOM. The trigger element must be in the DOM when the "trigger" property is set on ion-popover.`, this.el);
        return;
      }
      this.destroyTriggerInteraction = configureTriggerInteraction(triggerEl, triggerAction, el2);
    };
    this.configureKeyboardInteraction = () => {
      const { destroyKeyboardInteraction, el: el2 } = this;
      if (destroyKeyboardInteraction) {
        destroyKeyboardInteraction();
      }
      this.destroyKeyboardInteraction = configureKeyboardInteraction(el2);
    };
    this.configureDismissInteraction = () => {
      const { destroyDismissInteraction, parentPopover, triggerAction, triggerEl, el: el2 } = this;
      if (!parentPopover || !triggerEl) {
        return;
      }
      if (destroyDismissInteraction) {
        destroyDismissInteraction();
      }
      this.destroyDismissInteraction = configureDismissInteraction(triggerEl, triggerAction, el2, parentPopover);
    };
    this.presented = false;
    this.hasController = false;
    this.delegate = void 0;
    this.overlayIndex = void 0;
    this.enterAnimation = void 0;
    this.leaveAnimation = void 0;
    this.component = void 0;
    this.componentProps = void 0;
    this.keyboardClose = true;
    this.cssClass = void 0;
    this.backdropDismiss = true;
    this.event = void 0;
    this.showBackdrop = true;
    this.translucent = false;
    this.animated = true;
    this.htmlAttributes = void 0;
    this.triggerAction = "click";
    this.trigger = void 0;
    this.size = "auto";
    this.dismissOnSelect = false;
    this.reference = "trigger";
    this.side = "bottom";
    this.alignment = void 0;
    this.arrow = true;
    this.isOpen = false;
    this.keyboardEvents = false;
    this.keepContentsMounted = false;
  }
  onTriggerChange() {
    this.configureTriggerInteraction();
  }
  onIsOpenChange(newValue, oldValue) {
    if (newValue === true && oldValue === false) {
      this.present();
    } else if (newValue === false && oldValue === true) {
      this.dismiss();
    }
  }
  connectedCallback() {
    const { configureTriggerInteraction: configureTriggerInteraction2, el: el2 } = this;
    prepareOverlay(el2);
    configureTriggerInteraction2();
  }
  disconnectedCallback() {
    const { destroyTriggerInteraction } = this;
    if (destroyTriggerInteraction) {
      destroyTriggerInteraction();
    }
  }
  componentWillLoad() {
    const { el: el2 } = this;
    const popoverId = setOverlayId(el2);
    this.parentPopover = el2.closest(`ion-popover:not(#${popoverId})`);
    if (this.alignment === void 0) {
      this.alignment = getIonMode$2(this) === "ios" ? "center" : "start";
    }
  }
  componentDidLoad() {
    const { parentPopover, isOpen } = this;
    if (isOpen === true) {
      raf(() => this.present());
    }
    if (parentPopover) {
      addEventListener$1(parentPopover, "ionPopoverWillDismiss", () => {
        this.dismiss(void 0, void 0, false);
      });
    }
  }
  /**
   * When opening a popover from a trigger, we should not be
   * modifying the `event` prop from inside the component.
   * Additionally, when pressing the "Right" arrow key, we need
   * to shift focus to the first descendant in the newly presented
   * popover.
   *
   * @internal
   */
  async presentFromTrigger(event, focusDescendant = false) {
    this.focusDescendantOnPresent = focusDescendant;
    await this.present(event);
    this.focusDescendantOnPresent = false;
  }
  /**
   * Determines whether or not an overlay
   * is being used inline or via a controller/JS
   * and returns the correct delegate.
   * By default, subsequent calls to getDelegate
   * will use a cached version of the delegate.
   * This is useful for calling dismiss after
   * present so that the correct delegate is given.
   */
  getDelegate(force = false) {
    if (this.workingDelegate && !force) {
      return {
        delegate: this.workingDelegate,
        inline: this.inline
      };
    }
    const parentEl = this.el.parentNode;
    const inline = this.inline = parentEl !== null && !this.hasController;
    const delegate = this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate;
    return { inline, delegate };
  }
  /**
   * Present the popover overlay after it has been created.
   * Developers can pass a mouse, touch, or pointer event
   * to position the popover relative to where that event
   * was dispatched.
   */
  async present(event) {
    if (this.presented) {
      return;
    }
    if (this.currentTransition !== void 0) {
      await this.currentTransition;
    }
    const { el: el2 } = this;
    const { inline, delegate } = this.getDelegate(true);
    this.usersElement = await attachComponent(delegate, el2, this.component, ["popover-viewport"], this.componentProps, inline);
    if (!this.keyboardEvents) {
      this.configureKeyboardInteraction();
    }
    this.configureDismissInteraction();
    this.ionMount.emit();
    if (hasLazyBuild(el2)) {
      await deepReady(this.usersElement);
    } else if (!this.keepContentsMounted) {
      await waitForMount();
    }
    this.currentTransition = present(this, "popoverEnter", iosEnterAnimation$5, mdEnterAnimation$5, {
      event: event || this.event,
      size: this.size,
      trigger: this.triggerEl,
      reference: this.reference,
      side: this.side,
      align: this.alignment
    });
    await this.currentTransition;
    this.currentTransition = void 0;
    if (this.focusDescendantOnPresent) {
      focusFirstDescendant(this.el, this.el);
    }
  }
  /**
   * Dismiss the popover overlay after it has been presented.
   *
   * @param data Any data to emit in the dismiss events.
   * @param role The role of the element that is dismissing the popover. For example, 'cancel' or 'backdrop'.
   * @param dismissParentPopover If `true`, dismissing this popover will also dismiss
   * a parent popover if this popover is nested. Defaults to `true`.
   */
  async dismiss(data2, role, dismissParentPopover = true) {
    if (this.currentTransition !== void 0) {
      await this.currentTransition;
    }
    const { destroyKeyboardInteraction, destroyDismissInteraction } = this;
    if (dismissParentPopover && this.parentPopover) {
      this.parentPopover.dismiss(data2, role, dismissParentPopover);
    }
    this.currentTransition = dismiss(this, data2, role, "popoverLeave", iosLeaveAnimation$5, mdLeaveAnimation$5, this.event);
    const shouldDismiss = await this.currentTransition;
    if (shouldDismiss) {
      if (destroyKeyboardInteraction) {
        destroyKeyboardInteraction();
        this.destroyKeyboardInteraction = void 0;
      }
      if (destroyDismissInteraction) {
        destroyDismissInteraction();
        this.destroyDismissInteraction = void 0;
      }
      const { delegate } = this.getDelegate();
      await detachComponent(delegate, this.usersElement);
    }
    this.currentTransition = void 0;
    return shouldDismiss;
  }
  /**
   * @internal
   */
  async getParentPopover() {
    return this.parentPopover;
  }
  /**
   * Returns a promise that resolves when the popover did dismiss.
   */
  onDidDismiss() {
    return eventMethod(this.el, "ionPopoverDidDismiss");
  }
  /**
   * Returns a promise that resolves when the popover will dismiss.
   */
  onWillDismiss() {
    return eventMethod(this.el, "ionPopoverWillDismiss");
  }
  render() {
    const mode = getIonMode$2(this);
    const { onLifecycle, parentPopover, dismissOnSelect, side, arrow, htmlAttributes } = this;
    const desktop = isPlatform("desktop");
    const enableArrow = arrow && !parentPopover;
    return h$5(Host$1, Object.assign({ "aria-modal": "true", "no-router": true, tabindex: "-1" }, htmlAttributes, { style: {
      zIndex: `${2e4 + this.overlayIndex}`
    }, class: Object.assign(Object.assign({}, getClassMap(this.cssClass)), { [mode]: true, "popover-translucent": this.translucent, "overlay-hidden": true, "popover-desktop": desktop, [`popover-side-${side}`]: true, "popover-nested": !!parentPopover }), onIonPopoverDidPresent: onLifecycle, onIonPopoverWillPresent: onLifecycle, onIonPopoverWillDismiss: onLifecycle, onIonPopoverDidDismiss: onLifecycle, onIonBackdropTap: this.onBackdropTap }), !parentPopover && h$5("ion-backdrop", { tappable: this.backdropDismiss, visible: this.showBackdrop, part: "backdrop" }), h$5("div", { class: "popover-wrapper ion-overlay-wrapper", onClick: dismissOnSelect ? () => this.dismiss() : void 0 }, enableArrow && h$5("div", { class: "popover-arrow", part: "arrow" }), h$5("div", { class: "popover-content", part: "content" }, h$5("slot", null))));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "trigger": ["onTriggerChange"],
      "triggerAction": ["onTriggerChange"],
      "isOpen": ["onIsOpenChange"]
    };
  }
  static get style() {
    return {
      ios: popoverIosCss,
      md: popoverMdCss
    };
  }
}, [33, "ion-popover", {
  "hasController": [4, "has-controller"],
  "delegate": [16],
  "overlayIndex": [2, "overlay-index"],
  "enterAnimation": [16],
  "leaveAnimation": [16],
  "component": [1],
  "componentProps": [16],
  "keyboardClose": [4, "keyboard-close"],
  "cssClass": [1, "css-class"],
  "backdropDismiss": [4, "backdrop-dismiss"],
  "event": [8],
  "showBackdrop": [4, "show-backdrop"],
  "translucent": [4],
  "animated": [4],
  "htmlAttributes": [16],
  "triggerAction": [1, "trigger-action"],
  "trigger": [1],
  "size": [1],
  "dismissOnSelect": [4, "dismiss-on-select"],
  "reference": [1],
  "side": [1],
  "alignment": [1025],
  "arrow": [4],
  "isOpen": [4, "is-open"],
  "keyboardEvents": [4, "keyboard-events"],
  "keepContentsMounted": [4, "keep-contents-mounted"],
  "presented": [32],
  "presentFromTrigger": [64],
  "present": [64],
  "dismiss": [64],
  "getParentPopover": [64],
  "onDidDismiss": [64],
  "onWillDismiss": [64]
}]);
const LIFECYCLE_MAP$1 = {
  ionPopoverDidPresent: "ionViewDidEnter",
  ionPopoverWillPresent: "ionViewWillEnter",
  ionPopoverWillDismiss: "ionViewWillLeave",
  ionPopoverDidDismiss: "ionViewDidLeave"
};
function defineCustomElement$Q() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-popover", "ion-backdrop"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-popover":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Popover);
        }
        break;
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          defineCustomElement$17();
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const isYearDisabled = (refYear, minParts, maxParts) => {
  if (minParts && minParts.year > refYear) {
    return true;
  }
  if (maxParts && maxParts.year < refYear) {
    return true;
  }
  return false;
};
const isDayDisabled = (refParts, minParts, maxParts, dayValues) => {
  if (refParts.day === null) {
    return true;
  }
  if (dayValues !== void 0 && !dayValues.includes(refParts.day)) {
    return true;
  }
  if (minParts && isBefore$1(refParts, minParts)) {
    return true;
  }
  if (maxParts && isAfter$1(refParts, maxParts)) {
    return true;
  }
  return false;
};
const getCalendarDayState = (locale2, refParts, activeParts, todayParts, minParts, maxParts, dayValues) => {
  const activePartsArray = Array.isArray(activeParts) ? activeParts : [activeParts];
  const isActive = activePartsArray.find((parts) => isSameDay(refParts, parts)) !== void 0;
  const isToday = isSameDay(refParts, todayParts);
  const disabled = isDayDisabled(refParts, minParts, maxParts, dayValues);
  return {
    disabled,
    isActive,
    isToday,
    ariaSelected: isActive ? "true" : null,
    ariaLabel: generateDayAriaLabel(locale2, isToday, refParts),
    text: refParts.day != null ? getDay(locale2, refParts) : null
  };
};
const isMonthDisabled = (refParts, { minParts, maxParts }) => {
  if (isYearDisabled(refParts.year, minParts, maxParts)) {
    return true;
  }
  if (minParts && isBefore$1(refParts, minParts) || maxParts && isAfter$1(refParts, maxParts)) {
    return true;
  }
  return false;
};
const isPrevMonthDisabled = (refParts, minParts, maxParts) => {
  const prevMonth = Object.assign(Object.assign({}, getPreviousMonth(refParts)), { day: null });
  return isMonthDisabled(prevMonth, {
    minParts,
    maxParts
  });
};
const isNextMonthDisabled = (refParts, maxParts) => {
  const nextMonth = Object.assign(Object.assign({}, getNextMonth(refParts)), { day: null });
  return isMonthDisabled(nextMonth, {
    maxParts
  });
};
const getHighlightStyles = (highlightedDates, dateIsoString, el2) => {
  if (Array.isArray(highlightedDates)) {
    const dateStringWithoutTime = dateIsoString.split("T")[0];
    const matchingHighlight = highlightedDates.find((hd2) => hd2.date === dateStringWithoutTime);
    if (matchingHighlight) {
      return {
        textColor: matchingHighlight.textColor,
        backgroundColor: matchingHighlight.backgroundColor
      };
    }
  } else {
    try {
      return highlightedDates(dateIsoString);
    } catch (e3) {
      printIonError("Exception thrown from provided `highlightedDates` callback. Please check your function and try again.", el2, e3);
    }
  }
  return void 0;
};
const datetimeIosCss = ":host{display:-ms-flexbox;display:flex;-ms-flex-flow:column;flex-flow:column;background:var(--background);overflow:hidden}ion-picker-column-internal{min-width:26px}:host(.datetime-size-fixed){width:auto;height:auto}:host(.datetime-size-fixed:not(.datetime-prefer-wheel)){max-width:350px}:host(.datetime-size-fixed.datetime-prefer-wheel){min-width:350px;max-width:-webkit-max-content;max-width:-moz-max-content;max-width:max-content}:host(.datetime-size-cover){width:100%}:host .calendar-body,:host .datetime-year{opacity:0}:host(:not(.datetime-ready)) .datetime-year{position:absolute;pointer-events:none}:host(.datetime-ready) .calendar-body{opacity:1}:host(.datetime-ready) .datetime-year{display:none;opacity:1}:host .wheel-order-year-first .day-column{-ms-flex-order:3;order:3;text-align:end}:host .wheel-order-year-first .month-column{-ms-flex-order:2;order:2;text-align:end}:host .wheel-order-year-first .year-column{-ms-flex-order:1;order:1;text-align:start}:host .datetime-calendar,:host .datetime-year{display:-ms-flexbox;display:flex;-ms-flex:1 1 auto;flex:1 1 auto;-ms-flex-flow:column;flex-flow:column}:host(.show-month-and-year) .datetime-year{display:-ms-flexbox;display:flex}@supports (background: -webkit-named-image(apple-pay-logo-black)) and (not (aspect-ratio: 1/1)){:host(.show-month-and-year) .calendar-next-prev,:host(.show-month-and-year) .calendar-days-of-week,:host(.show-month-and-year) .calendar-body,:host(.show-month-and-year) .datetime-time{position:absolute;visibility:hidden;pointer-events:none}@supports (inset-inline-start: 0){:host(.show-month-and-year) .calendar-next-prev,:host(.show-month-and-year) .calendar-days-of-week,:host(.show-month-and-year) .calendar-body,:host(.show-month-and-year) .datetime-time{inset-inline-start:-99999px}}@supports not (inset-inline-start: 0){:host(.show-month-and-year) .calendar-next-prev,:host(.show-month-and-year) .calendar-days-of-week,:host(.show-month-and-year) .calendar-body,:host(.show-month-and-year) .datetime-time{left:-99999px}:host-context([dir=rtl]):host(.show-month-and-year) .calendar-next-prev,:host-context([dir=rtl]).show-month-and-year .calendar-next-prev,:host-context([dir=rtl]):host(.show-month-and-year) .calendar-days-of-week,:host-context([dir=rtl]).show-month-and-year .calendar-days-of-week,:host-context([dir=rtl]):host(.show-month-and-year) .calendar-body,:host-context([dir=rtl]).show-month-and-year .calendar-body,:host-context([dir=rtl]):host(.show-month-and-year) .datetime-time,:host-context([dir=rtl]).show-month-and-year .datetime-time{left:unset;right:unset;right:-99999px}@supports selector(:dir(rtl)){:host(.show-month-and-year) .calendar-next-prev:dir(rtl),:host(.show-month-and-year) .calendar-days-of-week:dir(rtl),:host(.show-month-and-year) .calendar-body:dir(rtl),:host(.show-month-and-year) .datetime-time:dir(rtl){left:unset;right:unset;right:-99999px}}}}@supports (not (background: -webkit-named-image(apple-pay-logo-black))) or ((background: -webkit-named-image(apple-pay-logo-black)) and (aspect-ratio: 1/1)){:host(.show-month-and-year) .calendar-next-prev,:host(.show-month-and-year) .calendar-days-of-week,:host(.show-month-and-year) .calendar-body,:host(.show-month-and-year) .datetime-time{display:none}}:host(.month-year-picker-open) .datetime-footer{display:none}:host(.datetime-readonly),:host(.datetime-disabled){pointer-events:none}:host(.datetime-disabled){opacity:0.4}:host .datetime-header .datetime-title{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}:host .datetime-action-buttons.has-clear-button{width:100%}:host .datetime-action-buttons ion-buttons{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}:host .calendar-action-buttons{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}:host .calendar-action-buttons ion-item,:host .calendar-action-buttons ion-button{--background:translucent}:host .calendar-action-buttons ion-item ion-label{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}:host .calendar-action-buttons ion-item ion-icon{-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:0;padding-inline-end:0;padding-top:0;padding-bottom:0}:host .calendar-days-of-week{display:grid;grid-template-columns:repeat(7, 1fr);text-align:center}:host .calendar-body{display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;-webkit-scroll-snap-type:x mandatory;-ms-scroll-snap-type:x mandatory;scroll-snap-type:x mandatory;overflow-x:scroll;overflow-y:hidden;scrollbar-width:none;outline:none}:host .calendar-body .calendar-month{scroll-snap-align:start;scroll-snap-stop:always;-ms-flex-negative:0;flex-shrink:0;width:100%}:host .calendar-body .calendar-month-disabled{scroll-snap-align:none}:host .calendar-body::-webkit-scrollbar{display:none}:host .calendar-body .calendar-month-grid{display:grid;grid-template-columns:repeat(7, 1fr)}:host .calendar-day{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:0px;padding-bottom:0px;-webkit-margin-start:0px;margin-inline-start:0px;-webkit-margin-end:0px;margin-inline-end:0px;margin-top:0px;margin-bottom:0px;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;border:none;outline:none;background:none;color:currentColor;font-family:var(--ion-font-family, inherit);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;z-index:0}:host .calendar-day[disabled]{pointer-events:none;opacity:0.4}.calendar-day-highlight{border-radius:32px;-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px;padding-top:4px;padding-bottom:4px;position:absolute;width:32px;height:32px;z-index:-1}:host .datetime-time{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}:host(.datetime-presentation-time) .datetime-time{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}:host ion-popover{--height:200px}:host .time-header{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}:host .time-body{border-radius:8px;-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px;padding-top:6px;padding-bottom:6px;display:-ms-flexbox;display:flex;border:none;background:var(--ion-color-step-300, #edeef0);color:var(--ion-text-color, #000);font-family:inherit;font-size:inherit;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}:host .time-body-active{color:var(--ion-color-base)}:host(.in-item){position:static}:host(.show-month-and-year) .calendar-action-buttons ion-item{--color:var(--ion-color-base)}:host{--background:var(--ion-color-light, #ffffff);--background-rgb:var(--ion-color-light-rgb);--title-color:var(--ion-color-step-600, #666666)}:host(.datetime-presentation-date-time:not(.datetime-prefer-wheel)),:host(.datetime-presentation-time-date:not(.datetime-prefer-wheel)),:host(.datetime-presentation-date:not(.datetime-prefer-wheel)){min-height:350px}:host .datetime-header{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:16px;padding-bottom:16px;border-bottom:0.55px solid var(--ion-color-step-200, #cccccc);font-size:14px}:host .datetime-header .datetime-title{color:var(--title-color)}:host .datetime-header .datetime-selected-date{margin-top:10px}:host .calendar-action-buttons ion-item{--padding-start:16px;--background-hover:transparent;--background-activated:transparent;font-size:16px;font-weight:600}:host .calendar-action-buttons ion-item ion-icon,:host .calendar-action-buttons ion-buttons ion-button{color:var(--ion-color-base)}:host .calendar-action-buttons ion-buttons{padding-left:0;padding-right:0;padding-top:8px;padding-bottom:0}:host .calendar-action-buttons ion-buttons ion-button{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}:host .calendar-days-of-week{-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px;padding-top:0;padding-bottom:0;color:var(--ion-color-step-300, #b3b3b3);font-size:12px;font-weight:600;line-height:24px;text-transform:uppercase}:host .calendar-body .calendar-month .calendar-month-grid{-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px;padding-top:8px;padding-bottom:8px;height:calc(100% - 16px)}:host .calendar-day{font-size:20px}.calendar-day:focus .calendar-day-highlight,.calendar-day.calendar-day-active .calendar-day-highlight{opacity:0.2}.calendar-day.calendar-day-active .calendar-day-highlight{background:var(--ion-color-base)}.calendar-day:focus .calendar-day-highlight{background:var(--ion-color-base) !important}:host .calendar-day.calendar-day-today{color:var(--ion-color-base)}:host .calendar-day.calendar-day-active{color:var(--ion-color-base);font-weight:600}:host .calendar-day.calendar-day-today.calendar-day-active{color:var(--ion-color-contrast)}.calendar-day.calendar-day-today.calendar-day-active .calendar-day-highlight{background:var(--ion-color-base);opacity:1}:host .datetime-time{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:8px;padding-bottom:16px;font-size:16px}:host .datetime-time .time-header{font-weight:600}:host .datetime-buttons{-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px;padding-top:8px;padding-bottom:8px;border-top:0.55px solid var(--ion-color-step-200, #cccccc)}:host .datetime-buttons ::slotted(ion-buttons),:host .datetime-buttons ion-buttons{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between}:host .datetime-action-buttons{width:100%}";
const datetimeMdCss = ":host{display:-ms-flexbox;display:flex;-ms-flex-flow:column;flex-flow:column;background:var(--background);overflow:hidden}ion-picker-column-internal{min-width:26px}:host(.datetime-size-fixed){width:auto;height:auto}:host(.datetime-size-fixed:not(.datetime-prefer-wheel)){max-width:350px}:host(.datetime-size-fixed.datetime-prefer-wheel){min-width:350px;max-width:-webkit-max-content;max-width:-moz-max-content;max-width:max-content}:host(.datetime-size-cover){width:100%}:host .calendar-body,:host .datetime-year{opacity:0}:host(:not(.datetime-ready)) .datetime-year{position:absolute;pointer-events:none}:host(.datetime-ready) .calendar-body{opacity:1}:host(.datetime-ready) .datetime-year{display:none;opacity:1}:host .wheel-order-year-first .day-column{-ms-flex-order:3;order:3;text-align:end}:host .wheel-order-year-first .month-column{-ms-flex-order:2;order:2;text-align:end}:host .wheel-order-year-first .year-column{-ms-flex-order:1;order:1;text-align:start}:host .datetime-calendar,:host .datetime-year{display:-ms-flexbox;display:flex;-ms-flex:1 1 auto;flex:1 1 auto;-ms-flex-flow:column;flex-flow:column}:host(.show-month-and-year) .datetime-year{display:-ms-flexbox;display:flex}@supports (background: -webkit-named-image(apple-pay-logo-black)) and (not (aspect-ratio: 1/1)){:host(.show-month-and-year) .calendar-next-prev,:host(.show-month-and-year) .calendar-days-of-week,:host(.show-month-and-year) .calendar-body,:host(.show-month-and-year) .datetime-time{position:absolute;visibility:hidden;pointer-events:none}@supports (inset-inline-start: 0){:host(.show-month-and-year) .calendar-next-prev,:host(.show-month-and-year) .calendar-days-of-week,:host(.show-month-and-year) .calendar-body,:host(.show-month-and-year) .datetime-time{inset-inline-start:-99999px}}@supports not (inset-inline-start: 0){:host(.show-month-and-year) .calendar-next-prev,:host(.show-month-and-year) .calendar-days-of-week,:host(.show-month-and-year) .calendar-body,:host(.show-month-and-year) .datetime-time{left:-99999px}:host-context([dir=rtl]):host(.show-month-and-year) .calendar-next-prev,:host-context([dir=rtl]).show-month-and-year .calendar-next-prev,:host-context([dir=rtl]):host(.show-month-and-year) .calendar-days-of-week,:host-context([dir=rtl]).show-month-and-year .calendar-days-of-week,:host-context([dir=rtl]):host(.show-month-and-year) .calendar-body,:host-context([dir=rtl]).show-month-and-year .calendar-body,:host-context([dir=rtl]):host(.show-month-and-year) .datetime-time,:host-context([dir=rtl]).show-month-and-year .datetime-time{left:unset;right:unset;right:-99999px}@supports selector(:dir(rtl)){:host(.show-month-and-year) .calendar-next-prev:dir(rtl),:host(.show-month-and-year) .calendar-days-of-week:dir(rtl),:host(.show-month-and-year) .calendar-body:dir(rtl),:host(.show-month-and-year) .datetime-time:dir(rtl){left:unset;right:unset;right:-99999px}}}}@supports (not (background: -webkit-named-image(apple-pay-logo-black))) or ((background: -webkit-named-image(apple-pay-logo-black)) and (aspect-ratio: 1/1)){:host(.show-month-and-year) .calendar-next-prev,:host(.show-month-and-year) .calendar-days-of-week,:host(.show-month-and-year) .calendar-body,:host(.show-month-and-year) .datetime-time{display:none}}:host(.month-year-picker-open) .datetime-footer{display:none}:host(.datetime-readonly),:host(.datetime-disabled){pointer-events:none}:host(.datetime-disabled){opacity:0.4}:host .datetime-header .datetime-title{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}:host .datetime-action-buttons.has-clear-button{width:100%}:host .datetime-action-buttons ion-buttons{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}:host .calendar-action-buttons{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}:host .calendar-action-buttons ion-item,:host .calendar-action-buttons ion-button{--background:translucent}:host .calendar-action-buttons ion-item ion-label{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}:host .calendar-action-buttons ion-item ion-icon{-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:0;padding-inline-end:0;padding-top:0;padding-bottom:0}:host .calendar-days-of-week{display:grid;grid-template-columns:repeat(7, 1fr);text-align:center}:host .calendar-body{display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;-webkit-scroll-snap-type:x mandatory;-ms-scroll-snap-type:x mandatory;scroll-snap-type:x mandatory;overflow-x:scroll;overflow-y:hidden;scrollbar-width:none;outline:none}:host .calendar-body .calendar-month{scroll-snap-align:start;scroll-snap-stop:always;-ms-flex-negative:0;flex-shrink:0;width:100%}:host .calendar-body .calendar-month-disabled{scroll-snap-align:none}:host .calendar-body::-webkit-scrollbar{display:none}:host .calendar-body .calendar-month-grid{display:grid;grid-template-columns:repeat(7, 1fr)}:host .calendar-day{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:0px;padding-bottom:0px;-webkit-margin-start:0px;margin-inline-start:0px;-webkit-margin-end:0px;margin-inline-end:0px;margin-top:0px;margin-bottom:0px;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;border:none;outline:none;background:none;color:currentColor;font-family:var(--ion-font-family, inherit);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;z-index:0}:host .calendar-day[disabled]{pointer-events:none;opacity:0.4}.calendar-day-highlight{border-radius:32px;-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px;padding-top:4px;padding-bottom:4px;position:absolute;width:32px;height:32px;z-index:-1}:host .datetime-time{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}:host(.datetime-presentation-time) .datetime-time{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}:host ion-popover{--height:200px}:host .time-header{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}:host .time-body{border-radius:8px;-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px;padding-top:6px;padding-bottom:6px;display:-ms-flexbox;display:flex;border:none;background:var(--ion-color-step-300, #edeef0);color:var(--ion-text-color, #000);font-family:inherit;font-size:inherit;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}:host .time-body-active{color:var(--ion-color-base)}:host(.in-item){position:static}:host(.show-month-and-year) .calendar-action-buttons ion-item{--color:var(--ion-color-base)}:host{--background:var(--ion-color-step-100, #ffffff);--title-color:var(--ion-color-contrast)}:host .datetime-header{-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:20px;padding-inline-end:20px;padding-top:20px;padding-bottom:20px;background:var(--ion-color-base);color:var(--title-color)}:host .datetime-header .datetime-title{font-size:12px;text-transform:uppercase}:host .datetime-header .datetime-selected-date{margin-top:30px;font-size:34px}:host .datetime-calendar .calendar-action-buttons ion-item{--padding-start:20px}:host .calendar-action-buttons ion-item,:host .calendar-action-buttons ion-button{color:var(--ion-color-step-650, #595959)}:host .calendar-days-of-week{-webkit-padding-start:10px;padding-inline-start:10px;-webkit-padding-end:10px;padding-inline-end:10px;padding-top:0px;padding-bottom:0px;color:var(--ion-color-step-500, gray);font-size:14px;line-height:36px}:host .calendar-body .calendar-month .calendar-month-grid{-webkit-padding-start:10px;padding-inline-start:10px;-webkit-padding-end:10px;padding-inline-end:10px;padding-top:4px;padding-bottom:4px;grid-template-rows:repeat(6, 1fr)}:host .calendar-day{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0;padding-inline-end:0;padding-top:13px;padding-bottom:13px;font-size:14px}.calendar-day:focus .calendar-day-highlight{background:rgba(var(--ion-color-base-rgb), 0.2);-webkit-box-shadow:0px 0px 0px 4px rgba(var(--ion-color-base-rgb), 0.2);box-shadow:0px 0px 0px 4px rgba(var(--ion-color-base-rgb), 0.2)}:host .calendar-day.calendar-day-today{color:var(--ion-color-base)}.calendar-day.calendar-day-today .calendar-day-highlight{border:1px solid var(--ion-color-base)}:host .calendar-day.calendar-day-active{color:var(--ion-color-contrast)}.calendar-day.calendar-day-active .calendar-day-highlight{border:1px solid var(--ion-color-base);background:var(--ion-color-base)}:host .datetime-time{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:8px;padding-bottom:8px}:host .time-header{color:var(--ion-color-step-650, #595959)}:host(.datetime-presentation-month) .datetime-year,:host(.datetime-presentation-year) .datetime-year,:host(.datetime-presentation-month-year) .datetime-year{margin-top:20px;margin-bottom:20px}:host .datetime-buttons{-webkit-padding-start:10px;padding-inline-start:10px;-webkit-padding-end:10px;padding-inline-end:10px;padding-top:10px;padding-bottom:10px;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:end;justify-content:flex-end}:host .datetime-view-buttons ion-button{color:var(--ion-color-step-800, #333333)}";
const Datetime = /* @__PURE__ */ proxyCustomElement$1(class Datetime2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionCancel = createEvent(this, "ionCancel", 7);
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionValueChange = createEvent(this, "ionValueChange", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.ionRender = createEvent(this, "ionRender", 7);
    this.inputId = `ion-dt-${datetimeIds++}`;
    this.prevPresentation = null;
    this.activePartsClone = [];
    this.warnIfIncorrectValueUsage = () => {
      const { multiple, value } = this;
      if (!multiple && Array.isArray(value)) {
        printIonWarning(`ion-datetime was passed an array of values, but multiple="false". This is incorrect usage and may result in unexpected behaviors. To dismiss this warning, pass a string to the "value" property when multiple="false".

  Value Passed: [${value.map((v2) => `'${v2}'`).join(", ")}]
`, this.el);
      }
    };
    this.setValue = (value) => {
      this.value = value;
      this.ionChange.emit({ value });
    };
    this.getActivePartsWithFallback = () => {
      var _a2;
      const { defaultParts } = this;
      return (_a2 = this.getActivePart()) !== null && _a2 !== void 0 ? _a2 : defaultParts;
    };
    this.getActivePart = () => {
      const { activePartsClone } = this;
      return Array.isArray(activePartsClone) ? activePartsClone[0] : activePartsClone;
    };
    this.closeParentOverlay = () => {
      const popoverOrModal = this.el.closest("ion-modal, ion-popover");
      if (popoverOrModal) {
        popoverOrModal.dismiss();
      }
    };
    this.setWorkingParts = (parts) => {
      this.workingParts = Object.assign({}, parts);
    };
    this.setActiveParts = (parts, removeDate = false) => {
      const { multiple, minParts, maxParts, activePartsClone } = this;
      const validatedParts = validateParts(parts, minParts, maxParts);
      this.setWorkingParts(validatedParts);
      if (multiple) {
        const activePartsArray = Array.isArray(activePartsClone) ? activePartsClone : [activePartsClone];
        if (removeDate) {
          this.activeParts = activePartsArray.filter((p2) => !isSameDay(p2, validatedParts));
        } else {
          this.activeParts = [...activePartsArray, validatedParts];
        }
      } else {
        this.activeParts = Object.assign({}, validatedParts);
      }
      const hasSlottedButtons = this.el.querySelector('[slot="buttons"]') !== null;
      if (hasSlottedButtons || this.showDefaultButtons) {
        return;
      }
      this.confirm();
    };
    this.initializeKeyboardListeners = () => {
      const calendarBodyRef = this.calendarBodyRef;
      if (!calendarBodyRef) {
        return;
      }
      const root2 = this.el.shadowRoot;
      const currentMonth = calendarBodyRef.querySelector(".calendar-month:nth-of-type(2)");
      const checkCalendarBodyFocus = (ev) => {
        var _a2;
        const record = ev[0];
        if (((_a2 = record.oldValue) === null || _a2 === void 0 ? void 0 : _a2.includes("ion-focused")) || !calendarBodyRef.classList.contains("ion-focused")) {
          return;
        }
        this.focusWorkingDay(currentMonth);
      };
      const mo = new MutationObserver(checkCalendarBodyFocus);
      mo.observe(calendarBodyRef, { attributeFilter: ["class"], attributeOldValue: true });
      this.destroyKeyboardMO = () => {
        mo === null || mo === void 0 ? void 0 : mo.disconnect();
      };
      calendarBodyRef.addEventListener("keydown", (ev) => {
        const activeElement = root2.activeElement;
        if (!activeElement || !activeElement.classList.contains("calendar-day")) {
          return;
        }
        const parts = getPartsFromCalendarDay(activeElement);
        let partsToFocus;
        switch (ev.key) {
          case "ArrowDown":
            ev.preventDefault();
            partsToFocus = getNextWeek(parts);
            break;
          case "ArrowUp":
            ev.preventDefault();
            partsToFocus = getPreviousWeek(parts);
            break;
          case "ArrowRight":
            ev.preventDefault();
            partsToFocus = getNextDay(parts);
            break;
          case "ArrowLeft":
            ev.preventDefault();
            partsToFocus = getPreviousDay(parts);
            break;
          case "Home":
            ev.preventDefault();
            partsToFocus = getStartOfWeek(parts);
            break;
          case "End":
            ev.preventDefault();
            partsToFocus = getEndOfWeek(parts);
            break;
          case "PageUp":
            ev.preventDefault();
            partsToFocus = ev.shiftKey ? getPreviousYear(parts) : getPreviousMonth(parts);
            break;
          case "PageDown":
            ev.preventDefault();
            partsToFocus = ev.shiftKey ? getNextYear(parts) : getNextMonth(parts);
            break;
          default:
            return;
        }
        if (isDayDisabled(partsToFocus, this.minParts, this.maxParts)) {
          return;
        }
        this.setWorkingParts(Object.assign(Object.assign({}, this.workingParts), partsToFocus));
        requestAnimationFrame(() => this.focusWorkingDay(currentMonth));
      });
    };
    this.focusWorkingDay = (currentMonth) => {
      const padding = currentMonth.querySelectorAll(".calendar-day-padding");
      const { day } = this.workingParts;
      if (day === null) {
        return;
      }
      const dayEl = currentMonth.querySelector(`.calendar-day:nth-of-type(${padding.length + day})`);
      if (dayEl) {
        dayEl.focus();
      }
    };
    this.processMinParts = () => {
      const { min: min3, defaultParts } = this;
      if (min3 === void 0) {
        this.minParts = void 0;
        return;
      }
      this.minParts = parseMinParts(min3, defaultParts);
    };
    this.processMaxParts = () => {
      const { max: max3, defaultParts } = this;
      if (max3 === void 0) {
        this.maxParts = void 0;
        return;
      }
      this.maxParts = parseMaxParts(max3, defaultParts);
    };
    this.initializeCalendarListener = () => {
      const calendarBodyRef = this.calendarBodyRef;
      if (!calendarBodyRef) {
        return;
      }
      const months2 = calendarBodyRef.querySelectorAll(".calendar-month");
      const startMonth = months2[0];
      const workingMonth = months2[1];
      const endMonth = months2[2];
      const mode = getIonMode$2(this);
      const needsiOSRubberBandFix = mode === "ios" && typeof navigator !== "undefined" && navigator.maxTouchPoints > 1;
      writeTask$1(() => {
        calendarBodyRef.scrollLeft = startMonth.clientWidth * (isRTL$1(this.el) ? -1 : 1);
        const getChangedMonth = (parts) => {
          const box = calendarBodyRef.getBoundingClientRect();
          const root2 = this.el.shadowRoot;
          const elementAtCenter = root2.elementFromPoint(box.x + box.width / 2, box.y + box.height / 2);
          if (!elementAtCenter)
            return;
          const month = elementAtCenter.closest(".calendar-month");
          if (!month)
            return;
          const monthBox = month.getBoundingClientRect();
          if (Math.abs(monthBox.x - box.x) > 2)
            return;
          if (month === startMonth) {
            return getPreviousMonth(parts);
          } else if (month === endMonth) {
            return getNextMonth(parts);
          } else {
            return;
          }
        };
        const updateActiveMonth = () => {
          if (needsiOSRubberBandFix) {
            calendarBodyRef.style.removeProperty("pointer-events");
            appliediOSRubberBandFix = false;
          }
          const newDate2 = getChangedMonth(this.workingParts);
          if (!newDate2)
            return;
          const { month, day, year } = newDate2;
          if (isMonthDisabled({ month, year, day: null }, {
            minParts: Object.assign(Object.assign({}, this.minParts), { day: null }),
            maxParts: Object.assign(Object.assign({}, this.maxParts), { day: null })
          })) {
            return;
          }
          calendarBodyRef.style.setProperty("overflow", "hidden");
          writeTask$1(() => {
            this.setWorkingParts(Object.assign(Object.assign({}, this.workingParts), { month, day, year }));
            calendarBodyRef.scrollLeft = workingMonth.clientWidth * (isRTL$1(this.el) ? -1 : 1);
            calendarBodyRef.style.removeProperty("overflow");
          });
        };
        let scrollTimeout;
        let appliediOSRubberBandFix = false;
        const scrollCallback = () => {
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
          }
          if (!appliediOSRubberBandFix && needsiOSRubberBandFix) {
            calendarBodyRef.style.setProperty("pointer-events", "none");
            appliediOSRubberBandFix = true;
          }
          scrollTimeout = setTimeout(updateActiveMonth, 50);
        };
        calendarBodyRef.addEventListener("scroll", scrollCallback);
        this.destroyCalendarListener = () => {
          calendarBodyRef.removeEventListener("scroll", scrollCallback);
        };
      });
    };
    this.destroyInteractionListeners = () => {
      const { destroyCalendarListener, destroyKeyboardMO } = this;
      if (destroyCalendarListener !== void 0) {
        destroyCalendarListener();
      }
      if (destroyKeyboardMO !== void 0) {
        destroyKeyboardMO();
      }
    };
    this.processValue = (value) => {
      const hasValue = value !== null && value !== void 0;
      const valueToProcess = hasValue ? parseDate(value) : this.defaultParts;
      const { minParts, maxParts } = this;
      this.warnIfIncorrectValueUsage();
      if (hasValue) {
        warnIfValueOutOfBounds(valueToProcess, minParts, maxParts);
      }
      const singleValue = Array.isArray(valueToProcess) ? valueToProcess[0] : valueToProcess;
      const { month, day, year, hour, minute } = clampDate(singleValue, minParts, maxParts);
      const ampm = parseAmPm(hour);
      this.setWorkingParts({
        month,
        day,
        year,
        hour,
        minute,
        ampm
      });
      if (hasValue) {
        if (Array.isArray(valueToProcess)) {
          this.activeParts = [...valueToProcess];
        } else {
          this.activeParts = {
            month,
            day,
            year,
            hour,
            minute,
            ampm
          };
        }
      } else {
        this.activeParts = [];
      }
    };
    this.onFocus = () => {
      this.ionFocus.emit();
    };
    this.onBlur = () => {
      this.ionBlur.emit();
    };
    this.hasValue = () => {
      return this.value != null;
    };
    this.nextMonth = () => {
      const calendarBodyRef = this.calendarBodyRef;
      if (!calendarBodyRef) {
        return;
      }
      const nextMonth = calendarBodyRef.querySelector(".calendar-month:last-of-type");
      if (!nextMonth) {
        return;
      }
      const left = nextMonth.offsetWidth * 2;
      calendarBodyRef.scrollTo({
        top: 0,
        left: left * (isRTL$1(this.el) ? -1 : 1),
        behavior: "smooth"
      });
    };
    this.prevMonth = () => {
      const calendarBodyRef = this.calendarBodyRef;
      if (!calendarBodyRef) {
        return;
      }
      const prevMonth = calendarBodyRef.querySelector(".calendar-month:first-of-type");
      if (!prevMonth) {
        return;
      }
      calendarBodyRef.scrollTo({
        top: 0,
        left: 0,
        behavior: "smooth"
      });
    };
    this.toggleMonthAndYearView = () => {
      this.showMonthAndYear = !this.showMonthAndYear;
    };
    this.showMonthAndYear = false;
    this.activeParts = [];
    this.workingParts = {
      month: 5,
      day: 28,
      year: 2021,
      hour: 13,
      minute: 52,
      ampm: "pm"
    };
    this.isPresented = false;
    this.isTimePopoverOpen = false;
    this.color = "primary";
    this.name = this.inputId;
    this.disabled = false;
    this.readonly = false;
    this.isDateEnabled = void 0;
    this.min = void 0;
    this.max = void 0;
    this.presentation = "date-time";
    this.cancelText = "Cancel";
    this.doneText = "Done";
    this.clearText = "Clear";
    this.yearValues = void 0;
    this.monthValues = void 0;
    this.dayValues = void 0;
    this.hourValues = void 0;
    this.minuteValues = void 0;
    this.locale = "default";
    this.firstDayOfWeek = 0;
    this.titleSelectedDatesFormatter = void 0;
    this.multiple = false;
    this.highlightedDates = void 0;
    this.value = void 0;
    this.showDefaultTitle = false;
    this.showDefaultButtons = false;
    this.showClearButton = false;
    this.showDefaultTimeLabel = true;
    this.hourCycle = void 0;
    this.size = "fixed";
    this.preferWheel = false;
  }
  disabledChanged() {
    this.emitStyle();
  }
  minChanged() {
    this.processMinParts();
  }
  maxChanged() {
    this.processMaxParts();
  }
  yearValuesChanged() {
    this.parsedYearValues = convertToArrayOfNumbers(this.yearValues);
  }
  monthValuesChanged() {
    this.parsedMonthValues = convertToArrayOfNumbers(this.monthValues);
  }
  dayValuesChanged() {
    this.parsedDayValues = convertToArrayOfNumbers(this.dayValues);
  }
  hourValuesChanged() {
    this.parsedHourValues = convertToArrayOfNumbers(this.hourValues);
  }
  minuteValuesChanged() {
    this.parsedMinuteValues = convertToArrayOfNumbers(this.minuteValues);
  }
  activePartsChanged() {
    this.activePartsClone = this.activeParts;
  }
  /**
   * Update the datetime value when the value changes
   */
  valueChanged() {
    const { value, minParts, maxParts, workingParts } = this;
    if (this.hasValue()) {
      this.warnIfIncorrectValueUsage();
      const valueDateParts = parseDate(value);
      if (valueDateParts) {
        warnIfValueOutOfBounds(valueDateParts, minParts, maxParts);
        if (Array.isArray(valueDateParts)) {
          this.activePartsClone = [...valueDateParts];
        } else {
          const { month, day, year, hour, minute } = valueDateParts;
          const ampm = hour != null ? hour >= 12 ? "pm" : "am" : void 0;
          this.activePartsClone = Object.assign(Object.assign({}, this.activeParts), {
            month,
            day,
            year,
            hour,
            minute,
            ampm
          });
          this.setWorkingParts(Object.assign(Object.assign({}, workingParts), { ampm }));
        }
      } else {
        printIonWarning(`Unable to parse date string: ${value}. Please provide a valid ISO 8601 datetime string.`);
      }
    }
    this.emitStyle();
    this.ionValueChange.emit({ value });
  }
  /**
   * Confirms the selected datetime value, updates the
   * `value` property, and optionally closes the popover
   * or modal that the datetime was presented in.
   */
  async confirm(closeOverlay = false) {
    const { isCalendarPicker, activeParts } = this;
    if (activeParts !== void 0 || !isCalendarPicker) {
      const activePartsIsArray = Array.isArray(activeParts);
      if (activePartsIsArray && activeParts.length === 0) {
        this.setValue(void 0);
      } else {
        this.setValue(convertDataToISO(activeParts));
      }
    }
    if (closeOverlay) {
      this.closeParentOverlay();
    }
  }
  /**
   * Resets the internal state of the datetime but does not update the value.
   * Passing a valid ISO-8601 string will reset the state of the component to the provided date.
   * If no value is provided, the internal state will be reset to the clamped value of the min, max and today.
   */
  async reset(startDate) {
    this.processValue(startDate);
  }
  /**
   * Emits the ionCancel event and
   * optionally closes the popover
   * or modal that the datetime was
   * presented in.
   */
  async cancel(closeOverlay = false) {
    this.ionCancel.emit();
    if (closeOverlay) {
      this.closeParentOverlay();
    }
  }
  get isCalendarPicker() {
    const { presentation } = this;
    return presentation === "date" || presentation === "date-time" || presentation === "time-date";
  }
  connectedCallback() {
    this.clearFocusVisible = startFocusVisible(this.el).destroy;
  }
  disconnectedCallback() {
    if (this.clearFocusVisible) {
      this.clearFocusVisible();
      this.clearFocusVisible = void 0;
    }
  }
  initializeListeners() {
    this.initializeCalendarListener();
    this.initializeKeyboardListeners();
  }
  componentDidLoad() {
    const visibleCallback = (entries) => {
      const ev = entries[0];
      if (!ev.isIntersecting) {
        return;
      }
      this.initializeListeners();
      writeTask$1(() => {
        this.el.classList.add("datetime-ready");
      });
    };
    const visibleIO = new IntersectionObserver(visibleCallback, { threshold: 0.01 });
    raf(() => visibleIO === null || visibleIO === void 0 ? void 0 : visibleIO.observe(this.el));
    const hiddenCallback = (entries) => {
      const ev = entries[0];
      if (ev.isIntersecting) {
        return;
      }
      this.destroyInteractionListeners();
      this.showMonthAndYear = false;
      writeTask$1(() => {
        this.el.classList.remove("datetime-ready");
      });
    };
    const hiddenIO = new IntersectionObserver(hiddenCallback, { threshold: 0 });
    raf(() => hiddenIO === null || hiddenIO === void 0 ? void 0 : hiddenIO.observe(this.el));
    const root2 = getElementRoot(this.el);
    root2.addEventListener("ionFocus", (ev) => ev.stopPropagation());
    root2.addEventListener("ionBlur", (ev) => ev.stopPropagation());
  }
  /**
   * When the presentation is changed, all calendar content is recreated,
   * so we need to re-init behavior with the new elements.
   */
  componentDidRender() {
    const { presentation, prevPresentation, calendarBodyRef, minParts, preferWheel } = this;
    const hasCalendarGrid = !preferWheel && ["date-time", "time-date", "date"].includes(presentation);
    if (minParts !== void 0 && hasCalendarGrid && calendarBodyRef) {
      const workingMonth = calendarBodyRef.querySelector(".calendar-month:nth-of-type(1)");
      if (workingMonth) {
        calendarBodyRef.scrollLeft = workingMonth.clientWidth * (isRTL$1(this.el) ? -1 : 1);
      }
    }
    if (prevPresentation === null) {
      this.prevPresentation = presentation;
      return;
    }
    if (presentation === prevPresentation) {
      return;
    }
    this.prevPresentation = presentation;
    this.destroyInteractionListeners();
    this.initializeListeners();
    this.showMonthAndYear = false;
    raf(() => {
      this.ionRender.emit();
    });
  }
  componentWillLoad() {
    const { el: el2, highlightedDates, multiple, presentation, preferWheel } = this;
    if (multiple) {
      if (presentation !== "date") {
        printIonWarning('Multiple date selection is only supported for presentation="date".', el2);
      }
      if (preferWheel) {
        printIonWarning('Multiple date selection is not supported with preferWheel="true".', el2);
      }
    }
    if (highlightedDates !== void 0) {
      if (presentation !== "date" && presentation !== "date-time" && presentation !== "time-date") {
        printIonWarning("The highlightedDates property is only supported with the date, date-time, and time-date presentations.", el2);
      }
      if (preferWheel) {
        printIonWarning('The highlightedDates property is not supported with preferWheel="true".', el2);
      }
    }
    this.processMinParts();
    this.processMaxParts();
    const hourValues = this.parsedHourValues = convertToArrayOfNumbers(this.hourValues);
    const minuteValues = this.parsedMinuteValues = convertToArrayOfNumbers(this.minuteValues);
    const monthValues = this.parsedMonthValues = convertToArrayOfNumbers(this.monthValues);
    const yearValues = this.parsedYearValues = convertToArrayOfNumbers(this.yearValues);
    const dayValues = this.parsedDayValues = convertToArrayOfNumbers(this.dayValues);
    const todayParts = this.todayParts = parseDate(getToday());
    this.defaultParts = getClosestValidDate(todayParts, monthValues, dayValues, yearValues, hourValues, minuteValues);
    this.processValue(this.value);
    this.emitStyle();
  }
  emitStyle() {
    this.ionStyle.emit({
      interactive: true,
      datetime: true,
      "interactive-disabled": this.disabled
    });
  }
  /**
   * Universal render methods
   * These are pieces of datetime that
   * are rendered independently of presentation.
   */
  renderFooter() {
    const { showDefaultButtons, showClearButton } = this;
    const hasSlottedButtons = this.el.querySelector('[slot="buttons"]') !== null;
    if (!hasSlottedButtons && !showDefaultButtons && !showClearButton) {
      return;
    }
    const clearButtonClick = () => {
      this.reset();
      this.setValue(void 0);
    };
    return h$5("div", { class: "datetime-footer" }, h$5("div", { class: "datetime-buttons" }, h$5("div", { class: {
      ["datetime-action-buttons"]: true,
      ["has-clear-button"]: this.showClearButton
    } }, h$5("slot", { name: "buttons" }, h$5("ion-buttons", null, showDefaultButtons && h$5("ion-button", { id: "cancel-button", color: this.color, onClick: () => this.cancel(true) }, this.cancelText), h$5("div", null, showClearButton && h$5("ion-button", { id: "clear-button", color: this.color, onClick: () => clearButtonClick() }, this.clearText), showDefaultButtons && h$5("ion-button", { id: "confirm-button", color: this.color, onClick: () => this.confirm(true) }, this.doneText)))))));
  }
  /**
   * Wheel picker render methods
   */
  renderWheelPicker(forcePresentation = this.presentation) {
    const renderArray = forcePresentation === "time-date" ? [this.renderTimePickerColumns(forcePresentation), this.renderDatePickerColumns(forcePresentation)] : [this.renderDatePickerColumns(forcePresentation), this.renderTimePickerColumns(forcePresentation)];
    return h$5("ion-picker-internal", null, renderArray);
  }
  renderDatePickerColumns(forcePresentation) {
    return forcePresentation === "date-time" || forcePresentation === "time-date" ? this.renderCombinedDatePickerColumn() : this.renderIndividualDatePickerColumns(forcePresentation);
  }
  renderCombinedDatePickerColumn() {
    const { defaultParts, workingParts, locale: locale2, minParts, maxParts, todayParts, isDateEnabled } = this;
    const activePart = this.getActivePartsWithFallback();
    const monthsToRender = generateMonths(workingParts);
    const lastMonth = monthsToRender[monthsToRender.length - 1];
    monthsToRender[0].day = 1;
    lastMonth.day = getNumDaysInMonth(lastMonth.month, lastMonth.year);
    const min3 = minParts !== void 0 && isAfter$1(minParts, monthsToRender[0]) ? minParts : monthsToRender[0];
    const max3 = maxParts !== void 0 && isBefore$1(maxParts, lastMonth) ? maxParts : lastMonth;
    const result = getCombinedDateColumnData(locale2, todayParts, min3, max3, this.parsedDayValues, this.parsedMonthValues);
    let items = result.items;
    const parts = result.parts;
    if (isDateEnabled) {
      items = items.map((itemObject, index3) => {
        const referenceParts = parts[index3];
        let disabled;
        try {
          disabled = !isDateEnabled(convertDataToISO(referenceParts));
        } catch (e3) {
          printIonError("Exception thrown from provided `isDateEnabled` function. Please check your function and try again.", e3);
        }
        return Object.assign(Object.assign({}, itemObject), { disabled });
      });
    }
    const todayString = workingParts.day !== null ? `${workingParts.year}-${workingParts.month}-${workingParts.day}` : `${defaultParts.year}-${defaultParts.month}-${defaultParts.day}`;
    return h$5("ion-picker-column-internal", { class: "date-column", color: this.color, items, value: todayString, onIonChange: (ev) => {
      if (this.destroyCalendarListener) {
        this.destroyCalendarListener();
      }
      const { value } = ev.detail;
      const findPart = parts.find(({ month, day, year }) => value === `${year}-${month}-${day}`);
      this.setWorkingParts(Object.assign(Object.assign({}, workingParts), findPart));
      this.setActiveParts(Object.assign(Object.assign({}, activePart), findPart));
      this.initializeCalendarListener();
      ev.stopPropagation();
    } });
  }
  renderIndividualDatePickerColumns(forcePresentation) {
    const { workingParts, isDateEnabled } = this;
    const shouldRenderMonths = forcePresentation !== "year" && forcePresentation !== "time";
    const months2 = shouldRenderMonths ? getMonthColumnData(this.locale, workingParts, this.minParts, this.maxParts, this.parsedMonthValues) : [];
    const shouldRenderDays = forcePresentation === "date";
    let days2 = shouldRenderDays ? getDayColumnData(this.locale, workingParts, this.minParts, this.maxParts, this.parsedDayValues) : [];
    if (isDateEnabled) {
      days2 = days2.map((dayObject) => {
        const { value } = dayObject;
        const valueNum = typeof value === "string" ? parseInt(value) : value;
        const referenceParts = {
          month: workingParts.month,
          day: valueNum,
          year: workingParts.year
        };
        let disabled;
        try {
          disabled = !isDateEnabled(convertDataToISO(referenceParts));
        } catch (e3) {
          printIonError("Exception thrown from provided `isDateEnabled` function. Please check your function and try again.", e3);
        }
        return Object.assign(Object.assign({}, dayObject), { disabled });
      });
    }
    const shouldRenderYears = forcePresentation !== "month" && forcePresentation !== "time";
    const years2 = shouldRenderYears ? getYearColumnData(this.locale, this.defaultParts, this.minParts, this.maxParts, this.parsedYearValues) : [];
    const showMonthFirst = isMonthFirstLocale(this.locale, { month: "numeric", day: "numeric" });
    let renderArray = [];
    if (showMonthFirst) {
      renderArray = [
        this.renderMonthPickerColumn(months2),
        this.renderDayPickerColumn(days2),
        this.renderYearPickerColumn(years2)
      ];
    } else {
      renderArray = [
        this.renderDayPickerColumn(days2),
        this.renderMonthPickerColumn(months2),
        this.renderYearPickerColumn(years2)
      ];
    }
    return renderArray;
  }
  renderDayPickerColumn(days2) {
    var _a2;
    if (days2.length === 0) {
      return [];
    }
    const { workingParts } = this;
    const activePart = this.getActivePartsWithFallback();
    return h$5("ion-picker-column-internal", { class: "day-column", color: this.color, items: days2, value: (_a2 = workingParts.day !== null ? workingParts.day : this.defaultParts.day) !== null && _a2 !== void 0 ? _a2 : void 0, onIonChange: (ev) => {
      if (this.destroyCalendarListener) {
        this.destroyCalendarListener();
      }
      this.setWorkingParts(Object.assign(Object.assign({}, workingParts), { day: ev.detail.value }));
      this.setActiveParts(Object.assign(Object.assign({}, activePart), { day: ev.detail.value }));
      this.initializeCalendarListener();
      ev.stopPropagation();
    } });
  }
  renderMonthPickerColumn(months2) {
    if (months2.length === 0) {
      return [];
    }
    const { workingParts } = this;
    const activePart = this.getActivePartsWithFallback();
    return h$5("ion-picker-column-internal", { class: "month-column", color: this.color, items: months2, value: workingParts.month, onIonChange: (ev) => {
      if (this.destroyCalendarListener) {
        this.destroyCalendarListener();
      }
      this.setWorkingParts(Object.assign(Object.assign({}, workingParts), { month: ev.detail.value }));
      this.setActiveParts(Object.assign(Object.assign({}, activePart), { month: ev.detail.value }));
      this.initializeCalendarListener();
      ev.stopPropagation();
    } });
  }
  renderYearPickerColumn(years2) {
    if (years2.length === 0) {
      return [];
    }
    const { workingParts } = this;
    const activePart = this.getActivePartsWithFallback();
    return h$5("ion-picker-column-internal", { class: "year-column", color: this.color, items: years2, value: workingParts.year, onIonChange: (ev) => {
      if (this.destroyCalendarListener) {
        this.destroyCalendarListener();
      }
      this.setWorkingParts(Object.assign(Object.assign({}, workingParts), { year: ev.detail.value }));
      this.setActiveParts(Object.assign(Object.assign({}, activePart), { year: ev.detail.value }));
      this.initializeCalendarListener();
      ev.stopPropagation();
    } });
  }
  renderTimePickerColumns(forcePresentation) {
    if (["date", "month", "month-year", "year"].includes(forcePresentation)) {
      return [];
    }
    const activePart = this.getActivePart();
    const userHasSelectedDate = activePart !== void 0;
    const { hoursData, minutesData, dayPeriodData } = getTimeColumnsData(this.locale, this.workingParts, this.hourCycle, userHasSelectedDate ? this.minParts : void 0, userHasSelectedDate ? this.maxParts : void 0, this.parsedHourValues, this.parsedMinuteValues);
    return [
      this.renderHourPickerColumn(hoursData),
      this.renderMinutePickerColumn(minutesData),
      this.renderDayPeriodPickerColumn(dayPeriodData)
    ];
  }
  renderHourPickerColumn(hoursData) {
    const { workingParts } = this;
    if (hoursData.length === 0)
      return [];
    const activePart = this.getActivePartsWithFallback();
    return h$5("ion-picker-column-internal", { color: this.color, value: activePart.hour, items: hoursData, numericInput: true, onIonChange: (ev) => {
      this.setWorkingParts(Object.assign(Object.assign({}, workingParts), { hour: ev.detail.value }));
      this.setActiveParts(Object.assign(Object.assign({}, activePart), { hour: ev.detail.value }));
      ev.stopPropagation();
    } });
  }
  renderMinutePickerColumn(minutesData) {
    const { workingParts } = this;
    if (minutesData.length === 0)
      return [];
    const activePart = this.getActivePartsWithFallback();
    return h$5("ion-picker-column-internal", { color: this.color, value: activePart.minute, items: minutesData, numericInput: true, onIonChange: (ev) => {
      this.setWorkingParts(Object.assign(Object.assign({}, workingParts), { minute: ev.detail.value }));
      this.setActiveParts(Object.assign(Object.assign({}, activePart), { minute: ev.detail.value }));
      ev.stopPropagation();
    } });
  }
  renderDayPeriodPickerColumn(dayPeriodData) {
    const { workingParts } = this;
    if (dayPeriodData.length === 0) {
      return [];
    }
    const activePart = this.getActivePartsWithFallback();
    const isDayPeriodRTL = isLocaleDayPeriodRTL(this.locale);
    return h$5("ion-picker-column-internal", { style: isDayPeriodRTL ? { order: "-1" } : {}, color: this.color, value: activePart.ampm, items: dayPeriodData, onIonChange: (ev) => {
      const hour = calculateHourFromAMPM(workingParts, ev.detail.value);
      this.setWorkingParts(Object.assign(Object.assign({}, workingParts), { ampm: ev.detail.value, hour }));
      this.setActiveParts(Object.assign(Object.assign({}, activePart), { ampm: ev.detail.value, hour }));
      ev.stopPropagation();
    } });
  }
  renderWheelView(forcePresentation) {
    const { locale: locale2 } = this;
    const showMonthFirst = isMonthFirstLocale(locale2);
    const columnOrder = showMonthFirst ? "month-first" : "year-first";
    return h$5("div", { class: {
      [`wheel-order-${columnOrder}`]: true
    } }, this.renderWheelPicker(forcePresentation));
  }
  /**
   * Grid Render Methods
   */
  renderCalendarHeader(mode) {
    const expandedIcon = mode === "ios" ? chevronDown : caretUpSharp;
    const collapsedIcon = mode === "ios" ? chevronForward : caretDownSharp;
    const prevMonthDisabled = isPrevMonthDisabled(this.workingParts, this.minParts, this.maxParts);
    const nextMonthDisabled = isNextMonthDisabled(this.workingParts, this.maxParts);
    const hostDir = this.el.getAttribute("dir") || void 0;
    return h$5("div", { class: "calendar-header" }, h$5("div", { class: "calendar-action-buttons" }, h$5("div", { class: "calendar-month-year" }, h$5("ion-item", { ref: (el2) => this.monthYearToggleItemRef = el2, button: true, "aria-label": "Show year picker", detail: false, lines: "none", onClick: () => {
      var _a2;
      this.toggleMonthAndYearView();
      const { monthYearToggleItemRef } = this;
      if (monthYearToggleItemRef) {
        const btn = (_a2 = monthYearToggleItemRef.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".item-native");
        if (btn) {
          const monthYearAriaLabel = this.showMonthAndYear ? "Hide year picker" : "Show year picker";
          btn.setAttribute("aria-label", monthYearAriaLabel);
        }
      }
    } }, h$5("ion-label", null, getMonthAndYear(this.locale, this.workingParts), h$5("ion-icon", { "aria-hidden": "true", icon: this.showMonthAndYear ? expandedIcon : collapsedIcon, lazy: false, flipRtl: true })))), h$5("div", { class: "calendar-next-prev" }, h$5("ion-buttons", null, h$5("ion-button", { "aria-label": "Previous month", disabled: prevMonthDisabled, onClick: () => this.prevMonth() }, h$5("ion-icon", { dir: hostDir, "aria-hidden": "true", slot: "icon-only", icon: chevronBack, lazy: false, flipRtl: true })), h$5("ion-button", { "aria-label": "Next month", disabled: nextMonthDisabled, onClick: () => this.nextMonth() }, h$5("ion-icon", { dir: hostDir, "aria-hidden": "true", slot: "icon-only", icon: chevronForward, lazy: false, flipRtl: true }))))), h$5("div", { class: "calendar-days-of-week", "aria-hidden": "true" }, getDaysOfWeek(this.locale, mode, this.firstDayOfWeek % 7).map((d2) => {
      return h$5("div", { class: "day-of-week" }, d2);
    })));
  }
  renderMonth(month, year) {
    const yearAllowed = this.parsedYearValues === void 0 || this.parsedYearValues.includes(year);
    const monthAllowed = this.parsedMonthValues === void 0 || this.parsedMonthValues.includes(month);
    const isCalMonthDisabled = !yearAllowed || !monthAllowed;
    const swipeDisabled = isMonthDisabled({
      month,
      year,
      day: null
    }, {
      // The day is not used when checking if a month is disabled.
      // Users should be able to access the min or max month, even if the
      // min/max date is out of bounds (e.g. min is set to Feb 15, Feb should not be disabled).
      minParts: Object.assign(Object.assign({}, this.minParts), { day: null }),
      maxParts: Object.assign(Object.assign({}, this.maxParts), { day: null })
    });
    const isWorkingMonth = this.workingParts.month === month && this.workingParts.year === year;
    const activePart = this.getActivePartsWithFallback();
    return h$5("div", { "aria-hidden": !isWorkingMonth ? "true" : null, class: {
      "calendar-month": true,
      // Prevents scroll snap swipe gestures for months outside of the min/max bounds
      "calendar-month-disabled": !isWorkingMonth && swipeDisabled
    } }, h$5("div", { class: "calendar-month-grid" }, getDaysOfMonth(month, year, this.firstDayOfWeek % 7).map((dateObject, index3) => {
      const { day, dayOfWeek: dayOfWeek2 } = dateObject;
      const { el: el2, highlightedDates, isDateEnabled, multiple } = this;
      const referenceParts = { month, day, year };
      const isCalendarPadding = day === null;
      const { isActive, isToday, ariaLabel, ariaSelected, disabled, text } = getCalendarDayState(this.locale, referenceParts, this.activePartsClone, this.todayParts, this.minParts, this.maxParts, this.parsedDayValues);
      const dateIsoString = convertDataToISO(referenceParts);
      let isCalDayDisabled = isCalMonthDisabled || disabled;
      if (!isCalDayDisabled && isDateEnabled !== void 0) {
        try {
          isCalDayDisabled = !isDateEnabled(dateIsoString);
        } catch (e3) {
          printIonError("Exception thrown from provided `isDateEnabled` function. Please check your function and try again.", el2, e3);
        }
      }
      let dateStyle = void 0;
      if (highlightedDates !== void 0 && !isActive && day !== null) {
        dateStyle = getHighlightStyles(highlightedDates, dateIsoString, el2);
      }
      return h$5("button", { tabindex: "-1", "data-day": day, "data-month": month, "data-year": year, "data-index": index3, "data-day-of-week": dayOfWeek2, disabled: isCalDayDisabled, class: {
        "calendar-day-padding": isCalendarPadding,
        "calendar-day": true,
        "calendar-day-active": isActive,
        "calendar-day-today": isToday
      }, style: dateStyle && {
        color: dateStyle.textColor
      }, "aria-hidden": isCalendarPadding ? "true" : null, "aria-selected": ariaSelected, "aria-label": ariaLabel, onClick: () => {
        if (isCalendarPadding) {
          return;
        }
        this.setWorkingParts(Object.assign(Object.assign({}, this.workingParts), {
          month,
          day,
          year
        }));
        if (multiple) {
          this.setActiveParts({
            month,
            day,
            year
          }, isActive);
        } else {
          this.setActiveParts(Object.assign(Object.assign({}, activePart), {
            month,
            day,
            year
          }));
        }
      } }, h$5("div", { class: "calendar-day-highlight", style: {
        backgroundColor: dateStyle === null || dateStyle === void 0 ? void 0 : dateStyle.backgroundColor
      } }), text);
    })));
  }
  renderCalendarBody() {
    return h$5("div", { class: "calendar-body ion-focusable", ref: (el2) => this.calendarBodyRef = el2, tabindex: "0" }, generateMonths(this.workingParts).map(({ month, year }) => {
      return this.renderMonth(month, year);
    }));
  }
  renderCalendar(mode) {
    return h$5("div", { class: "datetime-calendar", key: "datetime-calendar" }, this.renderCalendarHeader(mode), this.renderCalendarBody());
  }
  renderTimeLabel() {
    const hasSlottedTimeLabel = this.el.querySelector('[slot="time-label"]') !== null;
    if (!hasSlottedTimeLabel && !this.showDefaultTimeLabel) {
      return;
    }
    return h$5("slot", { name: "time-label" }, "Time");
  }
  renderTimeOverlay() {
    const use24Hour = is24Hour(this.locale, this.hourCycle);
    const activePart = this.getActivePartsWithFallback();
    return [
      h$5("div", { class: "time-header" }, this.renderTimeLabel()),
      h$5("button", { class: {
        "time-body": true,
        "time-body-active": this.isTimePopoverOpen
      }, "aria-expanded": "false", "aria-haspopup": "true", onClick: async (ev) => {
        const { popoverRef } = this;
        if (popoverRef) {
          this.isTimePopoverOpen = true;
          popoverRef.present(new CustomEvent("ionShadowTarget", {
            detail: {
              ionShadowTarget: ev.target
            }
          }));
          await popoverRef.onWillDismiss();
          this.isTimePopoverOpen = false;
        }
      } }, getLocalizedTime(this.locale, activePart, use24Hour)),
      h$5("ion-popover", {
        alignment: "center",
        translucent: true,
        overlayIndex: 1,
        arrow: false,
        onWillPresent: (ev) => {
          const cols = ev.target.querySelectorAll("ion-picker-column-internal");
          cols.forEach((col) => col.scrollActiveItemIntoView());
        },
        style: {
          "--offset-y": "-10px",
          "--min-width": "fit-content"
        },
        // Allow native browser keyboard events to support up/down/home/end key
        // navigation within the time picker.
        keyboardEvents: true,
        ref: (el2) => this.popoverRef = el2
      }, this.renderWheelPicker("time"))
    ];
  }
  getHeaderSelectedDateText() {
    const { activeParts, multiple, titleSelectedDatesFormatter } = this;
    const isArray2 = Array.isArray(activeParts);
    let headerText;
    if (multiple && isArray2 && activeParts.length !== 1) {
      headerText = `${activeParts.length} days`;
      if (titleSelectedDatesFormatter !== void 0) {
        try {
          headerText = titleSelectedDatesFormatter(convertDataToISO(activeParts));
        } catch (e3) {
          printIonError("Exception in provided `titleSelectedDatesFormatter`: ", e3);
        }
      }
    } else {
      headerText = getMonthAndDay(this.locale, this.getActivePartsWithFallback());
    }
    return headerText;
  }
  renderHeader(showExpandedHeader = true) {
    const hasSlottedTitle = this.el.querySelector('[slot="title"]') !== null;
    if (!hasSlottedTitle && !this.showDefaultTitle) {
      return;
    }
    return h$5("div", { class: "datetime-header" }, h$5("div", { class: "datetime-title" }, h$5("slot", { name: "title" }, "Select Date")), showExpandedHeader && h$5("div", { class: "datetime-selected-date" }, this.getHeaderSelectedDateText()));
  }
  /**
   * Render time picker inside of datetime.
   * Do not pass color prop to segment on
   * iOS mode. MD segment has been customized and
   * should take on the color prop, but iOS
   * should just be the default segment.
   */
  renderTime() {
    const { presentation } = this;
    const timeOnlyPresentation = presentation === "time";
    return h$5("div", { class: "datetime-time" }, timeOnlyPresentation ? this.renderWheelPicker() : this.renderTimeOverlay());
  }
  /**
   * Renders the month/year picker that is
   * displayed on the calendar grid.
   * The .datetime-year class has additional
   * styles that let us show/hide the
   * picker when the user clicks on the
   * toggle in the calendar header.
   */
  renderCalendarViewMonthYearPicker() {
    return h$5("div", { class: "datetime-year" }, this.renderWheelView("month-year"));
  }
  /**
   * Render entry point
   * All presentation types are rendered from here.
   */
  renderDatetime(mode) {
    const { presentation, preferWheel } = this;
    const hasWheelVariant = presentation === "date" || presentation === "date-time" || presentation === "time-date";
    if (preferWheel && hasWheelVariant) {
      return [this.renderHeader(false), this.renderWheelView(), this.renderFooter()];
    }
    switch (presentation) {
      case "date-time":
        return [
          this.renderHeader(),
          this.renderCalendar(mode),
          this.renderCalendarViewMonthYearPicker(),
          this.renderTime(),
          this.renderFooter()
        ];
      case "time-date":
        return [
          this.renderHeader(),
          this.renderTime(),
          this.renderCalendar(mode),
          this.renderCalendarViewMonthYearPicker(),
          this.renderFooter()
        ];
      case "time":
        return [this.renderHeader(false), this.renderTime(), this.renderFooter()];
      case "month":
      case "month-year":
      case "year":
        return [this.renderHeader(false), this.renderWheelView(), this.renderFooter()];
      default:
        return [
          this.renderHeader(),
          this.renderCalendar(mode),
          this.renderCalendarViewMonthYearPicker(),
          this.renderFooter()
        ];
    }
  }
  render() {
    const { name, value, disabled, el: el2, color: color2, isPresented, readonly, showMonthAndYear, preferWheel, presentation, size } = this;
    const mode = getIonMode$2(this);
    const isMonthAndYearPresentation = presentation === "year" || presentation === "month" || presentation === "month-year";
    const shouldShowMonthAndYear = showMonthAndYear || isMonthAndYearPresentation;
    const monthYearPickerOpen = showMonthAndYear && !isMonthAndYearPresentation;
    const hasDatePresentation = presentation === "date" || presentation === "date-time" || presentation === "time-date";
    const hasWheelVariant = hasDatePresentation && preferWheel;
    const hasGrid = hasDatePresentation && !preferWheel;
    renderHiddenInput(true, el2, name, formatValue(value), disabled);
    return h$5(Host$1, { "aria-disabled": disabled ? "true" : null, onFocus: this.onFocus, onBlur: this.onBlur, class: Object.assign({}, createColorClasses$1(color2, {
      [mode]: true,
      ["datetime-presented"]: isPresented,
      ["datetime-readonly"]: readonly,
      ["datetime-disabled"]: disabled,
      "show-month-and-year": shouldShowMonthAndYear,
      "month-year-picker-open": monthYearPickerOpen,
      [`datetime-presentation-${presentation}`]: true,
      [`datetime-size-${size}`]: true,
      [`datetime-prefer-wheel`]: hasWheelVariant,
      [`datetime-grid`]: hasGrid
    })) }, this.renderDatetime(mode));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "disabled": ["disabledChanged"],
      "min": ["minChanged"],
      "max": ["maxChanged"],
      "yearValues": ["yearValuesChanged"],
      "monthValues": ["monthValuesChanged"],
      "dayValues": ["dayValuesChanged"],
      "hourValues": ["hourValuesChanged"],
      "minuteValues": ["minuteValuesChanged"],
      "activeParts": ["activePartsChanged"],
      "value": ["valueChanged"]
    };
  }
  static get style() {
    return {
      ios: datetimeIosCss,
      md: datetimeMdCss
    };
  }
}, [33, "ion-datetime", {
  "color": [1],
  "name": [1],
  "disabled": [4],
  "readonly": [4],
  "isDateEnabled": [16],
  "min": [1025],
  "max": [1025],
  "presentation": [1],
  "cancelText": [1, "cancel-text"],
  "doneText": [1, "done-text"],
  "clearText": [1, "clear-text"],
  "yearValues": [8, "year-values"],
  "monthValues": [8, "month-values"],
  "dayValues": [8, "day-values"],
  "hourValues": [8, "hour-values"],
  "minuteValues": [8, "minute-values"],
  "locale": [1],
  "firstDayOfWeek": [2, "first-day-of-week"],
  "titleSelectedDatesFormatter": [16],
  "multiple": [4],
  "highlightedDates": [16],
  "value": [1025],
  "showDefaultTitle": [4, "show-default-title"],
  "showDefaultButtons": [4, "show-default-buttons"],
  "showClearButton": [4, "show-clear-button"],
  "showDefaultTimeLabel": [4, "show-default-time-label"],
  "hourCycle": [1, "hour-cycle"],
  "size": [1],
  "preferWheel": [4, "prefer-wheel"],
  "showMonthAndYear": [32],
  "activeParts": [32],
  "workingParts": [32],
  "isPresented": [32],
  "isTimePopoverOpen": [32],
  "confirm": [64],
  "reset": [64],
  "cancel": [64]
}]);
let datetimeIds = 0;
function defineCustomElement$1$y() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-datetime", "ion-backdrop", "ion-button", "ion-buttons", "ion-icon", "ion-item", "ion-label", "ion-note", "ion-picker-column-internal", "ion-picker-internal", "ion-popover", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-datetime":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Datetime);
        }
        break;
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          defineCustomElement$17();
        }
        break;
      case "ion-button":
        if (!customElements.get(tagName)) {
          defineCustomElement$W();
        }
        break;
      case "ion-buttons":
        if (!customElements.get(tagName)) {
          defineCustomElement$15();
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$1b();
        }
        break;
      case "ion-item":
        if (!customElements.get(tagName)) {
          defineCustomElement$U();
        }
        break;
      case "ion-label":
        if (!customElements.get(tagName)) {
          defineCustomElement$T();
        }
        break;
      case "ion-note":
        if (!customElements.get(tagName)) {
          defineCustomElement$V();
        }
        break;
      case "ion-picker-column-internal":
        if (!customElements.get(tagName)) {
          defineCustomElement$S();
        }
        break;
      case "ion-picker-internal":
        if (!customElements.get(tagName)) {
          defineCustomElement$R();
        }
        break;
      case "ion-popover":
        if (!customElements.get(tagName)) {
          defineCustomElement$Q();
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$Z();
        }
        break;
    }
  });
}
const defineCustomElement$P = defineCustomElement$1$y;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const fabCss = ":host{position:absolute;z-index:999}:host(.fab-horizontal-center){-webkit-margin-start:-28px;margin-inline-start:-28px}@supports (inset-inline-start: 0){:host(.fab-horizontal-center){inset-inline-start:50%}}@supports not (inset-inline-start: 0){:host(.fab-horizontal-center){left:50%}:host-context([dir=rtl]):host(.fab-horizontal-center),:host-context([dir=rtl]).fab-horizontal-center{left:unset;right:unset;right:50%}@supports selector(:dir(rtl)){:host(.fab-horizontal-center):dir(rtl){left:unset;right:unset;right:50%}}}@supports (inset-inline-start: 0){:host(.fab-horizontal-start){inset-inline-start:calc(10px + var(--ion-safe-area-left, 0px))}}@supports not (inset-inline-start: 0){:host(.fab-horizontal-start){left:calc(10px + var(--ion-safe-area-left, 0px))}:host-context([dir=rtl]):host(.fab-horizontal-start),:host-context([dir=rtl]).fab-horizontal-start{left:unset;right:unset;right:calc(10px + var(--ion-safe-area-left, 0px))}@supports selector(:dir(rtl)){:host(.fab-horizontal-start):dir(rtl){left:unset;right:unset;right:calc(10px + var(--ion-safe-area-left, 0px))}}}@supports (inset-inline-start: 0){:host(.fab-horizontal-end){inset-inline-end:calc(10px + var(--ion-safe-area-right, 0px))}}@supports not (inset-inline-start: 0){:host(.fab-horizontal-end){right:calc(10px + var(--ion-safe-area-right, 0px))}:host-context([dir=rtl]):host(.fab-horizontal-end),:host-context([dir=rtl]).fab-horizontal-end{left:unset;right:unset;left:calc(10px + var(--ion-safe-area-right, 0px))}@supports selector(:dir(rtl)){:host(.fab-horizontal-end):dir(rtl){left:unset;right:unset;left:calc(10px + var(--ion-safe-area-right, 0px))}}}:host(.fab-vertical-top){top:10px}:host(.fab-vertical-top.fab-edge){top:-28px}:host(.fab-vertical-bottom){bottom:10px}:host(.fab-vertical-bottom.fab-edge){bottom:-28px}:host(.fab-vertical-center){margin-top:-28px;top:50%}";
const Fab = /* @__PURE__ */ proxyCustomElement$1(class Fab2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.horizontal = void 0;
    this.vertical = void 0;
    this.edge = false;
    this.activated = false;
  }
  activatedChanged() {
    const activated = this.activated;
    const fab = this.getFab();
    if (fab) {
      fab.activated = activated;
    }
    Array.from(this.el.querySelectorAll("ion-fab-list")).forEach((list) => {
      list.activated = activated;
    });
  }
  componentDidLoad() {
    if (this.activated) {
      this.activatedChanged();
    }
  }
  /**
   * Close an active FAB list container.
   */
  async close() {
    this.activated = false;
  }
  getFab() {
    return this.el.querySelector("ion-fab-button");
  }
  /**
   * Opens/Closes the FAB list container.
   * @internal
   */
  async toggle() {
    const hasList = !!this.el.querySelector("ion-fab-list");
    if (hasList) {
      this.activated = !this.activated;
    }
  }
  render() {
    const { horizontal, vertical, edge } = this;
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: {
      [mode]: true,
      [`fab-horizontal-${horizontal}`]: horizontal !== void 0,
      [`fab-vertical-${vertical}`]: vertical !== void 0,
      "fab-edge": edge
    } }, h$5("slot", null));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "activated": ["activatedChanged"]
    };
  }
  static get style() {
    return fabCss;
  }
}, [1, "ion-fab", {
  "horizontal": [1],
  "vertical": [1],
  "edge": [4],
  "activated": [1028],
  "close": [64],
  "toggle": [64]
}]);
function defineCustomElement$1$x() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-fab"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-fab":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Fab);
        }
        break;
    }
  });
}
const defineCustomElement$O = defineCustomElement$1$x;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const fabListCss = ":host{margin-left:0;margin-right:0;margin-top:66px;margin-bottom:66px;display:none;position:absolute;top:0;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;min-width:56px;min-height:56px}:host(.fab-list-active){display:-ms-flexbox;display:flex}::slotted(.fab-button-in-list){margin-left:0;margin-right:0;margin-top:8px;margin-bottom:8px;width:40px;height:40px;-webkit-transform:scale(0);transform:scale(0);opacity:0;visibility:hidden}:host(.fab-list-side-top) ::slotted(.fab-button-in-list),:host(.fab-list-side-bottom) ::slotted(.fab-button-in-list){margin-left:0;margin-right:0;margin-top:5px;margin-bottom:5px}:host(.fab-list-side-start) ::slotted(.fab-button-in-list),:host(.fab-list-side-end) ::slotted(.fab-button-in-list){-webkit-margin-start:5px;margin-inline-start:5px;-webkit-margin-end:5px;margin-inline-end:5px;margin-top:0;margin-bottom:0}::slotted(.fab-button-in-list.fab-button-show){-webkit-transform:scale(1);transform:scale(1);opacity:1;visibility:visible}:host(.fab-list-side-top){top:auto;bottom:0;-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.fab-list-side-start){-webkit-margin-start:66px;margin-inline-start:66px;-webkit-margin-end:66px;margin-inline-end:66px;margin-top:0;margin-bottom:0;-ms-flex-direction:row-reverse;flex-direction:row-reverse}@supports (inset-inline-start: 0){:host(.fab-list-side-start){inset-inline-end:0}}@supports not (inset-inline-start: 0){:host(.fab-list-side-start){right:0}:host-context([dir=rtl]):host(.fab-list-side-start),:host-context([dir=rtl]).fab-list-side-start{left:unset;right:unset;left:0}@supports selector(:dir(rtl)){:host(.fab-list-side-start):dir(rtl){left:unset;right:unset;left:0}}}:host(.fab-list-side-end){-webkit-margin-start:66px;margin-inline-start:66px;-webkit-margin-end:66px;margin-inline-end:66px;margin-top:0;margin-bottom:0;-ms-flex-direction:row;flex-direction:row}@supports (inset-inline-start: 0){:host(.fab-list-side-end){inset-inline-start:0}}@supports not (inset-inline-start: 0){:host(.fab-list-side-end){left:0}:host-context([dir=rtl]):host(.fab-list-side-end),:host-context([dir=rtl]).fab-list-side-end{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(.fab-list-side-end):dir(rtl){left:unset;right:unset;right:0}}}";
const FabList = /* @__PURE__ */ proxyCustomElement$1(class FabList2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.activated = false;
    this.side = "bottom";
  }
  activatedChanged(activated) {
    const fabs = Array.from(this.el.querySelectorAll("ion-fab-button"));
    const timeout = activated ? 30 : 0;
    fabs.forEach((fab, i) => {
      setTimeout(() => fab.show = activated, i * timeout);
    });
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: {
      [mode]: true,
      "fab-list-active": this.activated,
      [`fab-list-side-${this.side}`]: true
    } }, h$5("slot", null));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "activated": ["activatedChanged"]
    };
  }
  static get style() {
    return fabListCss;
  }
}, [1, "ion-fab-list", {
  "activated": [4],
  "side": [1]
}]);
function defineCustomElement$1$w() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-fab-list"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-fab-list":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, FabList);
        }
        break;
    }
  });
}
const defineCustomElement$N = defineCustomElement$1$w;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const ION_CONTENT_TAG_NAME = "ION-CONTENT";
const ION_CONTENT_ELEMENT_SELECTOR = "ion-content";
const ION_CONTENT_CLASS_SELECTOR = ".ion-content-scroll-host";
const ION_CONTENT_SELECTOR = `${ION_CONTENT_ELEMENT_SELECTOR}, ${ION_CONTENT_CLASS_SELECTOR}`;
const isIonContent = (el2) => el2.tagName === ION_CONTENT_TAG_NAME;
const getScrollElement = async (el2) => {
  if (isIonContent(el2)) {
    await new Promise((resolve) => componentOnReady(el2, resolve));
    return el2.getScrollElement();
  }
  return el2;
};
const findIonContent = (el2) => {
  const customContentHost = el2.querySelector(ION_CONTENT_CLASS_SELECTOR);
  if (customContentHost) {
    return customContentHost;
  }
  return el2.querySelector(ION_CONTENT_SELECTOR);
};
const findClosestIonContent = (el2) => {
  return el2.closest(ION_CONTENT_SELECTOR);
};
const scrollToTop = (el2, durationMs) => {
  if (isIonContent(el2)) {
    const content = el2;
    return content.scrollToTop(durationMs);
  }
  return Promise.resolve(el2.scrollTo({
    top: 0,
    left: 0,
    behavior: durationMs > 0 ? "smooth" : "auto"
  }));
};
const scrollByPoint = (el2, x2, y2, durationMs) => {
  if (isIonContent(el2)) {
    const content = el2;
    return content.scrollByPoint(x2, y2, durationMs);
  }
  return Promise.resolve(el2.scrollBy({
    top: y2,
    left: x2,
    behavior: durationMs > 0 ? "smooth" : "auto"
  }));
};
const printIonContentErrorMsg = (el2) => {
  return printRequiredElementError(el2, ION_CONTENT_ELEMENT_SELECTOR);
};
const disableContentScrollY = (contentEl) => {
  if (isIonContent(contentEl)) {
    const ionContent = contentEl;
    const initialScrollY = ionContent.scrollY;
    ionContent.scrollY = false;
    return initialScrollY;
  } else {
    contentEl.style.setProperty("overflow", "hidden");
    return true;
  }
};
const resetContentScrollY = (contentEl, initialScrollY) => {
  if (isIonContent(contentEl)) {
    contentEl.scrollY = initialScrollY;
  } else {
    contentEl.style.removeProperty("overflow");
  }
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
var KeyboardResize;
(function(KeyboardResize2) {
  KeyboardResize2["Body"] = "body";
  KeyboardResize2["Ionic"] = "ionic";
  KeyboardResize2["Native"] = "native";
  KeyboardResize2["None"] = "none";
})(KeyboardResize || (KeyboardResize = {}));
const Keyboard = {
  getEngine() {
    var _a2;
    return ((_a2 = win$2 === null || win$2 === void 0 ? void 0 : win$2.Capacitor) === null || _a2 === void 0 ? void 0 : _a2.isPluginAvailable("Keyboard")) && (win$2 === null || win$2 === void 0 ? void 0 : win$2.Capacitor.Plugins.Keyboard);
  },
  getResizeMode() {
    const engine = this.getEngine();
    if (!engine || !engine.getResizeMode) {
      return Promise.resolve(void 0);
    }
    return engine.getResizeMode();
  }
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const getResizeContainer = (resizeMode) => {
  if (doc$1 === void 0 || resizeMode === KeyboardResize.None || resizeMode === void 0) {
    return null;
  }
  const ionApp = doc$1.querySelector("ion-app");
  return ionApp !== null && ionApp !== void 0 ? ionApp : doc$1.body;
};
const getResizeContainerHeight = (resizeMode) => {
  const containerElement = getResizeContainer(resizeMode);
  return containerElement === null ? 0 : containerElement.clientHeight;
};
const createKeyboardController = async (keyboardChangeCallback) => {
  let keyboardWillShowHandler;
  let keyboardWillHideHandler;
  let keyboardVisible;
  let initialResizeContainerHeight;
  const init2 = async () => {
    const resizeOptions = await Keyboard.getResizeMode();
    const resizeMode = resizeOptions === void 0 ? void 0 : resizeOptions.mode;
    keyboardWillShowHandler = () => {
      if (initialResizeContainerHeight === void 0) {
        initialResizeContainerHeight = getResizeContainerHeight(resizeMode);
      }
      keyboardVisible = true;
      fireChangeCallback(keyboardVisible, resizeMode);
    };
    keyboardWillHideHandler = () => {
      keyboardVisible = false;
      fireChangeCallback(keyboardVisible, resizeMode);
    };
    win$2 === null || win$2 === void 0 ? void 0 : win$2.addEventListener("keyboardWillShow", keyboardWillShowHandler);
    win$2 === null || win$2 === void 0 ? void 0 : win$2.addEventListener("keyboardWillHide", keyboardWillHideHandler);
  };
  const fireChangeCallback = (state, resizeMode) => {
    if (keyboardChangeCallback) {
      keyboardChangeCallback(state, createResizePromiseIfNeeded(resizeMode));
    }
  };
  const createResizePromiseIfNeeded = (resizeMode) => {
    if (
      /**
       * If we are in an SSR environment then there is
       * no window to resize. Additionally, if there
       * is no resize mode or the resize mode is "None"
       * then initialResizeContainerHeight will be 0
       */
      initialResizeContainerHeight === 0 || /**
       * If the keyboard is closed before the webview resizes initially
       * then the webview will never resize.
       */
      initialResizeContainerHeight === getResizeContainerHeight(resizeMode)
    ) {
      return;
    }
    const containerElement = getResizeContainer(resizeMode);
    if (containerElement === null) {
      return;
    }
    return new Promise((resolve) => {
      const callback = () => {
        if (containerElement.clientHeight === initialResizeContainerHeight) {
          ro.disconnect();
          resolve();
        }
      };
      const ro = new ResizeObserver(callback);
      ro.observe(containerElement);
    });
  };
  const destroy = () => {
    win$2 === null || win$2 === void 0 ? void 0 : win$2.removeEventListener("keyboardWillShow", keyboardWillShowHandler);
    win$2 === null || win$2 === void 0 ? void 0 : win$2.removeEventListener("keyboardWillHide", keyboardWillHideHandler);
    keyboardWillShowHandler = keyboardWillHideHandler = void 0;
  };
  const isKeyboardVisible = () => keyboardVisible;
  await init2();
  return { init: init2, destroy, isKeyboardVisible };
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const handleFooterFade = (scrollEl, baseEl) => {
  readTask(() => {
    const scrollTop = scrollEl.scrollTop;
    const maxScroll = scrollEl.scrollHeight - scrollEl.clientHeight;
    const fadeDuration = 10;
    const fadeStart = maxScroll - fadeDuration;
    const distanceToStart = scrollTop - fadeStart;
    const scale = clamp$1(0, 1 - distanceToStart / fadeDuration, 1);
    writeTask$1(() => {
      baseEl.style.setProperty("--opacity-scale", scale.toString());
    });
  });
};
const footerIosCss = "ion-footer{display:block;position:relative;-ms-flex-order:1;order:1;width:100%;z-index:10}ion-footer.footer-toolbar-padding ion-toolbar:last-of-type{padding-bottom:var(--ion-safe-area-bottom, 0)}.footer-ios ion-toolbar:first-of-type{--border-width:0.55px 0 0}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.footer-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}.footer-translucent-ios ion-toolbar{--opacity:.8}}.footer-ios.ion-no-border ion-toolbar:first-of-type{--border-width:0}.footer-collapse-fade ion-toolbar{--opacity-scale:inherit}";
const footerMdCss = 'ion-footer{display:block;position:relative;-ms-flex-order:1;order:1;width:100%;z-index:10}ion-footer.footer-toolbar-padding ion-toolbar:last-of-type{padding-bottom:var(--ion-safe-area-bottom, 0)}.footer-md::before{top:-2px;bottom:auto;background-position:left 0 top 0;position:absolute;width:100%;height:2px;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAHBAMAAADzDtBxAAAAD1BMVEUAAAAAAAAAAAAAAAAAAABPDueNAAAABXRSTlMUCS0gBIh/TXEAAAAaSURBVAjXYxCEAgY4UIICBmMogMsgFLtAAQCNSwXZKOdPxgAAAABJRU5ErkJggg==");background-repeat:repeat-x;content:""}@supports (inset-inline-start: 0){.footer-md::before{inset-inline-start:0}}@supports not (inset-inline-start: 0){.footer-md::before{left:0}:host-context([dir=rtl]) .footer-md::before{left:unset;right:unset;right:0}[dir=rtl] .footer-md::before{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.footer-md::before:dir(rtl){left:unset;right:unset;right:0}}}:host-context([dir=rtl]) .footer-md::before{background-position:right 0 top 0}[dir=rtl] .footer-md::before{background-position:right 0 top 0}@supports selector(:dir(rtl)){.footer-md::before:dir(rtl){background-position:right 0 top 0}}.footer-md.ion-no-border::before{display:none}';
const Footer = /* @__PURE__ */ proxyCustomElement$1(class Footer2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.keyboardCtrl = null;
    this.checkCollapsibleFooter = () => {
      const mode = getIonMode$2(this);
      if (mode !== "ios") {
        return;
      }
      const { collapse } = this;
      const hasFade = collapse === "fade";
      this.destroyCollapsibleFooter();
      if (hasFade) {
        const pageEl = this.el.closest("ion-app,ion-page,.ion-page,page-inner");
        const contentEl = pageEl ? findIonContent(pageEl) : null;
        if (!contentEl) {
          printIonContentErrorMsg(this.el);
          return;
        }
        this.setupFadeFooter(contentEl);
      }
    };
    this.setupFadeFooter = async (contentEl) => {
      const scrollEl = this.scrollEl = await getScrollElement(contentEl);
      this.contentScrollCallback = () => {
        handleFooterFade(scrollEl, this.el);
      };
      scrollEl.addEventListener("scroll", this.contentScrollCallback);
      handleFooterFade(scrollEl, this.el);
    };
    this.keyboardVisible = false;
    this.collapse = void 0;
    this.translucent = false;
  }
  componentDidLoad() {
    this.checkCollapsibleFooter();
  }
  componentDidUpdate() {
    this.checkCollapsibleFooter();
  }
  async connectedCallback() {
    this.keyboardCtrl = await createKeyboardController(async (keyboardOpen2, waitForResize) => {
      if (keyboardOpen2 === false && waitForResize !== void 0) {
        await waitForResize;
      }
      this.keyboardVisible = keyboardOpen2;
    });
  }
  disconnectedCallback() {
    if (this.keyboardCtrl) {
      this.keyboardCtrl.destroy();
    }
  }
  destroyCollapsibleFooter() {
    if (this.scrollEl && this.contentScrollCallback) {
      this.scrollEl.removeEventListener("scroll", this.contentScrollCallback);
      this.contentScrollCallback = void 0;
    }
  }
  render() {
    const { translucent, collapse } = this;
    const mode = getIonMode$2(this);
    const tabs = this.el.closest("ion-tabs");
    const tabBar = tabs === null || tabs === void 0 ? void 0 : tabs.querySelector(":scope > ion-tab-bar");
    return h$5(Host$1, { role: "contentinfo", class: {
      [mode]: true,
      // Used internally for styling
      [`footer-${mode}`]: true,
      [`footer-translucent`]: translucent,
      [`footer-translucent-${mode}`]: translucent,
      ["footer-toolbar-padding"]: !this.keyboardVisible && (!tabBar || tabBar.slot !== "bottom"),
      [`footer-collapse-${collapse}`]: collapse !== void 0
    } }, mode === "ios" && translucent && h$5("div", { class: "footer-background" }), h$5("slot", null));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: footerIosCss,
      md: footerMdCss
    };
  }
}, [36, "ion-footer", {
  "collapse": [1],
  "translucent": [4],
  "keyboardVisible": [32]
}]);
function defineCustomElement$1$v() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-footer"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-footer":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Footer);
        }
        break;
    }
  });
}
const defineCustomElement$M = defineCustomElement$1$v;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const gridCss = ":host{-webkit-padding-start:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;display:block;-ms-flex:1;flex:1}@media (min-width: 576px){:host{-webkit-padding-start:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px))}}@media (min-width: 768px){:host{-webkit-padding-start:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px))}}@media (min-width: 992px){:host{-webkit-padding-start:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px))}}@media (min-width: 1200px){:host{-webkit-padding-start:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px))}}:host(.grid-fixed){width:var(--ion-grid-width-xs, var(--ion-grid-width, 100%));max-width:100%}@media (min-width: 576px){:host(.grid-fixed){width:var(--ion-grid-width-sm, var(--ion-grid-width, 540px))}}@media (min-width: 768px){:host(.grid-fixed){width:var(--ion-grid-width-md, var(--ion-grid-width, 720px))}}@media (min-width: 992px){:host(.grid-fixed){width:var(--ion-grid-width-lg, var(--ion-grid-width, 960px))}}@media (min-width: 1200px){:host(.grid-fixed){width:var(--ion-grid-width-xl, var(--ion-grid-width, 1140px))}}:host(.ion-no-padding){--ion-grid-column-padding:0;--ion-grid-column-padding-xs:0;--ion-grid-column-padding-sm:0;--ion-grid-column-padding-md:0;--ion-grid-column-padding-lg:0;--ion-grid-column-padding-xl:0}";
const Grid = /* @__PURE__ */ proxyCustomElement$1(class Grid2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.fixed = false;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: {
      [mode]: true,
      "grid-fixed": this.fixed
    } }, h$5("slot", null));
  }
  static get style() {
    return gridCss;
  }
}, [1, "ion-grid", {
  "fixed": [4]
}]);
function defineCustomElement$1$u() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-grid"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-grid":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Grid);
        }
        break;
    }
  });
}
const defineCustomElement$L = defineCustomElement$1$u;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const TRANSITION = "all 0.2s ease-in-out";
const cloneElement = (tagName) => {
  const getCachedEl = document.querySelector(`${tagName}.ion-cloned-element`);
  if (getCachedEl !== null) {
    return getCachedEl;
  }
  const clonedEl = document.createElement(tagName);
  clonedEl.classList.add("ion-cloned-element");
  clonedEl.style.setProperty("display", "none");
  document.body.appendChild(clonedEl);
  return clonedEl;
};
const createHeaderIndex = (headerEl) => {
  if (!headerEl) {
    return;
  }
  const toolbars = headerEl.querySelectorAll("ion-toolbar");
  return {
    el: headerEl,
    toolbars: Array.from(toolbars).map((toolbar) => {
      const ionTitleEl = toolbar.querySelector("ion-title");
      return {
        el: toolbar,
        background: toolbar.shadowRoot.querySelector(".toolbar-background"),
        ionTitleEl,
        innerTitleEl: ionTitleEl ? ionTitleEl.shadowRoot.querySelector(".toolbar-title") : null,
        ionButtonsEl: Array.from(toolbar.querySelectorAll("ion-buttons"))
      };
    })
  };
};
const handleContentScroll = (scrollEl, scrollHeaderIndex, contentEl) => {
  readTask(() => {
    const scrollTop = scrollEl.scrollTop;
    const scale = clamp$1(1, 1 + -scrollTop / 500, 1.1);
    const nativeRefresher = contentEl.querySelector("ion-refresher.refresher-native");
    if (nativeRefresher === null) {
      writeTask$1(() => {
        scaleLargeTitles(scrollHeaderIndex.toolbars, scale);
      });
    }
  });
};
const setToolbarBackgroundOpacity = (headerEl, opacity) => {
  if (headerEl.collapse === "fade") {
    return;
  }
  if (opacity === void 0) {
    headerEl.style.removeProperty("--opacity-scale");
  } else {
    headerEl.style.setProperty("--opacity-scale", opacity.toString());
  }
};
const handleToolbarBorderIntersection = (ev, mainHeaderIndex, scrollTop) => {
  if (!ev[0].isIntersecting) {
    return;
  }
  const scale = ev[0].intersectionRatio > 0.9 || scrollTop <= 0 ? 0 : (1 - ev[0].intersectionRatio) * 100 / 75;
  setToolbarBackgroundOpacity(mainHeaderIndex.el, scale === 1 ? void 0 : scale);
};
const handleToolbarIntersection = (ev, mainHeaderIndex, scrollHeaderIndex, scrollEl) => {
  writeTask$1(() => {
    const scrollTop = scrollEl.scrollTop;
    handleToolbarBorderIntersection(ev, mainHeaderIndex, scrollTop);
    const event = ev[0];
    const intersection3 = event.intersectionRect;
    const intersectionArea = intersection3.width * intersection3.height;
    const rootArea = event.rootBounds.width * event.rootBounds.height;
    const isPageHidden = intersectionArea === 0 && rootArea === 0;
    const leftDiff = Math.abs(intersection3.left - event.boundingClientRect.left);
    const rightDiff = Math.abs(intersection3.right - event.boundingClientRect.right);
    const isPageTransitioning = intersectionArea > 0 && (leftDiff >= 5 || rightDiff >= 5);
    if (isPageHidden || isPageTransitioning) {
      return;
    }
    if (event.isIntersecting) {
      setHeaderActive(mainHeaderIndex, false);
      setHeaderActive(scrollHeaderIndex);
    } else {
      const hasValidIntersection = intersection3.x === 0 && intersection3.y === 0 || intersection3.width !== 0 && intersection3.height !== 0;
      if (hasValidIntersection && scrollTop > 0) {
        setHeaderActive(mainHeaderIndex);
        setHeaderActive(scrollHeaderIndex, false);
        setToolbarBackgroundOpacity(mainHeaderIndex.el);
      }
    }
  });
};
const setHeaderActive = (headerIndex, active = true) => {
  const headerEl = headerIndex.el;
  if (active) {
    headerEl.classList.remove("header-collapse-condense-inactive");
    headerEl.removeAttribute("aria-hidden");
  } else {
    headerEl.classList.add("header-collapse-condense-inactive");
    headerEl.setAttribute("aria-hidden", "true");
  }
};
const scaleLargeTitles = (toolbars = [], scale = 1, transition2 = false) => {
  toolbars.forEach((toolbar) => {
    const ionTitle = toolbar.ionTitleEl;
    const titleDiv = toolbar.innerTitleEl;
    if (!ionTitle || ionTitle.size !== "large") {
      return;
    }
    titleDiv.style.transition = transition2 ? TRANSITION : "";
    titleDiv.style.transform = `scale3d(${scale}, ${scale}, 1)`;
  });
};
const handleHeaderFade = (scrollEl, baseEl, condenseHeader) => {
  readTask(() => {
    const scrollTop = scrollEl.scrollTop;
    const baseElHeight = baseEl.clientHeight;
    const fadeStart = condenseHeader ? condenseHeader.clientHeight : 0;
    if (condenseHeader !== null && scrollTop < fadeStart) {
      baseEl.style.setProperty("--opacity-scale", "0");
      scrollEl.style.setProperty("clip-path", `inset(${baseElHeight}px 0px 0px 0px)`);
      return;
    }
    const distanceToStart = scrollTop - fadeStart;
    const fadeDuration = 10;
    const scale = clamp$1(0, distanceToStart / fadeDuration, 1);
    writeTask$1(() => {
      scrollEl.style.removeProperty("clip-path");
      baseEl.style.setProperty("--opacity-scale", scale.toString());
    });
  });
};
const headerIosCss = "ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-ios ion-toolbar:last-of-type{--border-width:0 0 0.55px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.header-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}.header-translucent-ios ion-toolbar{--opacity:.8}.header-collapse-condense-inactive .header-background{-webkit-backdrop-filter:blur(20px);backdrop-filter:blur(20px)}}.header-ios.ion-no-border ion-toolbar:last-of-type{--border-width:0}.header-collapse-fade ion-toolbar{--opacity-scale:inherit}.header-collapse-condense{z-index:9}.header-collapse-condense ion-toolbar{position:-webkit-sticky;position:sticky;top:0}.header-collapse-condense ion-toolbar:first-of-type{padding-top:7px;z-index:1}.header-collapse-condense ion-toolbar{--background:var(--ion-background-color, #fff);z-index:0}.header-collapse-condense ion-toolbar:last-of-type{--border-width:0px}.header-collapse-condense ion-toolbar ion-searchbar{height:48px;padding-top:0px;padding-bottom:13px}.header-collapse-main{--opacity-scale:1}.header-collapse-main ion-toolbar{--opacity-scale:inherit}.header-collapse-main ion-toolbar.in-toolbar ion-title,.header-collapse-main ion-toolbar.in-toolbar ion-buttons{-webkit-transition:all 0.2s ease-in-out;transition:all 0.2s ease-in-out}.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-buttons.buttons-collapse{opacity:0;pointer-events:none}.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-buttons.buttons-collapse{visibility:hidden}";
const headerMdCss = 'ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-md::after{bottom:-5px;background-position:left 0 top -2px;position:absolute;width:100%;height:5px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAHBAMAAADzDtBxAAAAD1BMVEUAAAAAAAAAAAAAAAAAAABPDueNAAAABXRSTlMUCS0gBIh/TXEAAAAaSURBVAjXYxCEAgY4UIICBmMogMsgFLtAAQCNSwXZKOdPxgAAAABJRU5ErkJggg==);background-repeat:repeat-x;content:""}@supports (inset-inline-start: 0){.header-md::after{inset-inline-start:0}}@supports not (inset-inline-start: 0){.header-md::after{left:0}:host-context([dir=rtl]) .header-md::after{left:unset;right:unset;right:0}[dir=rtl] .header-md::after{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.header-md::after:dir(rtl){left:unset;right:unset;right:0}}}:host-context([dir=rtl]) .header-md::after{background-position:right 0 top -2px}[dir=rtl] .header-md::after{background-position:right 0 top -2px}@supports selector(:dir(rtl)){.header-md::after:dir(rtl){background-position:right 0 top -2px}}.header-collapse-condense{display:none}.header-md.ion-no-border::after{display:none}';
const Header = /* @__PURE__ */ proxyCustomElement$1(class Header2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.inheritedAttributes = {};
    this.setupFadeHeader = async (contentEl, condenseHeader) => {
      const scrollEl = this.scrollEl = await getScrollElement(contentEl);
      this.contentScrollCallback = () => {
        handleHeaderFade(this.scrollEl, this.el, condenseHeader);
      };
      scrollEl.addEventListener("scroll", this.contentScrollCallback);
      handleHeaderFade(this.scrollEl, this.el, condenseHeader);
    };
    this.collapse = void 0;
    this.translucent = false;
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAriaAttributes(this.el);
  }
  componentDidLoad() {
    this.checkCollapsibleHeader();
  }
  componentDidUpdate() {
    this.checkCollapsibleHeader();
  }
  disconnectedCallback() {
    this.destroyCollapsibleHeader();
  }
  async checkCollapsibleHeader() {
    const mode = getIonMode$2(this);
    if (mode !== "ios") {
      return;
    }
    const { collapse } = this;
    const hasCondense = collapse === "condense";
    const hasFade = collapse === "fade";
    this.destroyCollapsibleHeader();
    if (hasCondense) {
      const pageEl = this.el.closest("ion-app,ion-page,.ion-page,page-inner");
      const contentEl = pageEl ? findIonContent(pageEl) : null;
      writeTask$1(() => {
        const title = cloneElement("ion-title");
        title.size = "large";
        cloneElement("ion-back-button");
      });
      await this.setupCondenseHeader(contentEl, pageEl);
    } else if (hasFade) {
      const pageEl = this.el.closest("ion-app,ion-page,.ion-page,page-inner");
      const contentEl = pageEl ? findIonContent(pageEl) : null;
      if (!contentEl) {
        printIonContentErrorMsg(this.el);
        return;
      }
      const condenseHeader = contentEl.querySelector('ion-header[collapse="condense"]');
      await this.setupFadeHeader(contentEl, condenseHeader);
    }
  }
  destroyCollapsibleHeader() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      this.intersectionObserver = void 0;
    }
    if (this.scrollEl && this.contentScrollCallback) {
      this.scrollEl.removeEventListener("scroll", this.contentScrollCallback);
      this.contentScrollCallback = void 0;
    }
    if (this.collapsibleMainHeader) {
      this.collapsibleMainHeader.classList.remove("header-collapse-main");
      this.collapsibleMainHeader = void 0;
    }
  }
  async setupCondenseHeader(contentEl, pageEl) {
    if (!contentEl || !pageEl) {
      printIonContentErrorMsg(this.el);
      return;
    }
    if (typeof IntersectionObserver === "undefined") {
      return;
    }
    this.scrollEl = await getScrollElement(contentEl);
    const headers = pageEl.querySelectorAll("ion-header");
    this.collapsibleMainHeader = Array.from(headers).find((header) => header.collapse !== "condense");
    if (!this.collapsibleMainHeader) {
      return;
    }
    const mainHeaderIndex = createHeaderIndex(this.collapsibleMainHeader);
    const scrollHeaderIndex = createHeaderIndex(this.el);
    if (!mainHeaderIndex || !scrollHeaderIndex) {
      return;
    }
    setHeaderActive(mainHeaderIndex, false);
    setToolbarBackgroundOpacity(mainHeaderIndex.el, 0);
    const toolbarIntersection = (ev) => {
      handleToolbarIntersection(ev, mainHeaderIndex, scrollHeaderIndex, this.scrollEl);
    };
    this.intersectionObserver = new IntersectionObserver(toolbarIntersection, {
      root: contentEl,
      threshold: [0.25, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
    });
    this.intersectionObserver.observe(scrollHeaderIndex.toolbars[scrollHeaderIndex.toolbars.length - 1].el);
    this.contentScrollCallback = () => {
      handleContentScroll(this.scrollEl, scrollHeaderIndex, contentEl);
    };
    this.scrollEl.addEventListener("scroll", this.contentScrollCallback);
    writeTask$1(() => {
      if (this.collapsibleMainHeader !== void 0) {
        this.collapsibleMainHeader.classList.add("header-collapse-main");
      }
    });
  }
  render() {
    const { translucent, inheritedAttributes } = this;
    const mode = getIonMode$2(this);
    const collapse = this.collapse || "none";
    const roleType = hostContext("ion-menu", this.el) ? "none" : "banner";
    return h$5(Host$1, Object.assign({ role: roleType, class: {
      [mode]: true,
      // Used internally for styling
      [`header-${mode}`]: true,
      [`header-translucent`]: this.translucent,
      [`header-collapse-${collapse}`]: true,
      [`header-translucent-${mode}`]: this.translucent
    } }, inheritedAttributes), mode === "ios" && translucent && h$5("div", { class: "header-background" }), h$5("slot", null));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: headerIosCss,
      md: headerMdCss
    };
  }
}, [36, "ion-header", {
  "collapse": [1],
  "translucent": [4]
}]);
function defineCustomElement$1$t() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-header"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-header":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Header);
        }
        break;
    }
  });
}
const defineCustomElement$K = defineCustomElement$1$t;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const imgCss = ":host{display:block;-o-object-fit:contain;object-fit:contain}img{display:block;width:100%;height:100%;-o-object-fit:inherit;object-fit:inherit;-o-object-position:inherit;object-position:inherit}";
const Img = /* @__PURE__ */ proxyCustomElement$1(class Img2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionImgWillLoad = createEvent(this, "ionImgWillLoad", 7);
    this.ionImgDidLoad = createEvent(this, "ionImgDidLoad", 7);
    this.ionError = createEvent(this, "ionError", 7);
    this.inheritedAttributes = {};
    this.onLoad = () => {
      this.ionImgDidLoad.emit();
    };
    this.onError = () => {
      this.ionError.emit();
    };
    this.loadSrc = void 0;
    this.loadError = void 0;
    this.alt = void 0;
    this.src = void 0;
  }
  srcChanged() {
    this.addIO();
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAttributes$2(this.el, ["draggable"]);
  }
  componentDidLoad() {
    this.addIO();
  }
  addIO() {
    if (this.src === void 0) {
      return;
    }
    if (typeof window !== "undefined" && "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "isIntersecting" in window.IntersectionObserverEntry.prototype) {
      this.removeIO();
      this.io = new IntersectionObserver((data2) => {
        if (data2[data2.length - 1].isIntersecting) {
          this.load();
          this.removeIO();
        }
      });
      this.io.observe(this.el);
    } else {
      setTimeout(() => this.load(), 200);
    }
  }
  load() {
    this.loadError = this.onError;
    this.loadSrc = this.src;
    this.ionImgWillLoad.emit();
  }
  removeIO() {
    if (this.io) {
      this.io.disconnect();
      this.io = void 0;
    }
  }
  render() {
    const { loadSrc, alt, onLoad: onLoad2, loadError, inheritedAttributes } = this;
    const { draggable } = inheritedAttributes;
    return h$5(Host$1, { class: getIonMode$2(this) }, h$5("img", { decoding: "async", src: loadSrc, alt, onLoad: onLoad2, onError: loadError, part: "image", draggable: isDraggable(draggable) }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "src": ["srcChanged"]
    };
  }
  static get style() {
    return imgCss;
  }
}, [1, "ion-img", {
  "alt": [1],
  "src": [1],
  "loadSrc": [32],
  "loadError": [32]
}]);
const isDraggable = (draggable) => {
  switch (draggable) {
    case "true":
      return true;
    case "false":
      return false;
    default:
      return void 0;
  }
};
function defineCustomElement$1$s() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-img"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-img":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Img);
        }
        break;
    }
  });
}
const defineCustomElement$J = defineCustomElement$1$s;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const spinners = {
  bubbles: {
    dur: 1e3,
    circles: 9,
    fn: (dur, index3, total) => {
      const animationDelay = `${dur * index3 / total - dur}ms`;
      const angle = 2 * Math.PI * index3 / total;
      return {
        r: 5,
        style: {
          top: `${32 * Math.sin(angle)}%`,
          left: `${32 * Math.cos(angle)}%`,
          "animation-delay": animationDelay
        }
      };
    }
  },
  circles: {
    dur: 1e3,
    circles: 8,
    fn: (dur, index3, total) => {
      const step = index3 / total;
      const animationDelay = `${dur * step - dur}ms`;
      const angle = 2 * Math.PI * step;
      return {
        r: 5,
        style: {
          top: `${32 * Math.sin(angle)}%`,
          left: `${32 * Math.cos(angle)}%`,
          "animation-delay": animationDelay
        }
      };
    }
  },
  circular: {
    dur: 1400,
    elmDuration: true,
    circles: 1,
    fn: () => {
      return {
        r: 20,
        cx: 48,
        cy: 48,
        fill: "none",
        viewBox: "24 24 48 48",
        transform: "translate(0,0)",
        style: {}
      };
    }
  },
  crescent: {
    dur: 750,
    circles: 1,
    fn: () => {
      return {
        r: 26,
        style: {}
      };
    }
  },
  dots: {
    dur: 750,
    circles: 3,
    fn: (_2, index3) => {
      const animationDelay = -(110 * index3) + "ms";
      return {
        r: 6,
        style: {
          left: `${32 - 32 * index3}%`,
          "animation-delay": animationDelay
        }
      };
    }
  },
  lines: {
    dur: 1e3,
    lines: 8,
    fn: (dur, index3, total) => {
      const transform = `rotate(${360 / total * index3 + (index3 < total / 2 ? 180 : -180)}deg)`;
      const animationDelay = `${dur * index3 / total - dur}ms`;
      return {
        y1: 14,
        y2: 26,
        style: {
          transform,
          "animation-delay": animationDelay
        }
      };
    }
  },
  "lines-small": {
    dur: 1e3,
    lines: 8,
    fn: (dur, index3, total) => {
      const transform = `rotate(${360 / total * index3 + (index3 < total / 2 ? 180 : -180)}deg)`;
      const animationDelay = `${dur * index3 / total - dur}ms`;
      return {
        y1: 12,
        y2: 20,
        style: {
          transform,
          "animation-delay": animationDelay
        }
      };
    }
  },
  "lines-sharp": {
    dur: 1e3,
    lines: 12,
    fn: (dur, index3, total) => {
      const transform = `rotate(${30 * index3 + (index3 < 6 ? 180 : -180)}deg)`;
      const animationDelay = `${dur * index3 / total - dur}ms`;
      return {
        y1: 17,
        y2: 29,
        style: {
          transform,
          "animation-delay": animationDelay
        }
      };
    }
  },
  "lines-sharp-small": {
    dur: 1e3,
    lines: 12,
    fn: (dur, index3, total) => {
      const transform = `rotate(${30 * index3 + (index3 < 6 ? 180 : -180)}deg)`;
      const animationDelay = `${dur * index3 / total - dur}ms`;
      return {
        y1: 12,
        y2: 20,
        style: {
          transform,
          "animation-delay": animationDelay
        }
      };
    }
  }
};
const SPINNERS = spinners;
const spinnerCss = ":host{display:inline-block;position:relative;width:28px;height:28px;color:var(--color);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.ion-color){color:var(--ion-color-base)}svg{-webkit-transform-origin:center;transform-origin:center;position:absolute;top:0;left:0;width:100%;height:100%;-webkit-transform:translateZ(0);transform:translateZ(0)}:host-context([dir=rtl]) svg{-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}[dir=rtl] svg{-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}@supports selector(:dir(rtl)){svg:dir(rtl){-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}}:host(.spinner-lines) line,:host(.spinner-lines-small) line{stroke-width:7px}:host(.spinner-lines-sharp) line,:host(.spinner-lines-sharp-small) line{stroke-width:4px}:host(.spinner-lines) line,:host(.spinner-lines-small) line,:host(.spinner-lines-sharp) line,:host(.spinner-lines-sharp-small) line{stroke-linecap:round;stroke:currentColor}:host(.spinner-lines) svg,:host(.spinner-lines-small) svg,:host(.spinner-lines-sharp) svg,:host(.spinner-lines-sharp-small) svg{-webkit-animation:spinner-fade-out 1s linear infinite;animation:spinner-fade-out 1s linear infinite}:host(.spinner-bubbles) svg{-webkit-animation:spinner-scale-out 1s linear infinite;animation:spinner-scale-out 1s linear infinite;fill:currentColor}:host(.spinner-circles) svg{-webkit-animation:spinner-fade-out 1s linear infinite;animation:spinner-fade-out 1s linear infinite;fill:currentColor}:host(.spinner-crescent) circle{fill:transparent;stroke-width:4px;stroke-dasharray:128px;stroke-dashoffset:82px;stroke:currentColor}:host(.spinner-crescent) svg{-webkit-animation:spinner-rotate 1s linear infinite;animation:spinner-rotate 1s linear infinite}:host(.spinner-dots) circle{stroke-width:0;fill:currentColor}:host(.spinner-dots) svg{-webkit-animation:spinner-dots 1s linear infinite;animation:spinner-dots 1s linear infinite}:host(.spinner-circular) svg{-webkit-animation:spinner-circular linear infinite;animation:spinner-circular linear infinite}:host(.spinner-circular) circle{-webkit-animation:spinner-circular-inner ease-in-out infinite;animation:spinner-circular-inner ease-in-out infinite;stroke:currentColor;stroke-dasharray:80px, 200px;stroke-dashoffset:0px;stroke-width:5.6;fill:none}:host(.spinner-paused),:host(.spinner-paused) svg,:host(.spinner-paused) circle{-webkit-animation-play-state:paused;animation-play-state:paused}@-webkit-keyframes spinner-fade-out{0%{opacity:1}100%{opacity:0}}@keyframes spinner-fade-out{0%{opacity:1}100%{opacity:0}}@-webkit-keyframes spinner-scale-out{0%{-webkit-transform:scale(1, 1);transform:scale(1, 1)}100%{-webkit-transform:scale(0, 0);transform:scale(0, 0)}}@keyframes spinner-scale-out{0%{-webkit-transform:scale(1, 1);transform:scale(1, 1)}100%{-webkit-transform:scale(0, 0);transform:scale(0, 0)}}@-webkit-keyframes spinner-rotate{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-rotate{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes spinner-dots{0%{-webkit-transform:scale(1, 1);transform:scale(1, 1);opacity:0.9}50%{-webkit-transform:scale(0.4, 0.4);transform:scale(0.4, 0.4);opacity:0.3}100%{-webkit-transform:scale(1, 1);transform:scale(1, 1);opacity:0.9}}@keyframes spinner-dots{0%{-webkit-transform:scale(1, 1);transform:scale(1, 1);opacity:0.9}50%{-webkit-transform:scale(0.4, 0.4);transform:scale(0.4, 0.4);opacity:0.3}100%{-webkit-transform:scale(1, 1);transform:scale(1, 1);opacity:0.9}}@-webkit-keyframes spinner-circular{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-circular{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes spinner-circular-inner{0%{stroke-dasharray:1px, 200px;stroke-dashoffset:0px}50%{stroke-dasharray:100px, 200px;stroke-dashoffset:-15px}100%{stroke-dasharray:100px, 200px;stroke-dashoffset:-125px}}@keyframes spinner-circular-inner{0%{stroke-dasharray:1px, 200px;stroke-dashoffset:0px}50%{stroke-dasharray:100px, 200px;stroke-dashoffset:-15px}100%{stroke-dasharray:100px, 200px;stroke-dashoffset:-125px}}";
const Spinner = /* @__PURE__ */ proxyCustomElement$1(class Spinner2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.color = void 0;
    this.duration = void 0;
    this.name = void 0;
    this.paused = false;
  }
  getName() {
    const spinnerName = this.name || config$1.get("spinner");
    const mode = getIonMode$2(this);
    if (spinnerName) {
      return spinnerName;
    }
    return mode === "ios" ? "lines" : "circular";
  }
  render() {
    var _a2;
    const self2 = this;
    const mode = getIonMode$2(self2);
    const spinnerName = self2.getName();
    const spinner = (_a2 = SPINNERS[spinnerName]) !== null && _a2 !== void 0 ? _a2 : SPINNERS["lines"];
    const duration = typeof self2.duration === "number" && self2.duration > 10 ? self2.duration : spinner.dur;
    const svgs = [];
    if (spinner.circles !== void 0) {
      for (let i = 0; i < spinner.circles; i++) {
        svgs.push(buildCircle(spinner, duration, i, spinner.circles));
      }
    } else if (spinner.lines !== void 0) {
      for (let i = 0; i < spinner.lines; i++) {
        svgs.push(buildLine(spinner, duration, i, spinner.lines));
      }
    }
    return h$5(Host$1, { class: createColorClasses$1(self2.color, {
      [mode]: true,
      [`spinner-${spinnerName}`]: true,
      "spinner-paused": self2.paused || config$1.getBoolean("_testing")
    }), role: "progressbar", style: spinner.elmDuration ? { animationDuration: duration + "ms" } : {} }, svgs);
  }
  static get style() {
    return spinnerCss;
  }
}, [1, "ion-spinner", {
  "color": [513],
  "duration": [2],
  "name": [1],
  "paused": [4]
}]);
const buildCircle = (spinner, duration, index3, total) => {
  const data2 = spinner.fn(duration, index3, total);
  data2.style["animation-duration"] = duration + "ms";
  return h$5("svg", { viewBox: data2.viewBox || "0 0 64 64", style: data2.style }, h$5("circle", { transform: data2.transform || "translate(32,32)", cx: data2.cx, cy: data2.cy, r: data2.r, style: spinner.elmDuration ? { animationDuration: duration + "ms" } : {} }));
};
const buildLine = (spinner, duration, index3, total) => {
  const data2 = spinner.fn(duration, index3, total);
  data2.style["animation-duration"] = duration + "ms";
  return h$5("svg", { viewBox: data2.viewBox || "0 0 64 64", style: data2.style }, h$5("line", { transform: "translate(32,32)", y1: data2.y1, y2: data2.y2 }));
};
function defineCustomElement$I() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-spinner"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-spinner":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Spinner);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const getCounterText = (value, maxLength, counterFormatter) => {
  const valueLength = value == null ? 0 : value.toString().length;
  const defaultCounterText = defaultCounterFormatter(valueLength, maxLength);
  if (counterFormatter === void 0) {
    return defaultCounterText;
  }
  try {
    return counterFormatter(valueLength, maxLength);
  } catch (e3) {
    printIonError("Exception in provided `counterFormatter`.", e3);
    return defaultCounterText;
  }
};
const defaultCounterFormatter = (length3, maxlength) => {
  return `${length3} / ${maxlength}`;
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const inputIosCss = ".sc-ion-input-ios-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:0.6;--padding-top:0px;--padding-end:0px;--padding-bottom:0px;--padding-start:0px;--background:transparent;--color:initial;--border-style:solid;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);--highlight-color:var(--highlight-color-focused);display:block;position:relative;width:100%;padding:0 !important;color:var(--color);font-family:var(--ion-font-family, inherit);z-index:2}.legacy-input.sc-ion-input-ios-h{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;background:var(--background)}.legacy-input.sc-ion-input-ios-h .native-input.sc-ion-input-ios{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);border-radius:var(--border-radius)}ion-item.sc-ion-input-ios-h:not(.item-label):not(.item-has-modern-input),ion-item:not(.item-label):not(.item-has-modern-input) .sc-ion-input-ios-h{--padding-start:0}ion-item[slot=start].sc-ion-input-ios-h,ion-item [slot=start].sc-ion-input-ios-h,ion-item[slot=end].sc-ion-input-ios-h,ion-item [slot=end].sc-ion-input-ios-h{width:auto}.legacy-input.ion-color.sc-ion-input-ios-h{color:var(--ion-color-base)}.ion-color.sc-ion-input-ios-h{--highlight-color-focused:var(--ion-color-base)}.native-input.sc-ion-input-ios{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:inline-block;position:relative;-ms-flex:1;flex:1;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none;z-index:1}.native-input.sc-ion-input-ios::-webkit-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios::-moz-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios:-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios::-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios:-webkit-autofill{background-color:transparent}.native-input.sc-ion-input-ios:invalid{-webkit-box-shadow:none;box-shadow:none}.native-input.sc-ion-input-ios::-ms-clear{display:none}.legacy-input.sc-ion-input-ios-h .native-input[disabled].sc-ion-input-ios,.input-disabled.sc-ion-input-ios-h{opacity:0.4}.cloned-input.sc-ion-input-ios{top:0;bottom:0;position:absolute;pointer-events:none}@supports (inset-inline-start: 0){.cloned-input.sc-ion-input-ios{inset-inline-start:0}}@supports not (inset-inline-start: 0){.cloned-input.sc-ion-input-ios{left:0}[dir=rtl].sc-ion-input-ios-h .cloned-input.sc-ion-input-ios,[dir=rtl] .sc-ion-input-ios-h .cloned-input.sc-ion-input-ios{left:unset;right:unset;right:0}[dir=rtl].sc-ion-input-ios .cloned-input.sc-ion-input-ios{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.cloned-input.sc-ion-input-ios:dir(rtl){left:unset;right:unset;right:0}}}.cloned-input.sc-ion-input-ios:disabled{opacity:1}.legacy-input.sc-ion-input-ios-h .input-clear-icon.sc-ion-input-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.input-clear-icon.sc-ion-input-ios{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:auto;margin-bottom:auto;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;background-position:center;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:30px;height:30px;border:0;outline:none;background-color:transparent;background-repeat:no-repeat;color:var(--ion-color-step-600, #666666);visibility:hidden;-webkit-appearance:none;-moz-appearance:none;appearance:none}.in-item-color.sc-ion-input-ios-h .input-clear-icon.sc-ion-input-ios{color:inherit}.input-clear-icon.sc-ion-input-ios:focus{opacity:0.5}.has-value.sc-ion-input-ios-h .input-clear-icon.sc-ion-input-ios{visibility:visible}.has-focus.sc-ion-input-ios-h{pointer-events:none}.has-focus.sc-ion-input-ios-h input.sc-ion-input-ios,.has-focus.sc-ion-input-ios-h a.sc-ion-input-ios,.has-focus.sc-ion-input-ios-h button.sc-ion-input-ios{pointer-events:auto}.item-label-floating.item-has-placeholder.sc-ion-input-ios-h:not(.item-has-value),.item-label-floating.item-has-placeholder:not(.item-has-value) .sc-ion-input-ios-h{opacity:0}.item-label-floating.item-has-placeholder.sc-ion-input-ios-h:not(.item-has-value).item-has-focus,.item-label-floating.item-has-placeholder:not(.item-has-value).item-has-focus .sc-ion-input-ios-h{-webkit-transition:opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1);opacity:1}.input-wrapper.sc-ion-input-ios{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:stretch;align-items:stretch;height:inherit;min-height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;background:var(--background);line-height:normal}.native-wrapper.sc-ion-input-ios{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;width:100%}.ion-touched.ion-invalid.sc-ion-input-ios-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-input-ios-h{--highlight-color:var(--highlight-color-valid)}.input-bottom.sc-ion-input-ios{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:5px;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;border-top:var(--border-width) var(--border-style) var(--border-color);font-size:12px}.has-focus.ion-valid.sc-ion-input-ios-h,.ion-touched.ion-invalid.sc-ion-input-ios-h{--border-color:var(--highlight-color)}.input-bottom.sc-ion-input-ios .error-text.sc-ion-input-ios{display:none;color:var(--highlight-color-invalid)}.input-bottom.sc-ion-input-ios .helper-text.sc-ion-input-ios{display:block;color:var(--ion-color-step-550, #737373)}.ion-touched.ion-invalid.sc-ion-input-ios-h .input-bottom.sc-ion-input-ios .error-text.sc-ion-input-ios{display:block}.ion-touched.ion-invalid.sc-ion-input-ios-h .input-bottom.sc-ion-input-ios .helper-text.sc-ion-input-ios{display:none}.input-bottom.sc-ion-input-ios .counter.sc-ion-input-ios{-webkit-margin-start:auto;margin-inline-start:auto;color:var(--ion-color-step-550, #737373);white-space:nowrap;-webkit-padding-start:16px;padding-inline-start:16px}.has-focus.sc-ion-input-ios-h input.sc-ion-input-ios{caret-color:var(--highlight-color)}.label-text-wrapper.sc-ion-input-ios{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;max-width:200px;-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.label-text.sc-ion-input-ios{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.input-wrapper.sc-ion-input-ios input.sc-ion-input-ios{-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.input-label-placement-start.sc-ion-input-ios-h .input-wrapper.sc-ion-input-ios{-ms-flex-direction:row;flex-direction:row}.input-label-placement-start.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.input-label-placement-end.sc-ion-input-ios-h .input-wrapper.sc-ion-input-ios{-ms-flex-direction:row-reverse;flex-direction:row-reverse}.input-label-placement-end.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}.input-label-placement-fixed.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.input-label-placement-fixed.sc-ion-input-ios-h .label-text.sc-ion-input-ios{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.input-label-placement-stacked.sc-ion-input-ios-h .input-wrapper.sc-ion-input-ios,.input-label-placement-floating.sc-ion-input-ios-h .input-wrapper.sc-ion-input-ios{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:start}.input-label-placement-stacked.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,.input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-transform-origin:left top;transform-origin:left top;max-width:100%}[dir=rtl].sc-ion-input-ios-h -no-combinator.input-label-placement-stacked.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl] .sc-ion-input-ios-h -no-combinator.input-label-placement-stacked.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl].input-label-placement-stacked.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl] .input-label-placement-stacked.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl].sc-ion-input-ios-h -no-combinator.input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl] .sc-ion-input-ios-h -no-combinator.input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl].input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,[dir=rtl] .input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.input-label-placement-stacked.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios:dir(rtl),.input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios:dir(rtl){-webkit-transform-origin:right top;transform-origin:right top}}.input-label-placement-stacked.sc-ion-input-ios-h input.sc-ion-input-ios,.input-label-placement-floating.sc-ion-input-ios-h input.sc-ion-input-ios{margin-left:0;margin-right:0;margin-top:1px;margin-bottom:0}.input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-transform:translateY(100%) scale(1);transform:translateY(100%) scale(1)}.input-label-placement-floating.sc-ion-input-ios-h input.sc-ion-input-ios{opacity:0}.has-focus.input-label-placement-floating.sc-ion-input-ios-h input.sc-ion-input-ios,.has-value.input-label-placement-floating.sc-ion-input-ios-h input.sc-ion-input-ios{opacity:1}.input-label-placement-stacked.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,.has-focus.input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios,.has-value.input-label-placement-floating.sc-ion-input-ios-h .label-text-wrapper.sc-ion-input-ios{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);max-width:calc(100% / 0.75)}.sc-ion-input-ios-h{--border-width:0.55px;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));font-size:inherit}.legacy-input.sc-ion-input-ios-h{--padding-top:10px;--padding-end:8px;--padding-bottom:10px;--padding-start:0}.item-label-stacked.sc-ion-input-ios-h,.item-label-stacked .sc-ion-input-ios-h,.item-label-floating.sc-ion-input-ios-h,.item-label-floating .sc-ion-input-ios-h{--padding-top:8px;--padding-bottom:8px;--padding-start:0px}.input-clear-icon.sc-ion-input-ios ion-icon.sc-ion-input-ios{width:18px;height:18px}.sc-ion-input-ios-h:not(.legacy-input){min-height:44px}.input-label-placement-floating.sc-ion-input-ios-h,.input-label-placement-stacked.sc-ion-input-ios-h{min-height:56px}";
const inputMdCss = ".sc-ion-input-md-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:0.6;--padding-top:0px;--padding-end:0px;--padding-bottom:0px;--padding-start:0px;--background:transparent;--color:initial;--border-style:solid;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);--highlight-color:var(--highlight-color-focused);display:block;position:relative;width:100%;padding:0 !important;color:var(--color);font-family:var(--ion-font-family, inherit);z-index:2}.legacy-input.sc-ion-input-md-h{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;background:var(--background)}.legacy-input.sc-ion-input-md-h .native-input.sc-ion-input-md{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);border-radius:var(--border-radius)}ion-item.sc-ion-input-md-h:not(.item-label):not(.item-has-modern-input),ion-item:not(.item-label):not(.item-has-modern-input) .sc-ion-input-md-h{--padding-start:0}ion-item[slot=start].sc-ion-input-md-h,ion-item [slot=start].sc-ion-input-md-h,ion-item[slot=end].sc-ion-input-md-h,ion-item [slot=end].sc-ion-input-md-h{width:auto}.legacy-input.ion-color.sc-ion-input-md-h{color:var(--ion-color-base)}.ion-color.sc-ion-input-md-h{--highlight-color-focused:var(--ion-color-base)}.native-input.sc-ion-input-md{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:inline-block;position:relative;-ms-flex:1;flex:1;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none;z-index:1}.native-input.sc-ion-input-md::-webkit-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-md::-moz-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-md:-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-md::-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-md::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-md:-webkit-autofill{background-color:transparent}.native-input.sc-ion-input-md:invalid{-webkit-box-shadow:none;box-shadow:none}.native-input.sc-ion-input-md::-ms-clear{display:none}.legacy-input.sc-ion-input-md-h .native-input[disabled].sc-ion-input-md,.input-disabled.sc-ion-input-md-h{opacity:0.4}.cloned-input.sc-ion-input-md{top:0;bottom:0;position:absolute;pointer-events:none}@supports (inset-inline-start: 0){.cloned-input.sc-ion-input-md{inset-inline-start:0}}@supports not (inset-inline-start: 0){.cloned-input.sc-ion-input-md{left:0}[dir=rtl].sc-ion-input-md-h .cloned-input.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h .cloned-input.sc-ion-input-md{left:unset;right:unset;right:0}[dir=rtl].sc-ion-input-md .cloned-input.sc-ion-input-md{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.cloned-input.sc-ion-input-md:dir(rtl){left:unset;right:unset;right:0}}}.cloned-input.sc-ion-input-md:disabled{opacity:1}.legacy-input.sc-ion-input-md-h .input-clear-icon.sc-ion-input-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.input-clear-icon.sc-ion-input-md{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:auto;margin-bottom:auto;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;background-position:center;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:30px;height:30px;border:0;outline:none;background-color:transparent;background-repeat:no-repeat;color:var(--ion-color-step-600, #666666);visibility:hidden;-webkit-appearance:none;-moz-appearance:none;appearance:none}.in-item-color.sc-ion-input-md-h .input-clear-icon.sc-ion-input-md{color:inherit}.input-clear-icon.sc-ion-input-md:focus{opacity:0.5}.has-value.sc-ion-input-md-h .input-clear-icon.sc-ion-input-md{visibility:visible}.has-focus.sc-ion-input-md-h{pointer-events:none}.has-focus.sc-ion-input-md-h input.sc-ion-input-md,.has-focus.sc-ion-input-md-h a.sc-ion-input-md,.has-focus.sc-ion-input-md-h button.sc-ion-input-md{pointer-events:auto}.item-label-floating.item-has-placeholder.sc-ion-input-md-h:not(.item-has-value),.item-label-floating.item-has-placeholder:not(.item-has-value) .sc-ion-input-md-h{opacity:0}.item-label-floating.item-has-placeholder.sc-ion-input-md-h:not(.item-has-value).item-has-focus,.item-label-floating.item-has-placeholder:not(.item-has-value).item-has-focus .sc-ion-input-md-h{-webkit-transition:opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1);opacity:1}.input-wrapper.sc-ion-input-md{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:stretch;align-items:stretch;height:inherit;min-height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;background:var(--background);line-height:normal}.native-wrapper.sc-ion-input-md{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;width:100%}.ion-touched.ion-invalid.sc-ion-input-md-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-input-md-h{--highlight-color:var(--highlight-color-valid)}.input-bottom.sc-ion-input-md{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:5px;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;border-top:var(--border-width) var(--border-style) var(--border-color);font-size:12px}.has-focus.ion-valid.sc-ion-input-md-h,.ion-touched.ion-invalid.sc-ion-input-md-h{--border-color:var(--highlight-color)}.input-bottom.sc-ion-input-md .error-text.sc-ion-input-md{display:none;color:var(--highlight-color-invalid)}.input-bottom.sc-ion-input-md .helper-text.sc-ion-input-md{display:block;color:var(--ion-color-step-550, #737373)}.ion-touched.ion-invalid.sc-ion-input-md-h .input-bottom.sc-ion-input-md .error-text.sc-ion-input-md{display:block}.ion-touched.ion-invalid.sc-ion-input-md-h .input-bottom.sc-ion-input-md .helper-text.sc-ion-input-md{display:none}.input-bottom.sc-ion-input-md .counter.sc-ion-input-md{-webkit-margin-start:auto;margin-inline-start:auto;color:var(--ion-color-step-550, #737373);white-space:nowrap;-webkit-padding-start:16px;padding-inline-start:16px}.has-focus.sc-ion-input-md-h input.sc-ion-input-md{caret-color:var(--highlight-color)}.label-text-wrapper.sc-ion-input-md{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;max-width:200px;-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.label-text.sc-ion-input-md{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.input-wrapper.sc-ion-input-md input.sc-ion-input-md{-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.input-label-placement-start.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{-ms-flex-direction:row;flex-direction:row}.input-label-placement-start.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.input-label-placement-end.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{-ms-flex-direction:row-reverse;flex-direction:row-reverse}.input-label-placement-end.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}.input-label-placement-fixed.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.input-label-placement-fixed.sc-ion-input-md-h .label-text.sc-ion-input-md{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.input-label-placement-stacked.sc-ion-input-md-h .input-wrapper.sc-ion-input-md,.input-label-placement-floating.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:start}.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform-origin:left top;transform-origin:left top;max-width:100%}[dir=rtl].sc-ion-input-md-h -no-combinator.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h -no-combinator.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl].input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl].sc-ion-input-md-h -no-combinator.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h -no-combinator.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl].input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md:dir(rtl),.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md:dir(rtl){-webkit-transform-origin:right top;transform-origin:right top}}.input-label-placement-stacked.sc-ion-input-md-h input.sc-ion-input-md,.input-label-placement-floating.sc-ion-input-md-h input.sc-ion-input-md{margin-left:0;margin-right:0;margin-top:1px;margin-bottom:0}.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform:translateY(100%) scale(1);transform:translateY(100%) scale(1)}.input-label-placement-floating.sc-ion-input-md-h input.sc-ion-input-md{opacity:0}.has-focus.input-label-placement-floating.sc-ion-input-md-h input.sc-ion-input-md,.has-value.input-label-placement-floating.sc-ion-input-md-h input.sc-ion-input-md{opacity:1}.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.has-focus.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.has-value.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);max-width:calc(100% / 0.75)}.input-fill-solid.sc-ion-input-md-h{--background:var(--ion-color-step-50, #f2f2f2);--border-color:var(--ion-color-step-500, gray);--border-radius:4px;--padding-start:16px;--padding-end:16px}.input-fill-solid.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{border-bottom:var(--border-width) var(--border-style) var(--border-color)}.has-focus.input-fill-solid.ion-valid.sc-ion-input-md-h,.input-fill-solid.ion-touched.ion-invalid.sc-ion-input-md-h{--border-color:var(--highlight-color)}.input-fill-solid.sc-ion-input-md-h .input-bottom.sc-ion-input-md{border-top:none}@media (any-hover: hover){.input-fill-solid.sc-ion-input-md-h:hover{--background:var(--ion-color-step-100, #e6e6e6);--border-color:var(--ion-color-step-750, #404040)}}.input-fill-solid.has-focus.sc-ion-input-md-h{--background:var(--ion-color-step-150, #d9d9d9);--border-color:var(--ion-color-step-750, #404040)}.input-fill-solid.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0px;border-bottom-left-radius:0px}[dir=rtl].sc-ion-input-md-h -no-combinator.input-fill-solid.sc-ion-input-md-h .input-wrapper.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h -no-combinator.input-fill-solid.sc-ion-input-md-h .input-wrapper.sc-ion-input-md,[dir=rtl].input-fill-solid.sc-ion-input-md-h .input-wrapper.sc-ion-input-md,[dir=rtl] .input-fill-solid.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0px;border-bottom-left-radius:0px}@supports selector(:dir(rtl)){.input-fill-solid.sc-ion-input-md-h .input-wrapper.sc-ion-input-md:dir(rtl){border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0px;border-bottom-left-radius:0px}}.input-fill-solid.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.has-focus.input-fill-solid.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.has-value.input-fill-solid.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{max-width:calc(100% / 0.75)}.input-fill-outline.sc-ion-input-md-h{--border-color:var(--ion-color-step-300, #b3b3b3);--border-radius:4px;--padding-start:16px;--padding-end:16px}.input-fill-outline.input-shape-round.sc-ion-input-md-h{--border-radius:28px;--padding-start:32px;--padding-end:32px}.has-focus.input-fill-outline.ion-valid.sc-ion-input-md-h,.input-fill-outline.ion-touched.ion-invalid.sc-ion-input-md-h{--border-color:var(--highlight-color)}@media (any-hover: hover){.input-fill-outline.sc-ion-input-md-h:hover{--border-color:var(--ion-color-step-750, #404040)}}.input-fill-outline.has-focus.sc-ion-input-md-h{--border-width:2px;--border-color:var(--highlight-color)}.input-fill-outline.sc-ion-input-md-h .input-bottom.sc-ion-input-md{border-top:none}.input-fill-outline.sc-ion-input-md-h .input-wrapper.sc-ion-input-md{border-bottom:none}.input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform-origin:left top;transform-origin:left top;position:absolute;max-width:calc(100% - var(--padding-start) - var(--padding-end))}[dir=rtl].sc-ion-input-md-h -no-combinator.input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h -no-combinator.input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl].input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl].sc-ion-input-md-h -no-combinator.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h -no-combinator.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl].input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,[dir=rtl] .input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md:dir(rtl),.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md:dir(rtl){-webkit-transform-origin:right top;transform-origin:right top}}.input-fill-outline.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{position:relative;z-index:1}.has-focus.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.has-value.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{-webkit-transform:translateY(-32%) scale(0.75);transform:translateY(-32%) scale(0.75);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;max-width:calc((100% - var(--padding-start) - var(--padding-end) - 8px) / 0.75)}.input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h input.sc-ion-input-md,.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h input.sc-ion-input-md{margin-left:0;margin-right:0;margin-top:6px;margin-bottom:6px}.input-fill-outline.sc-ion-input-md-h .input-outline-container.sc-ion-input-md{left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;width:100%;height:100%}.input-fill-outline.sc-ion-input-md-h .input-outline-start.sc-ion-input-md,.input-fill-outline.sc-ion-input-md-h .input-outline-end.sc-ion-input-md{pointer-events:none}.input-fill-outline.sc-ion-input-md-h .input-outline-start.sc-ion-input-md,.input-fill-outline.sc-ion-input-md-h .input-outline-notch.sc-ion-input-md,.input-fill-outline.sc-ion-input-md-h .input-outline-end.sc-ion-input-md{border-top:var(--border-width) var(--border-style) var(--border-color);border-bottom:var(--border-width) var(--border-style) var(--border-color)}.input-fill-outline.sc-ion-input-md-h .input-outline-notch.sc-ion-input-md{max-width:calc(100% - var(--padding-start) - var(--padding-end))}.input-fill-outline.sc-ion-input-md-h .notch-spacer.sc-ion-input-md{-webkit-padding-end:8px;padding-inline-end:8px;font-size:calc(1em * 0.75);opacity:0;pointer-events:none}.input-fill-outline.sc-ion-input-md-h .input-outline-start.sc-ion-input-md{border-top-left-radius:var(--border-radius);border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:var(--border-radius);-webkit-border-start:var(--border-width) var(--border-style) var(--border-color);border-inline-start:var(--border-width) var(--border-style) var(--border-color);width:calc(var(--padding-start) - 4px)}[dir=rtl].sc-ion-input-md-h -no-combinator.input-fill-outline.sc-ion-input-md-h .input-outline-start.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h -no-combinator.input-fill-outline.sc-ion-input-md-h .input-outline-start.sc-ion-input-md,[dir=rtl].input-fill-outline.sc-ion-input-md-h .input-outline-start.sc-ion-input-md,[dir=rtl] .input-fill-outline.sc-ion-input-md-h .input-outline-start.sc-ion-input-md{border-top-left-radius:0px;border-top-right-radius:var(--border-radius);border-bottom-right-radius:var(--border-radius);border-bottom-left-radius:0px}@supports selector(:dir(rtl)){.input-fill-outline.sc-ion-input-md-h .input-outline-start.sc-ion-input-md:dir(rtl){border-top-left-radius:0px;border-top-right-radius:var(--border-radius);border-bottom-right-radius:var(--border-radius);border-bottom-left-radius:0px}}.input-fill-outline.sc-ion-input-md-h .input-outline-end.sc-ion-input-md{-webkit-border-end:var(--border-width) var(--border-style) var(--border-color);border-inline-end:var(--border-width) var(--border-style) var(--border-color);border-top-left-radius:0px;border-top-right-radius:var(--border-radius);border-bottom-right-radius:var(--border-radius);border-bottom-left-radius:0px;-ms-flex-positive:1;flex-grow:1}[dir=rtl].sc-ion-input-md-h -no-combinator.input-fill-outline.sc-ion-input-md-h .input-outline-end.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h -no-combinator.input-fill-outline.sc-ion-input-md-h .input-outline-end.sc-ion-input-md,[dir=rtl].input-fill-outline.sc-ion-input-md-h .input-outline-end.sc-ion-input-md,[dir=rtl] .input-fill-outline.sc-ion-input-md-h .input-outline-end.sc-ion-input-md{border-top-left-radius:var(--border-radius);border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:var(--border-radius)}@supports selector(:dir(rtl)){.input-fill-outline.sc-ion-input-md-h .input-outline-end.sc-ion-input-md:dir(rtl){border-top-left-radius:var(--border-radius);border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:var(--border-radius)}}.has-focus.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .input-outline-notch.sc-ion-input-md,.has-value.input-fill-outline.input-label-placement-floating.sc-ion-input-md-h .input-outline-notch.sc-ion-input-md,.input-fill-outline.input-label-placement-stacked.sc-ion-input-md-h .input-outline-notch.sc-ion-input-md{border-top:none}.sc-ion-input-md-h{--border-width:1px;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));font-size:inherit}.legacy-input.sc-ion-input-md-h{--padding-top:10px;--padding-end:0;--padding-bottom:10px;--padding-start:8px}.item-label-stacked.sc-ion-input-md-h,.item-label-stacked .sc-ion-input-md-h,.item-label-floating.sc-ion-input-md-h,.item-label-floating .sc-ion-input-md-h{--padding-top:8px;--padding-bottom:8px;--padding-start:0}.input-clear-icon.sc-ion-input-md ion-icon.sc-ion-input-md{width:22px;height:22px}.legacy-input.sc-ion-input-md-h .native-input[disabled].sc-ion-input-md,.input-disabled.sc-ion-input-md-h{opacity:0.37}.has-focus.ion-valid.sc-ion-input-md-h,.ion-touched.ion-invalid.sc-ion-input-md-h{--border-color:var(--highlight-color)}.input-bottom.sc-ion-input-md .counter.sc-ion-input-md{letter-spacing:0.0333333333em}.sc-ion-input-md-h:not(.legacy-input){min-height:56px}.input-label-placement-floating.has-focus.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.input-label-placement-stacked.has-focus.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{color:var(--highlight-color)}.has-focus.input-label-placement-floating.ion-valid.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.input-label-placement-floating.ion-touched.ion-invalid.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.has-focus.input-label-placement-stacked.ion-valid.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md,.input-label-placement-stacked.ion-touched.ion-invalid.sc-ion-input-md-h .label-text-wrapper.sc-ion-input-md{color:var(--highlight-color)}.input-highlight.sc-ion-input-md{bottom:-1px;position:absolute;width:100%;height:2px;-webkit-transform:scale(0);transform:scale(0);-webkit-transition:-webkit-transform 200ms;transition:-webkit-transform 200ms;transition:transform 200ms;transition:transform 200ms, -webkit-transform 200ms;background:var(--highlight-color)}@supports (inset-inline-start: 0){.input-highlight.sc-ion-input-md{inset-inline-start:0}}@supports not (inset-inline-start: 0){.input-highlight.sc-ion-input-md{left:0}[dir=rtl].sc-ion-input-md-h .input-highlight.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h .input-highlight.sc-ion-input-md{left:unset;right:unset;right:0}[dir=rtl].sc-ion-input-md .input-highlight.sc-ion-input-md{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.input-highlight.sc-ion-input-md:dir(rtl){left:unset;right:unset;right:0}}}.has-focus.sc-ion-input-md-h .input-highlight.sc-ion-input-md{-webkit-transform:scale(1);transform:scale(1)}.in-item.sc-ion-input-md-h .input-highlight.sc-ion-input-md{bottom:0}@supports (inset-inline-start: 0){.in-item.sc-ion-input-md-h .input-highlight.sc-ion-input-md{inset-inline-start:0}}@supports not (inset-inline-start: 0){.in-item.sc-ion-input-md-h .input-highlight.sc-ion-input-md{left:0}[dir=rtl].sc-ion-input-md-h -no-combinator.in-item.sc-ion-input-md-h .input-highlight.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h -no-combinator.in-item.sc-ion-input-md-h .input-highlight.sc-ion-input-md,[dir=rtl].in-item.sc-ion-input-md-h .input-highlight.sc-ion-input-md,[dir=rtl] .in-item.sc-ion-input-md-h .input-highlight.sc-ion-input-md{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.in-item.sc-ion-input-md-h .input-highlight.sc-ion-input-md:dir(rtl){left:unset;right:unset;right:0}}}.input-shape-round.sc-ion-input-md-h{--border-radius:16px}";
const Input = /* @__PURE__ */ proxyCustomElement$1(class Input2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.ionInput = createEvent(this, "ionInput", 7);
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.inputId = `ion-input-${inputIds++}`;
    this.inheritedAttributes = {};
    this.isComposing = false;
    this.hasLoggedDeprecationWarning = false;
    this.didInputClearOnEdit = false;
    this.onInput = (ev) => {
      const input = ev.target;
      if (input) {
        this.value = input.value || "";
      }
      this.emitInputChange(ev);
    };
    this.onChange = (ev) => {
      this.emitValueChange(ev);
    };
    this.onBlur = (ev) => {
      this.hasFocus = false;
      this.emitStyle();
      if (this.focusedValue !== this.value) {
        this.emitValueChange(ev);
      }
      this.didInputClearOnEdit = false;
      this.ionBlur.emit(ev);
    };
    this.onFocus = (ev) => {
      this.hasFocus = true;
      this.focusedValue = this.value;
      this.emitStyle();
      this.ionFocus.emit(ev);
    };
    this.onKeydown = (ev) => {
      this.checkClearOnEdit(ev);
    };
    this.onCompositionStart = () => {
      this.isComposing = true;
    };
    this.onCompositionEnd = () => {
      this.isComposing = false;
    };
    this.clearTextInput = (ev) => {
      if (this.clearInput && !this.readonly && !this.disabled && ev) {
        ev.preventDefault();
        ev.stopPropagation();
        this.setFocus();
      }
      this.value = "";
      this.emitInputChange(ev);
    };
    this.hasFocus = false;
    this.color = void 0;
    this.accept = void 0;
    this.autocapitalize = "off";
    this.autocomplete = "off";
    this.autocorrect = "off";
    this.autofocus = false;
    this.clearInput = false;
    this.clearOnEdit = void 0;
    this.counter = false;
    this.counterFormatter = void 0;
    this.debounce = void 0;
    this.disabled = false;
    this.enterkeyhint = void 0;
    this.errorText = void 0;
    this.fill = void 0;
    this.inputmode = void 0;
    this.helperText = void 0;
    this.label = void 0;
    this.labelPlacement = "start";
    this.legacy = void 0;
    this.max = void 0;
    this.maxlength = void 0;
    this.min = void 0;
    this.minlength = void 0;
    this.multiple = void 0;
    this.name = this.inputId;
    this.pattern = void 0;
    this.placeholder = void 0;
    this.readonly = false;
    this.required = false;
    this.shape = void 0;
    this.spellcheck = false;
    this.step = void 0;
    this.size = void 0;
    this.type = "text";
    this.value = "";
  }
  debounceChanged() {
    const { ionInput, debounce: debounce2, originalIonInput } = this;
    this.ionInput = debounce2 === void 0 ? originalIonInput !== null && originalIonInput !== void 0 ? originalIonInput : ionInput : debounceEvent(ionInput, debounce2);
  }
  disabledChanged() {
    this.emitStyle();
  }
  /**
   * Update the item classes when the placeholder changes
   */
  placeholderChanged() {
    this.emitStyle();
  }
  /**
   * Update the native input element when the value changes
   */
  valueChanged() {
    const nativeInput = this.nativeInput;
    const value = this.getValue();
    if (nativeInput && nativeInput.value !== value && !this.isComposing) {
      nativeInput.value = value;
    }
    this.emitStyle();
  }
  componentWillLoad() {
    this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes$2(this.el, ["tabindex", "title", "data-form-type"]));
  }
  connectedCallback() {
    const { el: el2 } = this;
    this.legacyFormController = createLegacyFormController(el2);
    this.emitStyle();
    this.debounceChanged();
    {
      document.dispatchEvent(new CustomEvent("ionInputDidLoad", {
        detail: this.el
      }));
    }
  }
  componentDidLoad() {
    this.originalIonInput = this.ionInput;
  }
  disconnectedCallback() {
    {
      document.dispatchEvent(new CustomEvent("ionInputDidUnload", {
        detail: this.el
      }));
    }
  }
  /**
   * Sets focus on the native `input` in `ion-input`. Use this method instead of the global
   * `input.focus()`.
   *
   * Developers who wish to focus an input when a page enters
   * should call `setFocus()` in the `ionViewDidEnter()` lifecycle method.
   *
   * Developers who wish to focus an input when an overlay is presented
   * should call `setFocus` after `didPresent` has resolved.
   */
  async setFocus() {
    if (this.nativeInput) {
      this.nativeInput.focus();
    }
  }
  /**
   * Returns the native `<input>` element used under the hood.
   */
  getInputElement() {
    return Promise.resolve(this.nativeInput);
  }
  /**
   * Emits an `ionChange` event.
   *
   * This API should be called for user committed changes.
   * This API should not be used for external value changes.
   */
  emitValueChange(event) {
    const { value } = this;
    const newValue = value == null ? value : value.toString();
    this.focusedValue = newValue;
    this.ionChange.emit({ value: newValue, event });
  }
  /**
   * Emits an `ionInput` event.
   */
  emitInputChange(event) {
    const { value } = this;
    const newValue = value == null ? value : value.toString();
    this.ionInput.emit({ value: newValue, event });
  }
  shouldClearOnEdit() {
    const { type: type3, clearOnEdit } = this;
    return clearOnEdit === void 0 ? type3 === "password" : clearOnEdit;
  }
  getValue() {
    return typeof this.value === "number" ? this.value.toString() : (this.value || "").toString();
  }
  emitStyle() {
    if (this.legacyFormController.hasLegacyControl()) {
      this.ionStyle.emit({
        interactive: true,
        input: true,
        "has-placeholder": this.placeholder !== void 0,
        "has-value": this.hasValue(),
        "has-focus": this.hasFocus,
        "interactive-disabled": this.disabled
      });
    }
  }
  checkClearOnEdit(ev) {
    if (!this.shouldClearOnEdit()) {
      return;
    }
    if (!this.didInputClearOnEdit && this.hasValue() && ev.key !== "Enter") {
      this.value = "";
      this.emitInputChange(ev);
    }
    this.didInputClearOnEdit = true;
  }
  hasValue() {
    return this.getValue().length > 0;
  }
  /**
   * Renders the helper text or error text values
   */
  renderHintText() {
    const { helperText, errorText } = this;
    return [h$5("div", { class: "helper-text" }, helperText), h$5("div", { class: "error-text" }, errorText)];
  }
  renderCounter() {
    const { counter, maxlength, counterFormatter, value } = this;
    if (counter !== true || maxlength === void 0) {
      return;
    }
    return h$5("div", { class: "counter" }, getCounterText(value, maxlength, counterFormatter));
  }
  /**
   * Responsible for rendering helper text,
   * error text, and counter. This element should only
   * be rendered if hint text is set or counter is enabled.
   */
  renderBottomContent() {
    const { counter, helperText, errorText, maxlength } = this;
    const hasHintText = !!helperText || !!errorText;
    const hasCounter = counter === true && maxlength !== void 0;
    if (!hasHintText && !hasCounter) {
      return;
    }
    return h$5("div", { class: "input-bottom" }, this.renderHintText(), this.renderCounter());
  }
  renderLabel() {
    const { label } = this;
    if (label === void 0) {
      return;
    }
    return h$5("div", { class: "label-text-wrapper" }, h$5("div", { class: "label-text" }, this.label));
  }
  /**
   * Renders the border container
   * when fill="outline".
   */
  renderLabelContainer() {
    const mode = getIonMode$2(this);
    const hasOutlineFill = mode === "md" && this.fill === "outline";
    if (hasOutlineFill) {
      return [
        h$5("div", { class: "input-outline-container" }, h$5("div", { class: "input-outline-start" }), h$5("div", { class: "input-outline-notch" }, h$5("div", { class: "notch-spacer", "aria-hidden": "true" }, this.label)), h$5("div", { class: "input-outline-end" })),
        this.renderLabel()
      ];
    }
    return this.renderLabel();
  }
  renderInput() {
    const { disabled, fill, readonly, shape, inputId, labelPlacement } = this;
    const mode = getIonMode$2(this);
    const value = this.getValue();
    const inItem = hostContext("ion-item", this.el);
    const shouldRenderHighlight = mode === "md" && fill !== "outline" && !inItem;
    return h$5(Host$1, { class: createColorClasses$1(this.color, {
      [mode]: true,
      "has-value": this.hasValue(),
      "has-focus": this.hasFocus,
      [`input-fill-${fill}`]: fill !== void 0,
      [`input-shape-${shape}`]: shape !== void 0,
      [`input-label-placement-${labelPlacement}`]: true,
      "in-item": inItem,
      "in-item-color": hostContext("ion-item.ion-color", this.el),
      "input-disabled": disabled
    }) }, h$5("label", { class: "input-wrapper" }, this.renderLabelContainer(), h$5("div", { class: "native-wrapper" }, h$5("input", Object.assign({ class: "native-input", ref: (input) => this.nativeInput = input, id: inputId, disabled, accept: this.accept, autoCapitalize: this.autocapitalize, autoComplete: this.autocomplete, autoCorrect: this.autocorrect, autoFocus: this.autofocus, enterKeyHint: this.enterkeyhint, inputMode: this.inputmode, min: this.min, max: this.max, minLength: this.minlength, maxLength: this.maxlength, multiple: this.multiple, name: this.name, pattern: this.pattern, placeholder: this.placeholder || "", readOnly: readonly, required: this.required, spellcheck: this.spellcheck, step: this.step, size: this.size, type: this.type, value, onInput: this.onInput, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, onKeyDown: this.onKeydown, onCompositionstart: this.onCompositionStart, onCompositionend: this.onCompositionEnd }, this.inheritedAttributes)), this.clearInput && !readonly && !disabled && h$5("button", { "aria-label": "reset", type: "button", class: "input-clear-icon", onPointerDown: (ev) => {
      ev.preventDefault();
    }, onClick: this.clearTextInput }, h$5("ion-icon", { "aria-hidden": "true", icon: mode === "ios" ? closeCircle$1 : closeSharp }))), shouldRenderHighlight && h$5("div", { class: "input-highlight" })), this.renderBottomContent());
  }
  // TODO FW-2764 Remove this
  renderLegacyInput() {
    if (!this.hasLoggedDeprecationWarning) {
      printIonWarning(`ion-input now requires providing a label with either the "label" property or the "aria-label" attribute. To migrate, remove any usage of "ion-label" and pass the label text to either the "label" property or the "aria-label" attribute.

Example: <ion-input label="Email"></ion-input>
Example with aria-label: <ion-input aria-label="Email"></ion-input>

For inputs that do not render the label immediately next to the input, developers may continue to use "ion-label" but must manually associate the label with the input by using "aria-labelledby".

Developers can use the "legacy" property to continue using the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.`, this.el);
      if (this.legacy) {
        printIonWarning(`ion-input is being used with the "legacy" property enabled which will forcibly enable the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.

Developers can dismiss this warning by removing their usage of the "legacy" property and using the new input syntax.`, this.el);
      }
      this.hasLoggedDeprecationWarning = true;
    }
    const mode = getIonMode$2(this);
    const value = this.getValue();
    const labelId = this.inputId + "-lbl";
    const label = findItemLabel(this.el);
    if (label) {
      label.id = labelId;
    }
    return h$5(Host$1, { "aria-disabled": this.disabled ? "true" : null, class: createColorClasses$1(this.color, {
      [mode]: true,
      "has-value": this.hasValue(),
      "has-focus": this.hasFocus,
      "legacy-input": true,
      "in-item-color": hostContext("ion-item.ion-color", this.el)
    }) }, h$5("input", Object.assign({ class: "native-input", ref: (input) => this.nativeInput = input, "aria-labelledby": label ? label.id : null, disabled: this.disabled, accept: this.accept, autoCapitalize: this.autocapitalize, autoComplete: this.autocomplete, autoCorrect: this.autocorrect, autoFocus: this.autofocus, enterKeyHint: this.enterkeyhint, inputMode: this.inputmode, min: this.min, max: this.max, minLength: this.minlength, maxLength: this.maxlength, multiple: this.multiple, name: this.name, pattern: this.pattern, placeholder: this.placeholder || "", readOnly: this.readonly, required: this.required, spellcheck: this.spellcheck, step: this.step, size: this.size, type: this.type, value, onInput: this.onInput, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, onKeyDown: this.onKeydown }, this.inheritedAttributes)), this.clearInput && !this.readonly && !this.disabled && h$5("button", { "aria-label": "reset", type: "button", class: "input-clear-icon", onPointerDown: (ev) => {
      ev.preventDefault();
    }, onClick: this.clearTextInput }, h$5("ion-icon", { "aria-hidden": "true", icon: mode === "ios" ? closeCircle$1 : closeSharp })));
  }
  render() {
    const { legacyFormController } = this;
    return legacyFormController.hasLegacyControl() ? this.renderLegacyInput() : this.renderInput();
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "debounce": ["debounceChanged"],
      "disabled": ["disabledChanged"],
      "placeholder": ["placeholderChanged"],
      "value": ["valueChanged"]
    };
  }
  static get style() {
    return {
      ios: inputIosCss,
      md: inputMdCss
    };
  }
}, [34, "ion-input", {
  "color": [513],
  "accept": [1],
  "autocapitalize": [1],
  "autocomplete": [1],
  "autocorrect": [1],
  "autofocus": [4],
  "clearInput": [4, "clear-input"],
  "clearOnEdit": [4, "clear-on-edit"],
  "counter": [4],
  "counterFormatter": [16],
  "debounce": [2],
  "disabled": [4],
  "enterkeyhint": [1],
  "errorText": [1, "error-text"],
  "fill": [1],
  "inputmode": [1],
  "helperText": [1, "helper-text"],
  "label": [1],
  "labelPlacement": [1, "label-placement"],
  "legacy": [4],
  "max": [8],
  "maxlength": [2],
  "min": [8],
  "minlength": [2],
  "multiple": [4],
  "name": [1],
  "pattern": [1],
  "placeholder": [1],
  "readonly": [4],
  "required": [4],
  "shape": [1],
  "spellcheck": [4],
  "step": [1],
  "size": [2],
  "type": [1],
  "value": [1032],
  "hasFocus": [32],
  "setFocus": [64],
  "getInputElement": [64]
}]);
let inputIds = 0;
function defineCustomElement$1$r() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-input", "ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-input":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Input);
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$1b();
        }
        break;
    }
  });
}
const defineCustomElement$H = defineCustomElement$1$r;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const itemDividerIosCss = ":host{--padding-top:0px;--padding-end:0px;--padding-bottom:0px;--padding-start:0px;--inner-padding-top:0px;--inner-padding-end:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);overflow:hidden;z-index:100;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.item-divider-sticky){position:-webkit-sticky;position:sticky;top:0}.item-divider-inner{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--inner-padding-start);padding-inline-start:var(--inner-padding-start);-webkit-padding-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-inline-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border:0;overflow:hidden}.item-divider-wrapper{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;text-overflow:ellipsis;overflow:hidden}:host{--background:var(--ion-color-step-100, #e6e6e6);--color:var(--ion-color-step-850, #262626);--padding-start:16px;--inner-padding-end:8px;border-radius:0;position:relative;min-height:28px;font-size:17px;font-weight:600}:host([slot=start]){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:2px;margin-bottom:2px}::slotted(ion-icon[slot=start]),::slotted(ion-icon[slot=end]){margin-top:7px;margin-bottom:7px}::slotted(h1){margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}::slotted(h2){margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:17px;font-weight:normal}::slotted(h3),::slotted(h4),::slotted(h5),::slotted(h6){margin-left:0;margin-right:0;margin-top:0;margin-bottom:3px;font-size:14px;font-weight:normal;line-height:normal}::slotted(p){margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.4);font-size:14px;line-height:normal;text-overflow:inherit;overflow:inherit}::slotted(h2:last-child) ::slotted(h3:last-child),::slotted(h4:last-child),::slotted(h5:last-child),::slotted(h6:last-child),::slotted(p:last-child){margin-bottom:0}";
const itemDividerMdCss = ":host{--padding-top:0px;--padding-end:0px;--padding-bottom:0px;--padding-start:0px;--inner-padding-top:0px;--inner-padding-end:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);overflow:hidden;z-index:100;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.item-divider-sticky){position:-webkit-sticky;position:sticky;top:0}.item-divider-inner{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--inner-padding-start);padding-inline-start:var(--inner-padding-start);-webkit-padding-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-inline-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border:0;overflow:hidden}.item-divider-wrapper{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;text-overflow:ellipsis;overflow:hidden}:host{--background:var(--ion-background-color, #fff);--color:var(--ion-color-step-400, #999999);--padding-start:16px;--inner-padding-end:16px;min-height:30px;border-bottom:1px solid var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));font-size:14px}::slotted([slot=start]){-webkit-margin-end:32px;margin-inline-end:32px}::slotted([slot=end]){-webkit-margin-start:32px;margin-inline-start:32px}::slotted(ion-label){margin-left:0;margin-right:0;margin-top:13px;margin-bottom:10px}::slotted(ion-icon){color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54);font-size:24px}:host(.ion-color) ::slotted(ion-icon){color:var(--ion-color-contrast)}::slotted(ion-icon[slot]){margin-top:12px;margin-bottom:12px}::slotted(ion-icon[slot=start]){-webkit-margin-end:32px;margin-inline-end:32px}::slotted(ion-icon[slot=end]){-webkit-margin-start:16px;margin-inline-start:16px}::slotted(ion-note){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-ms-flex-item-align:start;align-self:flex-start;font-size:11px}::slotted(ion-note[slot]){padding-left:0;padding-right:0;padding-top:18px;padding-bottom:10px}::slotted(ion-note[slot=start]){-webkit-padding-end:16px;padding-inline-end:16px}::slotted(ion-note[slot=end]){-webkit-padding-start:16px;padding-inline-start:16px}::slotted(ion-avatar){width:40px;height:40px}::slotted(ion-thumbnail){--size:56px}::slotted(ion-avatar),::slotted(ion-thumbnail){margin-top:8px;margin-bottom:8px}::slotted(ion-avatar[slot=start]),::slotted(ion-thumbnail[slot=start]){-webkit-margin-end:16px;margin-inline-end:16px}::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){-webkit-margin-start:16px;margin-inline-start:16px}::slotted(h1){margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}::slotted(h2){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:16px;font-weight:normal}::slotted(h3,h4,h5,h6){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:14px;font-weight:normal;line-height:normal}::slotted(p){margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;color:var(--ion-color-step-600, #666666);font-size:14px;line-height:normal;text-overflow:inherit;overflow:inherit}";
const ItemDivider = /* @__PURE__ */ proxyCustomElement$1(class ItemDivider2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.color = void 0;
    this.sticky = false;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: createColorClasses$1(this.color, {
      [mode]: true,
      "item-divider-sticky": this.sticky,
      item: true
    }) }, h$5("slot", { name: "start" }), h$5("div", { class: "item-divider-inner" }, h$5("div", { class: "item-divider-wrapper" }, h$5("slot", null)), h$5("slot", { name: "end" })));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: itemDividerIosCss,
      md: itemDividerMdCss
    };
  }
}, [33, "ion-item-divider", {
  "color": [513],
  "sticky": [4]
}]);
function defineCustomElement$1$q() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-item-divider"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-item-divider":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ItemDivider);
        }
        break;
    }
  });
}
const defineCustomElement$G = defineCustomElement$1$q;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const itemGroupIosCss = "ion-item-group{display:block}";
const itemGroupMdCss = "ion-item-group{display:block}";
const ItemGroup = /* @__PURE__ */ proxyCustomElement$1(class ItemGroup2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { role: "group", class: {
      [mode]: true,
      // Used internally for styling
      [`item-group-${mode}`]: true,
      item: true
    } });
  }
  static get style() {
    return {
      ios: itemGroupIosCss,
      md: itemGroupMdCss
    };
  }
}, [32, "ion-item-group"]);
function defineCustomElement$1$p() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-item-group"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-item-group":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ItemGroup);
        }
        break;
    }
  });
}
const defineCustomElement$F = defineCustomElement$1$p;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const itemOptionsIosCss = "ion-item-options{top:0;right:0;-ms-flex-pack:end;justify-content:flex-end;display:none;position:absolute;height:100%;font-size:14px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1}:host-context([dir=rtl]) ion-item-options{-ms-flex-pack:start;justify-content:flex-start}:host-context([dir=rtl]) ion-item-options:not(.item-options-end){right:auto;left:0;-ms-flex-pack:end;justify-content:flex-end}[dir=rtl] ion-item-options{-ms-flex-pack:start;justify-content:flex-start}[dir=rtl] ion-item-options:not(.item-options-end){right:auto;left:0;-ms-flex-pack:end;justify-content:flex-end}@supports selector(:dir(rtl)){ion-item-options:dir(rtl){-ms-flex-pack:start;justify-content:flex-start}ion-item-options:dir(rtl):not(.item-options-end){right:auto;left:0;-ms-flex-pack:end;justify-content:flex-end}}.item-options-start{right:auto;left:0;-ms-flex-pack:start;justify-content:flex-start}:host-context([dir=rtl]) .item-options-start{-ms-flex-pack:end;justify-content:flex-end}[dir=rtl] .item-options-start{-ms-flex-pack:end;justify-content:flex-end}@supports selector(:dir(rtl)){.item-options-start:dir(rtl){-ms-flex-pack:end;justify-content:flex-end}}.item-options-start ion-item-option:first-child{-webkit-padding-end:var(--ion-safe-area-left);padding-inline-end:var(--ion-safe-area-left)}.item-options-end ion-item-option:last-child{-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}:host-context([dir=rtl]) .item-sliding-active-slide.item-sliding-active-options-start ion-item-options:not(.item-options-end){width:100%;visibility:visible}[dir=rtl] .item-sliding-active-slide.item-sliding-active-options-start ion-item-options:not(.item-options-end){width:100%;visibility:visible}@supports selector(:dir(rtl)){.item-sliding-active-slide:dir(rtl).item-sliding-active-options-start ion-item-options:not(.item-options-end){width:100%;visibility:visible}}.item-sliding-active-slide ion-item-options{display:-ms-flexbox;display:flex;visibility:hidden}.item-sliding-active-slide.item-sliding-active-options-start .item-options-start,.item-sliding-active-slide.item-sliding-active-options-end ion-item-options:not(.item-options-start){width:100%;visibility:visible}.item-options-ios{border-bottom-width:0;border-bottom-style:solid;border-bottom-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)))}.item-options-ios.item-options-end{border-bottom-width:0.55px}.list-ios-lines-none .item-options-ios{border-bottom-width:0}.list-ios-lines-full .item-options-ios,.list-ios-lines-inset .item-options-ios.item-options-end{border-bottom-width:0.55px}";
const itemOptionsMdCss = "ion-item-options{top:0;right:0;-ms-flex-pack:end;justify-content:flex-end;display:none;position:absolute;height:100%;font-size:14px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1}:host-context([dir=rtl]) ion-item-options{-ms-flex-pack:start;justify-content:flex-start}:host-context([dir=rtl]) ion-item-options:not(.item-options-end){right:auto;left:0;-ms-flex-pack:end;justify-content:flex-end}[dir=rtl] ion-item-options{-ms-flex-pack:start;justify-content:flex-start}[dir=rtl] ion-item-options:not(.item-options-end){right:auto;left:0;-ms-flex-pack:end;justify-content:flex-end}@supports selector(:dir(rtl)){ion-item-options:dir(rtl){-ms-flex-pack:start;justify-content:flex-start}ion-item-options:dir(rtl):not(.item-options-end){right:auto;left:0;-ms-flex-pack:end;justify-content:flex-end}}.item-options-start{right:auto;left:0;-ms-flex-pack:start;justify-content:flex-start}:host-context([dir=rtl]) .item-options-start{-ms-flex-pack:end;justify-content:flex-end}[dir=rtl] .item-options-start{-ms-flex-pack:end;justify-content:flex-end}@supports selector(:dir(rtl)){.item-options-start:dir(rtl){-ms-flex-pack:end;justify-content:flex-end}}.item-options-start ion-item-option:first-child{-webkit-padding-end:var(--ion-safe-area-left);padding-inline-end:var(--ion-safe-area-left)}.item-options-end ion-item-option:last-child{-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}:host-context([dir=rtl]) .item-sliding-active-slide.item-sliding-active-options-start ion-item-options:not(.item-options-end){width:100%;visibility:visible}[dir=rtl] .item-sliding-active-slide.item-sliding-active-options-start ion-item-options:not(.item-options-end){width:100%;visibility:visible}@supports selector(:dir(rtl)){.item-sliding-active-slide:dir(rtl).item-sliding-active-options-start ion-item-options:not(.item-options-end){width:100%;visibility:visible}}.item-sliding-active-slide ion-item-options{display:-ms-flexbox;display:flex;visibility:hidden}.item-sliding-active-slide.item-sliding-active-options-start .item-options-start,.item-sliding-active-slide.item-sliding-active-options-end ion-item-options:not(.item-options-start){width:100%;visibility:visible}.item-options-md{border-bottom-width:0;border-bottom-style:solid;border-bottom-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))))}.list-md-lines-none .item-options-md{border-bottom-width:0}.list-md-lines-full .item-options-md,.list-md-lines-inset .item-options-md.item-options-end{border-bottom-width:1px}";
const ItemOptions = /* @__PURE__ */ proxyCustomElement$1(class ItemOptions2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.ionSwipe = createEvent(this, "ionSwipe", 7);
    this.side = "end";
  }
  /** @internal */
  async fireSwipeEvent() {
    this.ionSwipe.emit({
      side: this.side
    });
  }
  render() {
    const mode = getIonMode$2(this);
    const isEnd3 = isEndSide(this.side);
    return h$5(Host$1, { class: {
      [mode]: true,
      // Used internally for styling
      [`item-options-${mode}`]: true,
      "item-options-start": !isEnd3,
      "item-options-end": isEnd3
    } });
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: itemOptionsIosCss,
      md: itemOptionsMdCss
    };
  }
}, [32, "ion-item-options", {
  "side": [1],
  "fireSwipeEvent": [64]
}]);
function defineCustomElement$1$o() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-item-options"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-item-options":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ItemOptions);
        }
        break;
    }
  });
}
const defineCustomElement$E = defineCustomElement$1$o;
const itemSlidingCss = "ion-item-sliding{display:block;position:relative;width:100%;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}ion-item-sliding .item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.item-sliding-active-slide .item{position:relative;-webkit-transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:-webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1), -webkit-transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);opacity:1;z-index:2;pointer-events:none;will-change:transform}.item-sliding-active-swipe-end .item-options-end .item-option-expandable{padding-left:100%;-ms-flex-order:1;order:1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-left;transition-property:padding-left}:host-context([dir=rtl]) .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}[dir=rtl] .item-sliding-active-swipe-end .item-options-end .item-option-expandable{-ms-flex-order:-1;order:-1}@supports selector(:dir(rtl)){.item-sliding-active-swipe-end .item-options-end .item-option-expandable:dir(rtl){-ms-flex-order:-1;order:-1}}.item-sliding-active-swipe-start .item-options-start .item-option-expandable{padding-right:100%;-ms-flex-order:-1;order:-1;-webkit-transition-duration:0.6s;transition-duration:0.6s;-webkit-transition-property:padding-right;transition-property:padding-right}:host-context([dir=rtl]) .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}[dir=rtl] .item-sliding-active-swipe-start .item-options-start .item-option-expandable{-ms-flex-order:1;order:1}@supports selector(:dir(rtl)){.item-sliding-active-swipe-start .item-options-start .item-option-expandable:dir(rtl){-ms-flex-order:1;order:1}}";
const SWIPE_MARGIN = 30;
const ELASTIC_FACTOR = 0.55;
let openSlidingItem;
const ItemSliding = /* @__PURE__ */ proxyCustomElement$1(class ItemSliding2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.ionDrag = createEvent(this, "ionDrag", 7);
    this.item = null;
    this.openAmount = 0;
    this.initialOpenAmount = 0;
    this.optsWidthRightSide = 0;
    this.optsWidthLeftSide = 0;
    this.sides = 0;
    this.optsDirty = true;
    this.contentEl = null;
    this.initialContentScrollY = true;
    this.state = 2;
    this.disabled = false;
  }
  disabledChanged() {
    if (this.gesture) {
      this.gesture.enable(!this.disabled);
    }
  }
  async connectedCallback() {
    this.item = this.el.querySelector("ion-item");
    this.contentEl = findClosestIonContent(this.el);
    await this.updateOptions();
    this.gesture = (await __vitePreload(() => Promise.resolve().then(() => index2), true ? void 0 : void 0)).createGesture({
      el: this.el,
      gestureName: "item-swipe",
      gesturePriority: 100,
      threshold: 5,
      canStart: (ev) => this.canStart(ev),
      onStart: () => this.onStart(),
      onMove: (ev) => this.onMove(ev),
      onEnd: (ev) => this.onEnd(ev)
    });
    this.disabledChanged();
  }
  disconnectedCallback() {
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
    this.item = null;
    this.leftOptions = this.rightOptions = void 0;
    if (openSlidingItem === this.el) {
      openSlidingItem = void 0;
    }
  }
  /**
   * Get the amount the item is open in pixels.
   */
  getOpenAmount() {
    return Promise.resolve(this.openAmount);
  }
  /**
   * Get the ratio of the open amount of the item compared to the width of the options.
   * If the number returned is positive, then the options on the right side are open.
   * If the number returned is negative, then the options on the left side are open.
   * If the absolute value of the number is greater than 1, the item is open more than
   * the width of the options.
   */
  getSlidingRatio() {
    return Promise.resolve(this.getSlidingRatioSync());
  }
  /**
   * Open the sliding item.
   *
   * @param side The side of the options to open. If a side is not provided, it will open the first set of options it finds within the item.
   */
  async open(side) {
    var _a2;
    const item = this.item = (_a2 = this.item) !== null && _a2 !== void 0 ? _a2 : this.el.querySelector("ion-item");
    if (item === null) {
      return;
    }
    const optionsToOpen = this.getOptions(side);
    if (!optionsToOpen) {
      return;
    }
    if (side === void 0) {
      side = optionsToOpen === this.leftOptions ? "start" : "end";
    }
    side = isEndSide(side) ? "end" : "start";
    const isStartOpen = this.openAmount < 0;
    const isEndOpen = this.openAmount > 0;
    if (isStartOpen && optionsToOpen === this.leftOptions) {
      return;
    }
    if (isEndOpen && optionsToOpen === this.rightOptions) {
      return;
    }
    this.closeOpened();
    this.state = 4;
    requestAnimationFrame(() => {
      this.calculateOptsWidth();
      const width = side === "end" ? this.optsWidthRightSide : -this.optsWidthLeftSide;
      openSlidingItem = this.el;
      this.setOpenAmount(width, false);
      this.state = side === "end" ? 8 : 16;
    });
  }
  /**
   * Close the sliding item. Items can also be closed from the [List](./list).
   */
  async close() {
    this.setOpenAmount(0, true);
  }
  /**
   * Close all of the sliding items in the list. Items can also be closed from the [List](./list).
   */
  async closeOpened() {
    if (openSlidingItem !== void 0) {
      openSlidingItem.close();
      openSlidingItem = void 0;
      return true;
    }
    return false;
  }
  /**
   * Given an optional side, return the ion-item-options element.
   *
   * @param side This side of the options to get. If a side is not provided it will
   * return the first one available.
   */
  getOptions(side) {
    if (side === void 0) {
      return this.leftOptions || this.rightOptions;
    } else if (side === "start") {
      return this.leftOptions;
    } else {
      return this.rightOptions;
    }
  }
  async updateOptions() {
    const options = this.el.querySelectorAll("ion-item-options");
    let sides = 0;
    this.leftOptions = this.rightOptions = void 0;
    for (let i = 0; i < options.length; i++) {
      const item = options.item(i);
      const option = item.componentOnReady !== void 0 ? await item.componentOnReady() : item;
      const side = isEndSide(option.side) ? "end" : "start";
      if (side === "start") {
        this.leftOptions = option;
        sides |= 1;
      } else {
        this.rightOptions = option;
        sides |= 2;
      }
    }
    this.optsDirty = true;
    this.sides = sides;
  }
  canStart(gesture) {
    const rtl = document.dir === "rtl";
    const atEdge = rtl ? window.innerWidth - gesture.startX < 15 : gesture.startX < 15;
    if (atEdge) {
      return false;
    }
    const selected = openSlidingItem;
    if (selected && selected !== this.el) {
      this.closeOpened();
    }
    return !!(this.rightOptions || this.leftOptions);
  }
  onStart() {
    this.item = this.el.querySelector("ion-item");
    const { contentEl } = this;
    if (contentEl) {
      this.initialContentScrollY = disableContentScrollY(contentEl);
    }
    openSlidingItem = this.el;
    if (this.tmr !== void 0) {
      clearTimeout(this.tmr);
      this.tmr = void 0;
    }
    if (this.openAmount === 0) {
      this.optsDirty = true;
      this.state = 4;
    }
    this.initialOpenAmount = this.openAmount;
    if (this.item) {
      this.item.style.transition = "none";
    }
  }
  onMove(gesture) {
    if (this.optsDirty) {
      this.calculateOptsWidth();
    }
    let openAmount = this.initialOpenAmount - gesture.deltaX;
    switch (this.sides) {
      case 2:
        openAmount = Math.max(0, openAmount);
        break;
      case 1:
        openAmount = Math.min(0, openAmount);
        break;
      case 3:
        break;
      case 0:
        return;
      default:
        console.warn("invalid ItemSideFlags value", this.sides);
        break;
    }
    let optsWidth;
    if (openAmount > this.optsWidthRightSide) {
      optsWidth = this.optsWidthRightSide;
      openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;
    } else if (openAmount < -this.optsWidthLeftSide) {
      optsWidth = -this.optsWidthLeftSide;
      openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;
    }
    this.setOpenAmount(openAmount, false);
  }
  onEnd(gesture) {
    const { contentEl, initialContentScrollY } = this;
    if (contentEl) {
      resetContentScrollY(contentEl, initialContentScrollY);
    }
    const velocity = gesture.velocityX;
    let restingPoint = this.openAmount > 0 ? this.optsWidthRightSide : -this.optsWidthLeftSide;
    const isResetDirection = this.openAmount > 0 === !(velocity < 0);
    const isMovingFast = Math.abs(velocity) > 0.3;
    const isOnCloseZone = Math.abs(this.openAmount) < Math.abs(restingPoint / 2);
    if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {
      restingPoint = 0;
    }
    const state = this.state;
    this.setOpenAmount(restingPoint, true);
    if ((state & 32) !== 0 && this.rightOptions) {
      this.rightOptions.fireSwipeEvent();
    } else if ((state & 64) !== 0 && this.leftOptions) {
      this.leftOptions.fireSwipeEvent();
    }
  }
  calculateOptsWidth() {
    this.optsWidthRightSide = 0;
    if (this.rightOptions) {
      this.rightOptions.style.display = "flex";
      this.optsWidthRightSide = this.rightOptions.offsetWidth;
      this.rightOptions.style.display = "";
    }
    this.optsWidthLeftSide = 0;
    if (this.leftOptions) {
      this.leftOptions.style.display = "flex";
      this.optsWidthLeftSide = this.leftOptions.offsetWidth;
      this.leftOptions.style.display = "";
    }
    this.optsDirty = false;
  }
  setOpenAmount(openAmount, isFinal) {
    if (this.tmr !== void 0) {
      clearTimeout(this.tmr);
      this.tmr = void 0;
    }
    if (!this.item) {
      return;
    }
    const style = this.item.style;
    this.openAmount = openAmount;
    if (isFinal) {
      style.transition = "";
    }
    if (openAmount > 0) {
      this.state = openAmount >= this.optsWidthRightSide + SWIPE_MARGIN ? 8 | 32 : 8;
    } else if (openAmount < 0) {
      this.state = openAmount <= -this.optsWidthLeftSide - SWIPE_MARGIN ? 16 | 64 : 16;
    } else {
      if (this.gesture) {
        this.gesture.enable(false);
      }
      this.tmr = setTimeout(() => {
        this.state = 2;
        this.tmr = void 0;
        if (this.gesture) {
          this.gesture.enable(!this.disabled);
        }
      }, 600);
      openSlidingItem = void 0;
      style.transform = "";
      return;
    }
    style.transform = `translate3d(${-openAmount}px,0,0)`;
    this.ionDrag.emit({
      amount: openAmount,
      ratio: this.getSlidingRatioSync()
    });
  }
  getSlidingRatioSync() {
    if (this.openAmount > 0) {
      return this.openAmount / this.optsWidthRightSide;
    } else if (this.openAmount < 0) {
      return this.openAmount / this.optsWidthLeftSide;
    } else {
      return 0;
    }
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: {
      [mode]: true,
      "item-sliding-active-slide": this.state !== 2,
      "item-sliding-active-options-end": (this.state & 8) !== 0,
      "item-sliding-active-options-start": (this.state & 16) !== 0,
      "item-sliding-active-swipe-end": (this.state & 32) !== 0,
      "item-sliding-active-swipe-start": (this.state & 64) !== 0
    } });
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "disabled": ["disabledChanged"]
    };
  }
  static get style() {
    return itemSlidingCss;
  }
}, [0, "ion-item-sliding", {
  "disabled": [4],
  "state": [32],
  "getOpenAmount": [64],
  "getSlidingRatio": [64],
  "open": [64],
  "close": [64],
  "closeOpened": [64]
}]);
const swipeShouldReset = (isResetDirection, isMovingFast, isOnResetZone) => {
  return !isMovingFast && isOnResetZone || isResetDirection && isMovingFast;
};
function defineCustomElement$1$n() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-item-sliding"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-item-sliding":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ItemSliding);
        }
        break;
    }
  });
}
const defineCustomElement$D = defineCustomElement$1$n;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$C = defineCustomElement$T;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const listIosCss = "ion-list{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;contain:content;list-style-type:none}ion-list.list-inset{-webkit-transform:translateZ(0);transform:translateZ(0);overflow:hidden}.list-ios{background:var(--ion-item-background, var(--ion-background-color, #fff))}.list-ios.list-inset{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:16px;margin-bottom:16px;border-radius:10px}.list-ios.list-inset ion-item:last-child{--border-width:0;--inner-border-width:0}.list-ios.list-inset+ion-list.list-inset{margin-top:0}.list-ios-lines-none .item-lines-default{--inner-border-width:0px;--border-width:0px}.list-ios-lines-full .item-lines-default{--inner-border-width:0px;--border-width:0 0 0.55px 0}.list-ios-lines-inset .item-lines-default{--inner-border-width:0 0 0.55px 0;--border-width:0px}ion-card .list-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}";
const listMdCss = "ion-list{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;contain:content;list-style-type:none}ion-list.list-inset{-webkit-transform:translateZ(0);transform:translateZ(0);overflow:hidden}.list-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:8px;padding-bottom:8px;background:var(--ion-item-background, var(--ion-background-color, #fff))}@supports (inset-inline-start: 0){.list-md>.input:last-child::after{inset-inline-start:0}}@supports not (inset-inline-start: 0){.list-md>.input:last-child::after{left:0}:host-context([dir=rtl]) .list-md>.input:last-child::after{left:unset;right:unset;right:0}[dir=rtl] .list-md>.input:last-child::after{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.list-md>.input:last-child::after:dir(rtl){left:unset;right:unset;right:0}}}.list-md.list-inset{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:16px;margin-bottom:16px;border-radius:2px}.list-md.list-inset ion-item:first-child{--border-radius:2px 2px 0 0}.list-md.list-inset ion-item:last-child{--border-radius:0 0 2px, 2px;--border-width:0;--inner-border-width:0}.list-md.list-inset+ion-list.list-inset{margin-top:0}.list-md-lines-none .item-lines-default{--inner-border-width:0px;--border-width:0px}.list-md-lines-full .item-lines-default{--inner-border-width:0px;--border-width:0 0 1px 0}.list-md-lines-inset .item-lines-default{--inner-border-width:0 0 1px 0;--border-width:0px}ion-card .list-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}";
const List = /* @__PURE__ */ proxyCustomElement$1(class List2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.lines = void 0;
    this.inset = false;
  }
  /**
   * If `ion-item-sliding` are used inside the list, this method closes
   * any open sliding item.
   *
   * Returns `true` if an actual `ion-item-sliding` is closed.
   */
  async closeSlidingItems() {
    const item = this.el.querySelector("ion-item-sliding");
    if (item === null || item === void 0 ? void 0 : item.closeOpened) {
      return item.closeOpened();
    }
    return false;
  }
  render() {
    const mode = getIonMode$2(this);
    const { lines, inset } = this;
    return h$5(Host$1, { role: "list", class: {
      [mode]: true,
      // Used internally for styling
      [`list-${mode}`]: true,
      "list-inset": inset,
      [`list-lines-${lines}`]: lines !== void 0,
      [`list-${mode}-lines-${lines}`]: lines !== void 0
    } });
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: listIosCss,
      md: listMdCss
    };
  }
}, [32, "ion-list", {
  "lines": [1],
  "inset": [4],
  "closeSlidingItems": [64]
}]);
function defineCustomElement$B() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-list"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-list":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, List);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$A = defineCustomElement$B;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const listHeaderIosCss = ":host{--border-style:solid;--border-width:0;--inner-border-width:0;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:40px;border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);color:var(--color);overflow:hidden}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}.list-header-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex:1 1 auto;flex:1 1 auto}:host(.list-header-lines-inset),:host(.list-header-lines-none){--border-width:0}:host(.list-header-lines-full),:host(.list-header-lines-none){--inner-border-width:0}:host{--background:transparent;--color:var(--ion-color-step-850, #262626);--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));-webkit-padding-start:calc(var(--ion-safe-area-left, 0px) + 16px);padding-inline-start:calc(var(--ion-safe-area-left, 0px) + 16px);position:relative;-ms-flex-align:end;align-items:flex-end;font-size:22px;font-weight:700;letter-spacing:0}::slotted(ion-button),::slotted(ion-label){margin-top:29px;margin-bottom:6px}::slotted(ion-button){-webkit-margin-start:3px;margin-inline-start:3px;-webkit-margin-end:3px;margin-inline-end:3px;height:1.4em}:host(.list-header-lines-full){--border-width:0 0 0.55px 0}:host(.list-header-lines-inset){--inner-border-width:0 0 0.55px 0}";
const listHeaderMdCss = ":host{--border-style:solid;--border-width:0;--inner-border-width:0;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:40px;border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);color:var(--color);overflow:hidden}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}.list-header-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex:1 1 auto;flex:1 1 auto}:host(.list-header-lines-inset),:host(.list-header-lines-none){--border-width:0}:host(.list-header-lines-full),:host(.list-header-lines-none){--inner-border-width:0}:host{--background:transparent;--color:var(--ion-text-color, #000);--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));-webkit-padding-start:calc(var(--ion-safe-area-left, 0) + 16px);padding-inline-start:calc(var(--ion-safe-area-left, 0) + 16px);min-height:45px;font-size:14px}:host(.list-header-lines-full){--border-width:0 0 1px 0}:host(.list-header-lines-inset){--inner-border-width:0 0 1px 0}";
const ListHeader = /* @__PURE__ */ proxyCustomElement$1(class ListHeader2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.color = void 0;
    this.lines = void 0;
  }
  render() {
    const { lines } = this;
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: createColorClasses$1(this.color, {
      [mode]: true,
      [`list-header-lines-${lines}`]: lines !== void 0
    }) }, h$5("div", { class: "list-header-inner" }, h$5("slot", null)));
  }
  static get style() {
    return {
      ios: listHeaderIosCss,
      md: listHeaderMdCss
    };
  }
}, [33, "ion-list-header", {
  "color": [513],
  "lines": [1]
}]);
function defineCustomElement$z() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-list-header"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-list-header":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ListHeader);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$y = defineCustomElement$z;
const menuIosCss = ":host{--width:304px;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--background:var(--ion-background-color, #fff);left:0;right:0;top:0;bottom:0;display:none;position:absolute;contain:strict}:host(.show-menu){display:block}.menu-inner{-webkit-transform:translateX(-9999px);transform:translateX(-9999px);display:-ms-flexbox;display:flex;position:absolute;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:justify;justify-content:space-between;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);contain:strict}:host(.menu-side-start) .menu-inner{--ion-safe-area-right:0px;top:0;bottom:0}@supports (inset-inline-start: 0){:host(.menu-side-start) .menu-inner{inset-inline-start:0;inset-inline-end:auto}}@supports not (inset-inline-start: 0){:host(.menu-side-start) .menu-inner{left:0;right:auto}:host-context([dir=rtl]):host(.menu-side-start) .menu-inner,:host-context([dir=rtl]).menu-side-start .menu-inner{left:unset;right:unset;left:auto;right:0}@supports selector(:dir(rtl)){:host(.menu-side-start) .menu-inner:dir(rtl){left:unset;right:unset;left:auto;right:0}}}:host(.menu-side-end) .menu-inner{--ion-safe-area-left:0px;top:0;bottom:0}@supports (inset-inline-start: 0){:host(.menu-side-end) .menu-inner{inset-inline-start:auto;inset-inline-end:0}}@supports not (inset-inline-start: 0){:host(.menu-side-end) .menu-inner{left:auto;right:0}:host-context([dir=rtl]):host(.menu-side-end) .menu-inner,:host-context([dir=rtl]).menu-side-end .menu-inner{left:unset;right:unset;left:0;right:auto}@supports selector(:dir(rtl)){:host(.menu-side-end) .menu-inner:dir(rtl){left:unset;right:unset;left:0;right:auto}}}ion-backdrop{display:none;opacity:0.01;z-index:-1}@media (max-width: 340px){.menu-inner{--width:264px}}:host(.menu-type-reveal){z-index:0}:host(.menu-type-reveal.show-menu) .menu-inner{-webkit-transform:translate3d(0,  0,  0);transform:translate3d(0,  0,  0)}:host(.menu-type-overlay){z-index:1000}:host(.menu-type-overlay) .show-backdrop{display:block;cursor:pointer}:host(.menu-pane-visible){width:var(--width);min-width:var(--min-width);max-width:var(--max-width)}:host(.menu-pane-visible) .menu-inner{left:0;right:0;width:auto;-webkit-transform:none !important;transform:none !important;-webkit-box-shadow:none !important;box-shadow:none !important}:host(.menu-pane-visible) ion-backdrop{display:hidden !important;}:host(.menu-type-push){z-index:1000}:host(.menu-type-push) .show-backdrop{display:block}";
const menuMdCss = ":host{--width:304px;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--background:var(--ion-background-color, #fff);left:0;right:0;top:0;bottom:0;display:none;position:absolute;contain:strict}:host(.show-menu){display:block}.menu-inner{-webkit-transform:translateX(-9999px);transform:translateX(-9999px);display:-ms-flexbox;display:flex;position:absolute;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:justify;justify-content:space-between;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);contain:strict}:host(.menu-side-start) .menu-inner{--ion-safe-area-right:0px;top:0;bottom:0}@supports (inset-inline-start: 0){:host(.menu-side-start) .menu-inner{inset-inline-start:0;inset-inline-end:auto}}@supports not (inset-inline-start: 0){:host(.menu-side-start) .menu-inner{left:0;right:auto}:host-context([dir=rtl]):host(.menu-side-start) .menu-inner,:host-context([dir=rtl]).menu-side-start .menu-inner{left:unset;right:unset;left:auto;right:0}@supports selector(:dir(rtl)){:host(.menu-side-start) .menu-inner:dir(rtl){left:unset;right:unset;left:auto;right:0}}}:host(.menu-side-end) .menu-inner{--ion-safe-area-left:0px;top:0;bottom:0}@supports (inset-inline-start: 0){:host(.menu-side-end) .menu-inner{inset-inline-start:auto;inset-inline-end:0}}@supports not (inset-inline-start: 0){:host(.menu-side-end) .menu-inner{left:auto;right:0}:host-context([dir=rtl]):host(.menu-side-end) .menu-inner,:host-context([dir=rtl]).menu-side-end .menu-inner{left:unset;right:unset;left:0;right:auto}@supports selector(:dir(rtl)){:host(.menu-side-end) .menu-inner:dir(rtl){left:unset;right:unset;left:0;right:auto}}}ion-backdrop{display:none;opacity:0.01;z-index:-1}@media (max-width: 340px){.menu-inner{--width:264px}}:host(.menu-type-reveal){z-index:0}:host(.menu-type-reveal.show-menu) .menu-inner{-webkit-transform:translate3d(0,  0,  0);transform:translate3d(0,  0,  0)}:host(.menu-type-overlay){z-index:1000}:host(.menu-type-overlay) .show-backdrop{display:block;cursor:pointer}:host(.menu-pane-visible){width:var(--width);min-width:var(--min-width);max-width:var(--max-width)}:host(.menu-pane-visible) .menu-inner{left:0;right:0;width:auto;-webkit-transform:none !important;transform:none !important;-webkit-box-shadow:none !important;box-shadow:none !important}:host(.menu-pane-visible) ion-backdrop{display:hidden !important;}:host(.menu-type-overlay) .menu-inner{-webkit-box-shadow:4px 0px 16px rgba(0, 0, 0, 0.18);box-shadow:4px 0px 16px rgba(0, 0, 0, 0.18)}";
const iosEasing = "cubic-bezier(0.32,0.72,0,1)";
const mdEasing = "cubic-bezier(0.0,0.0,0.2,1)";
const iosEasingReverse = "cubic-bezier(1, 0, 0.68, 0.28)";
const mdEasingReverse = "cubic-bezier(0.4, 0, 0.6, 1)";
const focusableQueryString = '[tabindex]:not([tabindex^="-"]), input:not([type=hidden]):not([tabindex^="-"]), textarea:not([tabindex^="-"]), button:not([tabindex^="-"]), select:not([tabindex^="-"]), .ion-focusable:not([tabindex^="-"])';
const Menu = /* @__PURE__ */ proxyCustomElement$1(class Menu2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionWillOpen = createEvent(this, "ionWillOpen", 7);
    this.ionWillClose = createEvent(this, "ionWillClose", 7);
    this.ionDidOpen = createEvent(this, "ionDidOpen", 7);
    this.ionDidClose = createEvent(this, "ionDidClose", 7);
    this.ionMenuChange = createEvent(this, "ionMenuChange", 7);
    this.lastOnEnd = 0;
    this.blocker = GESTURE_CONTROLLER.createBlocker({ disableScroll: true });
    this.isAnimating = false;
    this._isOpen = false;
    this.inheritedAttributes = {};
    this.handleFocus = (ev) => {
      const lastOverlay = getOverlay(document);
      if (lastOverlay && !lastOverlay.contains(this.el)) {
        return;
      }
      this.trapKeyboardFocus(ev, document);
    };
    this.isPaneVisible = false;
    this.isEndSide = false;
    this.contentId = void 0;
    this.menuId = void 0;
    this.type = void 0;
    this.disabled = false;
    this.side = "start";
    this.swipeGesture = true;
    this.maxEdgeStart = 50;
  }
  typeChanged(type3, oldType) {
    const contentEl = this.contentEl;
    if (contentEl) {
      if (oldType !== void 0) {
        contentEl.classList.remove(`menu-content-${oldType}`);
      }
      contentEl.classList.add(`menu-content-${type3}`);
      contentEl.removeAttribute("style");
    }
    if (this.menuInnerEl) {
      this.menuInnerEl.removeAttribute("style");
    }
    this.animation = void 0;
  }
  disabledChanged() {
    this.updateState();
    this.ionMenuChange.emit({
      disabled: this.disabled,
      open: this._isOpen
    });
  }
  sideChanged() {
    this.isEndSide = isEndSide(this.side);
    this.animation = void 0;
  }
  swipeGestureChanged() {
    this.updateState();
  }
  async connectedCallback() {
    if (typeof customElements !== "undefined" && customElements != null) {
      await customElements.whenDefined("ion-menu");
    }
    if (this.type === void 0) {
      this.type = config$1.get("menuType", "overlay");
    }
    const content = this.contentId !== void 0 ? document.getElementById(this.contentId) : null;
    if (content === null) {
      console.error('Menu: must have a "content" element to listen for drag events on.');
      return;
    }
    if (this.el.contains(content)) {
      console.error(`Menu: "contentId" should refer to the main view's ion-content, not the ion-content inside of the ion-menu.`);
    }
    this.contentEl = content;
    content.classList.add("menu-content");
    this.typeChanged(this.type, void 0);
    this.sideChanged();
    menuController._register(this);
    this.gesture = (await __vitePreload(() => Promise.resolve().then(() => index2), true ? void 0 : void 0)).createGesture({
      el: document,
      gestureName: "menu-swipe",
      gesturePriority: 30,
      threshold: 10,
      blurOnStart: true,
      canStart: (ev) => this.canStart(ev),
      onWillStart: () => this.onWillStart(),
      onStart: () => this.onStart(),
      onMove: (ev) => this.onMove(ev),
      onEnd: (ev) => this.onEnd(ev)
    });
    this.updateState();
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAriaAttributes(this.el);
  }
  async componentDidLoad() {
    this.ionMenuChange.emit({ disabled: this.disabled, open: this._isOpen });
    this.updateState();
  }
  async disconnectedCallback() {
    await this.close(false);
    this.blocker.destroy();
    menuController._unregister(this);
    if (this.animation) {
      this.animation.destroy();
    }
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
    this.animation = void 0;
    this.contentEl = void 0;
  }
  onSplitPaneChanged(ev) {
    this.isPaneVisible = ev.detail.isPane(this.el);
    this.updateState();
  }
  onBackdropClick(ev) {
    if (this._isOpen && this.lastOnEnd < ev.timeStamp - 100) {
      const shouldClose = ev.composedPath ? !ev.composedPath().includes(this.menuInnerEl) : false;
      if (shouldClose) {
        ev.preventDefault();
        ev.stopPropagation();
        this.close();
      }
    }
  }
  onKeydown(ev) {
    if (ev.key === "Escape") {
      this.close();
    }
  }
  /**
   * Returns `true` is the menu is open.
   */
  isOpen() {
    return Promise.resolve(this._isOpen);
  }
  /**
   * Returns `true` is the menu is active.
   *
   * A menu is active when it can be opened or closed, meaning it's enabled
   * and it's not part of a `ion-split-pane`.
   */
  isActive() {
    return Promise.resolve(this._isActive());
  }
  /**
   * Opens the menu. If the menu is already open or it can't be opened,
   * it returns `false`.
   */
  open(animated = true) {
    return this.setOpen(true, animated);
  }
  /**
   * Closes the menu. If the menu is already closed or it can't be closed,
   * it returns `false`.
   */
  close(animated = true) {
    return this.setOpen(false, animated);
  }
  /**
   * Toggles the menu. If the menu is already open, it will try to close, otherwise it will try to open it.
   * If the operation can't be completed successfully, it returns `false`.
   */
  toggle(animated = true) {
    return this.setOpen(!this._isOpen, animated);
  }
  /**
   * Opens or closes the button.
   * If the operation can't be completed successfully, it returns `false`.
   */
  setOpen(shouldOpen, animated = true) {
    return menuController._setOpen(this, shouldOpen, animated);
  }
  focusFirstDescendant() {
    const { el: el2 } = this;
    const firstInput = el2.querySelector(focusableQueryString);
    if (firstInput) {
      firstInput.focus();
    } else {
      el2.focus();
    }
  }
  focusLastDescendant() {
    const { el: el2 } = this;
    const inputs = Array.from(el2.querySelectorAll(focusableQueryString));
    const lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;
    if (lastInput) {
      lastInput.focus();
    } else {
      el2.focus();
    }
  }
  trapKeyboardFocus(ev, doc2) {
    const target = ev.target;
    if (!target) {
      return;
    }
    if (this.el.contains(target)) {
      this.lastFocus = target;
    } else {
      this.focusFirstDescendant();
      if (this.lastFocus === doc2.activeElement) {
        this.focusLastDescendant();
      }
    }
  }
  async _setOpen(shouldOpen, animated = true) {
    if (!this._isActive() || this.isAnimating || shouldOpen === this._isOpen) {
      return false;
    }
    this.beforeAnimation(shouldOpen);
    await this.loadAnimation();
    await this.startAnimation(shouldOpen, animated);
    this.afterAnimation(shouldOpen);
    return true;
  }
  async loadAnimation() {
    const width = this.menuInnerEl.offsetWidth;
    const isEndSide$1 = isEndSide(this.side);
    if (width === this.width && this.animation !== void 0 && isEndSide$1 === this.isEndSide) {
      return;
    }
    this.width = width;
    this.isEndSide = isEndSide$1;
    if (this.animation) {
      this.animation.destroy();
      this.animation = void 0;
    }
    this.animation = await menuController._createAnimation(this.type, this);
    if (!config$1.getBoolean("animated", true)) {
      this.animation.duration(0);
    }
    this.animation.fill("both");
  }
  async startAnimation(shouldOpen, animated) {
    const isReversed = !shouldOpen;
    const mode = getIonMode$2(this);
    const easing = mode === "ios" ? iosEasing : mdEasing;
    const easingReverse = mode === "ios" ? iosEasingReverse : mdEasingReverse;
    const ani = this.animation.direction(isReversed ? "reverse" : "normal").easing(isReversed ? easingReverse : easing).onFinish(() => {
      if (ani.getDirection() === "reverse") {
        ani.direction("normal");
      }
    });
    if (animated) {
      await ani.play();
    } else {
      ani.play({ sync: true });
    }
  }
  _isActive() {
    return !this.disabled && !this.isPaneVisible;
  }
  canSwipe() {
    return this.swipeGesture && !this.isAnimating && this._isActive();
  }
  canStart(detail) {
    const isModalPresented = !!document.querySelector("ion-modal.show-modal");
    if (isModalPresented || !this.canSwipe()) {
      return false;
    }
    if (this._isOpen) {
      return true;
    } else if (menuController._getOpenSync()) {
      return false;
    }
    return checkEdgeSide(window, detail.currentX, this.isEndSide, this.maxEdgeStart);
  }
  onWillStart() {
    this.beforeAnimation(!this._isOpen);
    return this.loadAnimation();
  }
  onStart() {
    if (!this.isAnimating || !this.animation) {
      assert$1(false, "isAnimating has to be true");
      return;
    }
    this.animation.progressStart(true, this._isOpen ? 1 : 0);
  }
  onMove(detail) {
    if (!this.isAnimating || !this.animation) {
      assert$1(false, "isAnimating has to be true");
      return;
    }
    const delta = computeDelta(detail.deltaX, this._isOpen, this.isEndSide);
    const stepValue = delta / this.width;
    this.animation.progressStep(this._isOpen ? 1 - stepValue : stepValue);
  }
  onEnd(detail) {
    if (!this.isAnimating || !this.animation) {
      assert$1(false, "isAnimating has to be true");
      return;
    }
    const isOpen = this._isOpen;
    const isEndSide2 = this.isEndSide;
    const delta = computeDelta(detail.deltaX, isOpen, isEndSide2);
    const width = this.width;
    const stepValue = delta / width;
    const velocity = detail.velocityX;
    const z2 = width / 2;
    const shouldCompleteRight = velocity >= 0 && (velocity > 0.2 || detail.deltaX > z2);
    const shouldCompleteLeft = velocity <= 0 && (velocity < -0.2 || detail.deltaX < -z2);
    const shouldComplete3 = isOpen ? isEndSide2 ? shouldCompleteRight : shouldCompleteLeft : isEndSide2 ? shouldCompleteLeft : shouldCompleteRight;
    let shouldOpen = !isOpen && shouldComplete3;
    if (isOpen && !shouldComplete3) {
      shouldOpen = true;
    }
    this.lastOnEnd = detail.currentTime;
    let newStepValue = shouldComplete3 ? 1e-3 : -1e-3;
    const adjustedStepValue = stepValue < 0 ? 0.01 : stepValue;
    newStepValue += getTimeGivenProgression([0, 0], [0.4, 0], [0.6, 1], [1, 1], clamp$1(0, adjustedStepValue, 0.9999))[0] || 0;
    const playTo = this._isOpen ? !shouldComplete3 : shouldComplete3;
    this.animation.easing("cubic-bezier(0.4, 0.0, 0.6, 1)").onFinish(() => this.afterAnimation(shouldOpen), { oneTimeCallback: true }).progressEnd(playTo ? 1 : 0, this._isOpen ? 1 - newStepValue : newStepValue, 300);
  }
  beforeAnimation(shouldOpen) {
    assert$1(!this.isAnimating, "_before() should not be called while animating");
    this.el.classList.add(SHOW_MENU);
    this.el.setAttribute("tabindex", "0");
    if (this.backdropEl) {
      this.backdropEl.classList.add(SHOW_BACKDROP);
    }
    if (this.contentEl) {
      this.contentEl.classList.add(MENU_CONTENT_OPEN);
      this.contentEl.setAttribute("aria-hidden", "true");
    }
    this.blocker.block();
    this.isAnimating = true;
    if (shouldOpen) {
      this.ionWillOpen.emit();
    } else {
      this.ionWillClose.emit();
    }
  }
  afterAnimation(isOpen) {
    var _a2;
    assert$1(this.isAnimating, "_before() should be called while animating");
    this._isOpen = isOpen;
    this.isAnimating = false;
    if (!this._isOpen) {
      this.blocker.unblock();
    }
    if (isOpen) {
      this.ionDidOpen.emit();
      const focusedMenu = (_a2 = document.activeElement) === null || _a2 === void 0 ? void 0 : _a2.closest("ion-menu");
      if (focusedMenu !== this.el) {
        this.el.focus();
      }
      document.addEventListener("focus", this.handleFocus, true);
    } else {
      this.el.classList.remove(SHOW_MENU);
      this.el.removeAttribute("tabindex");
      if (this.contentEl) {
        this.contentEl.classList.remove(MENU_CONTENT_OPEN);
        this.contentEl.removeAttribute("aria-hidden");
      }
      if (this.backdropEl) {
        this.backdropEl.classList.remove(SHOW_BACKDROP);
      }
      if (this.animation) {
        this.animation.stop();
      }
      this.ionDidClose.emit();
      document.removeEventListener("focus", this.handleFocus, true);
    }
  }
  updateState() {
    const isActive = this._isActive();
    if (this.gesture) {
      this.gesture.enable(isActive && this.swipeGesture);
    }
    if (!isActive && this._isOpen) {
      this.forceClosing();
    }
    if (!this.disabled) {
      menuController._setActiveMenu(this);
    }
    assert$1(!this.isAnimating, "can not be animating");
  }
  forceClosing() {
    assert$1(this._isOpen, "menu cannot be closed");
    this.isAnimating = true;
    const ani = this.animation.direction("reverse");
    ani.play({ sync: true });
    this.afterAnimation(false);
  }
  render() {
    const { type: type3, disabled, isPaneVisible, inheritedAttributes, side } = this;
    const mode = getIonMode$2(this);
    return h$5(Host$1, { role: "navigation", "aria-label": inheritedAttributes["aria-label"] || "menu", class: {
      [mode]: true,
      [`menu-type-${type3}`]: true,
      "menu-enabled": !disabled,
      [`menu-side-${side}`]: true,
      "menu-pane-visible": isPaneVisible
    } }, h$5("div", { class: "menu-inner", part: "container", ref: (el2) => this.menuInnerEl = el2 }, h$5("slot", null)), h$5("ion-backdrop", { ref: (el2) => this.backdropEl = el2, class: "menu-backdrop", tappable: false, stopPropagation: false, part: "backdrop" }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "type": ["typeChanged"],
      "disabled": ["disabledChanged"],
      "side": ["sideChanged"],
      "swipeGesture": ["swipeGestureChanged"]
    };
  }
  static get style() {
    return {
      ios: menuIosCss,
      md: menuMdCss
    };
  }
}, [33, "ion-menu", {
  "contentId": [513, "content-id"],
  "menuId": [513, "menu-id"],
  "type": [1025],
  "disabled": [1028],
  "side": [513],
  "swipeGesture": [4, "swipe-gesture"],
  "maxEdgeStart": [2, "max-edge-start"],
  "isPaneVisible": [32],
  "isEndSide": [32],
  "isOpen": [64],
  "isActive": [64],
  "open": [64],
  "close": [64],
  "toggle": [64],
  "setOpen": [64]
}, [[16, "ionSplitPaneVisible", "onSplitPaneChanged"], [2, "click", "onBackdropClick"], [0, "keydown", "onKeydown"]]]);
const computeDelta = (deltaX, isOpen, isEndSide2) => {
  return Math.max(0, isOpen !== isEndSide2 ? -deltaX : deltaX);
};
const checkEdgeSide = (win2, posX, isEndSide2, maxEdgeStart) => {
  if (isEndSide2) {
    return posX >= win2.innerWidth - maxEdgeStart;
  } else {
    return posX <= maxEdgeStart;
  }
};
const SHOW_MENU = "show-menu";
const SHOW_BACKDROP = "show-backdrop";
const MENU_CONTENT_OPEN = "menu-content-open";
function defineCustomElement$1$m() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-menu", "ion-backdrop"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-menu":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Menu);
        }
        break;
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          defineCustomElement$17();
        }
        break;
    }
  });
}
const defineCustomElement$x = defineCustomElement$1$m;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const updateVisibility = async (menu2) => {
  const menuEl = await menuController.get(menu2);
  return !!(menuEl && await menuEl.isActive());
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const menuToggleCss = ":host(.menu-toggle-hidden){display:none}";
const MenuToggle = /* @__PURE__ */ proxyCustomElement$1(class MenuToggle2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.onClick = () => {
      return menuController.toggle(this.menu);
    };
    this.visible = false;
    this.menu = void 0;
    this.autoHide = true;
  }
  connectedCallback() {
    this.visibilityChanged();
  }
  async visibilityChanged() {
    this.visible = await updateVisibility(this.menu);
  }
  render() {
    const mode = getIonMode$2(this);
    const hidden = this.autoHide && !this.visible;
    return h$5(Host$1, { onClick: this.onClick, "aria-hidden": hidden ? "true" : null, class: {
      [mode]: true,
      "menu-toggle-hidden": hidden
    } }, h$5("slot", null));
  }
  static get style() {
    return menuToggleCss;
  }
}, [1, "ion-menu-toggle", {
  "menu": [1],
  "autoHide": [4, "auto-hide"],
  "visible": [32]
}, [[16, "ionMenuChange", "visibilityChanged"], [16, "ionSplitPaneVisible", "visibilityChanged"]]]);
function defineCustomElement$1$l() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-menu-toggle"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-menu-toggle":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, MenuToggle);
        }
        break;
    }
  });
}
const defineCustomElement$w = defineCustomElement$1$l;
const VIEW_STATE_NEW = 1;
const VIEW_STATE_ATTACHED = 2;
const VIEW_STATE_DESTROYED = 3;
class ViewController {
  constructor(component, params) {
    this.component = component;
    this.params = params;
    this.state = VIEW_STATE_NEW;
  }
  async init(container) {
    this.state = VIEW_STATE_ATTACHED;
    if (!this.element) {
      const component = this.component;
      this.element = await attachComponent(this.delegate, container, component, ["ion-page", "ion-page-invisible"], this.params);
    }
  }
  /**
   * DOM WRITE
   */
  _destroy() {
    assert$1(this.state !== VIEW_STATE_DESTROYED, "view state must be ATTACHED");
    const element = this.element;
    if (element) {
      if (this.delegate) {
        this.delegate.removeViewFromDom(element.parentElement, element);
      } else {
        element.remove();
      }
    }
    this.nav = void 0;
    this.state = VIEW_STATE_DESTROYED;
  }
}
const matches = (view3, id2, params) => {
  if (!view3) {
    return false;
  }
  if (view3.component !== id2) {
    return false;
  }
  return shallowEqualStringMap(view3.params, params);
};
const convertToView = (page, params) => {
  if (!page) {
    return null;
  }
  if (page instanceof ViewController) {
    return page;
  }
  return new ViewController(page, params);
};
const convertToViews = (pages) => {
  return pages.map((page) => {
    if (page instanceof ViewController) {
      return page;
    }
    if ("component" in page) {
      return convertToView(page.component, page.componentProps === null ? void 0 : page.componentProps);
    }
    return convertToView(page, void 0);
  }).filter((v2) => v2 !== null);
};
const navCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}";
const Nav = /* @__PURE__ */ proxyCustomElement$1(class Nav2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionNavWillLoad = createEvent(this, "ionNavWillLoad", 7);
    this.ionNavWillChange = createEvent(this, "ionNavWillChange", 3);
    this.ionNavDidChange = createEvent(this, "ionNavDidChange", 3);
    this.transInstr = [];
    this.animationEnabled = true;
    this.useRouter = false;
    this.isTransitioning = false;
    this.destroyed = false;
    this.views = [];
    this.delegate = void 0;
    this.swipeGesture = void 0;
    this.animated = true;
    this.animation = void 0;
    this.rootParams = void 0;
    this.root = void 0;
  }
  swipeGestureChanged() {
    if (this.gesture) {
      this.gesture.enable(this.swipeGesture === true);
    }
  }
  rootChanged() {
    if (this.root !== void 0) {
      if (!this.useRouter) {
        this.setRoot(this.root, this.rootParams);
      }
    }
  }
  componentWillLoad() {
    this.useRouter = document.querySelector("ion-router") !== null && this.el.closest("[no-router]") === null;
    if (this.swipeGesture === void 0) {
      const mode = getIonMode$2(this);
      this.swipeGesture = config$1.getBoolean("swipeBackEnabled", mode === "ios");
    }
    this.ionNavWillLoad.emit();
  }
  async componentDidLoad() {
    this.rootChanged();
    this.gesture = (await __vitePreload(() => import("./swipe-back-32076500.js"), true ? [] : void 0)).createSwipeBackGesture(this.el, this.canStart.bind(this), this.onStart.bind(this), this.onMove.bind(this), this.onEnd.bind(this));
    this.swipeGestureChanged();
  }
  connectedCallback() {
    this.destroyed = false;
  }
  disconnectedCallback() {
    for (const view3 of this.views) {
      lifecycle(view3.element, LIFECYCLE_WILL_UNLOAD);
      view3._destroy();
    }
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
    this.transInstr.length = 0;
    this.views.length = 0;
    this.destroyed = true;
  }
  /**
   * Push a new component onto the current navigation stack. Pass any additional
   * information along as an object. This additional information is accessible
   * through NavParams.
   *
   * @param component The component to push onto the navigation stack.
   * @param componentProps Any properties of the component.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  push(component, componentProps, opts, done3) {
    return this.insert(-1, component, componentProps, opts, done3);
  }
  /**
   * Inserts a component into the navigation stack at the specified index.
   * This is useful to add a component at any point in the navigation stack.
   *
   * @param insertIndex The index to insert the component at in the stack.
   * @param component The component to insert into the navigation stack.
   * @param componentProps Any properties of the component.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  insert(insertIndex, component, componentProps, opts, done3) {
    return this.insertPages(insertIndex, [{ component, componentProps }], opts, done3);
  }
  /**
   * Inserts an array of components into the navigation stack at the specified index.
   * The last component in the array will become instantiated as a view, and animate
   * in to become the active view.
   *
   * @param insertIndex The index to insert the components at in the stack.
   * @param insertComponents The components to insert into the navigation stack.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  insertPages(insertIndex, insertComponents, opts, done3) {
    return this.queueTrns({
      insertStart: insertIndex,
      insertViews: insertComponents,
      opts
    }, done3);
  }
  /**
   * Pop a component off of the navigation stack. Navigates back from the current
   * component.
   *
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  pop(opts, done3) {
    return this.removeIndex(-1, 1, opts, done3);
  }
  /**
   * Pop to a specific index in the navigation stack.
   *
   * @param indexOrViewCtrl The index or view controller to pop to.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  popTo(indexOrViewCtrl, opts, done3) {
    const ti2 = {
      removeStart: -1,
      removeCount: -1,
      opts
    };
    if (typeof indexOrViewCtrl === "object" && indexOrViewCtrl.component) {
      ti2.removeView = indexOrViewCtrl;
      ti2.removeStart = 1;
    } else if (typeof indexOrViewCtrl === "number") {
      ti2.removeStart = indexOrViewCtrl + 1;
    }
    return this.queueTrns(ti2, done3);
  }
  /**
   * Navigate back to the root of the stack, no matter how far back that is.
   *
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  popToRoot(opts, done3) {
    return this.removeIndex(1, -1, opts, done3);
  }
  /**
   * Removes a component from the navigation stack at the specified index.
   *
   * @param startIndex The number to begin removal at.
   * @param removeCount The number of components to remove.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  removeIndex(startIndex, removeCount = 1, opts, done3) {
    return this.queueTrns({
      removeStart: startIndex,
      removeCount,
      opts
    }, done3);
  }
  /**
   * Set the root for the current navigation stack to a component.
   *
   * @param component The component to set as the root of the navigation stack.
   * @param componentProps Any properties of the component.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  setRoot(component, componentProps, opts, done3) {
    return this.setPages([{ component, componentProps }], opts, done3);
  }
  /**
   * Set the views of the current navigation stack and navigate to the last view.
   * By default animations are disabled, but they can be enabled by passing options
   * to the navigation controller. Navigation parameters can also be passed to the
   * individual pages in the array.
   *
   * @param views The list of views to set as the navigation stack.
   * @param opts The navigation options.
   * @param done The transition complete function.
   */
  setPages(views, opts, done3) {
    opts !== null && opts !== void 0 ? opts : opts = {};
    if (opts.animated !== true) {
      opts.animated = false;
    }
    return this.queueTrns({
      insertStart: 0,
      insertViews: views,
      removeStart: 0,
      removeCount: -1,
      opts
    }, done3);
  }
  /**
   * Called by the router to update the view.
   *
   * @param id The component tag.
   * @param params The component params.
   * @param direction A direction hint.
   * @param animation an AnimationBuilder.
   *
   * @return the status.
   * @internal
   */
  setRouteId(id2, params, direction, animation2) {
    const active = this.getActiveSync();
    if (matches(active, id2, params)) {
      return Promise.resolve({
        changed: false,
        element: active.element
      });
    }
    let resolve;
    const promise3 = new Promise((r2) => resolve = r2);
    let finish;
    const commonOpts = {
      updateURL: false,
      viewIsReady: (enteringEl) => {
        let mark;
        const p2 = new Promise((r2) => mark = r2);
        resolve({
          changed: true,
          element: enteringEl,
          markVisible: async () => {
            mark();
            await finish;
          }
        });
        return p2;
      }
    };
    if (direction === "root") {
      finish = this.setRoot(id2, params, commonOpts);
    } else {
      const viewController = this.views.find((v2) => matches(v2, id2, params));
      if (viewController) {
        finish = this.popTo(viewController, Object.assign(Object.assign({}, commonOpts), { direction: "back", animationBuilder: animation2 }));
      } else if (direction === "forward") {
        finish = this.push(id2, params, Object.assign(Object.assign({}, commonOpts), { animationBuilder: animation2 }));
      } else if (direction === "back") {
        finish = this.setRoot(id2, params, Object.assign(Object.assign({}, commonOpts), { direction: "back", animated: true, animationBuilder: animation2 }));
      }
    }
    return promise3;
  }
  /**
   * Called by <ion-router> to retrieve the current component.
   *
   * @internal
   */
  async getRouteId() {
    const active = this.getActiveSync();
    if (active) {
      return {
        id: active.element.tagName,
        params: active.params,
        element: active.element
      };
    }
    return void 0;
  }
  /**
   * Get the active view.
   */
  async getActive() {
    return this.getActiveSync();
  }
  /**
   * Get the view at the specified index.
   *
   * @param index The index of the view.
   */
  async getByIndex(index3) {
    return this.views[index3];
  }
  /**
   * Returns `true` if the current view can go back.
   *
   * @param view The view to check.
   */
  async canGoBack(view3) {
    return this.canGoBackSync(view3);
  }
  /**
   * Get the previous view.
   *
   * @param view The view to get.
   */
  async getPrevious(view3) {
    return this.getPreviousSync(view3);
  }
  getLength() {
    return this.views.length;
  }
  getActiveSync() {
    return this.views[this.views.length - 1];
  }
  canGoBackSync(view3 = this.getActiveSync()) {
    return !!(view3 && this.getPreviousSync(view3));
  }
  getPreviousSync(view3 = this.getActiveSync()) {
    if (!view3) {
      return void 0;
    }
    const views = this.views;
    const index3 = views.indexOf(view3);
    return index3 > 0 ? views[index3 - 1] : void 0;
  }
  /**
   * Adds a navigation stack change to the queue and schedules it to run.
   *
   * @returns Whether the transition succeeds.
   */
  async queueTrns(ti2, done3) {
    var _a2, _b;
    if (this.isTransitioning && ((_a2 = ti2.opts) === null || _a2 === void 0 ? void 0 : _a2.skipIfBusy)) {
      return false;
    }
    const promise3 = new Promise((resolve, reject3) => {
      ti2.resolve = resolve;
      ti2.reject = reject3;
    });
    ti2.done = done3;
    if (ti2.opts && ti2.opts.updateURL !== false && this.useRouter) {
      const router = document.querySelector("ion-router");
      if (router) {
        const canTransition = await router.canTransition();
        if (canTransition === false) {
          return false;
        }
        if (typeof canTransition === "string") {
          router.push(canTransition, ti2.opts.direction || "back");
          return false;
        }
      }
    }
    if (((_b = ti2.insertViews) === null || _b === void 0 ? void 0 : _b.length) === 0) {
      ti2.insertViews = void 0;
    }
    this.transInstr.push(ti2);
    this.nextTrns();
    return promise3;
  }
  success(result, ti2) {
    if (this.destroyed) {
      this.fireError("nav controller was destroyed", ti2);
      return;
    }
    if (ti2.done) {
      ti2.done(result.hasCompleted, result.requiresTransition, result.enteringView, result.leavingView, result.direction);
    }
    ti2.resolve(result.hasCompleted);
    if (ti2.opts.updateURL !== false && this.useRouter) {
      const router = document.querySelector("ion-router");
      if (router) {
        const direction = result.direction === "back" ? "back" : "forward";
        router.navChanged(direction);
      }
    }
  }
  failed(rejectReason, ti2) {
    if (this.destroyed) {
      this.fireError("nav controller was destroyed", ti2);
      return;
    }
    this.transInstr.length = 0;
    this.fireError(rejectReason, ti2);
  }
  fireError(rejectReason, ti2) {
    if (ti2.done) {
      ti2.done(false, false, rejectReason);
    }
    if (ti2.reject && !this.destroyed) {
      ti2.reject(rejectReason);
    } else {
      ti2.resolve(false);
    }
  }
  /**
   * Consumes the next transition in the queue.
   *
   * @returns whether the transition is executed.
   */
  nextTrns() {
    if (this.isTransitioning) {
      return false;
    }
    const ti2 = this.transInstr.shift();
    if (!ti2) {
      return false;
    }
    this.runTransition(ti2);
    return true;
  }
  /** Executes all the transition instruction from the queue. */
  async runTransition(ti2) {
    try {
      this.ionNavWillChange.emit();
      this.isTransitioning = true;
      this.prepareTI(ti2);
      const leavingView = this.getActiveSync();
      const enteringView = this.getEnteringView(ti2, leavingView);
      if (!leavingView && !enteringView) {
        throw new Error("no views in the stack to be removed");
      }
      if (enteringView && enteringView.state === VIEW_STATE_NEW) {
        await enteringView.init(this.el);
      }
      this.postViewInit(enteringView, leavingView, ti2);
      const requiresTransition = (ti2.enteringRequiresTransition || ti2.leavingRequiresTransition) && enteringView !== leavingView;
      if (requiresTransition && ti2.opts && leavingView) {
        const isBackDirection = ti2.opts.direction === "back";
        if (isBackDirection) {
          ti2.opts.animationBuilder = ti2.opts.animationBuilder || (enteringView === null || enteringView === void 0 ? void 0 : enteringView.animationBuilder);
        }
        leavingView.animationBuilder = ti2.opts.animationBuilder;
      }
      let result;
      if (requiresTransition) {
        result = await this.transition(enteringView, leavingView, ti2);
      } else {
        result = {
          hasCompleted: true,
          requiresTransition: false
        };
      }
      this.success(result, ti2);
      this.ionNavDidChange.emit();
    } catch (rejectReason) {
      this.failed(rejectReason, ti2);
    }
    this.isTransitioning = false;
    this.nextTrns();
  }
  prepareTI(ti2) {
    var _a2, _b;
    var _c;
    const viewsLength = this.views.length;
    (_a2 = ti2.opts) !== null && _a2 !== void 0 ? _a2 : ti2.opts = {};
    (_b = (_c = ti2.opts).delegate) !== null && _b !== void 0 ? _b : _c.delegate = this.delegate;
    if (ti2.removeView !== void 0) {
      assert$1(ti2.removeStart !== void 0, "removeView needs removeStart");
      assert$1(ti2.removeCount !== void 0, "removeView needs removeCount");
      const index3 = this.views.indexOf(ti2.removeView);
      if (index3 < 0) {
        throw new Error("removeView was not found");
      }
      ti2.removeStart += index3;
    }
    if (ti2.removeStart !== void 0) {
      if (ti2.removeStart < 0) {
        ti2.removeStart = viewsLength - 1;
      }
      if (ti2.removeCount < 0) {
        ti2.removeCount = viewsLength - ti2.removeStart;
      }
      ti2.leavingRequiresTransition = ti2.removeCount > 0 && ti2.removeStart + ti2.removeCount === viewsLength;
    }
    if (ti2.insertViews) {
      if (ti2.insertStart < 0 || ti2.insertStart > viewsLength) {
        ti2.insertStart = viewsLength;
      }
      ti2.enteringRequiresTransition = ti2.insertStart === viewsLength;
    }
    const insertViews = ti2.insertViews;
    if (!insertViews) {
      return;
    }
    assert$1(insertViews.length > 0, "length can not be zero");
    const viewControllers = convertToViews(insertViews);
    if (viewControllers.length === 0) {
      throw new Error("invalid views to insert");
    }
    for (const view3 of viewControllers) {
      view3.delegate = ti2.opts.delegate;
      const nav = view3.nav;
      if (nav && nav !== this) {
        throw new Error("inserted view was already inserted");
      }
      if (view3.state === VIEW_STATE_DESTROYED) {
        throw new Error("inserted view was already destroyed");
      }
    }
    ti2.insertViews = viewControllers;
  }
  /**
   * Returns the view that will be entered considering the transition instructions.
   *
   * @param ti The instructions.
   * @param leavingView The view being left or undefined if none.
   *
   * @returns The view that will be entered, undefined if none.
   */
  getEnteringView(ti2, leavingView) {
    const insertViews = ti2.insertViews;
    if (insertViews !== void 0) {
      return insertViews[insertViews.length - 1];
    }
    const removeStart = ti2.removeStart;
    if (removeStart !== void 0) {
      const views = this.views;
      const removeEnd = removeStart + ti2.removeCount;
      for (let i = views.length - 1; i >= 0; i--) {
        const view3 = views[i];
        if ((i < removeStart || i >= removeEnd) && view3 !== leavingView) {
          return view3;
        }
      }
    }
    return void 0;
  }
  /**
   * Adds and Removes the views from the navigation stack.
   *
   * @param enteringView The view being entered.
   * @param leavingView The view being left.
   * @param ti The instructions.
   */
  postViewInit(enteringView, leavingView, ti2) {
    var _a2, _b, _c;
    assert$1(leavingView || enteringView, "Both leavingView and enteringView are null");
    assert$1(ti2.resolve, "resolve must be valid");
    assert$1(ti2.reject, "reject must be valid");
    const opts = ti2.opts;
    const { insertViews, removeStart, removeCount } = ti2;
    let destroyQueue;
    if (removeStart !== void 0 && removeCount !== void 0) {
      assert$1(removeStart >= 0, "removeStart can not be negative");
      assert$1(removeCount >= 0, "removeCount can not be negative");
      destroyQueue = [];
      for (let i = removeStart; i < removeStart + removeCount; i++) {
        const view3 = this.views[i];
        if (view3 !== void 0 && view3 !== enteringView && view3 !== leavingView) {
          destroyQueue.push(view3);
        }
      }
      (_a2 = opts.direction) !== null && _a2 !== void 0 ? _a2 : opts.direction = "back";
    }
    const finalNumViews = this.views.length + ((_b = insertViews === null || insertViews === void 0 ? void 0 : insertViews.length) !== null && _b !== void 0 ? _b : 0) - (removeCount !== null && removeCount !== void 0 ? removeCount : 0);
    assert$1(finalNumViews >= 0, "final balance can not be negative");
    if (finalNumViews === 0) {
      console.warn(`You can't remove all the pages in the navigation stack. nav.pop() is probably called too many times.`, this, this.el);
      throw new Error("navigation stack needs at least one root page");
    }
    if (insertViews) {
      let insertIndex = ti2.insertStart;
      for (const view3 of insertViews) {
        this.insertViewAt(view3, insertIndex);
        insertIndex++;
      }
      if (ti2.enteringRequiresTransition) {
        (_c = opts.direction) !== null && _c !== void 0 ? _c : opts.direction = "forward";
      }
    }
    if (destroyQueue && destroyQueue.length > 0) {
      for (const view3 of destroyQueue) {
        lifecycle(view3.element, LIFECYCLE_WILL_LEAVE);
        lifecycle(view3.element, LIFECYCLE_DID_LEAVE);
        lifecycle(view3.element, LIFECYCLE_WILL_UNLOAD);
      }
      for (const view3 of destroyQueue) {
        this.destroyView(view3);
      }
    }
  }
  async transition(enteringView, leavingView, ti2) {
    const opts = ti2.opts;
    const progressCallback = opts.progressAnimation ? (ani) => this.sbAni = ani : void 0;
    const mode = getIonMode$2(this);
    const enteringEl = enteringView.element;
    const leavingEl = leavingView && leavingView.element;
    const animationOpts = Object.assign(Object.assign({
      mode,
      showGoBack: this.canGoBackSync(enteringView),
      baseEl: this.el,
      progressCallback,
      animated: this.animated && config$1.getBoolean("animated", true),
      enteringEl,
      leavingEl
    }, opts), { animationBuilder: opts.animationBuilder || this.animation || config$1.get("navAnimation") });
    const { hasCompleted } = await transition$1(animationOpts);
    return this.transitionFinish(hasCompleted, enteringView, leavingView, opts);
  }
  transitionFinish(hasCompleted, enteringView, leavingView, opts) {
    const activeView = hasCompleted ? enteringView : leavingView;
    if (activeView) {
      this.unmountInactiveViews(activeView);
    }
    return {
      hasCompleted,
      requiresTransition: true,
      enteringView,
      leavingView,
      direction: opts.direction
    };
  }
  /**
   * Inserts a view at the specified index.
   *
   * When the view already is in the stack it will be moved to the new position.
   *
   * @param view The view to insert.
   * @param index The index where to insert the view.
   */
  insertViewAt(view3, index3) {
    const views = this.views;
    const existingIndex = views.indexOf(view3);
    if (existingIndex > -1) {
      assert$1(view3.nav === this, "view is not part of the nav");
      views.splice(existingIndex, 1);
      views.splice(index3, 0, view3);
    } else {
      assert$1(!view3.nav, "nav is used");
      view3.nav = this;
      views.splice(index3, 0, view3);
    }
  }
  /**
   * Removes a view from the stack.
   *
   * @param view The view to remove.
   */
  removeView(view3) {
    assert$1(view3.state === VIEW_STATE_ATTACHED || view3.state === VIEW_STATE_DESTROYED, "view state should be loaded or destroyed");
    const views = this.views;
    const index3 = views.indexOf(view3);
    assert$1(index3 > -1, "view must be part of the stack");
    if (index3 >= 0) {
      views.splice(index3, 1);
    }
  }
  destroyView(view3) {
    view3._destroy();
    this.removeView(view3);
  }
  /**
   * Unmounts all inactive views after the specified active view.
   *
   * DOM WRITE
   *
   * @param activeView The view that is actively visible in the stack. Used to calculate which views to unmount.
   */
  unmountInactiveViews(activeView) {
    if (this.destroyed) {
      return;
    }
    const views = this.views;
    const activeViewIndex = views.indexOf(activeView);
    for (let i = views.length - 1; i >= 0; i--) {
      const view3 = views[i];
      const element = view3.element;
      if (element) {
        if (i > activeViewIndex) {
          lifecycle(element, LIFECYCLE_WILL_UNLOAD);
          this.destroyView(view3);
        } else if (i < activeViewIndex) {
          setPageHidden(element, true);
        }
      }
    }
  }
  canStart() {
    return !!this.swipeGesture && !this.isTransitioning && this.transInstr.length === 0 && this.animationEnabled && this.canGoBackSync();
  }
  onStart() {
    this.pop({ direction: "back", progressAnimation: true });
  }
  onMove(stepValue) {
    if (this.sbAni) {
      this.sbAni.progressStep(stepValue);
    }
  }
  onEnd(shouldComplete3, stepValue, dur) {
    if (this.sbAni) {
      this.animationEnabled = false;
      this.sbAni.onFinish(() => {
        this.animationEnabled = true;
      }, { oneTimeCallback: true });
      let newStepValue = shouldComplete3 ? -1e-3 : 1e-3;
      if (!shouldComplete3) {
        this.sbAni.easing("cubic-bezier(1, 0, 0.68, 0.28)");
        newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], stepValue)[0];
      } else {
        newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], stepValue)[0];
      }
      this.sbAni.progressEnd(shouldComplete3 ? 1 : 0, newStepValue, dur);
    }
  }
  render() {
    return h$5("slot", null);
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "swipeGesture": ["swipeGestureChanged"],
      "root": ["rootChanged"]
    };
  }
  static get style() {
    return navCss;
  }
}, [1, "ion-nav", {
  "delegate": [16],
  "swipeGesture": [1028, "swipe-gesture"],
  "animated": [4],
  "animation": [16],
  "rootParams": [16],
  "root": [1],
  "push": [64],
  "insert": [64],
  "insertPages": [64],
  "pop": [64],
  "popTo": [64],
  "popToRoot": [64],
  "removeIndex": [64],
  "setRoot": [64],
  "setPages": [64],
  "setRouteId": [64],
  "getRouteId": [64],
  "getActive": [64],
  "getByIndex": [64],
  "canGoBack": [64],
  "getPrevious": [64]
}]);
function defineCustomElement$1$k() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-nav"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-nav":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Nav);
        }
        break;
    }
  });
}
const defineCustomElement$v = defineCustomElement$1$k;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$u = defineCustomElement$V;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const radioIosCss = ':host{--inner-border-radius:50%;display:inline-block;position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;max-width:100%;min-height:inherit;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(:not(.legacy-radio)){cursor:pointer}:host(.radio-disabled){pointer-events:none}.radio-icon{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;contain:layout size style}.radio-icon,.radio-inner{-webkit-box-sizing:border-box;box-sizing:border-box}:host(.legacy-radio) label{top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;opacity:0}@supports (inset-inline-start: 0){:host(.legacy-radio) label{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host(.legacy-radio) label{left:0}:host-context([dir=rtl]):host(.legacy-radio) label,:host-context([dir=rtl]).legacy-radio label{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(.legacy-radio) label:dir(rtl){left:unset;right:unset;right:0}}}:host(.legacy-radio) label::-moz-focus-inner{border:0}input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}:host(:focus){outline:none}:host(.in-item:not(.legacy-radio)){width:100%;height:100%}:host([slot=start]:not(.legacy-radio)),:host([slot=end]:not(.legacy-radio)){width:auto}.radio-wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;height:inherit;min-height:inherit;cursor:inherit}.label-text-wrapper{pointer-events:none;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.label-text-wrapper-hidden{display:none}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}:host(.radio-justify-space-between) .radio-wrapper{-ms-flex-pack:justify;justify-content:space-between}:host(.radio-justify-start) .radio-wrapper{-ms-flex-pack:start;justify-content:start}:host(.radio-justify-end) .radio-wrapper{-ms-flex-pack:end;justify-content:end}:host(.radio-label-placement-start) .radio-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.radio-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.radio-label-placement-end) .radio-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.radio-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}:host(.radio-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.radio-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px}:host{--color-checked:var(--ion-color-primary, #3880ff)}:host(.legacy-radio){width:15px;height:24px}:host(.ion-color.radio-checked) .radio-inner{border-color:var(--ion-color-base)}.item-radio.item-ios ion-label{-webkit-margin-start:0;margin-inline-start:0}.radio-inner{width:33%;height:50%}:host(.radio-checked) .radio-inner{-webkit-transform:rotate(45deg);transform:rotate(45deg);border-width:2px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--color-checked)}:host(.radio-disabled){opacity:0.3}:host(.ion-focused) .radio-icon::after{border-radius:var(--inner-border-radius);top:-8px;display:block;position:absolute;width:36px;height:36px;background:var(--ion-color-primary-tint, #4c8dff);content:"";opacity:0.2}@supports (inset-inline-start: 0){:host(.ion-focused) .radio-icon::after{inset-inline-start:-9px}}@supports not (inset-inline-start: 0){:host(.ion-focused) .radio-icon::after{left:-9px}:host-context([dir=rtl]):host(.ion-focused) .radio-icon::after,:host-context([dir=rtl]).ion-focused .radio-icon::after{left:unset;right:unset;right:-9px}@supports selector(:dir(rtl)){:host(.ion-focused) .radio-icon::after:dir(rtl){left:unset;right:unset;right:-9px}}}:host(.in-item.legacy-radio){-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:11px;margin-inline-end:11px;margin-top:8px;margin-bottom:8px;display:block;position:static}:host(.in-item.legacy-radio[slot=start]){-webkit-margin-start:3px;margin-inline-start:3px;-webkit-margin-end:21px;margin-inline-end:21px;margin-top:8px;margin-bottom:8px}.native-wrapper .radio-icon{width:15px;height:24px}';
const radioMdCss = ':host{--inner-border-radius:50%;display:inline-block;position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;max-width:100%;min-height:inherit;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(:not(.legacy-radio)){cursor:pointer}:host(.radio-disabled){pointer-events:none}.radio-icon{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;contain:layout size style}.radio-icon,.radio-inner{-webkit-box-sizing:border-box;box-sizing:border-box}:host(.legacy-radio) label{top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;opacity:0}@supports (inset-inline-start: 0){:host(.legacy-radio) label{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host(.legacy-radio) label{left:0}:host-context([dir=rtl]):host(.legacy-radio) label,:host-context([dir=rtl]).legacy-radio label{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(.legacy-radio) label:dir(rtl){left:unset;right:unset;right:0}}}:host(.legacy-radio) label::-moz-focus-inner{border:0}input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}:host(:focus){outline:none}:host(.in-item:not(.legacy-radio)){width:100%;height:100%}:host([slot=start]:not(.legacy-radio)),:host([slot=end]:not(.legacy-radio)){width:auto}.radio-wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;height:inherit;min-height:inherit;cursor:inherit}.label-text-wrapper{pointer-events:none;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.label-text-wrapper-hidden{display:none}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}:host(.radio-justify-space-between) .radio-wrapper{-ms-flex-pack:justify;justify-content:space-between}:host(.radio-justify-start) .radio-wrapper{-ms-flex-pack:start;justify-content:start}:host(.radio-justify-end) .radio-wrapper{-ms-flex-pack:end;justify-content:end}:host(.radio-label-placement-start) .radio-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.radio-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.radio-label-placement-end) .radio-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.radio-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}:host(.radio-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.radio-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px}:host{--color:rgb(var(--ion-text-color-rgb, 0, 0, 0), 0.6);--color-checked:var(--ion-color-primary, #3880ff);--border-width:2px;--border-style:solid;--border-radius:50%}:host(.legacy-radio){width:20px;height:20px}:host(.ion-color) .radio-inner{background:var(--ion-color-base)}:host(.ion-color.radio-checked) .radio-icon{border-color:var(--ion-color-base)}.radio-icon{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;border-radius:var(--border-radius);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--color)}.radio-inner{border-radius:var(--inner-border-radius);width:calc(50% + var(--border-width));height:calc(50% + var(--border-width));-webkit-transform:scale3d(0, 0, 0);transform:scale3d(0, 0, 0);-webkit-transition:-webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1);transition:-webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1);transition:transform 280ms cubic-bezier(0.4, 0, 0.2, 1);transition:transform 280ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1);background:var(--color-checked)}:host(.radio-checked) .radio-icon{border-color:var(--color-checked)}:host(.radio-checked) .radio-inner{-webkit-transform:scale3d(1, 1, 1);transform:scale3d(1, 1, 1)}:host(.radio-disabled){opacity:0.3}:host(.ion-focused.legacy-radio) .radio-icon::after{top:-12px}@supports (inset-inline-start: 0){:host(.ion-focused.legacy-radio) .radio-icon::after{inset-inline-start:-12px}}@supports not (inset-inline-start: 0){:host(.ion-focused.legacy-radio) .radio-icon::after{left:-12px}:host-context([dir=rtl]):host(.ion-focused.legacy-radio) .radio-icon::after,:host-context([dir=rtl]).ion-focused.legacy-radio .radio-icon::after{left:unset;right:unset;right:-12px}@supports selector(:dir(rtl)){:host(.ion-focused.legacy-radio) .radio-icon::after:dir(rtl){left:unset;right:unset;right:-12px}}}:host(.ion-focused) .radio-icon::after{border-radius:var(--inner-border-radius);display:block;position:absolute;width:36px;height:36px;background:var(--ion-color-primary-tint, #4c8dff);content:"";opacity:0.2}:host(.in-item.legacy-radio){margin-left:0;margin-right:0;margin-top:9px;margin-bottom:9px;display:block;position:static}:host(.in-item.legacy-radio[slot=start]){-webkit-margin-start:4px;margin-inline-start:4px;-webkit-margin-end:36px;margin-inline-end:36px;margin-top:11px;margin-bottom:10px}.native-wrapper .radio-icon{width:20px;height:20px}';
const Radio = /* @__PURE__ */ proxyCustomElement$1(class Radio2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.inputId = `ion-rb-${radioButtonIds++}`;
    this.radioGroup = null;
    this.inheritedAttributes = {};
    this.hasLoggedDeprecationWarning = false;
    this.updateState = () => {
      if (this.radioGroup) {
        this.checked = this.radioGroup.value === this.value;
      }
    };
    this.onClick = () => {
      this.checked = this.nativeInput.checked;
    };
    this.onFocus = () => {
      this.ionFocus.emit();
    };
    this.onBlur = () => {
      this.ionBlur.emit();
    };
    this.checked = false;
    this.buttonTabindex = -1;
    this.color = void 0;
    this.name = this.inputId;
    this.disabled = false;
    this.value = void 0;
    this.labelPlacement = "start";
    this.legacy = void 0;
    this.justify = "space-between";
  }
  valueChanged() {
    this.updateState();
  }
  /** @internal */
  async setFocus(ev) {
    ev.stopPropagation();
    ev.preventDefault();
    this.el.focus();
  }
  /** @internal */
  async setButtonTabindex(value) {
    this.buttonTabindex = value;
  }
  connectedCallback() {
    this.legacyFormController = createLegacyFormController(this.el);
    if (this.value === void 0) {
      this.value = this.inputId;
    }
    const radioGroup = this.radioGroup = this.el.closest("ion-radio-group");
    if (radioGroup) {
      this.updateState();
      addEventListener$1(radioGroup, "ionValueChange", this.updateState);
    }
  }
  disconnectedCallback() {
    const radioGroup = this.radioGroup;
    if (radioGroup) {
      removeEventListener(radioGroup, "ionValueChange", this.updateState);
      this.radioGroup = null;
    }
  }
  componentWillLoad() {
    this.emitStyle();
    if (!this.legacyFormController.hasLegacyControl()) {
      this.inheritedAttributes = Object.assign({}, inheritAriaAttributes(this.el));
    }
  }
  styleChanged() {
    this.emitStyle();
  }
  emitStyle() {
    const style = {
      "interactive-disabled": this.disabled
    };
    if (this.legacyFormController.hasLegacyControl()) {
      style["radio-checked"] = this.checked;
    }
    this.ionStyle.emit(style);
  }
  get hasLabel() {
    return this.el.textContent !== "";
  }
  renderRadioControl() {
    return h$5("div", { class: "radio-icon", part: "container" }, h$5("div", { class: "radio-inner", part: "mark" }), h$5("div", { class: "radio-ripple" }));
  }
  render() {
    const { legacyFormController } = this;
    return legacyFormController.hasLegacyControl() ? this.renderLegacyRadio() : this.renderRadio();
  }
  renderRadio() {
    const { checked, disabled, inputId, color: color2, el: el2, justify, labelPlacement, inheritedAttributes, hasLabel } = this;
    const mode = getIonMode$2(this);
    const inItem = hostContext("ion-item", el2);
    return h$5(Host$1, { onClick: this.onClick, class: createColorClasses$1(color2, {
      [mode]: true,
      "in-item": inItem,
      "radio-checked": checked,
      "radio-disabled": disabled,
      [`radio-justify-${justify}`]: true,
      [`radio-label-placement-${labelPlacement}`]: true,
      // Focus and active styling should not apply when the radio is in an item
      "ion-activatable": !inItem,
      "ion-focusable": !inItem
    }) }, h$5("label", { class: "radio-wrapper" }, h$5("input", Object.assign({ type: "radio", checked, disabled, id: inputId, ref: (nativeEl) => this.nativeInput = nativeEl }, inheritedAttributes)), h$5("div", { class: {
      "label-text-wrapper": true,
      "label-text-wrapper-hidden": !hasLabel
    } }, h$5("slot", null)), h$5("div", { class: "native-wrapper" }, this.renderRadioControl())));
  }
  renderLegacyRadio() {
    if (!this.hasLoggedDeprecationWarning) {
      printIonWarning(`ion-radio now requires providing a label with either the default slot or the "aria-label" attribute. To migrate, remove any usage of "ion-label" and pass the label text to either the component or the "aria-label" attribute.

Example: <ion-radio>Option Label</ion-radio>
Example with aria-label: <ion-radio aria-label="Option Label"></ion-radio>

Developers can use the "legacy" property to continue using the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.`, this.el);
      if (this.legacy) {
        printIonWarning(`ion-radio is being used with the "legacy" property enabled which will forcibly enable the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.

Developers can dismiss this warning by removing their usage of the "legacy" property and using the new radio syntax.`, this.el);
      }
      this.hasLoggedDeprecationWarning = true;
    }
    const { inputId, disabled, checked, color: color2, el: el2, buttonTabindex } = this;
    const mode = getIonMode$2(this);
    const { label, labelId, labelText } = getAriaLabel(el2, inputId);
    return h$5(Host$1, { "aria-checked": `${checked}`, "aria-hidden": disabled ? "true" : null, "aria-labelledby": label ? labelId : null, role: "radio", tabindex: buttonTabindex, onFocus: this.onFocus, onBlur: this.onBlur, onClick: this.onClick, class: createColorClasses$1(color2, {
      [mode]: true,
      "in-item": hostContext("ion-item", el2),
      interactive: true,
      "radio-checked": checked,
      "radio-disabled": disabled,
      "legacy-radio": true
    }) }, this.renderRadioControl(), h$5("label", { htmlFor: inputId }, labelText), h$5("input", { type: "radio", checked, disabled, tabindex: "-1", id: inputId, ref: (nativeEl) => this.nativeInput = nativeEl }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "value": ["valueChanged"],
      "checked": ["styleChanged"],
      "color": ["styleChanged"],
      "disabled": ["styleChanged"]
    };
  }
  static get style() {
    return {
      ios: radioIosCss,
      md: radioMdCss
    };
  }
}, [33, "ion-radio", {
  "color": [513],
  "name": [1],
  "disabled": [4],
  "value": [8],
  "labelPlacement": [1, "label-placement"],
  "legacy": [4],
  "justify": [1],
  "checked": [32],
  "buttonTabindex": [32],
  "setFocus": [64],
  "setButtonTabindex": [64]
}]);
let radioButtonIds = 0;
function defineCustomElement$t() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-radio"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-radio":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Radio);
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const RadioGroup = /* @__PURE__ */ proxyCustomElement$1(class RadioGroup2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionValueChange = createEvent(this, "ionValueChange", 7);
    this.inputId = `ion-rg-${radioGroupIds++}`;
    this.labelId = `${this.inputId}-lbl`;
    this.setRadioTabindex = (value) => {
      const radios = this.getRadios();
      const first = radios.find((radio2) => !radio2.disabled);
      const checked = radios.find((radio2) => radio2.value === value && !radio2.disabled);
      if (!first && !checked) {
        return;
      }
      const focusable = checked || first;
      for (const radio2 of radios) {
        const tabindex = radio2 === focusable ? 0 : -1;
        radio2.setButtonTabindex(tabindex);
      }
    };
    this.onClick = (ev) => {
      ev.preventDefault();
      const selectedRadio = ev.target && ev.target.closest("ion-radio");
      if (selectedRadio) {
        const currentValue = this.value;
        const newValue = selectedRadio.value;
        if (newValue !== currentValue) {
          this.value = newValue;
          this.emitValueChange(ev);
        } else if (this.allowEmptySelection) {
          this.value = void 0;
          this.emitValueChange(ev);
        }
      }
    };
    this.allowEmptySelection = false;
    this.name = this.inputId;
    this.value = void 0;
  }
  valueChanged(value) {
    this.setRadioTabindex(value);
    this.ionValueChange.emit({ value });
  }
  componentDidLoad() {
    this.setRadioTabindex(this.value);
  }
  async connectedCallback() {
    const header = this.el.querySelector("ion-list-header") || this.el.querySelector("ion-item-divider");
    if (header) {
      const label = this.label = header.querySelector("ion-label");
      if (label) {
        this.labelId = label.id = this.name + "-lbl";
      }
    }
  }
  getRadios() {
    return Array.from(this.el.querySelectorAll("ion-radio"));
  }
  /**
   * Emits an `ionChange` event.
   *
   * This API should be called for user committed changes.
   * This API should not be used for external value changes.
   */
  emitValueChange(event) {
    const { value } = this;
    this.ionChange.emit({ value, event });
  }
  onKeydown(ev) {
    const inSelectPopover = !!this.el.closest("ion-select-popover");
    if (ev.target && !this.el.contains(ev.target)) {
      return;
    }
    const radios = this.getRadios().filter((radio2) => !radio2.disabled);
    if (ev.target && radios.includes(ev.target)) {
      const index3 = radios.findIndex((radio2) => radio2 === ev.target);
      const current2 = radios[index3];
      let next;
      if (["ArrowDown", "ArrowRight"].includes(ev.key)) {
        next = index3 === radios.length - 1 ? radios[0] : radios[index3 + 1];
      }
      if (["ArrowUp", "ArrowLeft"].includes(ev.key)) {
        next = index3 === 0 ? radios[radios.length - 1] : radios[index3 - 1];
      }
      if (next && radios.includes(next)) {
        next.setFocus(ev);
        if (!inSelectPopover) {
          this.value = next.value;
          this.emitValueChange(ev);
        }
      }
      if ([" "].includes(ev.key)) {
        const previousValue = this.value;
        this.value = this.allowEmptySelection && this.value !== void 0 ? void 0 : current2.value;
        if (previousValue !== this.value || this.allowEmptySelection) {
          this.emitValueChange(ev);
        }
        ev.preventDefault();
      }
    }
  }
  render() {
    const { label, labelId, el: el2, name, value } = this;
    const mode = getIonMode$2(this);
    renderHiddenInput(true, el2, name, value, false);
    return h$5(Host$1, { role: "radiogroup", "aria-labelledby": label ? labelId : null, onClick: this.onClick, class: mode });
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "value": ["valueChanged"]
    };
  }
}, [0, "ion-radio-group", {
  "allowEmptySelection": [4, "allow-empty-selection"],
  "name": [1],
  "value": [1032]
}, [[4, "keydown", "onKeydown"]]]);
let radioGroupIds = 0;
function defineCustomElement$s() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-radio-group"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-radio-group":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, RadioGroup);
        }
        break;
    }
  });
}
function getDecimalPlaces(n2) {
  if (n2 % 1 === 0)
    return 0;
  return n2.toString().split(".")[1].length;
}
function roundToMaxDecimalPlaces(n2, ...references) {
  const maxPlaces = Math.max(...references.map((r2) => getDecimalPlaces(r2)));
  return Number(n2.toFixed(maxPlaces));
}
const rangeIosCss = ":host{--knob-handle-size:calc(var(--knob-size) * 2);display:-ms-flexbox;display:flex;position:relative;-ms-flex:3;flex:3;-ms-flex-align:center;align-items:center;font-family:var(--ion-font-family, inherit);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.range-disabled){pointer-events:none}::slotted(ion-label){-ms-flex:initial;flex:initial}::slotted(ion-icon[slot]){font-size:24px}.range-slider{position:relative;-ms-flex:1;flex:1;width:100%;height:var(--height);contain:size layout style;cursor:-webkit-grab;cursor:grab;-ms-touch-action:pan-y;touch-action:pan-y}:host(.range-pressed) .range-slider{cursor:-webkit-grabbing;cursor:grabbing}.range-pin{position:absolute;background:var(--ion-color-base);color:var(--ion-color-contrast);text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box}.range-knob-handle{top:calc((var(--height) - var(--knob-handle-size)) / 2);-webkit-margin-start:calc(0px - var(--knob-handle-size) / 2);margin-inline-start:calc(0px - var(--knob-handle-size) / 2);position:absolute;width:var(--knob-handle-size);height:var(--knob-handle-size);text-align:center}@supports (inset-inline-start: 0){.range-knob-handle{inset-inline-start:0}}@supports not (inset-inline-start: 0){.range-knob-handle{left:0}:host-context([dir=rtl]) .range-knob-handle{left:unset;right:unset;right:0}[dir=rtl] .range-knob-handle{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.range-knob-handle:dir(rtl){left:unset;right:unset;right:0}}}:host-context([dir=rtl]) .range-knob-handle{left:unset}[dir=rtl] .range-knob-handle{left:unset}@supports selector(:dir(rtl)){.range-knob-handle:dir(rtl){left:unset}}.range-knob-handle:active,.range-knob-handle:focus{outline:none}.range-bar-container{border-radius:var(--bar-border-radius);top:calc((var(--height) - var(--bar-height)) / 2);position:absolute;width:100%;height:var(--bar-height)}@supports (inset-inline-start: 0){.range-bar-container{inset-inline-start:0}}@supports not (inset-inline-start: 0){.range-bar-container{left:0}:host-context([dir=rtl]) .range-bar-container{left:unset;right:unset;right:0}[dir=rtl] .range-bar-container{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.range-bar-container:dir(rtl){left:unset;right:unset;right:0}}}:host-context([dir=rtl]) .range-bar-container{left:unset}[dir=rtl] .range-bar-container{left:unset}@supports selector(:dir(rtl)){.range-bar-container:dir(rtl){left:unset}}.range-bar{border-radius:var(--bar-border-radius);position:absolute;width:100%;height:var(--bar-height);background:var(--bar-background);pointer-events:none}.range-knob{border-radius:var(--knob-border-radius);top:calc(50% - var(--knob-size) / 2);position:absolute;width:var(--knob-size);height:var(--knob-size);background:var(--knob-background);-webkit-box-shadow:var(--knob-box-shadow);box-shadow:var(--knob-box-shadow);z-index:2;pointer-events:none}@supports (inset-inline-start: 0){.range-knob{inset-inline-start:calc(50% - var(--knob-size) / 2)}}@supports not (inset-inline-start: 0){.range-knob{left:calc(50% - var(--knob-size) / 2)}:host-context([dir=rtl]) .range-knob{left:unset;right:unset;right:calc(50% - var(--knob-size) / 2)}[dir=rtl] .range-knob{left:unset;right:unset;right:calc(50% - var(--knob-size) / 2)}@supports selector(:dir(rtl)){.range-knob:dir(rtl){left:unset;right:unset;right:calc(50% - var(--knob-size) / 2)}}}:host-context([dir=rtl]) .range-knob{left:unset}[dir=rtl] .range-knob{left:unset}@supports selector(:dir(rtl)){.range-knob:dir(rtl){left:unset}}:host(.range-pressed) .range-bar-active{will-change:left, right}:host(.in-item){width:100%}:host([slot=start]),:host([slot=end]){width:auto}:host(.in-item) ::slotted(ion-label){-ms-flex-item-align:center;align-self:center}.range-wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;height:inherit}:host(.range-disabled) .label-text-wrapper{opacity:0.3}::slotted([slot=label]){max-width:200px;pointer-events:none;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.label-text-wrapper-hidden{display:none}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center}:host(.range-label-placement-start) .range-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.range-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.range-label-placement-end) .range-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.range-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}:host(.range-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.range-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}:host{--knob-border-radius:50%;--knob-background:#ffffff;--knob-box-shadow:0px 0.5px 4px rgba(0, 0, 0, 0.12), 0px 6px 13px rgba(0, 0, 0, 0.12);--knob-size:26px;--bar-height:4px;--bar-background:var(--ion-color-step-900, #e6e6e6);--bar-background-active:var(--ion-color-primary, #3880ff);--bar-border-radius:2px;--height:42px}:host(.legacy-range){-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:8px;padding-bottom:8px}:host(.ion-color) .range-bar-active,:host(.ion-color) .range-tick-active{background:var(--ion-color-base)}::slotted([slot=start]){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}::slotted([slot=end]){-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}:host(.range-has-pin){padding-top:20px}.range-bar-active{bottom:0;width:auto;background:var(--bar-background-active)}.range-bar-active.has-ticks{border-radius:0;-webkit-margin-start:-2px;margin-inline-start:-2px;-webkit-margin-end:-2px;margin-inline-end:-2px}.range-tick{-webkit-margin-start:-2px;margin-inline-start:-2px;border-radius:0;position:absolute;top:17px;width:4px;height:8px;background:var(--ion-color-step-900, #e6e6e6);pointer-events:none}.range-tick-active{background:var(--bar-background-active)}.range-pin{-webkit-transform:translate3d(0,  28px,  0) scale(0.01);transform:translate3d(0,  28px,  0) scale(0.01);-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px;padding-top:8px;padding-bottom:8px;display:inline-block;position:relative;top:-20px;min-width:28px;-webkit-transition:-webkit-transform 120ms ease;transition:-webkit-transform 120ms ease;transition:transform 120ms ease;transition:transform 120ms ease, -webkit-transform 120ms ease;background:transparent;color:var(--ion-text-color, #000);font-size:12px;text-align:center}.range-knob-pressed .range-pin,.range-knob-handle.ion-focused .range-pin{-webkit-transform:translate3d(0,  0,  0) scale(1);transform:translate3d(0,  0,  0) scale(1)}:host(.range-disabled){opacity:0.5}";
const rangeMdCss = ':host{--knob-handle-size:calc(var(--knob-size) * 2);display:-ms-flexbox;display:flex;position:relative;-ms-flex:3;flex:3;-ms-flex-align:center;align-items:center;font-family:var(--ion-font-family, inherit);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.range-disabled){pointer-events:none}::slotted(ion-label){-ms-flex:initial;flex:initial}::slotted(ion-icon[slot]){font-size:24px}.range-slider{position:relative;-ms-flex:1;flex:1;width:100%;height:var(--height);contain:size layout style;cursor:-webkit-grab;cursor:grab;-ms-touch-action:pan-y;touch-action:pan-y}:host(.range-pressed) .range-slider{cursor:-webkit-grabbing;cursor:grabbing}.range-pin{position:absolute;background:var(--ion-color-base);color:var(--ion-color-contrast);text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box}.range-knob-handle{top:calc((var(--height) - var(--knob-handle-size)) / 2);-webkit-margin-start:calc(0px - var(--knob-handle-size) / 2);margin-inline-start:calc(0px - var(--knob-handle-size) / 2);position:absolute;width:var(--knob-handle-size);height:var(--knob-handle-size);text-align:center}@supports (inset-inline-start: 0){.range-knob-handle{inset-inline-start:0}}@supports not (inset-inline-start: 0){.range-knob-handle{left:0}:host-context([dir=rtl]) .range-knob-handle{left:unset;right:unset;right:0}[dir=rtl] .range-knob-handle{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.range-knob-handle:dir(rtl){left:unset;right:unset;right:0}}}:host-context([dir=rtl]) .range-knob-handle{left:unset}[dir=rtl] .range-knob-handle{left:unset}@supports selector(:dir(rtl)){.range-knob-handle:dir(rtl){left:unset}}.range-knob-handle:active,.range-knob-handle:focus{outline:none}.range-bar-container{border-radius:var(--bar-border-radius);top:calc((var(--height) - var(--bar-height)) / 2);position:absolute;width:100%;height:var(--bar-height)}@supports (inset-inline-start: 0){.range-bar-container{inset-inline-start:0}}@supports not (inset-inline-start: 0){.range-bar-container{left:0}:host-context([dir=rtl]) .range-bar-container{left:unset;right:unset;right:0}[dir=rtl] .range-bar-container{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.range-bar-container:dir(rtl){left:unset;right:unset;right:0}}}:host-context([dir=rtl]) .range-bar-container{left:unset}[dir=rtl] .range-bar-container{left:unset}@supports selector(:dir(rtl)){.range-bar-container:dir(rtl){left:unset}}.range-bar{border-radius:var(--bar-border-radius);position:absolute;width:100%;height:var(--bar-height);background:var(--bar-background);pointer-events:none}.range-knob{border-radius:var(--knob-border-radius);top:calc(50% - var(--knob-size) / 2);position:absolute;width:var(--knob-size);height:var(--knob-size);background:var(--knob-background);-webkit-box-shadow:var(--knob-box-shadow);box-shadow:var(--knob-box-shadow);z-index:2;pointer-events:none}@supports (inset-inline-start: 0){.range-knob{inset-inline-start:calc(50% - var(--knob-size) / 2)}}@supports not (inset-inline-start: 0){.range-knob{left:calc(50% - var(--knob-size) / 2)}:host-context([dir=rtl]) .range-knob{left:unset;right:unset;right:calc(50% - var(--knob-size) / 2)}[dir=rtl] .range-knob{left:unset;right:unset;right:calc(50% - var(--knob-size) / 2)}@supports selector(:dir(rtl)){.range-knob:dir(rtl){left:unset;right:unset;right:calc(50% - var(--knob-size) / 2)}}}:host-context([dir=rtl]) .range-knob{left:unset}[dir=rtl] .range-knob{left:unset}@supports selector(:dir(rtl)){.range-knob:dir(rtl){left:unset}}:host(.range-pressed) .range-bar-active{will-change:left, right}:host(.in-item){width:100%}:host([slot=start]),:host([slot=end]){width:auto}:host(.in-item) ::slotted(ion-label){-ms-flex-item-align:center;align-self:center}.range-wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;height:inherit}:host(.range-disabled) .label-text-wrapper{opacity:0.3}::slotted([slot=label]){max-width:200px;pointer-events:none;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.label-text-wrapper-hidden{display:none}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center}:host(.range-label-placement-start) .range-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.range-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.range-label-placement-end) .range-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.range-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}:host(.range-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.range-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}:host{--knob-border-radius:50%;--knob-background:var(--bar-background-active);--knob-box-shadow:none;--knob-size:18px;--bar-height:2px;--bar-background:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.26);--bar-background-active:var(--ion-color-primary, #3880ff);--bar-border-radius:0;--height:42px;--pin-background:var(--ion-color-primary, #3880ff);--pin-color:var(--ion-color-primary-contrast, #fff);font-size:12px}::slotted([slot=label]){font-size:initial}:host(.legacy-range){-webkit-padding-start:14px;padding-inline-start:14px;-webkit-padding-end:14px;padding-inline-end:14px;padding-top:8px;padding-bottom:8px}:host(.ion-color) .range-bar{background:rgba(var(--ion-color-base-rgb), 0.26)}:host(.ion-color) .range-bar-active,:host(.ion-color) .range-knob,:host(.ion-color) .range-knob::before,:host(.ion-color) .range-pin,:host(.ion-color) .range-pin::before,:host(.ion-color) .range-tick{background:var(--ion-color-base);color:var(--ion-color-contrast)}::slotted([slot=start]){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:14px;margin-inline-end:14px;margin-top:0;margin-bottom:0}::slotted([slot=end]){-webkit-margin-start:14px;margin-inline-start:14px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}:host(.range-has-pin){padding-top:28px}.range-bar-active{bottom:0;width:auto;background:var(--bar-background-active)}.range-knob{-webkit-transform:scale(0.67);transform:scale(0.67);-webkit-transition-duration:120ms;transition-duration:120ms;-webkit-transition-property:background-color, border, -webkit-transform;transition-property:background-color, border, -webkit-transform;transition-property:transform, background-color, border;transition-property:transform, background-color, border, -webkit-transform;-webkit-transition-timing-function:ease;transition-timing-function:ease;z-index:2}.range-knob::before{border-radius:50%;position:absolute;width:var(--knob-size);height:var(--knob-size);-webkit-transform:scale(1);transform:scale(1);-webkit-transition:0.267s cubic-bezier(0, 0, 0.58, 1);transition:0.267s cubic-bezier(0, 0, 0.58, 1);background:var(--knob-background);content:"";opacity:0.13;pointer-events:none}@supports (inset-inline-start: 0){.range-knob::before{inset-inline-start:0}}@supports not (inset-inline-start: 0){.range-knob::before{left:0}:host-context([dir=rtl]) .range-knob::before{left:unset;right:unset;right:0}[dir=rtl] .range-knob::before{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.range-knob::before:dir(rtl){left:unset;right:unset;right:0}}}.range-tick{position:absolute;top:calc((var(--height) - var(--bar-height)) / 2);width:var(--bar-height);height:var(--bar-height);background:var(--bar-background-active);z-index:1;pointer-events:none}.range-tick-active{background:transparent}.range-pin{padding-left:0;padding-right:0;padding-top:8px;padding-bottom:8px;border-radius:50%;-webkit-transform:translate3d(0,  0,  0) scale(0.01);transform:translate3d(0,  0,  0) scale(0.01);display:inline-block;position:relative;min-width:28px;height:28px;-webkit-transition:background 120ms ease, -webkit-transform 120ms ease;transition:background 120ms ease, -webkit-transform 120ms ease;transition:transform 120ms ease, background 120ms ease;transition:transform 120ms ease, background 120ms ease, -webkit-transform 120ms ease;background:var(--pin-background);color:var(--pin-color);text-align:center}.range-pin::before{top:3px;-webkit-margin-start:-13px;margin-inline-start:-13px;border-radius:50% 50% 50% 0;position:absolute;width:26px;height:26px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transition:background 120ms ease;transition:background 120ms ease;background:var(--pin-background);content:"";z-index:-1}@supports (inset-inline-start: 0){.range-pin::before{inset-inline-start:50%}}@supports not (inset-inline-start: 0){.range-pin::before{left:50%}:host-context([dir=rtl]) .range-pin::before{left:unset;right:unset;right:50%}[dir=rtl] .range-pin::before{left:unset;right:unset;right:50%}@supports selector(:dir(rtl)){.range-pin::before:dir(rtl){left:unset;right:unset;right:50%}}}:host-context([dir=rtl]) .range-pin::before{left:unset}[dir=rtl] .range-pin::before{left:unset}@supports selector(:dir(rtl)){.range-pin::before:dir(rtl){left:unset}}.range-knob-pressed .range-pin,.range-knob-handle.ion-focused .range-pin{-webkit-transform:translate3d(0,  -24px,  0) scale(1);transform:translate3d(0,  -24px,  0) scale(1)}@media (any-hover: hover){.range-knob-handle:hover .range-knob:before{-webkit-transform:scale(2);transform:scale(2);opacity:0.13}}.range-knob-handle.ion-activated .range-knob:before,.range-knob-handle.ion-focused .range-knob:before,.range-knob-handle.range-knob-pressed .range-knob:before{-webkit-transform:scale(2);transform:scale(2)}.range-knob-handle.ion-focused .range-knob::before{opacity:0.13}.range-knob-handle.ion-activated .range-knob::before,.range-knob-handle.range-knob-pressed .range-knob::before{opacity:0.25}:host(:not(.range-has-pin)) .range-knob-pressed .range-knob,:host(:not(.range-has-pin)) .range-knob-handle.ion-focused .range-knob{-webkit-transform:scale(1);transform:scale(1)}:host(.range-disabled) .range-bar-active,:host(.range-disabled) .range-bar,:host(.range-disabled) .range-tick{background-color:var(--ion-color-step-250, #bfbfbf)}:host(.range-disabled) .range-knob{-webkit-transform:scale(0.55);transform:scale(0.55);outline:5px solid #fff;background-color:var(--ion-color-step-250, #bfbfbf)}';
const Range = /* @__PURE__ */ proxyCustomElement$1(class Range2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionInput = createEvent(this, "ionInput", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionKnobMoveStart = createEvent(this, "ionKnobMoveStart", 7);
    this.ionKnobMoveEnd = createEvent(this, "ionKnobMoveEnd", 7);
    this.rangeId = `ion-r-${rangeIds++}`;
    this.didLoad = false;
    this.noUpdate = false;
    this.hasFocus = false;
    this.inheritedAttributes = {};
    this.contentEl = null;
    this.initialContentScrollY = true;
    this.hasLoggedDeprecationWarning = false;
    this.clampBounds = (value) => {
      return clamp$1(this.min, value, this.max);
    };
    this.ensureValueInBounds = (value) => {
      if (this.dualKnobs) {
        return {
          lower: this.clampBounds(value.lower),
          upper: this.clampBounds(value.upper)
        };
      } else {
        return this.clampBounds(value);
      }
    };
    this.setupGesture = async () => {
      const rangeSlider = this.rangeSlider;
      if (rangeSlider) {
        this.gesture = (await __vitePreload(() => Promise.resolve().then(() => index2), true ? void 0 : void 0)).createGesture({
          el: rangeSlider,
          gestureName: "range",
          gesturePriority: 100,
          threshold: 0,
          onStart: (ev) => this.onStart(ev),
          onMove: (ev) => this.onMove(ev),
          onEnd: (ev) => this.onEnd(ev)
        });
        this.gesture.enable(!this.disabled);
      }
    };
    this.handleKeyboard = (knob, isIncrease) => {
      const { ensureValueInBounds } = this;
      let step = this.step;
      step = step > 0 ? step : 1;
      step = step / (this.max - this.min);
      if (!isIncrease) {
        step *= -1;
      }
      if (knob === "A") {
        this.ratioA = clamp$1(0, this.ratioA + step, 1);
      } else {
        this.ratioB = clamp$1(0, this.ratioB + step, 1);
      }
      this.ionKnobMoveStart.emit({ value: ensureValueInBounds(this.value) });
      this.updateValue();
      this.emitValueChange();
      this.ionKnobMoveEnd.emit({ value: ensureValueInBounds(this.value) });
    };
    this.onBlur = () => {
      if (this.hasFocus) {
        this.hasFocus = false;
        this.ionBlur.emit();
        this.emitStyle();
      }
    };
    this.onFocus = () => {
      if (!this.hasFocus) {
        this.hasFocus = true;
        this.ionFocus.emit();
        this.emitStyle();
      }
    };
    this.ratioA = 0;
    this.ratioB = 0;
    this.pressedKnob = void 0;
    this.color = void 0;
    this.debounce = void 0;
    this.name = this.rangeId;
    this.dualKnobs = false;
    this.min = 0;
    this.max = 100;
    this.pin = false;
    this.pinFormatter = (value) => Math.round(value);
    this.snaps = false;
    this.step = 1;
    this.ticks = true;
    this.activeBarStart = void 0;
    this.disabled = false;
    this.value = 0;
    this.labelPlacement = "start";
    this.legacy = void 0;
  }
  debounceChanged() {
    const { ionInput, debounce: debounce2, originalIonInput } = this;
    this.ionInput = debounce2 === void 0 ? originalIonInput !== null && originalIonInput !== void 0 ? originalIonInput : ionInput : debounceEvent(ionInput, debounce2);
  }
  minChanged() {
    if (!this.noUpdate) {
      this.updateRatio();
    }
  }
  maxChanged() {
    if (!this.noUpdate) {
      this.updateRatio();
    }
  }
  activeBarStartChanged() {
    const { activeBarStart } = this;
    if (activeBarStart !== void 0) {
      if (activeBarStart > this.max) {
        printIonWarning(`Range: The value of activeBarStart (${activeBarStart}) is greater than the max (${this.max}). Valid values are greater than or equal to the min value and less than or equal to the max value.`, this.el);
        this.activeBarStart = this.max;
      } else if (activeBarStart < this.min) {
        printIonWarning(`Range: The value of activeBarStart (${activeBarStart}) is less than the min (${this.min}). Valid values are greater than or equal to the min value and less than or equal to the max value.`, this.el);
        this.activeBarStart = this.min;
      }
    }
  }
  disabledChanged() {
    if (this.gesture) {
      this.gesture.enable(!this.disabled);
    }
    this.emitStyle();
  }
  valueChanged() {
    if (!this.noUpdate) {
      this.updateRatio();
    }
  }
  componentWillLoad() {
    if (this.el.hasAttribute("id")) {
      this.rangeId = this.el.getAttribute("id");
    }
    this.inheritedAttributes = inheritAriaAttributes(this.el);
  }
  componentDidLoad() {
    this.originalIonInput = this.ionInput;
    this.setupGesture();
    this.didLoad = true;
  }
  connectedCallback() {
    const { el: el2 } = this;
    this.legacyFormController = createLegacyFormController(el2);
    this.updateRatio();
    this.debounceChanged();
    this.disabledChanged();
    this.activeBarStartChanged();
    if (this.didLoad) {
      this.setupGesture();
    }
    this.contentEl = findClosestIonContent(this.el);
  }
  disconnectedCallback() {
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
  }
  getValue() {
    var _a2;
    const value = (_a2 = this.value) !== null && _a2 !== void 0 ? _a2 : 0;
    if (this.dualKnobs) {
      if (typeof value === "object") {
        return value;
      }
      return {
        lower: 0,
        upper: value
      };
    } else {
      if (typeof value === "object") {
        return value.upper;
      }
      return value;
    }
  }
  // TODO FW-2997 remove this
  emitStyle() {
    if (this.legacyFormController.hasLegacyControl()) {
      this.ionStyle.emit({
        interactive: true,
        "interactive-disabled": this.disabled
      });
    }
  }
  /**
   * Emits an `ionChange` event.
   *
   * This API should be called for user committed changes.
   * This API should not be used for external value changes.
   */
  emitValueChange() {
    this.value = this.ensureValueInBounds(this.value);
    this.ionChange.emit({ value: this.value });
  }
  onStart(detail) {
    const { contentEl } = this;
    if (contentEl) {
      this.initialContentScrollY = disableContentScrollY(contentEl);
    }
    const rect = this.rect = this.rangeSlider.getBoundingClientRect();
    const currentX = detail.currentX;
    let ratio = clamp$1(0, (currentX - rect.left) / rect.width, 1);
    if (isRTL$1(this.el)) {
      ratio = 1 - ratio;
    }
    this.pressedKnob = !this.dualKnobs || Math.abs(this.ratioA - ratio) < Math.abs(this.ratioB - ratio) ? "A" : "B";
    this.setFocus(this.pressedKnob);
    this.update(currentX);
    this.ionKnobMoveStart.emit({ value: this.ensureValueInBounds(this.value) });
  }
  onMove(detail) {
    this.update(detail.currentX);
  }
  onEnd(detail) {
    const { contentEl, initialContentScrollY } = this;
    if (contentEl) {
      resetContentScrollY(contentEl, initialContentScrollY);
    }
    this.update(detail.currentX);
    this.pressedKnob = void 0;
    this.emitValueChange();
    this.ionKnobMoveEnd.emit({ value: this.ensureValueInBounds(this.value) });
  }
  update(currentX) {
    const rect = this.rect;
    let ratio = clamp$1(0, (currentX - rect.left) / rect.width, 1);
    if (isRTL$1(this.el)) {
      ratio = 1 - ratio;
    }
    if (this.snaps) {
      ratio = valueToRatio(ratioToValue(ratio, this.min, this.max, this.step), this.min, this.max);
    }
    if (this.pressedKnob === "A") {
      this.ratioA = ratio;
    } else {
      this.ratioB = ratio;
    }
    this.updateValue();
  }
  get valA() {
    return ratioToValue(this.ratioA, this.min, this.max, this.step);
  }
  get valB() {
    return ratioToValue(this.ratioB, this.min, this.max, this.step);
  }
  get ratioLower() {
    if (this.dualKnobs) {
      return Math.min(this.ratioA, this.ratioB);
    }
    const { activeBarStart } = this;
    if (activeBarStart == null) {
      return 0;
    }
    return valueToRatio(activeBarStart, this.min, this.max);
  }
  get ratioUpper() {
    if (this.dualKnobs) {
      return Math.max(this.ratioA, this.ratioB);
    }
    return this.ratioA;
  }
  updateRatio() {
    const value = this.getValue();
    const { min: min3, max: max3 } = this;
    if (this.dualKnobs) {
      this.ratioA = valueToRatio(value.lower, min3, max3);
      this.ratioB = valueToRatio(value.upper, min3, max3);
    } else {
      this.ratioA = valueToRatio(value, min3, max3);
    }
  }
  updateValue() {
    this.noUpdate = true;
    const { valA, valB } = this;
    this.value = !this.dualKnobs ? valA : {
      lower: Math.min(valA, valB),
      upper: Math.max(valA, valB)
    };
    this.ionInput.emit({ value: this.value });
    this.noUpdate = false;
  }
  setFocus(knob) {
    if (this.el.shadowRoot) {
      const knobEl = this.el.shadowRoot.querySelector(knob === "A" ? ".range-knob-a" : ".range-knob-b");
      if (knobEl) {
        knobEl.focus();
      }
    }
  }
  // TODO FW-2997 remove this
  renderLegacyRange() {
    if (!this.hasLoggedDeprecationWarning) {
      printIonWarning(`ion-range now requires providing a label with either the label slot or the "aria-label" attribute. To migrate, remove any usage of "ion-label" and pass the label text to either the component or the "aria-label" attribute.

Example: <ion-range><div slot="label">Volume</div></ion-range>
Example with aria-label: <ion-range aria-label="Volume"></ion-range>

Developers can use the "legacy" property to continue using the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.`, this.el);
      if (this.legacy) {
        printIonWarning(`ion-range is being used with the "legacy" property enabled which will forcibly enable the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.

Developers can dismiss this warning by removing their usage of the "legacy" property and using the new range syntax.`, this.el);
      }
      this.hasLoggedDeprecationWarning = true;
    }
    const { el: el2, pressedKnob, disabled, pin: pin2, rangeId } = this;
    const mode = getIonMode$2(this);
    renderHiddenInput(true, el2, this.name, JSON.stringify(this.getValue()), disabled);
    return h$5(Host$1, { onFocusin: this.onFocus, onFocusout: this.onBlur, id: rangeId, class: createColorClasses$1(this.color, {
      [mode]: true,
      "in-item": hostContext("ion-item", el2),
      "range-disabled": disabled,
      "range-pressed": pressedKnob !== void 0,
      "range-has-pin": pin2,
      "legacy-range": true
    }) }, h$5("slot", { name: "start" }), this.renderRangeSlider(), h$5("slot", { name: "end" }));
  }
  renderRange() {
    const { disabled, el: el2, rangeId, pin: pin2, pressedKnob, labelPlacement } = this;
    const mode = getIonMode$2(this);
    renderHiddenInput(true, el2, this.name, JSON.stringify(this.getValue()), disabled);
    return h$5(Host$1, { onFocusin: this.onFocus, onFocusout: this.onBlur, id: rangeId, class: createColorClasses$1(this.color, {
      [mode]: true,
      "in-item": hostContext("ion-item", el2),
      "range-disabled": disabled,
      "range-pressed": pressedKnob !== void 0,
      "range-has-pin": pin2,
      [`range-label-placement-${labelPlacement}`]: true
    }) }, h$5("label", { class: "range-wrapper", id: "range-label" }, h$5("div", { class: {
      "label-text-wrapper": true,
      "label-text-wrapper-hidden": !this.hasLabel
    } }, h$5("slot", { name: "label" })), h$5("div", { class: "native-wrapper" }, h$5("slot", { name: "start" }), this.renderRangeSlider(), h$5("slot", { name: "end" }))));
  }
  get hasLabel() {
    return this.el.querySelector('[slot="label"]') !== null;
  }
  renderRangeSlider() {
    var _a2;
    const { min: min3, max: max3, step, el: el2, handleKeyboard, pressedKnob, disabled, pin: pin2, ratioLower, ratioUpper, inheritedAttributes, rangeId, pinFormatter } = this;
    let { labelText } = getAriaLabel(el2, rangeId);
    if (labelText === void 0 || labelText === null) {
      labelText = inheritedAttributes["aria-label"];
    }
    let barStart = `${ratioLower * 100}%`;
    let barEnd = `${100 - ratioUpper * 100}%`;
    const rtl = isRTL$1(this.el);
    const start = rtl ? "right" : "left";
    const end = rtl ? "left" : "right";
    const tickStyle = (tick) => {
      return {
        [start]: tick[start]
      };
    };
    if (this.dualKnobs === false) {
      if (this.valA < ((_a2 = this.activeBarStart) !== null && _a2 !== void 0 ? _a2 : this.min)) {
        barStart = `${ratioUpper * 100}%`;
        barEnd = `${100 - ratioLower * 100}%`;
      } else {
        barStart = `${ratioLower * 100}%`;
        barEnd = `${100 - ratioUpper * 100}%`;
      }
    }
    const barStyle = {
      [start]: barStart,
      [end]: barEnd
    };
    const ticks2 = [];
    if (this.snaps && this.ticks) {
      for (let value = min3; value <= max3; value += step) {
        const ratio = valueToRatio(value, min3, max3);
        const ratioMin = Math.min(ratioLower, ratioUpper);
        const ratioMax = Math.max(ratioLower, ratioUpper);
        const tick = {
          ratio,
          /**
           * Sets the tick mark as active when the tick is between the min bounds and the knob.
           * When using activeBarStart, the tick mark will be active between the knob and activeBarStart.
           */
          active: ratio >= ratioMin && ratio <= ratioMax
        };
        tick[start] = `${ratio * 100}%`;
        ticks2.push(tick);
      }
    }
    let labelledBy;
    if (!this.legacyFormController.hasLegacyControl() && this.hasLabel) {
      labelledBy = "range-label";
    }
    return h$5("div", { class: "range-slider", ref: (rangeEl) => this.rangeSlider = rangeEl }, ticks2.map((tick) => h$5("div", { style: tickStyle(tick), role: "presentation", class: {
      "range-tick": true,
      "range-tick-active": tick.active
    }, part: tick.active ? "tick-active" : "tick" })), h$5("div", { class: "range-bar-container" }, h$5("div", { class: "range-bar", role: "presentation", part: "bar" }), h$5("div", { class: {
      "range-bar": true,
      "range-bar-active": true,
      "has-ticks": ticks2.length > 0
    }, role: "presentation", style: barStyle, part: "bar-active" })), renderKnob(rtl, {
      knob: "A",
      pressed: pressedKnob === "A",
      value: this.valA,
      ratio: this.ratioA,
      pin: pin2,
      pinFormatter,
      disabled,
      handleKeyboard,
      min: min3,
      max: max3,
      labelText,
      labelledBy
    }), this.dualKnobs && renderKnob(rtl, {
      knob: "B",
      pressed: pressedKnob === "B",
      value: this.valB,
      ratio: this.ratioB,
      pin: pin2,
      pinFormatter,
      disabled,
      handleKeyboard,
      min: min3,
      max: max3,
      labelText,
      labelledBy
    }));
  }
  render() {
    const { legacyFormController } = this;
    return legacyFormController.hasLegacyControl() ? this.renderLegacyRange() : this.renderRange();
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "debounce": ["debounceChanged"],
      "min": ["minChanged"],
      "max": ["maxChanged"],
      "activeBarStart": ["activeBarStartChanged"],
      "disabled": ["disabledChanged"],
      "value": ["valueChanged"]
    };
  }
  static get style() {
    return {
      ios: rangeIosCss,
      md: rangeMdCss
    };
  }
}, [33, "ion-range", {
  "color": [513],
  "debounce": [2],
  "name": [1],
  "dualKnobs": [4, "dual-knobs"],
  "min": [2],
  "max": [2],
  "pin": [4],
  "pinFormatter": [16],
  "snaps": [4],
  "step": [2],
  "ticks": [4],
  "activeBarStart": [1026, "active-bar-start"],
  "disabled": [4],
  "value": [1026],
  "labelPlacement": [1, "label-placement"],
  "legacy": [4],
  "ratioA": [32],
  "ratioB": [32],
  "pressedKnob": [32]
}]);
const renderKnob = (rtl, { knob, value, ratio, min: min3, max: max3, disabled, pressed, pin: pin2, handleKeyboard, labelText, labelledBy, pinFormatter }) => {
  const start = rtl ? "right" : "left";
  const knobStyle = () => {
    const style = {};
    style[start] = `${ratio * 100}%`;
    return style;
  };
  return h$5("div", { onKeyDown: (ev) => {
    const key = ev.key;
    if (key === "ArrowLeft" || key === "ArrowDown") {
      handleKeyboard(knob, false);
      ev.preventDefault();
      ev.stopPropagation();
    } else if (key === "ArrowRight" || key === "ArrowUp") {
      handleKeyboard(knob, true);
      ev.preventDefault();
      ev.stopPropagation();
    }
  }, class: {
    "range-knob-handle": true,
    "range-knob-a": knob === "A",
    "range-knob-b": knob === "B",
    "range-knob-pressed": pressed,
    "range-knob-min": value === min3,
    "range-knob-max": value === max3,
    "ion-activatable": true,
    "ion-focusable": true
  }, style: knobStyle(), role: "slider", tabindex: disabled ? -1 : 0, "aria-label": labelledBy === void 0 ? labelText : null, "aria-labelledby": labelledBy !== void 0 ? labelledBy : null, "aria-valuemin": min3, "aria-valuemax": max3, "aria-disabled": disabled ? "true" : null, "aria-valuenow": value }, pin2 && h$5("div", { class: "range-pin", role: "presentation", part: "pin" }, pinFormatter(value)), h$5("div", { class: "range-knob", role: "presentation", part: "knob" }));
};
const ratioToValue = (ratio, min3, max3, step) => {
  let value = (max3 - min3) * ratio;
  if (step > 0) {
    value = Math.round(value / step) * step + min3;
  }
  const clampedValue = clamp$1(min3, value, max3);
  return roundToMaxDecimalPlaces(clampedValue, min3, max3, step);
};
const valueToRatio = (value, min3, max3) => {
  return clamp$1(0, (value - min3) / (max3 - min3), 1);
};
let rangeIds = 0;
function defineCustomElement$1$j() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-range"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-range":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Range);
        }
        break;
    }
  });
}
const defineCustomElement$r = defineCustomElement$1$j;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const rowCss = ":host{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}";
const Row = /* @__PURE__ */ proxyCustomElement$1(class Row2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
  }
  render() {
    return h$5(Host$1, { class: getIonMode$2(this) }, h$5("slot", null));
  }
  static get style() {
    return rowCss;
  }
}, [1, "ion-row"]);
function defineCustomElement$1$i() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-row"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-row":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Row);
        }
        break;
    }
  });
}
const defineCustomElement$q = defineCustomElement$1$i;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const searchbarIosCss = ".sc-ion-searchbar-ios-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:0.6;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-searchbar-ios-h{color:var(--ion-color-contrast)}.ion-color.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{background:var(--ion-color-base)}.ion-color.sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios,.ion-color.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.ion-color.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{color:inherit}.searchbar-search-icon.sc-ion-searchbar-ios{color:var(--icon-color);pointer-events:none}.searchbar-input-container.sc-ion-searchbar-ios{display:block;position:relative;-ms-flex-negative:1;flex-shrink:1;width:100%}.searchbar-input.sc-ion-searchbar-ios{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;border-radius:var(--border-radius);display:block;width:100%;border:0;outline:none;background:var(--background);font-family:inherit;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-input.sc-ion-searchbar-ios::-webkit-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::-moz-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios:-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::-webkit-search-cancel-button,.searchbar-input.sc-ion-searchbar-ios::-ms-clear{display:none}.searchbar-cancel-button.sc-ion-searchbar-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:none;height:100%;border:0;outline:none;color:var(--cancel-button-color);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-cancel-button.sc-ion-searchbar-ios>div.sc-ion-searchbar-ios{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.searchbar-clear-button.sc-ion-searchbar-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:none;min-height:0;outline:none;color:var(--clear-button-color);-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-clear-button.sc-ion-searchbar-ios:focus{opacity:0.5}.searchbar-has-value.searchbar-should-show-clear.sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios{display:block}.searchbar-disabled.sc-ion-searchbar-ios-h{cursor:default;opacity:0.4;pointer-events:none}.sc-ion-searchbar-ios-h{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.07);--border-radius:10px;--box-shadow:none;--cancel-button-color:var(--ion-color-primary, #3880ff);--clear-button-color:var(--ion-color-step-600, #666666);--color:var(--ion-text-color, #000);--icon-color:var(--ion-color-step-600, #666666);-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px;padding-top:12px;padding-bottom:12px;height:60px;contain:strict}.searchbar-input-container.sc-ion-searchbar-ios{height:36px}.searchbar-search-icon.sc-ion-searchbar-ios{-webkit-margin-start:calc(50% - 60px);margin-inline-start:calc(50% - 60px);top:0;position:absolute;width:22px;height:100%;contain:strict}@supports (inset-inline-start: 0){.searchbar-search-icon.sc-ion-searchbar-ios{inset-inline-start:5px}}@supports not (inset-inline-start: 0){.searchbar-search-icon.sc-ion-searchbar-ios{left:5px}[dir=rtl].sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,[dir=rtl] .sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{left:unset;right:unset;right:5px}[dir=rtl].sc-ion-searchbar-ios .searchbar-search-icon.sc-ion-searchbar-ios{left:unset;right:unset;right:5px}@supports selector(:dir(rtl)){.searchbar-search-icon.sc-ion-searchbar-ios:dir(rtl){left:unset;right:unset;right:5px}}}.searchbar-input.sc-ion-searchbar-ios{-webkit-padding-start:28px;padding-inline-start:28px;-webkit-padding-end:28px;padding-inline-end:28px;padding-top:0;padding-bottom:0;height:100%;font-size:17px;font-weight:400;contain:strict}.searchbar-clear-button.sc-ion-searchbar-ios{top:0;background-position:center;position:absolute;width:30px;height:100%;border:0;background-color:transparent}@supports (inset-inline-start: 0){.searchbar-clear-button.sc-ion-searchbar-ios{inset-inline-end:0}}@supports not (inset-inline-start: 0){.searchbar-clear-button.sc-ion-searchbar-ios{right:0}[dir=rtl].sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios,[dir=rtl] .sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios{left:unset;right:unset;left:0}[dir=rtl].sc-ion-searchbar-ios .searchbar-clear-button.sc-ion-searchbar-ios{left:unset;right:unset;left:0}@supports selector(:dir(rtl)){.searchbar-clear-button.sc-ion-searchbar-ios:dir(rtl){left:unset;right:unset;left:0}}}.searchbar-clear-icon.sc-ion-searchbar-ios{width:18px;height:100%}.searchbar-cancel-button.sc-ion-searchbar-ios{-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:0;padding-inline-end:0;padding-top:0;padding-bottom:0;-ms-flex-negative:0;flex-shrink:0;background-color:transparent;font-size:16px}.searchbar-left-aligned.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{-webkit-margin-start:0;margin-inline-start:0}.searchbar-left-aligned.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{-webkit-padding-start:30px;padding-inline-start:30px}.searchbar-has-focus.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.searchbar-should-show-cancel.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{display:block}.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{-webkit-transition:all 300ms ease;transition:all 300ms ease}.searchbar-animated.searchbar-has-focus.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.searchbar-animated.searchbar-should-show-cancel.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{opacity:1;pointer-events:auto}.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{-webkit-margin-end:-100%;margin-inline-end:-100%;-webkit-transform:translate3d(0,  0,  0);transform:translate3d(0,  0,  0);-webkit-transition:all 300ms ease;transition:all 300ms ease;opacity:0;pointer-events:none}.searchbar-no-animate.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,.searchbar-no-animate.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios,.searchbar-no-animate.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{-webkit-transition-duration:0ms;transition-duration:0ms}.ion-color.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{color:var(--ion-color-base)}@media (any-hover: hover){.ion-color.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios:hover{color:var(--ion-color-tint)}}ion-toolbar.sc-ion-searchbar-ios-h,ion-toolbar .sc-ion-searchbar-ios-h{padding-top:1px;padding-bottom:15px;height:52px}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color),ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color){color:inherit}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-cancel-button.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-cancel-button.sc-ion-searchbar-ios{color:currentColor}ion-toolbar.ion-color.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{color:currentColor;opacity:0.5}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-input.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-input.sc-ion-searchbar-ios{background:rgba(var(--ion-color-contrast-rgb), 0.07);color:currentColor}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-clear-button.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-clear-button.sc-ion-searchbar-ios{color:currentColor;opacity:0.5}";
const searchbarMdCss = ".sc-ion-searchbar-md-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:0.6;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-searchbar-md-h{color:var(--ion-color-contrast)}.ion-color.sc-ion-searchbar-md-h .searchbar-input.sc-ion-searchbar-md{background:var(--ion-color-base)}.ion-color.sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md,.ion-color.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md,.ion-color.sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md{color:inherit}.searchbar-search-icon.sc-ion-searchbar-md{color:var(--icon-color);pointer-events:none}.searchbar-input-container.sc-ion-searchbar-md{display:block;position:relative;-ms-flex-negative:1;flex-shrink:1;width:100%}.searchbar-input.sc-ion-searchbar-md{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;border-radius:var(--border-radius);display:block;width:100%;border:0;outline:none;background:var(--background);font-family:inherit;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-input.sc-ion-searchbar-md::-webkit-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::-moz-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md:-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::-ms-input-placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::-webkit-search-cancel-button,.searchbar-input.sc-ion-searchbar-md::-ms-clear{display:none}.searchbar-cancel-button.sc-ion-searchbar-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:none;height:100%;border:0;outline:none;color:var(--cancel-button-color);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-cancel-button.sc-ion-searchbar-md>div.sc-ion-searchbar-md{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.searchbar-clear-button.sc-ion-searchbar-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:none;min-height:0;outline:none;color:var(--clear-button-color);-webkit-appearance:none;-moz-appearance:none;appearance:none}.searchbar-clear-button.sc-ion-searchbar-md:focus{opacity:0.5}.searchbar-has-value.searchbar-should-show-clear.sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md{display:block}.searchbar-disabled.sc-ion-searchbar-md-h{cursor:default;opacity:0.4;pointer-events:none}.sc-ion-searchbar-md-h{--background:var(--ion-background-color, #fff);--border-radius:2px;--box-shadow:0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);--cancel-button-color:var(--ion-color-step-900, #1a1a1a);--clear-button-color:initial;--color:var(--ion-color-step-850, #262626);--icon-color:var(--ion-color-step-600, #666666);-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px;padding-top:8px;padding-bottom:8px;background:inherit}.searchbar-search-icon.sc-ion-searchbar-md{top:11px;width:21px;height:21px}@supports (inset-inline-start: 0){.searchbar-search-icon.sc-ion-searchbar-md{inset-inline-start:16px}}@supports not (inset-inline-start: 0){.searchbar-search-icon.sc-ion-searchbar-md{left:16px}[dir=rtl].sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md{left:unset;right:unset;right:16px}[dir=rtl].sc-ion-searchbar-md .searchbar-search-icon.sc-ion-searchbar-md{left:unset;right:unset;right:16px}@supports selector(:dir(rtl)){.searchbar-search-icon.sc-ion-searchbar-md:dir(rtl){left:unset;right:unset;right:16px}}}.searchbar-cancel-button.sc-ion-searchbar-md{top:0;background-color:transparent;font-size:1.6em}@supports (inset-inline-start: 0){.searchbar-cancel-button.sc-ion-searchbar-md{inset-inline-start:5px}}@supports not (inset-inline-start: 0){.searchbar-cancel-button.sc-ion-searchbar-md{left:5px}[dir=rtl].sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md{left:unset;right:unset;right:5px}[dir=rtl].sc-ion-searchbar-md .searchbar-cancel-button.sc-ion-searchbar-md{left:unset;right:unset;right:5px}@supports selector(:dir(rtl)){.searchbar-cancel-button.sc-ion-searchbar-md:dir(rtl){left:unset;right:unset;right:5px}}}.searchbar-search-icon.sc-ion-searchbar-md,.searchbar-cancel-button.sc-ion-searchbar-md{position:absolute}.searchbar-search-icon.ion-activated.sc-ion-searchbar-md,.searchbar-cancel-button.ion-activated.sc-ion-searchbar-md{background-color:transparent}.searchbar-input.sc-ion-searchbar-md{-webkit-padding-start:55px;padding-inline-start:55px;-webkit-padding-end:55px;padding-inline-end:55px;padding-top:6px;padding-bottom:6px;background-position:left 8px center;height:auto;font-size:16px;font-weight:400;line-height:30px}[dir=rtl].sc-ion-searchbar-md-h .searchbar-input.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-input.sc-ion-searchbar-md{background-position:right 8px center}[dir=rtl].sc-ion-searchbar-md .searchbar-input.sc-ion-searchbar-md{background-position:right 8px center}@supports selector(:dir(rtl)){.searchbar-input.sc-ion-searchbar-md:dir(rtl){background-position:right 8px center}}.searchbar-clear-button.sc-ion-searchbar-md{top:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;position:absolute;height:100%;border:0;background-color:transparent}@supports (inset-inline-start: 0){.searchbar-clear-button.sc-ion-searchbar-md{inset-inline-end:13px}}@supports not (inset-inline-start: 0){.searchbar-clear-button.sc-ion-searchbar-md{right:13px}[dir=rtl].sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md{left:unset;right:unset;left:13px}[dir=rtl].sc-ion-searchbar-md .searchbar-clear-button.sc-ion-searchbar-md{left:unset;right:unset;left:13px}@supports selector(:dir(rtl)){.searchbar-clear-button.sc-ion-searchbar-md:dir(rtl){left:unset;right:unset;left:13px}}}.searchbar-clear-button.ion-activated.sc-ion-searchbar-md{background-color:transparent}.searchbar-clear-icon.sc-ion-searchbar-md{width:22px;height:100%}.searchbar-has-focus.sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md{display:block}.searchbar-has-focus.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md,.searchbar-should-show-cancel.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md{display:block}.searchbar-has-focus.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md+.searchbar-search-icon.sc-ion-searchbar-md,.searchbar-should-show-cancel.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md+.searchbar-search-icon.sc-ion-searchbar-md{display:none}ion-toolbar.sc-ion-searchbar-md-h,ion-toolbar .sc-ion-searchbar-md-h{-webkit-padding-start:7px;padding-inline-start:7px;-webkit-padding-end:7px;padding-inline-end:7px;padding-top:3px;padding-bottom:3px}";
const Searchbar = /* @__PURE__ */ proxyCustomElement$1(class Searchbar2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.ionInput = createEvent(this, "ionInput", 7);
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionCancel = createEvent(this, "ionCancel", 7);
    this.ionClear = createEvent(this, "ionClear", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.isCancelVisible = false;
    this.shouldAlignLeft = true;
    this.onClearInput = async (shouldFocus) => {
      this.ionClear.emit();
      return new Promise((resolve) => {
        setTimeout(() => {
          const value = this.getValue();
          if (value !== "") {
            this.value = "";
            this.emitInputChange();
            if (shouldFocus && !this.focused) {
              this.setFocus();
              this.focusedValue = value;
            }
          }
          resolve();
        }, 16 * 4);
      });
    };
    this.onCancelSearchbar = async (ev) => {
      if (ev) {
        ev.preventDefault();
        ev.stopPropagation();
      }
      this.ionCancel.emit();
      const value = this.getValue();
      const focused = this.focused;
      await this.onClearInput();
      if (value && !focused) {
        this.emitValueChange(ev);
      }
      if (this.nativeInput) {
        this.nativeInput.blur();
      }
    };
    this.onInput = (ev) => {
      const input = ev.target;
      if (input) {
        this.value = input.value;
      }
      this.emitInputChange(ev);
    };
    this.onChange = (ev) => {
      this.emitValueChange(ev);
    };
    this.onBlur = (ev) => {
      this.focused = false;
      this.ionBlur.emit();
      this.positionElements();
      if (this.focusedValue !== this.value) {
        this.emitValueChange(ev);
      }
      this.focusedValue = void 0;
    };
    this.onFocus = () => {
      this.focused = true;
      this.focusedValue = this.value;
      this.ionFocus.emit();
      this.positionElements();
    };
    this.focused = false;
    this.noAnimate = true;
    this.color = void 0;
    this.animated = false;
    this.autocomplete = "off";
    this.autocorrect = "off";
    this.cancelButtonIcon = config$1.get("backButtonIcon", arrowBackSharp);
    this.cancelButtonText = "Cancel";
    this.clearIcon = void 0;
    this.debounce = void 0;
    this.disabled = false;
    this.inputmode = void 0;
    this.enterkeyhint = void 0;
    this.placeholder = "Search";
    this.searchIcon = void 0;
    this.showCancelButton = "never";
    this.showClearButton = "always";
    this.spellcheck = false;
    this.type = "search";
    this.value = "";
  }
  debounceChanged() {
    const { ionInput, debounce: debounce2, originalIonInput } = this;
    this.ionInput = debounce2 === void 0 ? originalIonInput !== null && originalIonInput !== void 0 ? originalIonInput : ionInput : debounceEvent(ionInput, debounce2);
  }
  valueChanged() {
    const inputEl = this.nativeInput;
    const value = this.getValue();
    if (inputEl && inputEl.value !== value) {
      inputEl.value = value;
    }
  }
  showCancelButtonChanged() {
    requestAnimationFrame(() => {
      this.positionElements();
      forceUpdate(this);
    });
  }
  connectedCallback() {
    this.emitStyle();
  }
  componentDidLoad() {
    this.originalIonInput = this.ionInput;
    this.positionElements();
    this.debounceChanged();
    setTimeout(() => {
      this.noAnimate = false;
    }, 300);
  }
  emitStyle() {
    this.ionStyle.emit({
      searchbar: true
    });
  }
  /**
   * Sets focus on the native `input` in `ion-searchbar`. Use this method instead of the global
   * `input.focus()`.
   *
   * Developers who wish to focus an input when a page enters
   * should call `setFocus()` in the `ionViewDidEnter()` lifecycle method.
   *
   * Developers who wish to focus an input when an overlay is presented
   * should call `setFocus` after `didPresent` has resolved.
   */
  async setFocus() {
    if (this.nativeInput) {
      this.nativeInput.focus();
    }
  }
  /**
   * Returns the native `<input>` element used under the hood.
   */
  getInputElement() {
    return Promise.resolve(this.nativeInput);
  }
  /**
   * Emits an `ionChange` event.
   *
   * This API should be called for user committed changes.
   * This API should not be used for external value changes.
   */
  emitValueChange(event) {
    const { value } = this;
    const newValue = value == null ? value : value.toString();
    this.focusedValue = newValue;
    this.ionChange.emit({ value: newValue, event });
  }
  /**
   * Emits an `ionInput` event.
   */
  emitInputChange(event) {
    const { value } = this;
    this.ionInput.emit({ value, event });
  }
  /**
   * Positions the input search icon, placeholder, and the cancel button
   * based on the input value and if it is focused. (ios only)
   */
  positionElements() {
    const value = this.getValue();
    const prevAlignLeft = this.shouldAlignLeft;
    const mode = getIonMode$2(this);
    const shouldAlignLeft = !this.animated || value.trim() !== "" || !!this.focused;
    this.shouldAlignLeft = shouldAlignLeft;
    if (mode !== "ios") {
      return;
    }
    if (prevAlignLeft !== shouldAlignLeft) {
      this.positionPlaceholder();
    }
    if (this.animated) {
      this.positionCancelButton();
    }
  }
  /**
   * Positions the input placeholder
   */
  positionPlaceholder() {
    const inputEl = this.nativeInput;
    if (!inputEl) {
      return;
    }
    const rtl = isRTL$1(this.el);
    const iconEl = (this.el.shadowRoot || this.el).querySelector(".searchbar-search-icon");
    if (this.shouldAlignLeft) {
      inputEl.removeAttribute("style");
      iconEl.removeAttribute("style");
    } else {
      const doc2 = document;
      const tempSpan = doc2.createElement("span");
      tempSpan.innerText = this.placeholder || "";
      doc2.body.appendChild(tempSpan);
      raf(() => {
        const textWidth = tempSpan.offsetWidth;
        tempSpan.remove();
        const inputLeft = "calc(50% - " + textWidth / 2 + "px)";
        const iconLeft = "calc(50% - " + (textWidth / 2 + 30) + "px)";
        if (rtl) {
          inputEl.style.paddingRight = inputLeft;
          iconEl.style.marginRight = iconLeft;
        } else {
          inputEl.style.paddingLeft = inputLeft;
          iconEl.style.marginLeft = iconLeft;
        }
      });
    }
  }
  /**
   * Show the iOS Cancel button on focus, hide it offscreen otherwise
   */
  positionCancelButton() {
    const rtl = isRTL$1(this.el);
    const cancelButton = (this.el.shadowRoot || this.el).querySelector(".searchbar-cancel-button");
    const shouldShowCancel = this.shouldShowCancelButton();
    if (cancelButton !== null && shouldShowCancel !== this.isCancelVisible) {
      const cancelStyle = cancelButton.style;
      this.isCancelVisible = shouldShowCancel;
      if (shouldShowCancel) {
        if (rtl) {
          cancelStyle.marginLeft = "0";
        } else {
          cancelStyle.marginRight = "0";
        }
      } else {
        const offset2 = cancelButton.offsetWidth;
        if (offset2 > 0) {
          if (rtl) {
            cancelStyle.marginLeft = -offset2 + "px";
          } else {
            cancelStyle.marginRight = -offset2 + "px";
          }
        }
      }
    }
  }
  getValue() {
    return this.value || "";
  }
  hasValue() {
    return this.getValue() !== "";
  }
  /**
   * Determines whether or not the cancel button should be visible onscreen.
   * Cancel button should be shown if one of two conditions applies:
   * 1. `showCancelButton` is set to `always`.
   * 2. `showCancelButton` is set to `focus`, and the searchbar has been focused.
   */
  shouldShowCancelButton() {
    if (this.showCancelButton === "never" || this.showCancelButton === "focus" && !this.focused) {
      return false;
    }
    return true;
  }
  /**
   * Determines whether or not the clear button should be visible onscreen.
   * Clear button should be shown if one of two conditions applies:
   * 1. `showClearButton` is set to `always`.
   * 2. `showClearButton` is set to `focus`, and the searchbar has been focused.
   */
  shouldShowClearButton() {
    if (this.showClearButton === "never" || this.showClearButton === "focus" && !this.focused) {
      return false;
    }
    return true;
  }
  render() {
    const { cancelButtonText } = this;
    const animated = this.animated && config$1.getBoolean("animated", true);
    const mode = getIonMode$2(this);
    const clearIcon = this.clearIcon || (mode === "ios" ? closeCircle$1 : closeSharp);
    const searchIcon = this.searchIcon || (mode === "ios" ? searchOutline : searchSharp);
    const shouldShowCancelButton = this.shouldShowCancelButton();
    const cancelButton = this.showCancelButton !== "never" && h$5("button", { "aria-label": cancelButtonText, "aria-hidden": shouldShowCancelButton ? void 0 : "true", type: "button", tabIndex: mode === "ios" && !shouldShowCancelButton ? -1 : void 0, onMouseDown: this.onCancelSearchbar, onTouchStart: this.onCancelSearchbar, class: "searchbar-cancel-button" }, h$5("div", { "aria-hidden": "true" }, mode === "md" ? h$5("ion-icon", { "aria-hidden": "true", mode, icon: this.cancelButtonIcon, lazy: false }) : cancelButtonText));
    return h$5(Host$1, { role: "search", "aria-disabled": this.disabled ? "true" : null, class: createColorClasses$1(this.color, {
      [mode]: true,
      "searchbar-animated": animated,
      "searchbar-disabled": this.disabled,
      "searchbar-no-animate": animated && this.noAnimate,
      "searchbar-has-value": this.hasValue(),
      "searchbar-left-aligned": this.shouldAlignLeft,
      "searchbar-has-focus": this.focused,
      "searchbar-should-show-clear": this.shouldShowClearButton(),
      "searchbar-should-show-cancel": this.shouldShowCancelButton()
    }) }, h$5("div", { class: "searchbar-input-container" }, h$5("input", { "aria-label": "search text", disabled: this.disabled, ref: (el2) => this.nativeInput = el2, class: "searchbar-input", inputMode: this.inputmode, enterKeyHint: this.enterkeyhint, onInput: this.onInput, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, placeholder: this.placeholder, type: this.type, value: this.getValue(), autoComplete: this.autocomplete, autoCorrect: this.autocorrect, spellcheck: this.spellcheck }), mode === "md" && cancelButton, h$5("ion-icon", { "aria-hidden": "true", mode, icon: searchIcon, lazy: false, class: "searchbar-search-icon" }), h$5("button", { "aria-label": "reset", type: "button", "no-blur": true, class: "searchbar-clear-button", onPointerDown: (ev) => {
      ev.preventDefault();
    }, onClick: () => this.onClearInput(true) }, h$5("ion-icon", { "aria-hidden": "true", mode, icon: clearIcon, lazy: false, class: "searchbar-clear-icon" }))), mode === "ios" && cancelButton);
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "debounce": ["debounceChanged"],
      "value": ["valueChanged"],
      "showCancelButton": ["showCancelButtonChanged"]
    };
  }
  static get style() {
    return {
      ios: searchbarIosCss,
      md: searchbarMdCss
    };
  }
}, [34, "ion-searchbar", {
  "color": [513],
  "animated": [4],
  "autocomplete": [1],
  "autocorrect": [1],
  "cancelButtonIcon": [1, "cancel-button-icon"],
  "cancelButtonText": [1, "cancel-button-text"],
  "clearIcon": [1, "clear-icon"],
  "debounce": [2],
  "disabled": [4],
  "inputmode": [1],
  "enterkeyhint": [1],
  "placeholder": [1],
  "searchIcon": [1, "search-icon"],
  "showCancelButton": [1, "show-cancel-button"],
  "showClearButton": [1, "show-clear-button"],
  "spellcheck": [4],
  "type": [1],
  "value": [1025],
  "focused": [32],
  "noAnimate": [32],
  "setFocus": [64],
  "getInputElement": [64]
}]);
function defineCustomElement$1$h() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-searchbar", "ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-searchbar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Searchbar);
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$1b();
        }
        break;
    }
  });
}
const defineCustomElement$p = defineCustomElement$1$h;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const createButtonActiveGesture = (el2, isButton) => {
  let currentTouchedButton;
  let initialTouchedButton;
  const activateButtonAtPoint = (x2, y2, hapticFeedbackFn) => {
    if (typeof document === "undefined") {
      return;
    }
    const target = document.elementFromPoint(x2, y2);
    if (!target || !isButton(target)) {
      clearActiveButton();
      return;
    }
    if (target !== currentTouchedButton) {
      clearActiveButton();
      setActiveButton(target, hapticFeedbackFn);
    }
  };
  const setActiveButton = (button, hapticFeedbackFn) => {
    currentTouchedButton = button;
    if (!initialTouchedButton) {
      initialTouchedButton = currentTouchedButton;
    }
    const buttonToModify = currentTouchedButton;
    writeTask$1(() => buttonToModify.classList.add("ion-activated"));
    hapticFeedbackFn();
  };
  const clearActiveButton = (dispatchClick = false) => {
    if (!currentTouchedButton) {
      return;
    }
    const buttonToModify = currentTouchedButton;
    writeTask$1(() => buttonToModify.classList.remove("ion-activated"));
    if (dispatchClick && initialTouchedButton !== currentTouchedButton) {
      currentTouchedButton.click();
    }
    currentTouchedButton = void 0;
  };
  return createGesture({
    el: el2,
    gestureName: "buttonActiveDrag",
    threshold: 0,
    onStart: (ev) => activateButtonAtPoint(ev.currentX, ev.currentY, hapticSelectionStart),
    onMove: (ev) => activateButtonAtPoint(ev.currentX, ev.currentY, hapticSelectionChanged),
    onEnd: () => {
      clearActiveButton(true);
      hapticSelectionEnd();
      initialTouchedButton = void 0;
    }
  });
};
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const iosEnterAnimation$4 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  wrapperAnimation.addElement(baseEl.querySelector(".action-sheet-wrapper")).fromTo("transform", "translateY(100%)", "translateY(0%)");
  return baseAnimation2.addElement(baseEl).easing("cubic-bezier(.36,.66,.04,1)").duration(400).addAnimation([backdropAnimation, wrapperAnimation]);
};
const iosLeaveAnimation$4 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", "var(--backdrop-opacity)", 0);
  wrapperAnimation.addElement(baseEl.querySelector(".action-sheet-wrapper")).fromTo("transform", "translateY(0%)", "translateY(100%)");
  return baseAnimation2.addElement(baseEl).easing("cubic-bezier(.36,.66,.04,1)").duration(450).addAnimation([backdropAnimation, wrapperAnimation]);
};
const mdEnterAnimation$4 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  wrapperAnimation.addElement(baseEl.querySelector(".action-sheet-wrapper")).fromTo("transform", "translateY(100%)", "translateY(0%)");
  return baseAnimation2.addElement(baseEl).easing("cubic-bezier(.36,.66,.04,1)").duration(400).addAnimation([backdropAnimation, wrapperAnimation]);
};
const mdLeaveAnimation$4 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", "var(--backdrop-opacity)", 0);
  wrapperAnimation.addElement(baseEl.querySelector(".action-sheet-wrapper")).fromTo("transform", "translateY(0%)", "translateY(100%)");
  return baseAnimation2.addElement(baseEl).easing("cubic-bezier(.36,.66,.04,1)").duration(450).addAnimation([backdropAnimation, wrapperAnimation]);
};
const actionSheetIosCss = '.sc-ion-action-sheet-ios-h{--color:initial;--button-color-activated:var(--button-color);--button-color-focused:var(--button-color);--button-color-hover:var(--button-color);--button-color-selected:var(--button-color);--min-width:auto;--width:100%;--max-width:500px;--min-height:auto;--height:auto;--max-height:calc(100% - (var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:block;position:fixed;outline:none;font-family:var(--ion-font-family, inherit);-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-action-sheet-ios-h{display:none}.action-sheet-wrapper.sc-ion-action-sheet-ios{left:0;right:0;bottom:0;-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0);display:block;position:absolute;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);z-index:10;pointer-events:none}.action-sheet-button.sc-ion-action-sheet-ios{display:block;position:relative;width:100%;border:0;outline:none;background:var(--button-background);color:var(--button-color);font-family:inherit;overflow:hidden}.action-sheet-button-inner.sc-ion-action-sheet-ios{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;pointer-events:none;width:100%;height:100%;z-index:1}.action-sheet-container.sc-ion-action-sheet-ios{display:-ms-flexbox;display:flex;-ms-flex-flow:column;flex-flow:column;-ms-flex-pack:end;justify-content:flex-end;height:100%;max-height:100vh}.action-sheet-group.sc-ion-action-sheet-ios{-ms-flex-negative:2;flex-shrink:2;overscroll-behavior-y:contain;overflow-y:auto;-webkit-overflow-scrolling:touch;pointer-events:all;background:var(--background)}.action-sheet-group.sc-ion-action-sheet-ios::-webkit-scrollbar{display:none}.action-sheet-group-cancel.sc-ion-action-sheet-ios{-ms-flex-negative:0;flex-shrink:0;overflow:hidden}.action-sheet-button.sc-ion-action-sheet-ios::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.action-sheet-selected.sc-ion-action-sheet-ios{color:var(--button-color-selected)}.action-sheet-selected.sc-ion-action-sheet-ios::after{background:var(--button-background-selected);opacity:var(--button-background-selected-opacity)}.action-sheet-button.ion-activated.sc-ion-action-sheet-ios{color:var(--button-color-activated)}.action-sheet-button.ion-activated.sc-ion-action-sheet-ios::after{background:var(--button-background-activated);opacity:var(--button-background-activated-opacity)}.action-sheet-button.ion-focused.sc-ion-action-sheet-ios{color:var(--button-color-focused)}.action-sheet-button.ion-focused.sc-ion-action-sheet-ios::after{background:var(--button-background-focused);opacity:var(--button-background-focused-opacity)}@media (any-hover: hover){.action-sheet-button.sc-ion-action-sheet-ios:hover{color:var(--button-color-hover)}.action-sheet-button.sc-ion-action-sheet-ios:hover::after{background:var(--button-background-hover);opacity:var(--button-background-hover-opacity)}}.sc-ion-action-sheet-ios-h{--background:var(--ion-overlay-background-color, var(--ion-color-step-100, #f9f9f9));--backdrop-opacity:var(--ion-backdrop-opacity, 0.4);--button-background:linear-gradient(0deg, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08), rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08) 50%, transparent 50%) bottom/100% 1px no-repeat transparent;--button-background-activated:var(--ion-text-color, #000);--button-background-activated-opacity:.08;--button-background-hover:currentColor;--button-background-hover-opacity:.04;--button-background-focused:currentColor;--button-background-focused-opacity:.12;--button-background-selected:var(--ion-color-step-150, var(--ion-background-color, #fff));--button-background-selected-opacity:1;--button-color:var(--ion-color-primary, #3880ff);--color:var(--ion-color-step-400, #999999);text-align:center}.action-sheet-wrapper.sc-ion-action-sheet-ios{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:var(--ion-safe-area-top, 0);margin-bottom:var(--ion-safe-area-bottom, 0)}.action-sheet-container.sc-ion-action-sheet-ios{-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px;padding-top:0;padding-bottom:0}.action-sheet-group.sc-ion-action-sheet-ios{border-radius:13px;margin-bottom:8px}.action-sheet-group.sc-ion-action-sheet-ios:first-child{margin-top:10px}.action-sheet-group.sc-ion-action-sheet-ios:last-child{margin-bottom:10px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-group.sc-ion-action-sheet-ios{background-color:transparent;-webkit-backdrop-filter:saturate(280%) blur(20px);backdrop-filter:saturate(280%) blur(20px)}.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-title.sc-ion-action-sheet-ios,.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-button.sc-ion-action-sheet-ios{background-color:transparent;background-image:-webkit-gradient(linear, left bottom, left top, from(rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8)), to(rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8))), -webkit-gradient(linear, left bottom, left top, from(rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.4)), color-stop(50%, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.4)), color-stop(50%, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8)));background-image:linear-gradient(0deg, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8), rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8) 100%), linear-gradient(0deg, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.4), rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.4) 50%, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8) 50%);background-repeat:no-repeat;background-position:top, bottom;background-size:100% calc(100% - 1px), 100% 1px;-webkit-backdrop-filter:saturate(120%);backdrop-filter:saturate(120%)}.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-button.ion-activated.sc-ion-action-sheet-ios{background-color:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.7);background-image:none}.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-cancel.sc-ion-action-sheet-ios{background:var(--button-background-selected)}}.action-sheet-title.sc-ion-action-sheet-ios{background:-webkit-gradient(linear, left bottom, left top, from(rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08)), color-stop(50%, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08)), color-stop(50%, transparent)) bottom/100% 1px no-repeat transparent;background:linear-gradient(0deg, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08), rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08) 50%, transparent 50%) bottom/100% 1px no-repeat transparent}.action-sheet-title.sc-ion-action-sheet-ios{-webkit-padding-start:10px;padding-inline-start:10px;-webkit-padding-end:10px;padding-inline-end:10px;padding-top:14px;padding-bottom:13px;color:var(--color, var(--ion-color-step-400, #999999));font-size:13px;font-weight:400;text-align:center}.action-sheet-title.action-sheet-has-sub-title.sc-ion-action-sheet-ios{font-weight:600}.action-sheet-sub-title.sc-ion-action-sheet-ios{padding-left:0;padding-right:0;padding-top:6px;padding-bottom:0;font-size:13px;font-weight:400}.action-sheet-button.sc-ion-action-sheet-ios{-webkit-padding-start:18px;padding-inline-start:18px;-webkit-padding-end:18px;padding-inline-end:18px;padding-top:18px;padding-bottom:18px;height:56px;font-size:20px;contain:strict}.action-sheet-button.sc-ion-action-sheet-ios .action-sheet-icon.sc-ion-action-sheet-ios{-webkit-margin-end:0.3em;margin-inline-end:0.3em;font-size:28px;pointer-events:none}.action-sheet-button.sc-ion-action-sheet-ios:last-child{background-image:none}.action-sheet-selected.sc-ion-action-sheet-ios{font-weight:bold}.action-sheet-cancel.sc-ion-action-sheet-ios{font-weight:600}.action-sheet-cancel.sc-ion-action-sheet-ios::after{background:var(--button-background-selected);opacity:var(--button-background-selected-opacity)}.action-sheet-destructive.sc-ion-action-sheet-ios,.action-sheet-destructive.ion-activated.sc-ion-action-sheet-ios,.action-sheet-destructive.ion-focused.sc-ion-action-sheet-ios{color:var(--ion-color-danger, #eb445a)}@media (any-hover: hover){.action-sheet-destructive.sc-ion-action-sheet-ios:hover{color:var(--ion-color-danger, #eb445a)}}';
const actionSheetMdCss = '.sc-ion-action-sheet-md-h{--color:initial;--button-color-activated:var(--button-color);--button-color-focused:var(--button-color);--button-color-hover:var(--button-color);--button-color-selected:var(--button-color);--min-width:auto;--width:100%;--max-width:500px;--min-height:auto;--height:auto;--max-height:calc(100% - (var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:block;position:fixed;outline:none;font-family:var(--ion-font-family, inherit);-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-action-sheet-md-h{display:none}.action-sheet-wrapper.sc-ion-action-sheet-md{left:0;right:0;bottom:0;-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0);display:block;position:absolute;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);z-index:10;pointer-events:none}.action-sheet-button.sc-ion-action-sheet-md{display:block;position:relative;width:100%;border:0;outline:none;background:var(--button-background);color:var(--button-color);font-family:inherit;overflow:hidden}.action-sheet-button-inner.sc-ion-action-sheet-md{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;pointer-events:none;width:100%;height:100%;z-index:1}.action-sheet-container.sc-ion-action-sheet-md{display:-ms-flexbox;display:flex;-ms-flex-flow:column;flex-flow:column;-ms-flex-pack:end;justify-content:flex-end;height:100%;max-height:100vh}.action-sheet-group.sc-ion-action-sheet-md{-ms-flex-negative:2;flex-shrink:2;overscroll-behavior-y:contain;overflow-y:auto;-webkit-overflow-scrolling:touch;pointer-events:all;background:var(--background)}.action-sheet-group.sc-ion-action-sheet-md::-webkit-scrollbar{display:none}.action-sheet-group-cancel.sc-ion-action-sheet-md{-ms-flex-negative:0;flex-shrink:0;overflow:hidden}.action-sheet-button.sc-ion-action-sheet-md::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.action-sheet-selected.sc-ion-action-sheet-md{color:var(--button-color-selected)}.action-sheet-selected.sc-ion-action-sheet-md::after{background:var(--button-background-selected);opacity:var(--button-background-selected-opacity)}.action-sheet-button.ion-activated.sc-ion-action-sheet-md{color:var(--button-color-activated)}.action-sheet-button.ion-activated.sc-ion-action-sheet-md::after{background:var(--button-background-activated);opacity:var(--button-background-activated-opacity)}.action-sheet-button.ion-focused.sc-ion-action-sheet-md{color:var(--button-color-focused)}.action-sheet-button.ion-focused.sc-ion-action-sheet-md::after{background:var(--button-background-focused);opacity:var(--button-background-focused-opacity)}@media (any-hover: hover){.action-sheet-button.sc-ion-action-sheet-md:hover{color:var(--button-color-hover)}.action-sheet-button.sc-ion-action-sheet-md:hover::after{background:var(--button-background-hover);opacity:var(--button-background-hover-opacity)}}.sc-ion-action-sheet-md-h{--background:var(--ion-overlay-background-color, var(--ion-background-color, #fff));--backdrop-opacity:var(--ion-backdrop-opacity, 0.32);--button-background:transparent;--button-background-selected:currentColor;--button-background-selected-opacity:0;--button-background-activated:transparent;--button-background-activated-opacity:0;--button-background-hover:currentColor;--button-background-hover-opacity:.04;--button-background-focused:currentColor;--button-background-focused-opacity:.12;--button-color:var(--ion-color-step-850, #262626);--color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54)}.action-sheet-wrapper.sc-ion-action-sheet-md{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:var(--ion-safe-area-top, 0);margin-bottom:0}.action-sheet-title.sc-ion-action-sheet-md{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:20px;padding-bottom:17px;min-height:60px;color:var(--color, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54));font-size:16px;text-align:start}.action-sheet-sub-title.sc-ion-action-sheet-md{padding-left:0;padding-right:0;padding-top:16px;padding-bottom:0;font-size:14px}.action-sheet-group.sc-ion-action-sheet-md:first-child{padding-top:0}.action-sheet-group.sc-ion-action-sheet-md:last-child{padding-bottom:var(--ion-safe-area-bottom)}.action-sheet-button.sc-ion-action-sheet-md{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:0;padding-bottom:0;position:relative;height:52px;font-size:16px;text-align:start;contain:strict;overflow:hidden}.action-sheet-icon.sc-ion-action-sheet-md{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:32px;margin-inline-end:32px;margin-top:0;margin-bottom:0;color:var(--color);font-size:24px}.action-sheet-button-inner.sc-ion-action-sheet-md{-ms-flex-pack:start;justify-content:flex-start}.action-sheet-selected.sc-ion-action-sheet-md{font-weight:bold}';
const ActionSheet = /* @__PURE__ */ proxyCustomElement$1(class ActionSheet2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.didPresent = createEvent(this, "ionActionSheetDidPresent", 7);
    this.willPresent = createEvent(this, "ionActionSheetWillPresent", 7);
    this.willDismiss = createEvent(this, "ionActionSheetWillDismiss", 7);
    this.didDismiss = createEvent(this, "ionActionSheetDidDismiss", 7);
    this.didPresentShorthand = createEvent(this, "didPresent", 7);
    this.willPresentShorthand = createEvent(this, "willPresent", 7);
    this.willDismissShorthand = createEvent(this, "willDismiss", 7);
    this.didDismissShorthand = createEvent(this, "didDismiss", 7);
    this.delegateController = createDelegateController(this);
    this.triggerController = createTriggerController();
    this.presented = false;
    this.onBackdropTap = () => {
      this.dismiss(void 0, BACKDROP);
    };
    this.dispatchCancelHandler = (ev) => {
      const role = ev.detail.role;
      if (isCancel$2(role)) {
        const cancelButton = this.getButtons().find((b2) => b2.role === "cancel");
        this.callButtonHandler(cancelButton);
      }
    };
    this.overlayIndex = void 0;
    this.delegate = void 0;
    this.hasController = false;
    this.keyboardClose = true;
    this.enterAnimation = void 0;
    this.leaveAnimation = void 0;
    this.buttons = [];
    this.cssClass = void 0;
    this.backdropDismiss = true;
    this.header = void 0;
    this.subHeader = void 0;
    this.translucent = false;
    this.animated = true;
    this.htmlAttributes = void 0;
    this.isOpen = false;
    this.trigger = void 0;
  }
  onIsOpenChange(newValue, oldValue) {
    if (newValue === true && oldValue === false) {
      this.present();
    } else if (newValue === false && oldValue === true) {
      this.dismiss();
    }
  }
  triggerChanged() {
    const { trigger, el: el2, triggerController } = this;
    if (trigger) {
      triggerController.addClickListener(el2, trigger);
    }
  }
  /**
   * Present the action sheet overlay after it has been created.
   */
  async present() {
    if (this.currentTransition !== void 0) {
      await this.currentTransition;
    }
    await this.delegateController.attachViewToDom();
    this.currentTransition = present(this, "actionSheetEnter", iosEnterAnimation$4, mdEnterAnimation$4);
    await this.currentTransition;
    this.currentTransition = void 0;
  }
  /**
   * Dismiss the action sheet overlay after it has been presented.
   *
   * @param data Any data to emit in the dismiss events.
   * @param role The role of the element that is dismissing the action sheet.
   * This can be useful in a button handler for determining which button was
   * clicked to dismiss the action sheet.
   * Some examples include: ``"cancel"`, `"destructive"`, "selected"`, and `"backdrop"`.
   */
  async dismiss(data2, role) {
    this.currentTransition = dismiss(this, data2, role, "actionSheetLeave", iosLeaveAnimation$4, mdLeaveAnimation$4);
    const dismissed = await this.currentTransition;
    if (dismissed) {
      this.delegateController.removeViewFromDom();
    }
    return dismissed;
  }
  /**
   * Returns a promise that resolves when the action sheet did dismiss.
   */
  onDidDismiss() {
    return eventMethod(this.el, "ionActionSheetDidDismiss");
  }
  /**
   * Returns a promise that resolves when the action sheet will dismiss.
   *
   */
  onWillDismiss() {
    return eventMethod(this.el, "ionActionSheetWillDismiss");
  }
  async buttonClick(button) {
    const role = button.role;
    if (isCancel$2(role)) {
      return this.dismiss(button.data, role);
    }
    const shouldDismiss = await this.callButtonHandler(button);
    if (shouldDismiss) {
      return this.dismiss(button.data, button.role);
    }
    return Promise.resolve();
  }
  async callButtonHandler(button) {
    if (button) {
      const rtn = await safeCall$1(button.handler);
      if (rtn === false) {
        return false;
      }
    }
    return true;
  }
  getButtons() {
    return this.buttons.map((b2) => {
      return typeof b2 === "string" ? { text: b2 } : b2;
    });
  }
  connectedCallback() {
    prepareOverlay(this.el);
    this.triggerChanged();
  }
  disconnectedCallback() {
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
    this.triggerController.removeClickListener();
  }
  componentWillLoad() {
    setOverlayId(this.el);
  }
  componentDidLoad() {
    const { groupEl, wrapperEl } = this;
    if (this.gesture || getIonMode$2(this) === "md" || !wrapperEl || !groupEl) {
      return;
    }
    readTask(() => {
      const isScrollable = groupEl.scrollHeight > groupEl.clientHeight;
      if (!isScrollable) {
        this.gesture = createButtonActiveGesture(wrapperEl, (refEl) => refEl.classList.contains("action-sheet-button"));
        this.gesture.enable(true);
      }
    });
  }
  render() {
    const { header, htmlAttributes, overlayIndex } = this;
    const mode = getIonMode$2(this);
    const allButtons = this.getButtons();
    const cancelButton = allButtons.find((b2) => b2.role === "cancel");
    const buttons = allButtons.filter((b2) => b2.role !== "cancel");
    const headerID = `action-sheet-${overlayIndex}-header`;
    return h$5(Host$1, Object.assign({ role: "dialog", "aria-modal": "true", "aria-labelledby": header !== void 0 ? headerID : null, tabindex: "-1" }, htmlAttributes, { style: {
      zIndex: `${2e4 + this.overlayIndex}`
    }, class: Object.assign(Object.assign({ [mode]: true }, getClassMap(this.cssClass)), { "overlay-hidden": true, "action-sheet-translucent": this.translucent }), onIonActionSheetWillDismiss: this.dispatchCancelHandler, onIonBackdropTap: this.onBackdropTap }), h$5("ion-backdrop", { tappable: this.backdropDismiss }), h$5("div", { tabindex: "0" }), h$5("div", { class: "action-sheet-wrapper ion-overlay-wrapper", ref: (el2) => this.wrapperEl = el2 }, h$5("div", { class: "action-sheet-container" }, h$5("div", { class: "action-sheet-group", ref: (el2) => this.groupEl = el2 }, header !== void 0 && h$5("div", { id: headerID, class: {
      "action-sheet-title": true,
      "action-sheet-has-sub-title": this.subHeader !== void 0
    } }, header, this.subHeader && h$5("div", { class: "action-sheet-sub-title" }, this.subHeader)), buttons.map((b2) => h$5("button", { type: "button", id: b2.id, class: buttonClass$2(b2), onClick: () => this.buttonClick(b2) }, h$5("span", { class: "action-sheet-button-inner" }, b2.icon && h$5("ion-icon", { icon: b2.icon, "aria-hidden": "true", lazy: false, class: "action-sheet-icon" }), b2.text), mode === "md" && h$5("ion-ripple-effect", null)))), cancelButton && h$5("div", { class: "action-sheet-group action-sheet-group-cancel" }, h$5("button", { type: "button", class: buttonClass$2(cancelButton), onClick: () => this.buttonClick(cancelButton) }, h$5("span", { class: "action-sheet-button-inner" }, cancelButton.icon && h$5("ion-icon", { icon: cancelButton.icon, "aria-hidden": "true", lazy: false, class: "action-sheet-icon" }), cancelButton.text), mode === "md" && h$5("ion-ripple-effect", null))))), h$5("div", { tabindex: "0" }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "isOpen": ["onIsOpenChange"],
      "trigger": ["triggerChanged"]
    };
  }
  static get style() {
    return {
      ios: actionSheetIosCss,
      md: actionSheetMdCss
    };
  }
}, [34, "ion-action-sheet", {
  "overlayIndex": [2, "overlay-index"],
  "delegate": [16],
  "hasController": [4, "has-controller"],
  "keyboardClose": [4, "keyboard-close"],
  "enterAnimation": [16],
  "leaveAnimation": [16],
  "buttons": [16],
  "cssClass": [1, "css-class"],
  "backdropDismiss": [4, "backdrop-dismiss"],
  "header": [1],
  "subHeader": [1, "sub-header"],
  "translucent": [4],
  "animated": [4],
  "htmlAttributes": [16],
  "isOpen": [4, "is-open"],
  "trigger": [1],
  "present": [64],
  "dismiss": [64],
  "onDidDismiss": [64],
  "onWillDismiss": [64]
}]);
const buttonClass$2 = (button) => {
  return Object.assign({ "action-sheet-button": true, "ion-activatable": true, "ion-focusable": true, [`action-sheet-${button.role}`]: button.role !== void 0 }, getClassMap(button.cssClass));
};
function defineCustomElement$o() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-action-sheet", "ion-backdrop", "ion-icon", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-action-sheet":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ActionSheet);
        }
        break;
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          defineCustomElement$17();
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$1b();
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$Z();
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const iosEnterAnimation$3 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  wrapperAnimation.addElement(baseEl.querySelector(".alert-wrapper")).keyframes([
    { offset: 0, opacity: "0.01", transform: "scale(1.1)" },
    { offset: 1, opacity: "1", transform: "scale(1)" }
  ]);
  return baseAnimation2.addElement(baseEl).easing("ease-in-out").duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};
const iosLeaveAnimation$3 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", "var(--backdrop-opacity)", 0);
  wrapperAnimation.addElement(baseEl.querySelector(".alert-wrapper")).keyframes([
    { offset: 0, opacity: 0.99, transform: "scale(1)" },
    { offset: 1, opacity: 0, transform: "scale(0.9)" }
  ]);
  return baseAnimation2.addElement(baseEl).easing("ease-in-out").duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};
const mdEnterAnimation$3 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  wrapperAnimation.addElement(baseEl.querySelector(".alert-wrapper")).keyframes([
    { offset: 0, opacity: "0.01", transform: "scale(0.9)" },
    { offset: 1, opacity: "1", transform: "scale(1)" }
  ]);
  return baseAnimation2.addElement(baseEl).easing("ease-in-out").duration(150).addAnimation([backdropAnimation, wrapperAnimation]);
};
const mdLeaveAnimation$3 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", "var(--backdrop-opacity)", 0);
  wrapperAnimation.addElement(baseEl.querySelector(".alert-wrapper")).fromTo("opacity", 0.99, 0);
  return baseAnimation2.addElement(baseEl).easing("ease-in-out").duration(150).addAnimation([backdropAnimation, wrapperAnimation]);
};
const alertIosCss = ".sc-ion-alert-ios-h{--min-width:250px;--width:auto;--min-height:auto;--height:auto;--max-height:90%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-alert-ios-h{display:none}.alert-top.sc-ion-alert-ios-h{padding-top:50px;-ms-flex-align:start;align-items:flex-start}.alert-wrapper.sc-ion-alert-ios{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);contain:content;opacity:0;z-index:10}.alert-title.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}.alert-sub-title.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-weight:normal}.alert-message.sc-ion-alert-ios{-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-overflow-scrolling:touch;overflow-y:auto;overscroll-behavior-y:contain}.alert-checkbox-group.sc-ion-alert-ios::-webkit-scrollbar,.alert-radio-group.sc-ion-alert-ios::-webkit-scrollbar,.alert-message.sc-ion-alert-ios::-webkit-scrollbar{display:none}.alert-input.sc-ion-alert-ios{padding-left:0;padding-right:0;padding-top:10px;padding-bottom:10px;width:100%;border:0;background:inherit;font:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.alert-button-group.sc-ion-alert-ios{display:-ms-flexbox;display:flex;-ms-flex-direction:row;flex-direction:row;width:100%}.alert-button-group-vertical.sc-ion-alert-ios{-ms-flex-direction:column;flex-direction:column;-ms-flex-wrap:nowrap;flex-wrap:nowrap}.alert-button.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;border:0;font-size:14px;line-height:20px;z-index:0}.alert-button.ion-focused.sc-ion-alert-ios,.alert-tappable.ion-focused.sc-ion-alert-ios{background:var(--ion-color-step-100, #e6e6e6)}.alert-button-inner.sc-ion-alert-ios{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.alert-input-disabled.sc-ion-alert-ios,.alert-checkbox-button-disabled.sc-ion-alert-ios .alert-button-inner.sc-ion-alert-ios,.alert-radio-button-disabled.sc-ion-alert-ios .alert-button-inner.sc-ion-alert-ios{cursor:default;opacity:0.5;pointer-events:none}.alert-tappable.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;width:100%;border:0;background:transparent;font-size:inherit;line-height:initial;text-align:start;-webkit-appearance:none;-moz-appearance:none;appearance:none;contain:strict}.alert-button.sc-ion-alert-ios,.alert-checkbox.sc-ion-alert-ios,.alert-input.sc-ion-alert-ios,.alert-radio.sc-ion-alert-ios{outline:none}.alert-radio-icon.sc-ion-alert-ios,.alert-checkbox-icon.sc-ion-alert-ios,.alert-checkbox-inner.sc-ion-alert-ios{-webkit-box-sizing:border-box;box-sizing:border-box}textarea.alert-input.sc-ion-alert-ios{min-height:37px;resize:none}.sc-ion-alert-ios-h{--background:var(--ion-overlay-background-color, var(--ion-color-step-100, #f9f9f9));--max-width:270px;--backdrop-opacity:var(--ion-backdrop-opacity, 0.3);font-size:14px}.alert-wrapper.sc-ion-alert-ios{border-radius:13px;-webkit-box-shadow:none;box-shadow:none;overflow:hidden}.alert-button.sc-ion-alert-ios .alert-button-inner.sc-ion-alert-ios{pointer-events:none}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.alert-translucent.sc-ion-alert-ios-h .alert-wrapper.sc-ion-alert-ios{background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.9);-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}}.alert-head.sc-ion-alert-ios{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:12px;padding-bottom:7px;text-align:center}.alert-title.sc-ion-alert-ios{margin-top:8px;color:var(--ion-text-color, #000);font-size:17px;font-weight:600}.alert-sub-title.sc-ion-alert-ios{color:var(--ion-color-step-600, #666666);font-size:14px}.alert-message.sc-ion-alert-ios,.alert-input-group.sc-ion-alert-ios{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:0;padding-bottom:21px;color:var(--ion-text-color, #000);font-size:13px;text-align:center}.alert-message.sc-ion-alert-ios{max-height:240px}.alert-message.sc-ion-alert-ios:empty{padding-left:0;padding-right:0;padding-top:0;padding-bottom:12px}.alert-input.sc-ion-alert-ios{border-radius:4px;margin-top:10px;-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px;padding-top:6px;padding-bottom:6px;border:0.55px solid var(--ion-color-step-250, #bfbfbf);background-color:var(--ion-background-color, #fff);-webkit-appearance:none;-moz-appearance:none;appearance:none}.alert-input.sc-ion-alert-ios::-webkit-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::-moz-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios:-ms-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::-ms-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::-ms-clear{display:none}.alert-radio-group.sc-ion-alert-ios,.alert-checkbox-group.sc-ion-alert-ios{-ms-scroll-chaining:none;overscroll-behavior:contain;max-height:240px;border-top:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2);overflow-y:auto;-webkit-overflow-scrolling:touch}.alert-tappable.sc-ion-alert-ios{height:44px}.alert-radio-label.sc-ion-alert-ios{-webkit-padding-start:13px;padding-inline-start:13px;-webkit-padding-end:13px;padding-inline-end:13px;padding-top:13px;padding-bottom:13px;-ms-flex:1;flex:1;-ms-flex-order:0;order:0;color:var(--ion-text-color, #000);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}[aria-checked=true].sc-ion-alert-ios .alert-radio-label.sc-ion-alert-ios{color:var(--ion-color-primary, #3880ff)}.alert-radio-icon.sc-ion-alert-ios{position:relative;-ms-flex-order:1;order:1;min-width:30px}[aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{top:-7px;position:absolute;width:6px;height:12px;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-width:2px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--ion-color-primary, #3880ff)}@supports (inset-inline-start: 0){[aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{inset-inline-start:7px}}@supports not (inset-inline-start: 0){[aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{left:7px}[dir=rtl].sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios,[dir=rtl] .sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{left:unset;right:unset;right:7px}[dir=rtl].sc-ion-alert-ios [aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{left:unset;right:unset;right:7px}@supports selector(:dir(rtl)){[aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios:dir(rtl){left:unset;right:unset;right:7px}}}.alert-checkbox-label.sc-ion-alert-ios{-webkit-padding-start:13px;padding-inline-start:13px;-webkit-padding-end:13px;padding-inline-end:13px;padding-top:13px;padding-bottom:13px;-ms-flex:1;flex:1;color:var(--ion-text-color, #000);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.alert-checkbox-icon.sc-ion-alert-ios{border-radius:50%;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:6px;margin-inline-end:6px;margin-top:10px;margin-bottom:10px;position:relative;width:24px;height:24px;border-width:1px;border-style:solid;border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));background-color:var(--ion-item-background, var(--ion-background-color, #fff));contain:strict}[aria-checked=true].sc-ion-alert-ios .alert-checkbox-icon.sc-ion-alert-ios{border-color:var(--ion-color-primary, #3880ff);background-color:var(--ion-color-primary, #3880ff)}[aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{top:4px;position:absolute;width:5px;height:12px;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-width:1px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--ion-background-color, #fff)}@supports (inset-inline-start: 0){[aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{inset-inline-start:9px}}@supports not (inset-inline-start: 0){[aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{left:9px}[dir=rtl].sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios,[dir=rtl] .sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{left:unset;right:unset;right:9px}[dir=rtl].sc-ion-alert-ios [aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{left:unset;right:unset;right:9px}@supports selector(:dir(rtl)){[aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios:dir(rtl){left:unset;right:unset;right:9px}}}.alert-button-group.sc-ion-alert-ios{-webkit-margin-end:-0.55px;margin-inline-end:-0.55px;-ms-flex-wrap:wrap;flex-wrap:wrap}.alert-button.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;border-radius:0;-ms-flex:1 1 auto;flex:1 1 auto;min-width:50%;height:44px;border-top:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2);border-right:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2);background-color:transparent;color:var(--ion-color-primary, #3880ff);font-size:17px;overflow:hidden}[dir=rtl].sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:first-child,[dir=rtl] .sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:first-child{border-right:0}[dir=rtl].sc-ion-alert-ios .alert-button.sc-ion-alert-ios:first-child{border-right:0}@supports selector(:dir(rtl)){.alert-button.sc-ion-alert-ios:first-child:dir(rtl){border-right:0}}.alert-button.sc-ion-alert-ios:last-child{border-right:0;font-weight:bold}[dir=rtl].sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:last-child,[dir=rtl] .sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:last-child{border-right:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2)}[dir=rtl].sc-ion-alert-ios .alert-button.sc-ion-alert-ios:last-child{border-right:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2)}@supports selector(:dir(rtl)){.alert-button.sc-ion-alert-ios:last-child:dir(rtl){border-right:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2)}}.alert-button.ion-activated.sc-ion-alert-ios{background-color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.1)}.alert-button-role-destructive.sc-ion-alert-ios,.alert-button-role-destructive.ion-activated.sc-ion-alert-ios,.alert-button-role-destructive.ion-focused.sc-ion-alert-ios{color:var(--ion-color-danger, #eb445a)}";
const alertMdCss = ".sc-ion-alert-md-h{--min-width:250px;--width:auto;--min-height:auto;--height:auto;--max-height:90%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-alert-md-h{display:none}.alert-top.sc-ion-alert-md-h{padding-top:50px;-ms-flex-align:start;align-items:flex-start}.alert-wrapper.sc-ion-alert-md{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);contain:content;opacity:0;z-index:10}.alert-title.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}.alert-sub-title.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-weight:normal}.alert-message.sc-ion-alert-md{-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-overflow-scrolling:touch;overflow-y:auto;overscroll-behavior-y:contain}.alert-checkbox-group.sc-ion-alert-md::-webkit-scrollbar,.alert-radio-group.sc-ion-alert-md::-webkit-scrollbar,.alert-message.sc-ion-alert-md::-webkit-scrollbar{display:none}.alert-input.sc-ion-alert-md{padding-left:0;padding-right:0;padding-top:10px;padding-bottom:10px;width:100%;border:0;background:inherit;font:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.alert-button-group.sc-ion-alert-md{display:-ms-flexbox;display:flex;-ms-flex-direction:row;flex-direction:row;width:100%}.alert-button-group-vertical.sc-ion-alert-md{-ms-flex-direction:column;flex-direction:column;-ms-flex-wrap:nowrap;flex-wrap:nowrap}.alert-button.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;border:0;font-size:14px;line-height:20px;z-index:0}.alert-button.ion-focused.sc-ion-alert-md,.alert-tappable.ion-focused.sc-ion-alert-md{background:var(--ion-color-step-100, #e6e6e6)}.alert-button-inner.sc-ion-alert-md{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.alert-input-disabled.sc-ion-alert-md,.alert-checkbox-button-disabled.sc-ion-alert-md .alert-button-inner.sc-ion-alert-md,.alert-radio-button-disabled.sc-ion-alert-md .alert-button-inner.sc-ion-alert-md{cursor:default;opacity:0.5;pointer-events:none}.alert-tappable.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;width:100%;border:0;background:transparent;font-size:inherit;line-height:initial;text-align:start;-webkit-appearance:none;-moz-appearance:none;appearance:none;contain:strict}.alert-button.sc-ion-alert-md,.alert-checkbox.sc-ion-alert-md,.alert-input.sc-ion-alert-md,.alert-radio.sc-ion-alert-md{outline:none}.alert-radio-icon.sc-ion-alert-md,.alert-checkbox-icon.sc-ion-alert-md,.alert-checkbox-inner.sc-ion-alert-md{-webkit-box-sizing:border-box;box-sizing:border-box}textarea.alert-input.sc-ion-alert-md{min-height:37px;resize:none}.sc-ion-alert-md-h{--background:var(--ion-overlay-background-color, var(--ion-background-color, #fff));--max-width:280px;--backdrop-opacity:var(--ion-backdrop-opacity, 0.32);font-size:14px}.alert-wrapper.sc-ion-alert-md{border-radius:4px;-webkit-box-shadow:0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12);box-shadow:0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12)}.alert-head.sc-ion-alert-md{-webkit-padding-start:23px;padding-inline-start:23px;-webkit-padding-end:23px;padding-inline-end:23px;padding-top:20px;padding-bottom:15px;text-align:start}.alert-title.sc-ion-alert-md{color:var(--ion-text-color, #000);font-size:20px;font-weight:500}.alert-sub-title.sc-ion-alert-md{color:var(--ion-text-color, #000);font-size:16px}.alert-message.sc-ion-alert-md,.alert-input-group.sc-ion-alert-md{-webkit-padding-start:24px;padding-inline-start:24px;-webkit-padding-end:24px;padding-inline-end:24px;padding-top:20px;padding-bottom:20px;color:var(--ion-color-step-550, #737373)}.alert-message.sc-ion-alert-md{max-height:266px;font-size:16px}.alert-message.sc-ion-alert-md:empty{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}.alert-head.sc-ion-alert-md+.alert-message.sc-ion-alert-md{padding-top:0}.alert-input.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:5px;border-bottom:1px solid var(--ion-color-step-150, #d9d9d9);color:var(--ion-text-color, #000)}.alert-input.sc-ion-alert-md::-webkit-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::-moz-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md:-ms-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::-ms-input-placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::-ms-clear{display:none}.alert-input.sc-ion-alert-md:focus{margin-bottom:4px;border-bottom:2px solid var(--ion-color-primary, #3880ff)}.alert-radio-group.sc-ion-alert-md,.alert-checkbox-group.sc-ion-alert-md{position:relative;max-height:266px;border-top:1px solid var(--ion-color-step-150, #d9d9d9);border-bottom:1px solid var(--ion-color-step-150, #d9d9d9);overflow:auto}.alert-tappable.sc-ion-alert-md{position:relative;height:48px;overflow:hidden}.alert-radio-label.sc-ion-alert-md{-webkit-padding-start:52px;padding-inline-start:52px;-webkit-padding-end:26px;padding-inline-end:26px;padding-top:13px;padding-bottom:13px;-ms-flex:1;flex:1;color:var(--ion-color-step-850, #262626);font-size:16px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.alert-radio-icon.sc-ion-alert-md{top:0;border-radius:50%;display:block;position:relative;width:20px;height:20px;border-width:2px;border-style:solid;border-color:var(--ion-color-step-550, #737373)}@supports (inset-inline-start: 0){.alert-radio-icon.sc-ion-alert-md{inset-inline-start:26px}}@supports not (inset-inline-start: 0){.alert-radio-icon.sc-ion-alert-md{left:26px}[dir=rtl].sc-ion-alert-md-h .alert-radio-icon.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h .alert-radio-icon.sc-ion-alert-md{left:unset;right:unset;right:26px}[dir=rtl].sc-ion-alert-md .alert-radio-icon.sc-ion-alert-md{left:unset;right:unset;right:26px}@supports selector(:dir(rtl)){.alert-radio-icon.sc-ion-alert-md:dir(rtl){left:unset;right:unset;right:26px}}}.alert-radio-inner.sc-ion-alert-md{top:3px;border-radius:50%;position:absolute;width:10px;height:10px;-webkit-transform:scale3d(0, 0, 0);transform:scale3d(0, 0, 0);-webkit-transition:-webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1);transition:-webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1);transition:transform 280ms cubic-bezier(0.4, 0, 0.2, 1);transition:transform 280ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:var(--ion-color-primary, #3880ff)}@supports (inset-inline-start: 0){.alert-radio-inner.sc-ion-alert-md{inset-inline-start:3px}}@supports not (inset-inline-start: 0){.alert-radio-inner.sc-ion-alert-md{left:3px}[dir=rtl].sc-ion-alert-md-h .alert-radio-inner.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h .alert-radio-inner.sc-ion-alert-md{left:unset;right:unset;right:3px}[dir=rtl].sc-ion-alert-md .alert-radio-inner.sc-ion-alert-md{left:unset;right:unset;right:3px}@supports selector(:dir(rtl)){.alert-radio-inner.sc-ion-alert-md:dir(rtl){left:unset;right:unset;right:3px}}}[aria-checked=true].sc-ion-alert-md .alert-radio-label.sc-ion-alert-md{color:var(--ion-color-step-850, #262626)}[aria-checked=true].sc-ion-alert-md .alert-radio-icon.sc-ion-alert-md{border-color:var(--ion-color-primary, #3880ff)}[aria-checked=true].sc-ion-alert-md .alert-radio-inner.sc-ion-alert-md{-webkit-transform:scale3d(1, 1, 1);transform:scale3d(1, 1, 1)}.alert-checkbox-label.sc-ion-alert-md{-webkit-padding-start:53px;padding-inline-start:53px;-webkit-padding-end:26px;padding-inline-end:26px;padding-top:13px;padding-bottom:13px;-ms-flex:1;flex:1;color:var(--ion-color-step-850, #262626);font-size:16px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.alert-checkbox-icon.sc-ion-alert-md{top:0;border-radius:2px;position:relative;width:16px;height:16px;border-width:2px;border-style:solid;border-color:var(--ion-color-step-550, #737373);contain:strict}@supports (inset-inline-start: 0){.alert-checkbox-icon.sc-ion-alert-md{inset-inline-start:26px}}@supports not (inset-inline-start: 0){.alert-checkbox-icon.sc-ion-alert-md{left:26px}[dir=rtl].sc-ion-alert-md-h .alert-checkbox-icon.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h .alert-checkbox-icon.sc-ion-alert-md{left:unset;right:unset;right:26px}[dir=rtl].sc-ion-alert-md .alert-checkbox-icon.sc-ion-alert-md{left:unset;right:unset;right:26px}@supports selector(:dir(rtl)){.alert-checkbox-icon.sc-ion-alert-md:dir(rtl){left:unset;right:unset;right:26px}}}[aria-checked=true].sc-ion-alert-md .alert-checkbox-icon.sc-ion-alert-md{border-color:var(--ion-color-primary, #3880ff);background-color:var(--ion-color-primary, #3880ff)}[aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{top:0;position:absolute;width:6px;height:10px;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-width:2px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--ion-color-primary-contrast, #fff)}@supports (inset-inline-start: 0){[aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{inset-inline-start:3px}}@supports not (inset-inline-start: 0){[aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{left:3px}[dir=rtl].sc-ion-alert-md-h [aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h [aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{left:unset;right:unset;right:3px}[dir=rtl].sc-ion-alert-md [aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{left:unset;right:unset;right:3px}@supports selector(:dir(rtl)){[aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md:dir(rtl){left:unset;right:unset;right:3px}}}.alert-button-group.sc-ion-alert-md{-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px;padding-top:8px;padding-bottom:8px;-webkit-box-sizing:border-box;box-sizing:border-box;-ms-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse;-ms-flex-pack:end;justify-content:flex-end}.alert-button.sc-ion-alert-md{border-radius:2px;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px;margin-top:0;margin-bottom:0;-webkit-padding-start:10px;padding-inline-start:10px;-webkit-padding-end:10px;padding-inline-end:10px;padding-top:10px;padding-bottom:10px;position:relative;background-color:transparent;color:var(--ion-color-primary, #3880ff);font-weight:500;text-align:end;text-transform:uppercase;overflow:hidden}.alert-button-inner.sc-ion-alert-md{-ms-flex-pack:end;justify-content:flex-end}";
const Alert = /* @__PURE__ */ proxyCustomElement$1(class Alert2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.didPresent = createEvent(this, "ionAlertDidPresent", 7);
    this.willPresent = createEvent(this, "ionAlertWillPresent", 7);
    this.willDismiss = createEvent(this, "ionAlertWillDismiss", 7);
    this.didDismiss = createEvent(this, "ionAlertDidDismiss", 7);
    this.didPresentShorthand = createEvent(this, "didPresent", 7);
    this.willPresentShorthand = createEvent(this, "willPresent", 7);
    this.willDismissShorthand = createEvent(this, "willDismiss", 7);
    this.didDismissShorthand = createEvent(this, "didDismiss", 7);
    this.delegateController = createDelegateController(this);
    this.triggerController = createTriggerController();
    this.customHTMLEnabled = config$1.get("innerHTMLTemplatesEnabled", ENABLE_HTML_CONTENT_DEFAULT);
    this.processedInputs = [];
    this.processedButtons = [];
    this.presented = false;
    this.onBackdropTap = () => {
      this.dismiss(void 0, BACKDROP);
    };
    this.dispatchCancelHandler = (ev) => {
      const role = ev.detail.role;
      if (isCancel$2(role)) {
        const cancelButton = this.processedButtons.find((b2) => b2.role === "cancel");
        this.callButtonHandler(cancelButton);
      }
    };
    this.overlayIndex = void 0;
    this.delegate = void 0;
    this.hasController = false;
    this.keyboardClose = true;
    this.enterAnimation = void 0;
    this.leaveAnimation = void 0;
    this.cssClass = void 0;
    this.header = void 0;
    this.subHeader = void 0;
    this.message = void 0;
    this.buttons = [];
    this.inputs = [];
    this.backdropDismiss = true;
    this.translucent = false;
    this.animated = true;
    this.htmlAttributes = void 0;
    this.isOpen = false;
    this.trigger = void 0;
  }
  onIsOpenChange(newValue, oldValue) {
    if (newValue === true && oldValue === false) {
      this.present();
    } else if (newValue === false && oldValue === true) {
      this.dismiss();
    }
  }
  triggerChanged() {
    const { trigger, el: el2, triggerController } = this;
    if (trigger) {
      triggerController.addClickListener(el2, trigger);
    }
  }
  onKeydown(ev) {
    const inputTypes = new Set(this.processedInputs.map((i) => i.type));
    if (!inputTypes.has("radio") || ev.target && !this.el.contains(ev.target) || ev.target.classList.contains("alert-button")) {
      return;
    }
    const query = this.el.querySelectorAll(".alert-radio");
    const radios = Array.from(query).filter((radio2) => !radio2.disabled);
    const index3 = radios.findIndex((radio2) => radio2.id === ev.target.id);
    let nextEl;
    if (["ArrowDown", "ArrowRight"].includes(ev.key)) {
      nextEl = index3 === radios.length - 1 ? radios[0] : radios[index3 + 1];
    }
    if (["ArrowUp", "ArrowLeft"].includes(ev.key)) {
      nextEl = index3 === 0 ? radios[radios.length - 1] : radios[index3 - 1];
    }
    if (nextEl && radios.includes(nextEl)) {
      const nextProcessed = this.processedInputs.find((input) => input.id === (nextEl === null || nextEl === void 0 ? void 0 : nextEl.id));
      if (nextProcessed) {
        this.rbClick(nextProcessed);
        nextEl.focus();
      }
    }
  }
  buttonsChanged() {
    const buttons = this.buttons;
    this.processedButtons = buttons.map((btn) => {
      return typeof btn === "string" ? { text: btn, role: btn.toLowerCase() === "cancel" ? "cancel" : void 0 } : btn;
    });
  }
  inputsChanged() {
    const inputs = this.inputs;
    const first = inputs.find((input) => !input.disabled);
    const checked = inputs.find((input) => input.checked && !input.disabled);
    const focusable = checked || first;
    const inputTypes = new Set(inputs.map((i) => i.type));
    if (inputTypes.has("checkbox") && inputTypes.has("radio")) {
      console.warn(`Alert cannot mix input types: ${Array.from(inputTypes.values()).join("/")}. Please see alert docs for more info.`);
    }
    this.inputType = inputTypes.values().next().value;
    this.processedInputs = inputs.map((i, index3) => {
      var _a2;
      return {
        type: i.type || "text",
        name: i.name || `${index3}`,
        placeholder: i.placeholder || "",
        value: i.value,
        label: i.label,
        checked: !!i.checked,
        disabled: !!i.disabled,
        id: i.id || `alert-input-${this.overlayIndex}-${index3}`,
        handler: i.handler,
        min: i.min,
        max: i.max,
        cssClass: (_a2 = i.cssClass) !== null && _a2 !== void 0 ? _a2 : "",
        attributes: i.attributes || {},
        tabindex: i.type === "radio" && i !== focusable ? -1 : 0
      };
    });
  }
  connectedCallback() {
    prepareOverlay(this.el);
    this.triggerChanged();
  }
  componentWillLoad() {
    setOverlayId(this.el);
    this.inputsChanged();
    this.buttonsChanged();
  }
  disconnectedCallback() {
    this.triggerController.removeClickListener();
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
  }
  componentDidLoad() {
    if (this.gesture || getIonMode$2(this) === "md" || !this.wrapperEl) {
      return;
    }
    this.gesture = createButtonActiveGesture(this.wrapperEl, (refEl) => refEl.classList.contains("alert-button"));
    this.gesture.enable(true);
  }
  /**
   * Present the alert overlay after it has been created.
   */
  async present() {
    if (this.currentTransition !== void 0) {
      await this.currentTransition;
    }
    await this.delegateController.attachViewToDom();
    this.currentTransition = present(this, "alertEnter", iosEnterAnimation$3, mdEnterAnimation$3);
    await this.currentTransition;
    this.currentTransition = void 0;
  }
  /**
   * Dismiss the alert overlay after it has been presented.
   *
   * @param data Any data to emit in the dismiss events.
   * @param role The role of the element that is dismissing the alert.
   * This can be useful in a button handler for determining which button was
   * clicked to dismiss the alert.
   * Some examples include: ``"cancel"`, `"destructive"`, "selected"`, and `"backdrop"`.
   */
  async dismiss(data2, role) {
    this.currentTransition = dismiss(this, data2, role, "alertLeave", iosLeaveAnimation$3, mdLeaveAnimation$3);
    const dismissed = await this.currentTransition;
    if (dismissed) {
      this.delegateController.removeViewFromDom();
    }
    return dismissed;
  }
  /**
   * Returns a promise that resolves when the alert did dismiss.
   */
  onDidDismiss() {
    return eventMethod(this.el, "ionAlertDidDismiss");
  }
  /**
   * Returns a promise that resolves when the alert will dismiss.
   */
  onWillDismiss() {
    return eventMethod(this.el, "ionAlertWillDismiss");
  }
  rbClick(selectedInput) {
    for (const input of this.processedInputs) {
      input.checked = input === selectedInput;
      input.tabindex = input === selectedInput ? 0 : -1;
    }
    this.activeId = selectedInput.id;
    safeCall$1(selectedInput.handler, selectedInput);
    forceUpdate(this);
  }
  cbClick(selectedInput) {
    selectedInput.checked = !selectedInput.checked;
    safeCall$1(selectedInput.handler, selectedInput);
    forceUpdate(this);
  }
  async buttonClick(button) {
    const role = button.role;
    const values3 = this.getValues();
    if (isCancel$2(role)) {
      return this.dismiss({ values: values3 }, role);
    }
    const returnData = await this.callButtonHandler(button, values3);
    if (returnData !== false) {
      return this.dismiss(Object.assign({ values: values3 }, returnData), button.role);
    }
    return false;
  }
  async callButtonHandler(button, data2) {
    if (button === null || button === void 0 ? void 0 : button.handler) {
      const returnData = await safeCall$1(button.handler, data2);
      if (returnData === false) {
        return false;
      }
      if (typeof returnData === "object") {
        return returnData;
      }
    }
    return {};
  }
  getValues() {
    if (this.processedInputs.length === 0) {
      return void 0;
    }
    if (this.inputType === "radio") {
      const checkedInput = this.processedInputs.find((i) => !!i.checked);
      return checkedInput ? checkedInput.value : void 0;
    }
    if (this.inputType === "checkbox") {
      return this.processedInputs.filter((i) => i.checked).map((i) => i.value);
    }
    const values3 = {};
    this.processedInputs.forEach((i) => {
      values3[i.name] = i.value || "";
    });
    return values3;
  }
  renderAlertInputs() {
    switch (this.inputType) {
      case "checkbox":
        return this.renderCheckbox();
      case "radio":
        return this.renderRadio();
      default:
        return this.renderInput();
    }
  }
  renderCheckbox() {
    const inputs = this.processedInputs;
    const mode = getIonMode$2(this);
    if (inputs.length === 0) {
      return null;
    }
    return h$5("div", { class: "alert-checkbox-group" }, inputs.map((i) => h$5("button", { type: "button", onClick: () => this.cbClick(i), "aria-checked": `${i.checked}`, id: i.id, disabled: i.disabled, tabIndex: i.tabindex, role: "checkbox", class: Object.assign(Object.assign({}, getClassMap(i.cssClass)), { "alert-tappable": true, "alert-checkbox": true, "alert-checkbox-button": true, "ion-focusable": true, "alert-checkbox-button-disabled": i.disabled || false }) }, h$5("div", { class: "alert-button-inner" }, h$5("div", { class: "alert-checkbox-icon" }, h$5("div", { class: "alert-checkbox-inner" })), h$5("div", { class: "alert-checkbox-label" }, i.label)), mode === "md" && h$5("ion-ripple-effect", null))));
  }
  renderRadio() {
    const inputs = this.processedInputs;
    if (inputs.length === 0) {
      return null;
    }
    return h$5("div", { class: "alert-radio-group", role: "radiogroup", "aria-activedescendant": this.activeId }, inputs.map((i) => h$5("button", { type: "button", onClick: () => this.rbClick(i), "aria-checked": `${i.checked}`, disabled: i.disabled, id: i.id, tabIndex: i.tabindex, class: Object.assign(Object.assign({}, getClassMap(i.cssClass)), { "alert-radio-button": true, "alert-tappable": true, "alert-radio": true, "ion-focusable": true, "alert-radio-button-disabled": i.disabled || false }), role: "radio" }, h$5("div", { class: "alert-button-inner" }, h$5("div", { class: "alert-radio-icon" }, h$5("div", { class: "alert-radio-inner" })), h$5("div", { class: "alert-radio-label" }, i.label)))));
  }
  renderInput() {
    const inputs = this.processedInputs;
    if (inputs.length === 0) {
      return null;
    }
    return h$5("div", { class: "alert-input-group" }, inputs.map((i) => {
      var _a2, _b, _c, _d;
      if (i.type === "textarea") {
        return h$5("div", { class: "alert-input-wrapper" }, h$5("textarea", Object.assign({ placeholder: i.placeholder, value: i.value, id: i.id, tabIndex: i.tabindex }, i.attributes, { disabled: (_b = (_a2 = i.attributes) === null || _a2 === void 0 ? void 0 : _a2.disabled) !== null && _b !== void 0 ? _b : i.disabled, class: inputClass(i), onInput: (e3) => {
          var _a3;
          i.value = e3.target.value;
          if ((_a3 = i.attributes) === null || _a3 === void 0 ? void 0 : _a3.onInput) {
            i.attributes.onInput(e3);
          }
        } })));
      } else {
        return h$5("div", { class: "alert-input-wrapper" }, h$5("input", Object.assign({ placeholder: i.placeholder, type: i.type, min: i.min, max: i.max, value: i.value, id: i.id, tabIndex: i.tabindex }, i.attributes, { disabled: (_d = (_c = i.attributes) === null || _c === void 0 ? void 0 : _c.disabled) !== null && _d !== void 0 ? _d : i.disabled, class: inputClass(i), onInput: (e3) => {
          var _a3;
          i.value = e3.target.value;
          if ((_a3 = i.attributes) === null || _a3 === void 0 ? void 0 : _a3.onInput) {
            i.attributes.onInput(e3);
          }
        } })));
      }
    }));
  }
  renderAlertButtons() {
    const buttons = this.processedButtons;
    const mode = getIonMode$2(this);
    const alertButtonGroupClass = {
      "alert-button-group": true,
      "alert-button-group-vertical": buttons.length > 2
    };
    return h$5("div", { class: alertButtonGroupClass }, buttons.map((button) => h$5("button", { type: "button", id: button.id, class: buttonClass$1(button), tabIndex: 0, onClick: () => this.buttonClick(button) }, h$5("span", { class: "alert-button-inner" }, button.text), mode === "md" && h$5("ion-ripple-effect", null))));
  }
  renderAlertMessage(msgId) {
    const { customHTMLEnabled, message } = this;
    if (customHTMLEnabled) {
      return h$5("div", { id: msgId, class: "alert-message", innerHTML: sanitizeDOMString(message) });
    }
    return h$5("div", { id: msgId, class: "alert-message" }, message);
  }
  render() {
    const { overlayIndex, header, subHeader, message, htmlAttributes } = this;
    const mode = getIonMode$2(this);
    const hdrId = `alert-${overlayIndex}-hdr`;
    const subHdrId = `alert-${overlayIndex}-sub-hdr`;
    const msgId = `alert-${overlayIndex}-msg`;
    const role = this.inputs.length > 0 || this.buttons.length > 0 ? "alertdialog" : "alert";
    const ariaLabelledBy = header ? hdrId : subHeader ? subHdrId : null;
    return h$5(Host$1, Object.assign({ role, "aria-modal": "true", "aria-labelledby": ariaLabelledBy, "aria-describedby": message !== void 0 ? msgId : null, tabindex: "-1" }, htmlAttributes, { style: {
      zIndex: `${2e4 + overlayIndex}`
    }, class: Object.assign(Object.assign({}, getClassMap(this.cssClass)), { [mode]: true, "overlay-hidden": true, "alert-translucent": this.translucent }), onIonAlertWillDismiss: this.dispatchCancelHandler, onIonBackdropTap: this.onBackdropTap }), h$5("ion-backdrop", { tappable: this.backdropDismiss }), h$5("div", { tabindex: "0" }), h$5("div", { class: "alert-wrapper ion-overlay-wrapper", ref: (el2) => this.wrapperEl = el2 }, h$5("div", { class: "alert-head" }, header && h$5("h2", { id: hdrId, class: "alert-title" }, header), subHeader && h$5("h2", { id: subHdrId, class: "alert-sub-title" }, subHeader)), this.renderAlertMessage(msgId), this.renderAlertInputs(), this.renderAlertButtons()), h$5("div", { tabindex: "0" }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "isOpen": ["onIsOpenChange"],
      "trigger": ["triggerChanged"],
      "buttons": ["buttonsChanged"],
      "inputs": ["inputsChanged"]
    };
  }
  static get style() {
    return {
      ios: alertIosCss,
      md: alertMdCss
    };
  }
}, [34, "ion-alert", {
  "overlayIndex": [2, "overlay-index"],
  "delegate": [16],
  "hasController": [4, "has-controller"],
  "keyboardClose": [4, "keyboard-close"],
  "enterAnimation": [16],
  "leaveAnimation": [16],
  "cssClass": [1, "css-class"],
  "header": [1],
  "subHeader": [1, "sub-header"],
  "message": [1],
  "buttons": [16],
  "inputs": [1040],
  "backdropDismiss": [4, "backdrop-dismiss"],
  "translucent": [4],
  "animated": [4],
  "htmlAttributes": [16],
  "isOpen": [4, "is-open"],
  "trigger": [1],
  "present": [64],
  "dismiss": [64],
  "onDidDismiss": [64],
  "onWillDismiss": [64]
}, [[4, "keydown", "onKeydown"]]]);
const inputClass = (input) => {
  var _a2, _b, _c;
  return Object.assign(Object.assign({ "alert-input": true, "alert-input-disabled": ((_b = (_a2 = input.attributes) === null || _a2 === void 0 ? void 0 : _a2.disabled) !== null && _b !== void 0 ? _b : input.disabled) || false }, getClassMap(input.cssClass)), getClassMap(input.attributes ? (_c = input.attributes.class) === null || _c === void 0 ? void 0 : _c.toString() : ""));
};
const buttonClass$1 = (button) => {
  return Object.assign({ "alert-button": true, "ion-focusable": true, "ion-activatable": true, [`alert-button-role-${button.role}`]: button.role !== void 0 }, getClassMap(button.cssClass));
};
function defineCustomElement$n() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-alert", "ion-backdrop", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-alert":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Alert);
        }
        break;
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          defineCustomElement$17();
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$Z();
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const selectPopoverIosCss = ".sc-ion-select-popover-ios-h ion-list.sc-ion-select-popover-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}ion-list-header.sc-ion-select-popover-ios,ion-label.sc-ion-select-popover-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}";
const selectPopoverMdCss = ".sc-ion-select-popover-md-h ion-list.sc-ion-select-popover-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}ion-list-header.sc-ion-select-popover-md,ion-label.sc-ion-select-popover-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}ion-list.sc-ion-select-popover-md ion-radio.sc-ion-select-popover-md{opacity:0}ion-item.sc-ion-select-popover-md{--inner-border-width:0}.item-radio-checked.sc-ion-select-popover-md{--background:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.08);--background-focused:var(--ion-color-primary, #3880ff);--background-focused-opacity:0.2;--background-hover:var(--ion-color-primary, #3880ff);--background-hover-opacity:0.12}.item-checkbox-checked.sc-ion-select-popover-md{--background-activated:var(--ion-item-color, var(--ion-text-color, #000));--background-focused:var(--ion-item-color, var(--ion-text-color, #000));--background-hover:var(--ion-item-color, var(--ion-text-color, #000));--color:var(--ion-color-primary, #3880ff)}";
const SelectPopover = /* @__PURE__ */ proxyCustomElement$1(class SelectPopover2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.header = void 0;
    this.subHeader = void 0;
    this.message = void 0;
    this.multiple = void 0;
    this.options = [];
  }
  findOptionFromEvent(ev) {
    const { options } = this;
    return options.find((o3) => o3.value === ev.target.value);
  }
  /**
   * When an option is selected we need to get the value(s)
   * of the selected option(s) and return it in the option
   * handler
   */
  callOptionHandler(ev) {
    const option = this.findOptionFromEvent(ev);
    const values3 = this.getValues(ev);
    if (option === null || option === void 0 ? void 0 : option.handler) {
      safeCall$1(option.handler, values3);
    }
  }
  /**
   * Dismisses the host popover that the `ion-select-popover`
   * is rendered within.
   */
  dismissParentPopover() {
    const popover = this.el.closest("ion-popover");
    if (popover) {
      popover.dismiss();
    }
  }
  setChecked(ev) {
    const { multiple } = this;
    const option = this.findOptionFromEvent(ev);
    if (multiple && option) {
      option.checked = ev.detail.checked;
    }
  }
  getValues(ev) {
    const { multiple, options } = this;
    if (multiple) {
      return options.filter((o3) => o3.checked).map((o3) => o3.value);
    }
    const option = this.findOptionFromEvent(ev);
    return option ? option.value : void 0;
  }
  renderOptions(options) {
    const { multiple } = this;
    switch (multiple) {
      case true:
        return this.renderCheckboxOptions(options);
      default:
        return this.renderRadioOptions(options);
    }
  }
  renderCheckboxOptions(options) {
    return options.map((option) => h$5("ion-item", { class: getClassMap(option.cssClass) }, h$5("ion-checkbox", { slot: "start", value: option.value, disabled: option.disabled, checked: option.checked, legacy: true, onIonChange: (ev) => {
      this.setChecked(ev);
      this.callOptionHandler(ev);
    } }), h$5("ion-label", null, option.text)));
  }
  renderRadioOptions(options) {
    const checked = options.filter((o3) => o3.checked).map((o3) => o3.value)[0];
    return h$5("ion-radio-group", { value: checked, onIonChange: (ev) => this.callOptionHandler(ev) }, options.map((option) => h$5("ion-item", { class: getClassMap(option.cssClass) }, h$5("ion-label", null, option.text), h$5("ion-radio", { value: option.value, disabled: option.disabled, legacy: true, onClick: () => this.dismissParentPopover(), onKeyUp: (ev) => {
      if (ev.key === " ") {
        this.dismissParentPopover();
      }
    } }))));
  }
  render() {
    const { header, message, options, subHeader } = this;
    const hasSubHeaderOrMessage = subHeader !== void 0 || message !== void 0;
    return h$5(Host$1, { class: getIonMode$2(this) }, h$5("ion-list", null, header !== void 0 && h$5("ion-list-header", null, header), hasSubHeaderOrMessage && h$5("ion-item", null, h$5("ion-label", { class: "ion-text-wrap" }, subHeader !== void 0 && h$5("h3", null, subHeader), message !== void 0 && h$5("p", null, message))), this.renderOptions(options)));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: selectPopoverIosCss,
      md: selectPopoverMdCss
    };
  }
}, [34, "ion-select-popover", {
  "header": [1],
  "subHeader": [1, "sub-header"],
  "message": [1],
  "multiple": [4],
  "options": [16]
}]);
function defineCustomElement$m() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-select-popover", "ion-checkbox", "ion-icon", "ion-item", "ion-label", "ion-list", "ion-list-header", "ion-note", "ion-radio", "ion-radio-group", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-select-popover":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, SelectPopover);
        }
        break;
      case "ion-checkbox":
        if (!customElements.get(tagName)) {
          defineCustomElement$$();
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$1b();
        }
        break;
      case "ion-item":
        if (!customElements.get(tagName)) {
          defineCustomElement$U();
        }
        break;
      case "ion-label":
        if (!customElements.get(tagName)) {
          defineCustomElement$T();
        }
        break;
      case "ion-list":
        if (!customElements.get(tagName)) {
          defineCustomElement$B();
        }
        break;
      case "ion-list-header":
        if (!customElements.get(tagName)) {
          defineCustomElement$z();
        }
        break;
      case "ion-note":
        if (!customElements.get(tagName)) {
          defineCustomElement$V();
        }
        break;
      case "ion-radio":
        if (!customElements.get(tagName)) {
          defineCustomElement$t();
        }
        break;
      case "ion-radio-group":
        if (!customElements.get(tagName)) {
          defineCustomElement$s();
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$Z();
        }
        break;
    }
  });
}
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const watchForOptions = (containerEl, tagName, onChange) => {
  if (typeof MutationObserver === "undefined") {
    return;
  }
  const mutation = new MutationObserver((mutationList) => {
    onChange(getSelectedOption(mutationList, tagName));
  });
  mutation.observe(containerEl, {
    childList: true,
    subtree: true
  });
  return mutation;
};
const getSelectedOption = (mutationList, tagName) => {
  let newOption;
  mutationList.forEach((mut) => {
    for (let i = 0; i < mut.addedNodes.length; i++) {
      newOption = findCheckedOption(mut.addedNodes[i], tagName) || newOption;
    }
  });
  return newOption;
};
const findCheckedOption = (el2, tagName) => {
  if (el2.nodeType !== 1) {
    return void 0;
  }
  const options = el2.tagName === tagName.toUpperCase() ? [el2] : Array.from(el2.querySelectorAll(tagName));
  return options.find((o3) => o3.value === el2.value);
};
const selectIosCss = ":host{--padding-top:0px;--padding-end:0px;--padding-bottom:0px;--padding-start:0px;--placeholder-color:currentColor;--placeholder-opacity:0.6;--background:transparent;--border-style:solid;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);--highlight-color:var(--highlight-color-focused);display:block;position:relative;font-family:var(--ion-font-family, inherit);white-space:nowrap;cursor:pointer;z-index:2}:host(:not(.legacy-select)){width:100%}:host(.ion-color){--highlight-color-focused:var(--ion-color-base)}:host(.legacy-select){-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;overflow:hidden}:host(.in-item.legacy-select){position:static;max-width:45%}:host(.select-disabled){opacity:0.4;pointer-events:none}:host(.ion-focused) button{border:2px solid #5e9ed6}:host([slot=start]:not(.legacy-select)),:host([slot=end]:not(.legacy-select)){width:auto}.select-placeholder{color:var(--placeholder-color);opacity:var(--placeholder-opacity)}:host(.legacy-select) label{top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;opacity:0}@supports (inset-inline-start: 0){:host(.legacy-select) label{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host(.legacy-select) label{left:0}:host-context([dir=rtl]):host(.legacy-select) label,:host-context([dir=rtl]).legacy-select label{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(.legacy-select) label:dir(rtl){left:unset;right:unset;right:0}}}:host(.legacy-select) label::-moz-focus-inner{border:0}button{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}.select-icon{-webkit-margin-start:4px;margin-inline-start:4px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0;position:relative}:host(.in-item-color) .select-icon{color:inherit}:host(.select-label-placement-stacked) .select-icon,:host(.select-label-placement-floating) .select-icon{position:absolute;height:100%}:host(.select-ltr.select-label-placement-stacked) .select-icon,:host(.select-ltr.select-label-placement-floating) .select-icon{right:var(--padding-end, 0)}:host(.select-rtl.select-label-placement-stacked) .select-icon,:host(.select-rtl.select-label-placement-floating) .select-icon{left:var(--padding-start, 0)}.select-text{-ms-flex:1;flex:1;min-width:16px;font-size:inherit;text-overflow:ellipsis;white-space:inherit;overflow:hidden}.select-wrapper{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;height:inherit;min-height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;background:var(--background);line-height:normal;cursor:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.select-wrapper .select-placeholder{-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}:host(.ion-touched.ion-invalid){--highlight-color:var(--highlight-color-invalid)}:host(.ion-valid){--highlight-color:var(--highlight-color-valid)}.label-text-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;max-width:200px;-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.label-text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);overflow:hidden}:host(.select-justify-space-between) .select-wrapper{-ms-flex-pack:justify;justify-content:space-between}:host(.select-justify-start) .select-wrapper{-ms-flex-pack:start;justify-content:start}:host(.select-justify-end) .select-wrapper{-ms-flex-pack:end;justify-content:end}:host(.select-label-placement-start) .select-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.select-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.select-label-placement-end) .select-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.select-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}:host(.select-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.select-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}:host(.select-label-placement-stacked) .select-wrapper,:host(.select-label-placement-floating) .select-wrapper{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:start}:host(.select-label-placement-stacked) .label-text-wrapper,:host(.select-label-placement-floating) .label-text-wrapper{max-width:100%}:host(.select-ltr.select-label-placement-stacked) .label-text-wrapper,:host(.select-ltr.select-label-placement-floating) .label-text-wrapper{-webkit-transform-origin:left top;transform-origin:left top}:host(.select-rtl.select-label-placement-stacked) .label-text-wrapper,:host(.select-rtl.select-label-placement-floating) .label-text-wrapper{-webkit-transform-origin:right top;transform-origin:right top}:host(.select-label-placement-stacked) .native-wrapper,:host(.select-label-placement-floating) .native-wrapper{margin-left:0;margin-right:0;margin-top:1px;margin-bottom:0;-ms-flex-positive:1;flex-grow:1;width:100%}:host(.select-label-placement-floating) .label-text-wrapper{-webkit-transform:translateY(100%) scale(1);transform:translateY(100%) scale(1)}:host(.select-label-placement-floating) .native-wrapper .select-placeholder{opacity:0}:host(.select-expanded.select-label-placement-floating) .native-wrapper .select-placeholder,:host(.ion-focused.select-label-placement-floating) .native-wrapper .select-placeholder,:host(.has-value.select-label-placement-floating) .native-wrapper .select-placeholder{opacity:1}:host(.select-label-placement-stacked) .label-text-wrapper,:host(.select-expanded.select-label-placement-floating) .label-text-wrapper,:host(.ion-focused.select-label-placement-floating) .label-text-wrapper,:host(.has-value.select-label-placement-floating) .label-text-wrapper{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);max-width:calc(100% / 0.75)}:host(.legacy-select){--padding-top:10px;--padding-end:8px;--padding-bottom:10px;--padding-start:16px}:host(:not(.legacy-select)){min-height:44px}:host(.select-label-placement-floating),:host(.select-label-placement-stacked){min-height:56px}.select-icon{width:18px;height:18px;color:var(--ion-color-step-650, #595959)}:host(.select-label-placement-stacked) .native-wrapper,:host(.select-label-placement-floating) .native-wrapper{width:calc(100% - 18px - 4px)}";
const selectMdCss = ":host{--padding-top:0px;--padding-end:0px;--padding-bottom:0px;--padding-start:0px;--placeholder-color:currentColor;--placeholder-opacity:0.6;--background:transparent;--border-style:solid;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);--highlight-color:var(--highlight-color-focused);display:block;position:relative;font-family:var(--ion-font-family, inherit);white-space:nowrap;cursor:pointer;z-index:2}:host(:not(.legacy-select)){width:100%}:host(.ion-color){--highlight-color-focused:var(--ion-color-base)}:host(.legacy-select){-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;overflow:hidden}:host(.in-item.legacy-select){position:static;max-width:45%}:host(.select-disabled){opacity:0.4;pointer-events:none}:host(.ion-focused) button{border:2px solid #5e9ed6}:host([slot=start]:not(.legacy-select)),:host([slot=end]:not(.legacy-select)){width:auto}.select-placeholder{color:var(--placeholder-color);opacity:var(--placeholder-opacity)}:host(.legacy-select) label{top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;opacity:0}@supports (inset-inline-start: 0){:host(.legacy-select) label{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host(.legacy-select) label{left:0}:host-context([dir=rtl]):host(.legacy-select) label,:host-context([dir=rtl]).legacy-select label{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(.legacy-select) label:dir(rtl){left:unset;right:unset;right:0}}}:host(.legacy-select) label::-moz-focus-inner{border:0}button{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}.select-icon{-webkit-margin-start:4px;margin-inline-start:4px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0;position:relative}:host(.in-item-color) .select-icon{color:inherit}:host(.select-label-placement-stacked) .select-icon,:host(.select-label-placement-floating) .select-icon{position:absolute;height:100%}:host(.select-ltr.select-label-placement-stacked) .select-icon,:host(.select-ltr.select-label-placement-floating) .select-icon{right:var(--padding-end, 0)}:host(.select-rtl.select-label-placement-stacked) .select-icon,:host(.select-rtl.select-label-placement-floating) .select-icon{left:var(--padding-start, 0)}.select-text{-ms-flex:1;flex:1;min-width:16px;font-size:inherit;text-overflow:ellipsis;white-space:inherit;overflow:hidden}.select-wrapper{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;height:inherit;min-height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;background:var(--background);line-height:normal;cursor:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}.select-wrapper .select-placeholder{-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}:host(.ion-touched.ion-invalid){--highlight-color:var(--highlight-color-invalid)}:host(.ion-valid){--highlight-color:var(--highlight-color-valid)}.label-text-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;max-width:200px;-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.label-text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);overflow:hidden}:host(.select-justify-space-between) .select-wrapper{-ms-flex-pack:justify;justify-content:space-between}:host(.select-justify-start) .select-wrapper{-ms-flex-pack:start;justify-content:start}:host(.select-justify-end) .select-wrapper{-ms-flex-pack:end;justify-content:end}:host(.select-label-placement-start) .select-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.select-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.select-label-placement-end) .select-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.select-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}:host(.select-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.select-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}:host(.select-label-placement-stacked) .select-wrapper,:host(.select-label-placement-floating) .select-wrapper{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:start}:host(.select-label-placement-stacked) .label-text-wrapper,:host(.select-label-placement-floating) .label-text-wrapper{max-width:100%}:host(.select-ltr.select-label-placement-stacked) .label-text-wrapper,:host(.select-ltr.select-label-placement-floating) .label-text-wrapper{-webkit-transform-origin:left top;transform-origin:left top}:host(.select-rtl.select-label-placement-stacked) .label-text-wrapper,:host(.select-rtl.select-label-placement-floating) .label-text-wrapper{-webkit-transform-origin:right top;transform-origin:right top}:host(.select-label-placement-stacked) .native-wrapper,:host(.select-label-placement-floating) .native-wrapper{margin-left:0;margin-right:0;margin-top:1px;margin-bottom:0;-ms-flex-positive:1;flex-grow:1;width:100%}:host(.select-label-placement-floating) .label-text-wrapper{-webkit-transform:translateY(100%) scale(1);transform:translateY(100%) scale(1)}:host(.select-label-placement-floating) .native-wrapper .select-placeholder{opacity:0}:host(.select-expanded.select-label-placement-floating) .native-wrapper .select-placeholder,:host(.ion-focused.select-label-placement-floating) .native-wrapper .select-placeholder,:host(.has-value.select-label-placement-floating) .native-wrapper .select-placeholder{opacity:1}:host(.select-label-placement-stacked) .label-text-wrapper,:host(.select-expanded.select-label-placement-floating) .label-text-wrapper,:host(.ion-focused.select-label-placement-floating) .label-text-wrapper,:host(.has-value.select-label-placement-floating) .label-text-wrapper{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);max-width:calc(100% / 0.75)}:host(.select-fill-solid){--background:var(--ion-color-step-50, #f2f2f2);--border-color:var(--ion-color-step-500, gray);--border-radius:4px;--padding-start:16px;--padding-end:16px}:host(.select-fill-solid) .select-wrapper{border-bottom:var(--border-width) var(--border-style) var(--border-color)}:host(.has-focus.select-fill-solid.ion-valid),:host(.select-fill-solid.ion-touched.ion-invalid){--border-color:var(--highlight-color)}:host(.select-fill-solid) .select-bottom{border-top:none}@media (any-hover: hover){:host(.select-fill-solid:hover){--background:var(--ion-color-step-100, #e6e6e6);--border-color:var(--ion-color-step-750, #404040)}}:host(.select-fill-solid.select-expanded),:host(.select-fill-solid.ion-focused){--background:var(--ion-color-step-150, #d9d9d9);--border-color:var(--ion-color-step-750, #404040)}:host(.select-fill-solid) .select-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0px;border-bottom-left-radius:0px}:host-context([dir=rtl]):host(.select-fill-solid) .select-wrapper,:host-context([dir=rtl]).select-fill-solid .select-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0px;border-bottom-left-radius:0px}@supports selector(:dir(rtl)){:host(.select-fill-solid) .select-wrapper:dir(rtl){border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0px;border-bottom-left-radius:0px}}:host(.select-fill-solid.select-label-placement-stacked) .label-text-wrapper,:host(.select-expanded.select-fill-solid.select-label-placement-floating) .label-text-wrapper,:host(.ion-focused.select-fill-solid.select-label-placement-floating) .label-text-wrapper,:host(.has-value.select-fill-solid.select-label-placement-floating) .label-text-wrapper{max-width:calc(100% / 0.75)}:host(.select-fill-outline){--border-color:var(--ion-color-step-300, #b3b3b3);--border-radius:4px;--padding-start:16px;--padding-end:16px}:host(.select-fill-outline.select-shape-round){--border-radius:28px;--padding-start:32px;--padding-end:32px}:host(.has-focus.select-fill-outline.ion-valid),:host(.select-fill-outline.ion-touched.ion-invalid){--border-color:var(--highlight-color)}@media (any-hover: hover){:host(.select-fill-outline:hover){--border-color:var(--ion-color-step-750, #404040)}}:host(.select-fill-outline.select-expanded),:host(.select-fill-outline.ion-focused){--border-width:2px;--border-color:var(--highlight-color)}:host(.select-fill-outline) .select-bottom{border-top:none}:host(.select-fill-outline) .select-wrapper{border-bottom:none}:host(.select-ltr.select-fill-outline.select-label-placement-stacked) .label-text-wrapper,:host(.select-ltr.select-fill-outline.select-label-placement-floating) .label-text-wrapper{-webkit-transform-origin:left top;transform-origin:left top}:host(.select-rtl.select-fill-outline.select-label-placement-stacked) .label-text-wrapper,:host(.select-rtl.select-fill-outline.select-label-placement-floating) .label-text-wrapper{-webkit-transform-origin:right top;transform-origin:right top}:host(.select-fill-outline.select-label-placement-stacked) .label-text-wrapper,:host(.select-fill-outline.select-label-placement-floating) .label-text-wrapper{position:absolute;max-width:calc(100% - var(--padding-start) - var(--padding-end))}:host(.select-fill-outline) .label-text-wrapper{position:relative;z-index:1}:host(.select-expanded.select-fill-outline.select-label-placement-floating) .label-text-wrapper,:host(.ion-focused.select-fill-outline.select-label-placement-floating) .label-text-wrapper,:host(.has-value.select-fill-outline.select-label-placement-floating) .label-text-wrapper,:host(.select-fill-outline.select-label-placement-stacked) .label-text-wrapper{-webkit-transform:translateY(-32%) scale(0.75);transform:translateY(-32%) scale(0.75);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;max-width:calc((100% - var(--padding-start) - var(--padding-end) - 8px) / 0.75)}:host(.select-fill-outline.select-label-placement-stacked) select,:host(.select-fill-outline.select-label-placement-floating) select{margin-left:0;margin-right:0;margin-top:6px;margin-bottom:6px}:host(.select-fill-outline) .select-outline-container{left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;width:100%;height:100%}:host(.select-fill-outline) .select-outline-start,:host(.select-fill-outline) .select-outline-end{pointer-events:none}:host(.select-fill-outline) .select-outline-start,:host(.select-fill-outline) .select-outline-notch,:host(.select-fill-outline) .select-outline-end{border-top:var(--border-width) var(--border-style) var(--border-color);border-bottom:var(--border-width) var(--border-style) var(--border-color);-webkit-box-sizing:border-box;box-sizing:border-box}:host(.select-fill-outline) .select-outline-notch{max-width:calc(100% - var(--padding-start) - var(--padding-end))}:host(.select-fill-outline) .notch-spacer{-webkit-padding-end:8px;padding-inline-end:8px;font-size:calc(1em * 0.75);opacity:0;pointer-events:none}:host(.select-ltr.select-fill-outline) .select-outline-start{border-left:var(--border-width) var(--border-style) var(--border-color);border-radius:var(--border-radius) 0px 0px var(--border-radius)}:host(.select-rtl.select-fill-outline) .select-outline-start{border-right:var(--border-width) var(--border-style) var(--border-color);border-radius:0px var(--border-radius) var(--border-radius) 0px}:host(.select-fill-outline) .select-outline-start{width:calc(var(--padding-start) - 4px)}:host(.select-ltr.select-fill-outline) .select-outline-end{border-right:var(--border-width) var(--border-style) var(--border-color);border-radius:0px var(--border-radius) var(--border-radius) 0px}:host(.select-rtl.select-fill-outline) .select-outline-end{border-left:var(--border-width) var(--border-style) var(--border-color);border-radius:var(--border-radius) 0px 0px var(--border-radius)}:host(.select-fill-outline) .select-outline-end{-ms-flex-positive:1;flex-grow:1}:host(.select-expanded.select-fill-outline.select-label-placement-floating) .select-outline-notch,:host(.ion-focused.select-fill-outline.select-label-placement-floating) .select-outline-notch,:host(.has-value.select-fill-outline.select-label-placement-floating) .select-outline-notch,:host(.select-fill-outline.select-label-placement-stacked) .select-outline-notch{border-top:none}:host{--border-width:1px;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))))}:host(.legacy-select){--padding-top:10px;--padding-end:0;--padding-bottom:10px;--padding-start:16px}:host(:not(.legacy-select)){min-height:56px}.select-icon{width:13px;-webkit-transition:-webkit-transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);transition:-webkit-transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.15s cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);color:var(--ion-color-step-500, gray)}:host(.select-label-placement-floating.select-expanded) .label-text-wrapper,:host(.select-label-placement-floating.ion-focused) .label-text-wrapper,:host(.select-label-placement-stacked.select-expanded) .label-text-wrapper,:host(.select-label-placement-stacked.ion-focused) .label-text-wrapper{color:var(--highlight-color)}:host(.has-focus.select-label-placement-floating.ion-valid) .label-text-wrapper,:host(.select-label-placement-floating.ion-touched.ion-invalid) .label-text-wrapper,:host(.has-focus.select-label-placement-stacked.ion-valid) .label-text-wrapper,:host(.select-label-placement-stacked.ion-touched.ion-invalid) .label-text-wrapper{color:var(--highlight-color)}.select-highlight{bottom:-1px;position:absolute;width:100%;height:2px;-webkit-transform:scale(0);transform:scale(0);-webkit-transition:-webkit-transform 200ms;transition:-webkit-transform 200ms;transition:transform 200ms;transition:transform 200ms, -webkit-transform 200ms;background:var(--highlight-color)}@supports (inset-inline-start: 0){.select-highlight{inset-inline-start:0}}@supports not (inset-inline-start: 0){.select-highlight{left:0}:host-context([dir=rtl]) .select-highlight{left:unset;right:unset;right:0}[dir=rtl] .select-highlight{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.select-highlight:dir(rtl){left:unset;right:unset;right:0}}}:host(.select-expanded) .select-highlight,:host(.ion-focused) .select-highlight{-webkit-transform:scale(1);transform:scale(1)}:host(.in-item) .select-highlight{bottom:0}@supports (inset-inline-start: 0){:host(.in-item) .select-highlight{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host(.in-item) .select-highlight{left:0}:host-context([dir=rtl]):host(.in-item) .select-highlight,:host-context([dir=rtl]).in-item .select-highlight{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(.in-item) .select-highlight:dir(rtl){left:unset;right:unset;right:0}}}:host(.select-expanded:not(.legacy-select)) .select-icon{-webkit-transform:rotate(180deg);transform:rotate(180deg)}:host(.select-expanded) .select-wrapper .select-icon,:host(.has-focus.ion-valid) .select-wrapper .select-icon,:host(.ion-touched.ion-invalid) .select-wrapper .select-icon,:host(.ion-focused) .select-wrapper .select-icon{color:var(--highlight-color)}:host-context(.item-label-stacked) .select-icon,:host-context(.item-label-floating:not(.item-fill-outline)) .select-icon,:host-context(.item-label-floating.item-fill-outline){-webkit-transform:translate3d(0,  -9px,  0);transform:translate3d(0,  -9px,  0)}:host-context(.item-has-focus) .select-icon{-webkit-transform:rotate(180deg);transform:rotate(180deg)}:host-context(.item-has-focus.item-label-stacked) .select-icon,:host-context(.item-has-focus.item-label-floating:not(.item-fill-outline)) .select-icon{-webkit-transform:translate3d(0,  -9px,  0) rotate(180deg);transform:translate3d(0,  -9px,  0) rotate(180deg)}:host(.select-shape-round){--border-radius:16px}:host(.select-label-placement-stacked) .native-wrapper,:host(.select-label-placement-floating) .native-wrapper{width:calc(100% - 13px - 4px)}";
const Select = /* @__PURE__ */ proxyCustomElement$1(class Select2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionCancel = createEvent(this, "ionCancel", 7);
    this.ionDismiss = createEvent(this, "ionDismiss", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.inputId = `ion-sel-${selectIds++}`;
    this.inheritedAttributes = {};
    this.hasLoggedDeprecationWarning = false;
    this.onClick = (ev) => {
      this.setFocus();
      this.open(ev);
    };
    this.onFocus = () => {
      this.ionFocus.emit();
    };
    this.onBlur = () => {
      this.ionBlur.emit();
    };
    this.isExpanded = false;
    this.cancelText = "Cancel";
    this.color = void 0;
    this.compareWith = void 0;
    this.disabled = false;
    this.fill = void 0;
    this.interface = "alert";
    this.interfaceOptions = {};
    this.justify = "space-between";
    this.label = void 0;
    this.labelPlacement = "start";
    this.legacy = void 0;
    this.multiple = false;
    this.name = this.inputId;
    this.okText = "OK";
    this.placeholder = void 0;
    this.selectedText = void 0;
    this.shape = void 0;
    this.value = void 0;
  }
  styleChanged() {
    this.emitStyle();
  }
  setValue(value) {
    this.value = value;
    this.ionChange.emit({ value });
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAttributes$2(this.el, ["aria-label"]);
  }
  async connectedCallback() {
    const { el: el2 } = this;
    this.legacyFormController = createLegacyFormController(el2);
    this.updateOverlayOptions();
    this.emitStyle();
    this.mutationO = watchForOptions(this.el, "ion-select-option", async () => {
      this.updateOverlayOptions();
      forceUpdate(this);
    });
  }
  disconnectedCallback() {
    if (this.mutationO) {
      this.mutationO.disconnect();
      this.mutationO = void 0;
    }
  }
  /**
   * Open the select overlay. The overlay is either an alert, action sheet, or popover,
   * depending on the `interface` property on the `ion-select`.
   *
   * @param event The user interface event that called the open.
   */
  async open(event) {
    if (this.disabled || this.isExpanded) {
      return void 0;
    }
    this.isExpanded = true;
    const overlay = this.overlay = await this.createOverlay(event);
    overlay.onDidDismiss().then(() => {
      this.overlay = void 0;
      this.isExpanded = false;
      this.ionDismiss.emit();
      this.setFocus();
    });
    await overlay.present();
    if (this.interface === "popover") {
      let indexOfSelected = this.childOpts.map((o3) => o3.value).indexOf(this.value);
      indexOfSelected = indexOfSelected > -1 ? indexOfSelected : 0;
      const selectedItem = overlay.querySelector(`.select-interface-option:nth-child(${indexOfSelected + 1})`);
      if (selectedItem) {
        focusElement(selectedItem);
        const interactiveEl = selectedItem.querySelector("ion-radio, ion-checkbox");
        if (interactiveEl) {
          interactiveEl.focus();
        }
      }
    }
    return overlay;
  }
  createOverlay(ev) {
    let selectInterface = this.interface;
    if (selectInterface === "action-sheet" && this.multiple) {
      console.warn(`Select interface cannot be "${selectInterface}" with a multi-value select. Using the "alert" interface instead.`);
      selectInterface = "alert";
    }
    if (selectInterface === "popover" && !ev) {
      console.warn(`Select interface cannot be a "${selectInterface}" without passing an event. Using the "alert" interface instead.`);
      selectInterface = "alert";
    }
    if (selectInterface === "action-sheet") {
      return this.openActionSheet();
    }
    if (selectInterface === "popover") {
      return this.openPopover(ev);
    }
    return this.openAlert();
  }
  updateOverlayOptions() {
    const overlay = this.overlay;
    if (!overlay) {
      return;
    }
    const childOpts = this.childOpts;
    const value = this.value;
    switch (this.interface) {
      case "action-sheet":
        overlay.buttons = this.createActionSheetButtons(childOpts, value);
        break;
      case "popover":
        const popover = overlay.querySelector("ion-select-popover");
        if (popover) {
          popover.options = this.createPopoverOptions(childOpts, value);
        }
        break;
      case "alert":
        const inputType = this.multiple ? "checkbox" : "radio";
        overlay.inputs = this.createAlertInputs(childOpts, inputType, value);
        break;
    }
  }
  createActionSheetButtons(data2, selectValue) {
    const actionSheetButtons = data2.map((option) => {
      const value = getOptionValue(option);
      const copyClasses = Array.from(option.classList).filter((cls) => cls !== "hydrated").join(" ");
      const optClass = `${OPTION_CLASS} ${copyClasses}`;
      return {
        role: isOptionSelected(selectValue, value, this.compareWith) ? "selected" : "",
        text: option.textContent,
        cssClass: optClass,
        handler: () => {
          this.setValue(value);
        }
      };
    });
    actionSheetButtons.push({
      text: this.cancelText,
      role: "cancel",
      handler: () => {
        this.ionCancel.emit();
      }
    });
    return actionSheetButtons;
  }
  createAlertInputs(data2, inputType, selectValue) {
    const alertInputs = data2.map((option) => {
      const value = getOptionValue(option);
      const copyClasses = Array.from(option.classList).filter((cls) => cls !== "hydrated").join(" ");
      const optClass = `${OPTION_CLASS} ${copyClasses}`;
      return {
        type: inputType,
        cssClass: optClass,
        label: option.textContent || "",
        value,
        checked: isOptionSelected(selectValue, value, this.compareWith),
        disabled: option.disabled
      };
    });
    return alertInputs;
  }
  createPopoverOptions(data2, selectValue) {
    const popoverOptions = data2.map((option) => {
      const value = getOptionValue(option);
      const copyClasses = Array.from(option.classList).filter((cls) => cls !== "hydrated").join(" ");
      const optClass = `${OPTION_CLASS} ${copyClasses}`;
      return {
        text: option.textContent || "",
        cssClass: optClass,
        value,
        checked: isOptionSelected(selectValue, value, this.compareWith),
        disabled: option.disabled,
        handler: (selected) => {
          this.setValue(selected);
          if (!this.multiple) {
            this.close();
          }
        }
      };
    });
    return popoverOptions;
  }
  async openPopover(ev) {
    const { fill, labelPlacement } = this;
    const interfaceOptions = this.interfaceOptions;
    const mode = getIonMode$2(this);
    const showBackdrop = mode === "md" ? false : true;
    const multiple = this.multiple;
    const value = this.value;
    let event = ev;
    let size = "auto";
    if (this.legacyFormController.hasLegacyControl()) {
      const item = this.el.closest("ion-item");
      if (item && (item.classList.contains("item-label-floating") || item.classList.contains("item-label-stacked"))) {
        event = Object.assign(Object.assign({}, ev), { detail: {
          ionShadowTarget: item
        } });
        size = "cover";
      }
    } else {
      const hasFloatingOrStackedLabel = labelPlacement === "floating" || labelPlacement === "stacked";
      if (hasFloatingOrStackedLabel || mode === "md" && fill !== void 0) {
        size = "cover";
      } else {
        event = Object.assign(Object.assign({}, ev), { detail: {
          ionShadowTarget: this.nativeWrapperEl
        } });
      }
    }
    const popoverOpts = Object.assign(Object.assign({
      mode,
      event,
      alignment: "center",
      size,
      showBackdrop
    }, interfaceOptions), { component: "ion-select-popover", cssClass: ["select-popover", interfaceOptions.cssClass], componentProps: {
      header: interfaceOptions.header,
      subHeader: interfaceOptions.subHeader,
      message: interfaceOptions.message,
      multiple,
      value,
      options: this.createPopoverOptions(this.childOpts, value)
    } });
    return popoverController.create(popoverOpts);
  }
  async openActionSheet() {
    const mode = getIonMode$2(this);
    const interfaceOptions = this.interfaceOptions;
    const actionSheetOpts = Object.assign(Object.assign({ mode }, interfaceOptions), { buttons: this.createActionSheetButtons(this.childOpts, this.value), cssClass: ["select-action-sheet", interfaceOptions.cssClass] });
    return actionSheetController.create(actionSheetOpts);
  }
  async openAlert() {
    let label;
    let labelText;
    if (this.legacyFormController.hasLegacyControl()) {
      label = this.getLabel();
      labelText = label ? label.textContent : null;
    } else {
      labelText = this.label;
    }
    const interfaceOptions = this.interfaceOptions;
    const inputType = this.multiple ? "checkbox" : "radio";
    const mode = getIonMode$2(this);
    const alertOpts = Object.assign(Object.assign({ mode }, interfaceOptions), { header: interfaceOptions.header ? interfaceOptions.header : labelText, inputs: this.createAlertInputs(this.childOpts, inputType, this.value), buttons: [
      {
        text: this.cancelText,
        role: "cancel",
        handler: () => {
          this.ionCancel.emit();
        }
      },
      {
        text: this.okText,
        handler: (selectedValues) => {
          this.setValue(selectedValues);
        }
      }
    ], cssClass: [
      "select-alert",
      interfaceOptions.cssClass,
      this.multiple ? "multiple-select-alert" : "single-select-alert"
    ] });
    return alertController.create(alertOpts);
  }
  /**
   * Close the select interface.
   */
  close() {
    if (!this.overlay) {
      return Promise.resolve(false);
    }
    return this.overlay.dismiss();
  }
  // TODO FW-3194 Remove this
  getLabel() {
    return findItemLabel(this.el);
  }
  hasValue() {
    return this.getText() !== "";
  }
  get childOpts() {
    return Array.from(this.el.querySelectorAll("ion-select-option"));
  }
  getText() {
    const selectedText = this.selectedText;
    if (selectedText != null && selectedText !== "") {
      return selectedText;
    }
    return generateText(this.childOpts, this.value, this.compareWith);
  }
  setFocus() {
    if (this.focusEl) {
      this.focusEl.focus();
    }
  }
  emitStyle() {
    const { disabled } = this;
    const style = {
      "interactive-disabled": disabled
    };
    if (this.legacyFormController.hasLegacyControl()) {
      style["interactive"] = true;
      style["select"] = true;
      style["select-disabled"] = disabled;
      style["has-placeholder"] = this.placeholder !== void 0;
      style["has-value"] = this.hasValue();
      style["has-focus"] = this.isExpanded;
    }
    this.ionStyle.emit(style);
  }
  renderLabel() {
    const { label } = this;
    if (label === void 0) {
      return;
    }
    return h$5("div", { class: "label-text-wrapper" }, h$5("div", { class: "label-text" }, this.label));
  }
  /**
   * Renders the border container
   * when fill="outline".
   */
  renderLabelContainer() {
    const mode = getIonMode$2(this);
    const hasOutlineFill = mode === "md" && this.fill === "outline";
    if (hasOutlineFill) {
      return [
        h$5("div", { class: "select-outline-container" }, h$5("div", { class: "select-outline-start" }), h$5("div", { class: "select-outline-notch" }, h$5("div", { class: "notch-spacer", "aria-hidden": "true" }, this.label)), h$5("div", { class: "select-outline-end" })),
        this.renderLabel()
      ];
    }
    return this.renderLabel();
  }
  renderSelect() {
    const { disabled, el: el2, isExpanded, labelPlacement, justify, placeholder, fill, shape, name, value } = this;
    const mode = getIonMode$2(this);
    const hasFloatingOrStackedLabel = labelPlacement === "floating" || labelPlacement === "stacked";
    const justifyEnabled = !hasFloatingOrStackedLabel;
    const rtl = isRTL$1(el2) ? "rtl" : "ltr";
    const inItem = hostContext("ion-item", this.el);
    const shouldRenderHighlight = mode === "md" && fill !== "outline" && !inItem;
    renderHiddenInput(true, el2, name, parseValue(value), disabled);
    return h$5(Host$1, { onClick: this.onClick, class: createColorClasses$1(this.color, {
      [mode]: true,
      "in-item": inItem,
      "in-item-color": hostContext("ion-item.ion-color", el2),
      "select-disabled": disabled,
      "select-expanded": isExpanded,
      "has-value": this.hasValue(),
      "has-placeholder": placeholder !== void 0,
      "ion-focusable": true,
      [`select-${rtl}`]: true,
      [`select-fill-${fill}`]: fill !== void 0,
      [`select-justify-${justify}`]: justifyEnabled,
      [`select-shape-${shape}`]: shape !== void 0,
      [`select-label-placement-${labelPlacement}`]: true
    }) }, h$5("label", { class: "select-wrapper", id: "select-label" }, this.renderLabelContainer(), h$5("div", { class: "native-wrapper", ref: (el3) => this.nativeWrapperEl = el3 }, this.renderSelectText(), !hasFloatingOrStackedLabel && this.renderSelectIcon(), this.renderListbox()), hasFloatingOrStackedLabel && this.renderSelectIcon(), shouldRenderHighlight && h$5("div", { class: "select-highlight" })));
  }
  // TODO FW-3194 - Remove this
  renderLegacySelect() {
    if (!this.hasLoggedDeprecationWarning) {
      printIonWarning(`ion-select now requires providing a label with either the "label" property or the "aria-label" attribute. To migrate, remove any usage of "ion-label" and pass the label text to either the "label" property or the "aria-label" attribute.

Example: <ion-select label="Favorite Color">...</ion-select>
Example with aria-label: <ion-select aria-label="Favorite Color">...</ion-select>

Developers can use the "legacy" property to continue using the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.`, this.el);
      if (this.legacy) {
        printIonWarning(`ion-select is being used with the "legacy" property enabled which will forcibly enable the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.
    Developers can dismiss this warning by removing their usage of the "legacy" property and using the new select syntax.`, this.el);
      }
      this.hasLoggedDeprecationWarning = true;
    }
    const { disabled, el: el2, inputId, isExpanded, name, placeholder, value } = this;
    const mode = getIonMode$2(this);
    const { labelText, labelId } = getAriaLabel(el2, inputId);
    renderHiddenInput(true, el2, name, parseValue(value), disabled);
    const displayValue = this.getText();
    let selectText = displayValue;
    if (selectText === "" && placeholder !== void 0) {
      selectText = placeholder;
    }
    const displayLabel = labelText !== void 0 ? selectText !== "" ? `${selectText}, ${labelText}` : labelText : selectText;
    return h$5(Host$1, { onClick: this.onClick, role: "button", "aria-haspopup": "listbox", "aria-disabled": disabled ? "true" : null, "aria-label": displayLabel, class: {
      [mode]: true,
      "in-item": hostContext("ion-item", el2),
      "in-item-color": hostContext("ion-item.ion-color", el2),
      "select-disabled": disabled,
      "select-expanded": isExpanded,
      "legacy-select": true
    } }, this.renderSelectText(), this.renderSelectIcon(), h$5("label", { id: labelId }, displayLabel), this.renderListbox());
  }
  /**
   * Renders either the placeholder
   * or the selected values based on
   * the state of the select.
   */
  renderSelectText() {
    const { placeholder } = this;
    const displayValue = this.getText();
    let addPlaceholderClass = false;
    let selectText = displayValue;
    if (selectText === "" && placeholder !== void 0) {
      selectText = placeholder;
      addPlaceholderClass = true;
    }
    const selectTextClasses = {
      "select-text": true,
      "select-placeholder": addPlaceholderClass
    };
    const textPart = addPlaceholderClass ? "placeholder" : "text";
    return h$5("div", { "aria-hidden": "true", class: selectTextClasses, part: textPart }, selectText);
  }
  /**
   * Renders the chevron icon
   * next to the select text.
   */
  renderSelectIcon() {
    const mode = getIonMode$2(this);
    const icon = mode === "ios" ? chevronExpand : caretDownSharp;
    return h$5("ion-icon", { class: "select-icon", part: "icon", "aria-hidden": "true", icon });
  }
  get ariaLabel() {
    var _a2;
    const { placeholder, label, el: el2, inputId, inheritedAttributes } = this;
    const displayValue = this.getText();
    const { labelText } = getAriaLabel(el2, inputId);
    const definedLabel = (_a2 = label !== null && label !== void 0 ? label : inheritedAttributes["aria-label"]) !== null && _a2 !== void 0 ? _a2 : labelText;
    let renderedLabel = displayValue;
    if (renderedLabel === "" && placeholder !== void 0) {
      renderedLabel = placeholder;
    }
    if (definedLabel !== void 0) {
      renderedLabel = renderedLabel === "" ? definedLabel : `${definedLabel}, ${renderedLabel}`;
    }
    return renderedLabel;
  }
  renderListbox() {
    const { disabled, inputId, isExpanded } = this;
    return h$5("button", { disabled, id: inputId, "aria-label": this.ariaLabel, "aria-haspopup": "listbox", "aria-expanded": `${isExpanded}`, onFocus: this.onFocus, onBlur: this.onBlur, ref: (focusEl) => this.focusEl = focusEl });
  }
  render() {
    const { legacyFormController } = this;
    return legacyFormController.hasLegacyControl() ? this.renderLegacySelect() : this.renderSelect();
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "disabled": ["styleChanged"],
      "isExpanded": ["styleChanged"],
      "placeholder": ["styleChanged"],
      "value": ["styleChanged"]
    };
  }
  static get style() {
    return {
      ios: selectIosCss,
      md: selectMdCss
    };
  }
}, [33, "ion-select", {
  "cancelText": [1, "cancel-text"],
  "color": [513],
  "compareWith": [1, "compare-with"],
  "disabled": [4],
  "fill": [1],
  "interface": [1],
  "interfaceOptions": [8, "interface-options"],
  "justify": [1],
  "label": [1],
  "labelPlacement": [1, "label-placement"],
  "legacy": [4],
  "multiple": [4],
  "name": [1],
  "okText": [1, "ok-text"],
  "placeholder": [1],
  "selectedText": [1, "selected-text"],
  "shape": [1],
  "value": [1032],
  "isExpanded": [32],
  "open": [64]
}]);
const isOptionSelected = (currentValue, compareValue, compareWith) => {
  if (currentValue === void 0) {
    return false;
  }
  if (Array.isArray(currentValue)) {
    return currentValue.some((val) => compareOptions(val, compareValue, compareWith));
  } else {
    return compareOptions(currentValue, compareValue, compareWith);
  }
};
const getOptionValue = (el2) => {
  const value = el2.value;
  return value === void 0 ? el2.textContent || "" : value;
};
const parseValue = (value) => {
  if (value == null) {
    return void 0;
  }
  if (Array.isArray(value)) {
    return value.join(",");
  }
  return value.toString();
};
const compareOptions = (currentValue, compareValue, compareWith) => {
  if (typeof compareWith === "function") {
    return compareWith(currentValue, compareValue);
  } else if (typeof compareWith === "string") {
    return currentValue[compareWith] === compareValue[compareWith];
  } else {
    return Array.isArray(compareValue) ? compareValue.includes(currentValue) : currentValue === compareValue;
  }
};
const generateText = (opts, value, compareWith) => {
  if (value === void 0) {
    return "";
  }
  if (Array.isArray(value)) {
    return value.map((v2) => textForValue(opts, v2, compareWith)).filter((opt) => opt !== null).join(", ");
  } else {
    return textForValue(opts, value, compareWith) || "";
  }
};
const textForValue = (opts, value, compareWith) => {
  const selectOpt = opts.find((opt) => {
    return compareOptions(value, getOptionValue(opt), compareWith);
  });
  return selectOpt ? selectOpt.textContent : null;
};
let selectIds = 0;
const OPTION_CLASS = "select-interface-option";
function defineCustomElement$1$g() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-select", "ion-action-sheet", "ion-alert", "ion-backdrop", "ion-checkbox", "ion-icon", "ion-item", "ion-label", "ion-list", "ion-list-header", "ion-note", "ion-popover", "ion-radio", "ion-radio-group", "ion-ripple-effect", "ion-select-popover"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-select":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Select);
        }
        break;
      case "ion-action-sheet":
        if (!customElements.get(tagName)) {
          defineCustomElement$o();
        }
        break;
      case "ion-alert":
        if (!customElements.get(tagName)) {
          defineCustomElement$n();
        }
        break;
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          defineCustomElement$17();
        }
        break;
      case "ion-checkbox":
        if (!customElements.get(tagName)) {
          defineCustomElement$$();
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$1b();
        }
        break;
      case "ion-item":
        if (!customElements.get(tagName)) {
          defineCustomElement$U();
        }
        break;
      case "ion-label":
        if (!customElements.get(tagName)) {
          defineCustomElement$T();
        }
        break;
      case "ion-list":
        if (!customElements.get(tagName)) {
          defineCustomElement$B();
        }
        break;
      case "ion-list-header":
        if (!customElements.get(tagName)) {
          defineCustomElement$z();
        }
        break;
      case "ion-note":
        if (!customElements.get(tagName)) {
          defineCustomElement$V();
        }
        break;
      case "ion-popover":
        if (!customElements.get(tagName)) {
          defineCustomElement$Q();
        }
        break;
      case "ion-radio":
        if (!customElements.get(tagName)) {
          defineCustomElement$t();
        }
        break;
      case "ion-radio-group":
        if (!customElements.get(tagName)) {
          defineCustomElement$s();
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$Z();
        }
        break;
      case "ion-select-popover":
        if (!customElements.get(tagName)) {
          defineCustomElement$m();
        }
        break;
    }
  });
}
const defineCustomElement$l = defineCustomElement$1$g;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const selectOptionCss = ":host{display:none}";
const SelectOption = /* @__PURE__ */ proxyCustomElement$1(class SelectOption2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.inputId = `ion-selopt-${selectOptionIds++}`;
    this.disabled = false;
    this.value = void 0;
  }
  render() {
    return h$5(Host$1, { role: "option", id: this.inputId, class: getIonMode$2(this) });
  }
  get el() {
    return this;
  }
  static get style() {
    return selectOptionCss;
  }
}, [1, "ion-select-option", {
  "disabled": [4],
  "value": [8]
}]);
let selectOptionIds = 0;
function defineCustomElement$1$f() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-select-option"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-select-option":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, SelectOption);
        }
        break;
    }
  });
}
const defineCustomElement$k = defineCustomElement$1$f;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$j = defineCustomElement$I;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const textCss = ":host(.ion-color){color:var(--ion-color-base)}";
const Text$1 = /* @__PURE__ */ proxyCustomElement$1(class Text extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.color = void 0;
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: createColorClasses$1(this.color, {
      [mode]: true
    }) }, h$5("slot", null));
  }
  static get style() {
    return textCss;
  }
}, [1, "ion-text", {
  "color": [513]
}]);
function defineCustomElement$1$e() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-text"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-text":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Text$1);
        }
        break;
    }
  });
}
const defineCustomElement$i = defineCustomElement$1$e;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const textareaIosCss = '.sc-ion-textarea-ios-h{--background:initial;--color:initial;--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:0.6;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;--border-radius:0;--border-style:solid;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);--highlight-color:var(--highlight-color-focused);display:block;position:relative;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);white-space:pre-wrap;z-index:2;-webkit-box-sizing:border-box;box-sizing:border-box}.legacy-textarea.sc-ion-textarea-ios-h{-ms-flex:1;flex:1;background:var(--background)}.legacy-textarea.ion-color.sc-ion-textarea-ios-h{color:var(--ion-color-base)}.sc-ion-textarea-ios-h:not(.legacy-textarea){--padding-bottom:8px}.ion-color.sc-ion-textarea-ios-h{--highlight-color-focused:var(--ion-color-base);background:initial}ion-item.sc-ion-textarea-ios-h,ion-item .sc-ion-textarea-ios-h{-ms-flex-item-align:baseline;align-self:baseline}ion-item.sc-ion-textarea-ios-h:not(.item-label),ion-item:not(.item-label) .sc-ion-textarea-ios-h{--padding-start:0}ion-item[slot=start].sc-ion-textarea-ios-h,ion-item [slot=start].sc-ion-textarea-ios-h,ion-item[slot=end].sc-ion-textarea-ios-h,ion-item [slot=end].sc-ion-textarea-ios-h{width:auto}.native-textarea.sc-ion-textarea-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;position:relative;-ms-flex:1;flex:1;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;-webkit-box-sizing:border-box;box-sizing:border-box;resize:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;z-index:1}.native-textarea.sc-ion-textarea-ios::-webkit-input-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios::-moz-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios:-ms-input-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios::-ms-input-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-ios::placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.legacy-textarea.sc-ion-textarea-ios-h .native-textarea.sc-ion-textarea-ios,.legacy-textarea.sc-ion-textarea-ios-h .textarea-legacy-wrapper.sc-ion-textarea-ios::after{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);border-radius:var(--border-radius)}.native-textarea.sc-ion-textarea-ios,.legacy-textarea.sc-ion-textarea-ios-h .textarea-legacy-wrapper.sc-ion-textarea-ios::after{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;grid-area:1/1/2/2;word-break:break-word}.legacy-textarea.sc-ion-textarea-ios-h .native-textarea[disabled].sc-ion-textarea-ios,.textarea-disabled.sc-ion-textarea-ios-h{opacity:0.4}.cloned-input.sc-ion-textarea-ios{top:0;bottom:0;position:absolute;pointer-events:none}@supports (inset-inline-start: 0){.cloned-input.sc-ion-textarea-ios{inset-inline-start:0}}@supports not (inset-inline-start: 0){.cloned-input.sc-ion-textarea-ios{left:0}[dir=rtl].sc-ion-textarea-ios-h .cloned-input.sc-ion-textarea-ios,[dir=rtl] .sc-ion-textarea-ios-h .cloned-input.sc-ion-textarea-ios{left:unset;right:unset;right:0}[dir=rtl].sc-ion-textarea-ios .cloned-input.sc-ion-textarea-ios{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.cloned-input.sc-ion-textarea-ios:dir(rtl){left:unset;right:unset;right:0}}}.cloned-input.sc-ion-textarea-ios:disabled{opacity:1}.legacy-textarea[auto-grow].sc-ion-textarea-ios-h .cloned-input.sc-ion-textarea-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}[auto-grow].sc-ion-textarea-ios-h .cloned-input.sc-ion-textarea-ios{height:100%}[auto-grow].sc-ion-textarea-ios-h .native-textarea.sc-ion-textarea-ios{overflow:hidden}.item-label-floating.item-has-placeholder.sc-ion-textarea-ios-h:not(.item-has-value),.item-label-floating.item-has-placeholder:not(.item-has-value) .sc-ion-textarea-ios-h{opacity:0}.item-label-floating.item-has-placeholder.sc-ion-textarea-ios-h:not(.item-has-value).item-has-focus,.item-label-floating.item-has-placeholder:not(.item-has-value).item-has-focus .sc-ion-textarea-ios-h{-webkit-transition:opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1);opacity:1}.textarea-wrapper.sc-ion-textarea-ios{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:0px;padding-bottom:0px;border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:start;align-items:flex-start;height:inherit;min-height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;background:var(--background);line-height:normal}.native-wrapper.sc-ion-textarea-ios{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;width:100%;height:100%}.has-focus.sc-ion-textarea-ios-h textarea.sc-ion-textarea-ios{caret-color:var(--highlight-color)}.native-wrapper.sc-ion-textarea-ios textarea.sc-ion-textarea-ios{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom)}.native-wrapper.sc-ion-textarea-ios,.textarea-legacy-wrapper.sc-ion-textarea-ios{display:grid;min-width:inherit;max-width:inherit;min-height:inherit;max-height:inherit}.native-wrapper.sc-ion-textarea-ios::after,.textarea-legacy-wrapper.sc-ion-textarea-ios::after{white-space:pre-wrap;content:attr(data-replicated-value) " ";visibility:hidden}.native-wrapper.sc-ion-textarea-ios::after{padding-left:0;padding-right:0;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;border-radius:var(--border-radius);grid-area:1/1/2/2;word-break:break-word}.ion-touched.ion-invalid.sc-ion-textarea-ios-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-textarea-ios-h{--highlight-color:var(--highlight-color-valid)}.textarea-bottom.sc-ion-textarea-ios{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:5px;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;border-top:var(--border-width) var(--border-style) var(--border-color);font-size:12px}.has-focus.ion-valid.sc-ion-textarea-ios-h,.ion-touched.ion-invalid.sc-ion-textarea-ios-h{--border-color:var(--highlight-color)}.textarea-bottom.sc-ion-textarea-ios .error-text.sc-ion-textarea-ios{display:none;color:var(--highlight-color-invalid)}.textarea-bottom.sc-ion-textarea-ios .helper-text.sc-ion-textarea-ios{display:block;color:var(--ion-color-step-550, #737373)}.ion-touched.ion-invalid.sc-ion-textarea-ios-h .textarea-bottom.sc-ion-textarea-ios .error-text.sc-ion-textarea-ios{display:block}.ion-touched.ion-invalid.sc-ion-textarea-ios-h .textarea-bottom.sc-ion-textarea-ios .helper-text.sc-ion-textarea-ios{display:none}.textarea-bottom.sc-ion-textarea-ios .counter.sc-ion-textarea-ios{-webkit-margin-start:auto;margin-inline-start:auto;color:var(--ion-color-step-550, #737373);white-space:nowrap;-webkit-padding-start:16px;padding-inline-start:16px}.label-text-wrapper.sc-ion-textarea-ios{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);max-width:200px;-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.label-text.sc-ion-textarea-ios{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.textarea-wrapper.sc-ion-textarea-ios textarea.sc-ion-textarea-ios{-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.textarea-label-placement-start.sc-ion-textarea-ios-h .textarea-wrapper.sc-ion-textarea-ios{-ms-flex-direction:row;flex-direction:row}.textarea-label-placement-start.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.textarea-label-placement-end.sc-ion-textarea-ios-h .textarea-wrapper.sc-ion-textarea-ios{-ms-flex-direction:row-reverse;flex-direction:row-reverse}.textarea-label-placement-end.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}.textarea-label-placement-fixed.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.textarea-label-placement-fixed.sc-ion-textarea-ios-h .label-text.sc-ion-textarea-ios{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.textarea-label-placement-stacked.sc-ion-textarea-ios-h .textarea-wrapper.sc-ion-textarea-ios,.textarea-label-placement-floating.sc-ion-textarea-ios-h .textarea-wrapper.sc-ion-textarea-ios{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:start}.textarea-label-placement-stacked.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,.textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-transform-origin:left top;transform-origin:left top;-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:0px;padding-bottom:0px;max-width:100%}[dir=rtl].sc-ion-textarea-ios-h -no-combinator.textarea-label-placement-stacked.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl] .sc-ion-textarea-ios-h -no-combinator.textarea-label-placement-stacked.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl].textarea-label-placement-stacked.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl] .textarea-label-placement-stacked.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl].sc-ion-textarea-ios-h -no-combinator.textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl] .sc-ion-textarea-ios-h -no-combinator.textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl].textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,[dir=rtl] .textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.textarea-label-placement-stacked.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios:dir(rtl),.textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios:dir(rtl){-webkit-transform-origin:right top;transform-origin:right top}}.textarea-label-placement-stacked.sc-ion-textarea-ios-h textarea.sc-ion-textarea-ios,.textarea-label-placement-floating.sc-ion-textarea-ios-h textarea.sc-ion-textarea-ios,.textarea-label-placement-stacked[auto-grow].sc-ion-textarea-ios-h .native-wrapper.sc-ion-textarea-ios::after,.textarea-label-placement-floating[auto-grow].sc-ion-textarea-ios-h .native-wrapper.sc-ion-textarea-ios::after{-webkit-margin-start:0px;margin-inline-start:0px;-webkit-margin-end:0px;margin-inline-end:0px;margin-top:8px;margin-bottom:0px}.textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-transform:translateY(100%) scale(1);transform:translateY(100%) scale(1)}.textarea-label-placement-floating.sc-ion-textarea-ios-h textarea.sc-ion-textarea-ios{opacity:0}.has-focus.textarea-label-placement-floating.sc-ion-textarea-ios-h textarea.sc-ion-textarea-ios,.has-value.textarea-label-placement-floating.sc-ion-textarea-ios-h textarea.sc-ion-textarea-ios{opacity:1}.textarea-label-placement-stacked.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,.has-focus.textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios,.has-value.textarea-label-placement-floating.sc-ion-textarea-ios-h .label-text-wrapper.sc-ion-textarea-ios{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);max-width:calc(100% / 0.75)}.sc-ion-textarea-ios-h{--border-width:0.55px;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));--padding-top:10px;--padding-end:0px;--padding-bottom:8px;--padding-start:0px;font-size:inherit}.legacy-textarea.sc-ion-textarea-ios-h{--padding-top:10px;--padding-end:8px;--padding-bottom:10px;--padding-start:0}.item-label-stacked.sc-ion-textarea-ios-h,.item-label-stacked .sc-ion-textarea-ios-h,.item-label-floating.sc-ion-textarea-ios-h,.item-label-floating .sc-ion-textarea-ios-h{--padding-top:8px;--padding-bottom:8px;--padding-start:0px}.sc-ion-textarea-ios-h:not(.legacy-textarea){min-height:44px}.textarea-label-placement-floating.sc-ion-textarea-ios-h,.textarea-label-placement-stacked.sc-ion-textarea-ios-h{--padding-top:0px;min-height:56px}';
const textareaMdCss = '.sc-ion-textarea-md-h{--background:initial;--color:initial;--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:0.6;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;--border-radius:0;--border-style:solid;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);--highlight-color:var(--highlight-color-focused);display:block;position:relative;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);white-space:pre-wrap;z-index:2;-webkit-box-sizing:border-box;box-sizing:border-box}.legacy-textarea.sc-ion-textarea-md-h{-ms-flex:1;flex:1;background:var(--background)}.legacy-textarea.ion-color.sc-ion-textarea-md-h{color:var(--ion-color-base)}.sc-ion-textarea-md-h:not(.legacy-textarea){--padding-bottom:8px}.ion-color.sc-ion-textarea-md-h{--highlight-color-focused:var(--ion-color-base);background:initial}ion-item.sc-ion-textarea-md-h,ion-item .sc-ion-textarea-md-h{-ms-flex-item-align:baseline;align-self:baseline}ion-item.sc-ion-textarea-md-h:not(.item-label),ion-item:not(.item-label) .sc-ion-textarea-md-h{--padding-start:0}ion-item[slot=start].sc-ion-textarea-md-h,ion-item [slot=start].sc-ion-textarea-md-h,ion-item[slot=end].sc-ion-textarea-md-h,ion-item [slot=end].sc-ion-textarea-md-h{width:auto}.native-textarea.sc-ion-textarea-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;position:relative;-ms-flex:1;flex:1;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;-webkit-box-sizing:border-box;box-sizing:border-box;resize:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;z-index:1}.native-textarea.sc-ion-textarea-md::-webkit-input-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-md::-moz-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-md:-ms-input-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-md::-ms-input-placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea.sc-ion-textarea-md::placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.legacy-textarea.sc-ion-textarea-md-h .native-textarea.sc-ion-textarea-md,.legacy-textarea.sc-ion-textarea-md-h .textarea-legacy-wrapper.sc-ion-textarea-md::after{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);border-radius:var(--border-radius)}.native-textarea.sc-ion-textarea-md,.legacy-textarea.sc-ion-textarea-md-h .textarea-legacy-wrapper.sc-ion-textarea-md::after{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;grid-area:1/1/2/2;word-break:break-word}.legacy-textarea.sc-ion-textarea-md-h .native-textarea[disabled].sc-ion-textarea-md,.textarea-disabled.sc-ion-textarea-md-h{opacity:0.4}.cloned-input.sc-ion-textarea-md{top:0;bottom:0;position:absolute;pointer-events:none}@supports (inset-inline-start: 0){.cloned-input.sc-ion-textarea-md{inset-inline-start:0}}@supports not (inset-inline-start: 0){.cloned-input.sc-ion-textarea-md{left:0}[dir=rtl].sc-ion-textarea-md-h .cloned-input.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h .cloned-input.sc-ion-textarea-md{left:unset;right:unset;right:0}[dir=rtl].sc-ion-textarea-md .cloned-input.sc-ion-textarea-md{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.cloned-input.sc-ion-textarea-md:dir(rtl){left:unset;right:unset;right:0}}}.cloned-input.sc-ion-textarea-md:disabled{opacity:1}.legacy-textarea[auto-grow].sc-ion-textarea-md-h .cloned-input.sc-ion-textarea-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}[auto-grow].sc-ion-textarea-md-h .cloned-input.sc-ion-textarea-md{height:100%}[auto-grow].sc-ion-textarea-md-h .native-textarea.sc-ion-textarea-md{overflow:hidden}.item-label-floating.item-has-placeholder.sc-ion-textarea-md-h:not(.item-has-value),.item-label-floating.item-has-placeholder:not(.item-has-value) .sc-ion-textarea-md-h{opacity:0}.item-label-floating.item-has-placeholder.sc-ion-textarea-md-h:not(.item-has-value).item-has-focus,.item-label-floating.item-has-placeholder:not(.item-has-value).item-has-focus .sc-ion-textarea-md-h{-webkit-transition:opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1);opacity:1}.textarea-wrapper.sc-ion-textarea-md{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:0px;padding-bottom:0px;border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:start;align-items:flex-start;height:inherit;min-height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;background:var(--background);line-height:normal}.native-wrapper.sc-ion-textarea-md{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;width:100%;height:100%}.has-focus.sc-ion-textarea-md-h textarea.sc-ion-textarea-md{caret-color:var(--highlight-color)}.native-wrapper.sc-ion-textarea-md textarea.sc-ion-textarea-md{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom)}.native-wrapper.sc-ion-textarea-md,.textarea-legacy-wrapper.sc-ion-textarea-md{display:grid;min-width:inherit;max-width:inherit;min-height:inherit;max-height:inherit}.native-wrapper.sc-ion-textarea-md::after,.textarea-legacy-wrapper.sc-ion-textarea-md::after{white-space:pre-wrap;content:attr(data-replicated-value) " ";visibility:hidden}.native-wrapper.sc-ion-textarea-md::after{padding-left:0;padding-right:0;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;border-radius:var(--border-radius);grid-area:1/1/2/2;word-break:break-word}.ion-touched.ion-invalid.sc-ion-textarea-md-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-textarea-md-h{--highlight-color:var(--highlight-color-valid)}.textarea-bottom.sc-ion-textarea-md{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:5px;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;border-top:var(--border-width) var(--border-style) var(--border-color);font-size:12px}.has-focus.ion-valid.sc-ion-textarea-md-h,.ion-touched.ion-invalid.sc-ion-textarea-md-h{--border-color:var(--highlight-color)}.textarea-bottom.sc-ion-textarea-md .error-text.sc-ion-textarea-md{display:none;color:var(--highlight-color-invalid)}.textarea-bottom.sc-ion-textarea-md .helper-text.sc-ion-textarea-md{display:block;color:var(--ion-color-step-550, #737373)}.ion-touched.ion-invalid.sc-ion-textarea-md-h .textarea-bottom.sc-ion-textarea-md .error-text.sc-ion-textarea-md{display:block}.ion-touched.ion-invalid.sc-ion-textarea-md-h .textarea-bottom.sc-ion-textarea-md .helper-text.sc-ion-textarea-md{display:none}.textarea-bottom.sc-ion-textarea-md .counter.sc-ion-textarea-md{-webkit-margin-start:auto;margin-inline-start:auto;color:var(--ion-color-step-550, #737373);white-space:nowrap;-webkit-padding-start:16px;padding-inline-start:16px}.label-text-wrapper.sc-ion-textarea-md{-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);max-width:200px;-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);pointer-events:none}.label-text.sc-ion-textarea-md{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.textarea-wrapper.sc-ion-textarea-md textarea.sc-ion-textarea-md{-webkit-transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.textarea-label-placement-start.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{-ms-flex-direction:row;flex-direction:row}.textarea-label-placement-start.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.textarea-label-placement-end.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{-ms-flex-direction:row-reverse;flex-direction:row-reverse}.textarea-label-placement-end.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}.textarea-label-placement-fixed.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}.textarea-label-placement-fixed.sc-ion-textarea-md-h .label-text.sc-ion-textarea-md{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.textarea-label-placement-stacked.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md,.textarea-label-placement-floating.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:start}.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform-origin:left top;transform-origin:left top;-webkit-padding-start:0px;padding-inline-start:0px;-webkit-padding-end:0px;padding-inline-end:0px;padding-top:0px;padding-bottom:0px;max-width:100%}[dir=rtl].sc-ion-textarea-md-h -no-combinator.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h -no-combinator.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl].textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl].sc-ion-textarea-md-h -no-combinator.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h -no-combinator.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl].textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md:dir(rtl),.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md:dir(rtl){-webkit-transform-origin:right top;transform-origin:right top}}.textarea-label-placement-stacked.sc-ion-textarea-md-h textarea.sc-ion-textarea-md,.textarea-label-placement-floating.sc-ion-textarea-md-h textarea.sc-ion-textarea-md,.textarea-label-placement-stacked[auto-grow].sc-ion-textarea-md-h .native-wrapper.sc-ion-textarea-md::after,.textarea-label-placement-floating[auto-grow].sc-ion-textarea-md-h .native-wrapper.sc-ion-textarea-md::after{-webkit-margin-start:0px;margin-inline-start:0px;-webkit-margin-end:0px;margin-inline-end:0px;margin-top:8px;margin-bottom:0px}.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform:translateY(100%) scale(1);transform:translateY(100%) scale(1)}.textarea-label-placement-floating.sc-ion-textarea-md-h textarea.sc-ion-textarea-md{opacity:0}.has-focus.textarea-label-placement-floating.sc-ion-textarea-md-h textarea.sc-ion-textarea-md,.has-value.textarea-label-placement-floating.sc-ion-textarea-md-h textarea.sc-ion-textarea-md{opacity:1}.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.has-focus.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.has-value.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);max-width:calc(100% / 0.75)}.textarea-fill-solid.sc-ion-textarea-md-h{--background:var(--ion-color-step-50, #f2f2f2);--border-color:var(--ion-color-step-500, gray);--border-radius:4px;--padding-start:16px;--padding-end:16px}.textarea-fill-solid.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{border-bottom:var(--border-width) var(--border-style) var(--border-color)}.has-focus.textarea-fill-solid.ion-valid.sc-ion-textarea-md-h,.textarea-fill-solid.ion-touched.ion-invalid.sc-ion-textarea-md-h{--border-color:var(--highlight-color)}.textarea-fill-solid.sc-ion-textarea-md-h .textarea-bottom.sc-ion-textarea-md{border-top:none}@media (any-hover: hover){.textarea-fill-solid.sc-ion-textarea-md-h:hover{--background:var(--ion-color-step-100, #e6e6e6);--border-color:var(--ion-color-step-750, #404040)}}.textarea-fill-solid.has-focus.sc-ion-textarea-md-h{--background:var(--ion-color-step-150, #d9d9d9);--border-color:var(--ion-color-step-750, #404040)}.textarea-fill-solid.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0px;border-bottom-left-radius:0px}[dir=rtl].sc-ion-textarea-md-h -no-combinator.textarea-fill-solid.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h -no-combinator.textarea-fill-solid.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md,[dir=rtl].textarea-fill-solid.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md,[dir=rtl] .textarea-fill-solid.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0px;border-bottom-left-radius:0px}@supports selector(:dir(rtl)){.textarea-fill-solid.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md:dir(rtl){border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0px;border-bottom-left-radius:0px}}.textarea-fill-solid.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.has-focus.textarea-fill-solid.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.has-value.textarea-fill-solid.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{max-width:calc(100% / 0.75)}.textarea-fill-outline.sc-ion-textarea-md-h{--border-color:var(--ion-color-step-300, #b3b3b3);--border-radius:4px;--padding-start:16px;--padding-end:16px}.textarea-fill-outline.textarea-shape-round.sc-ion-textarea-md-h{--border-radius:28px;--padding-start:32px;--padding-end:32px}.has-focus.textarea-fill-outline.ion-valid.sc-ion-textarea-md-h,.textarea-fill-outline.ion-touched.ion-invalid.sc-ion-textarea-md-h{--border-color:var(--highlight-color)}@media (any-hover: hover){.textarea-fill-outline.sc-ion-textarea-md-h:hover{--border-color:var(--ion-color-step-750, #404040)}}.textarea-fill-outline.has-focus.sc-ion-textarea-md-h{--border-width:2px;--border-color:var(--highlight-color)}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-bottom.sc-ion-textarea-md{border-top:none}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-wrapper.sc-ion-textarea-md{border-bottom:none}.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform-origin:left top;transform-origin:left top;position:absolute;max-width:calc(100% - var(--padding-start) - var(--padding-end))}[dir=rtl].sc-ion-textarea-md-h -no-combinator.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h -no-combinator.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl].textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl].sc-ion-textarea-md-h -no-combinator.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h -no-combinator.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl].textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,[dir=rtl] .textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md:dir(rtl),.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md:dir(rtl){-webkit-transform-origin:right top;transform-origin:right top}}.textarea-fill-outline.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{position:relative;z-index:1}.has-focus.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.has-value.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{-webkit-transform:translateY(-32%) scale(0.75);transform:translateY(-32%) scale(0.75);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;max-width:calc(\n    (100% - var(--padding-start) - var(--padding-end) - 8px) / 0.75\n  )}.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h textarea.sc-ion-textarea-md,.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h textarea.sc-ion-textarea-md,.textarea-fill-outline.textarea-label-placement-stacked[auto-grow].sc-ion-textarea-md-h .native-wrapper.sc-ion-textarea-md::after,.textarea-fill-outline.textarea-label-placement-floating[auto-grow].sc-ion-textarea-md-h .native-wrapper.sc-ion-textarea-md::after{-webkit-margin-start:0px;margin-inline-start:0px;-webkit-margin-end:0px;margin-inline-end:0px;margin-top:12px;margin-bottom:0px}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-container.sc-ion-textarea-md{left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;width:100%;height:100%}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-start.sc-ion-textarea-md,.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-end.sc-ion-textarea-md{pointer-events:none}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-start.sc-ion-textarea-md,.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-notch.sc-ion-textarea-md,.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-end.sc-ion-textarea-md{border-top:var(--border-width) var(--border-style) var(--border-color);border-bottom:var(--border-width) var(--border-style) var(--border-color)}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-notch.sc-ion-textarea-md{max-width:calc(100% - var(--padding-start) - var(--padding-end))}.textarea-fill-outline.sc-ion-textarea-md-h .notch-spacer.sc-ion-textarea-md{-webkit-padding-end:8px;padding-inline-end:8px;font-size:calc(1em * 0.75);opacity:0;pointer-events:none}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-start.sc-ion-textarea-md{border-top-left-radius:var(--border-radius);border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:var(--border-radius);-webkit-border-start:var(--border-width) var(--border-style) var(--border-color);border-inline-start:var(--border-width) var(--border-style) var(--border-color);width:calc(var(--padding-start) - 4px)}[dir=rtl].sc-ion-textarea-md-h -no-combinator.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-start.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h -no-combinator.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-start.sc-ion-textarea-md,[dir=rtl].textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-start.sc-ion-textarea-md,[dir=rtl] .textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-start.sc-ion-textarea-md{border-top-left-radius:0px;border-top-right-radius:var(--border-radius);border-bottom-right-radius:var(--border-radius);border-bottom-left-radius:0px}@supports selector(:dir(rtl)){.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-start.sc-ion-textarea-md:dir(rtl){border-top-left-radius:0px;border-top-right-radius:var(--border-radius);border-bottom-right-radius:var(--border-radius);border-bottom-left-radius:0px}}.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-end.sc-ion-textarea-md{-webkit-border-end:var(--border-width) var(--border-style) var(--border-color);border-inline-end:var(--border-width) var(--border-style) var(--border-color);border-top-left-radius:0px;border-top-right-radius:var(--border-radius);border-bottom-right-radius:var(--border-radius);border-bottom-left-radius:0px;-ms-flex-positive:1;flex-grow:1}[dir=rtl].sc-ion-textarea-md-h -no-combinator.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-end.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h -no-combinator.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-end.sc-ion-textarea-md,[dir=rtl].textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-end.sc-ion-textarea-md,[dir=rtl] .textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-end.sc-ion-textarea-md{border-top-left-radius:var(--border-radius);border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:var(--border-radius)}@supports selector(:dir(rtl)){.textarea-fill-outline.sc-ion-textarea-md-h .textarea-outline-end.sc-ion-textarea-md:dir(rtl){border-top-left-radius:var(--border-radius);border-top-right-radius:0px;border-bottom-right-radius:0px;border-bottom-left-radius:var(--border-radius)}}.has-focus.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .textarea-outline-notch.sc-ion-textarea-md,.has-value.textarea-fill-outline.textarea-label-placement-floating.sc-ion-textarea-md-h .textarea-outline-notch.sc-ion-textarea-md,.textarea-fill-outline.textarea-label-placement-stacked.sc-ion-textarea-md-h .textarea-outline-notch.sc-ion-textarea-md{border-top:none}.sc-ion-textarea-md-h{--border-width:1px;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));--padding-top:18px;--padding-end:0px;--padding-bottom:8px;--padding-start:0px;font-size:inherit}.legacy-textarea.sc-ion-textarea-md-h{--padding-top:10px;--padding-end:0;--padding-bottom:11px;--padding-start:8px;margin-left:0;margin-right:0;margin-top:8px;margin-bottom:0}.item-label-stacked.sc-ion-textarea-md-h,.item-label-stacked .sc-ion-textarea-md-h,.item-label-floating.sc-ion-textarea-md-h,.item-label-floating .sc-ion-textarea-md-h{--padding-top:8px;--padding-bottom:8px;--padding-start:0}.textarea-bottom.sc-ion-textarea-md .counter.sc-ion-textarea-md{letter-spacing:0.0333333333em}.sc-ion-textarea-md-h:not(.legacy-textarea){min-height:56px}.textarea-label-placement-floating.sc-ion-textarea-md-h,.textarea-label-placement-stacked.sc-ion-textarea-md-h{--padding-top:0px}.textarea-label-placement-floating.has-focus.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.textarea-label-placement-stacked.has-focus.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{color:var(--highlight-color)}.has-focus.textarea-label-placement-floating.ion-valid.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.textarea-label-placement-floating.ion-touched.ion-invalid.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.has-focus.textarea-label-placement-stacked.ion-valid.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md,.textarea-label-placement-stacked.ion-touched.ion-invalid.sc-ion-textarea-md-h .label-text-wrapper.sc-ion-textarea-md{color:var(--highlight-color)}.textarea-highlight.sc-ion-textarea-md{bottom:-1px;position:absolute;width:100%;height:2px;-webkit-transform:scale(0);transform:scale(0);-webkit-transition:-webkit-transform 200ms;transition:-webkit-transform 200ms;transition:transform 200ms;transition:transform 200ms, -webkit-transform 200ms;background:var(--highlight-color)}@supports (inset-inline-start: 0){.textarea-highlight.sc-ion-textarea-md{inset-inline-start:0}}@supports not (inset-inline-start: 0){.textarea-highlight.sc-ion-textarea-md{left:0}[dir=rtl].sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md{left:unset;right:unset;right:0}[dir=rtl].sc-ion-textarea-md .textarea-highlight.sc-ion-textarea-md{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.textarea-highlight.sc-ion-textarea-md:dir(rtl){left:unset;right:unset;right:0}}}.has-focus.sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md{-webkit-transform:scale(1);transform:scale(1)}.in-item.sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md{bottom:0}@supports (inset-inline-start: 0){.in-item.sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md{inset-inline-start:0}}@supports not (inset-inline-start: 0){.in-item.sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md{left:0}[dir=rtl].sc-ion-textarea-md-h -no-combinator.in-item.sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h -no-combinator.in-item.sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md,[dir=rtl].in-item.sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md,[dir=rtl] .in-item.sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){.in-item.sc-ion-textarea-md-h .textarea-highlight.sc-ion-textarea-md:dir(rtl){left:unset;right:unset;right:0}}}.textarea-shape-round.sc-ion-textarea-md-h{--border-radius:16px}';
const Textarea = /* @__PURE__ */ proxyCustomElement$1(class Textarea2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionInput = createEvent(this, "ionInput", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.inputId = `ion-textarea-${textareaIds++}`;
    this.didTextareaClearOnEdit = false;
    this.inheritedAttributes = {};
    this.hasLoggedDeprecationWarning = false;
    this.onInput = (ev) => {
      const input = ev.target;
      if (input) {
        this.value = input.value || "";
      }
      this.emitInputChange(ev);
    };
    this.onChange = (ev) => {
      this.emitValueChange(ev);
    };
    this.onFocus = (ev) => {
      this.hasFocus = true;
      this.focusedValue = this.value;
      this.focusChange();
      this.ionFocus.emit(ev);
    };
    this.onBlur = (ev) => {
      this.hasFocus = false;
      this.focusChange();
      if (this.focusedValue !== this.value) {
        this.emitValueChange(ev);
      }
      this.didTextareaClearOnEdit = false;
      this.ionBlur.emit(ev);
    };
    this.onKeyDown = (ev) => {
      this.checkClearOnEdit(ev);
    };
    this.hasFocus = false;
    this.color = void 0;
    this.autocapitalize = "none";
    this.autofocus = false;
    this.clearOnEdit = false;
    this.debounce = void 0;
    this.disabled = false;
    this.fill = void 0;
    this.inputmode = void 0;
    this.enterkeyhint = void 0;
    this.maxlength = void 0;
    this.minlength = void 0;
    this.name = this.inputId;
    this.placeholder = void 0;
    this.readonly = false;
    this.required = false;
    this.spellcheck = false;
    this.cols = void 0;
    this.rows = void 0;
    this.wrap = void 0;
    this.autoGrow = false;
    this.value = "";
    this.counter = false;
    this.counterFormatter = void 0;
    this.errorText = void 0;
    this.helperText = void 0;
    this.label = void 0;
    this.labelPlacement = "start";
    this.legacy = void 0;
    this.shape = void 0;
  }
  debounceChanged() {
    const { ionInput, debounce: debounce2, originalIonInput } = this;
    this.ionInput = debounce2 === void 0 ? originalIonInput !== null && originalIonInput !== void 0 ? originalIonInput : ionInput : debounceEvent(ionInput, debounce2);
  }
  disabledChanged() {
    this.emitStyle();
  }
  /**
   * Update the native input element when the value changes
   */
  valueChanged() {
    const nativeInput = this.nativeInput;
    const value = this.getValue();
    if (nativeInput && nativeInput.value !== value) {
      nativeInput.value = value;
    }
    this.runAutoGrow();
    this.emitStyle();
  }
  connectedCallback() {
    const { el: el2 } = this;
    this.legacyFormController = createLegacyFormController(el2);
    this.emitStyle();
    this.debounceChanged();
    {
      document.dispatchEvent(new CustomEvent("ionInputDidLoad", {
        detail: el2
      }));
    }
  }
  disconnectedCallback() {
    {
      document.dispatchEvent(new CustomEvent("ionInputDidUnload", {
        detail: this.el
      }));
    }
  }
  componentWillLoad() {
    this.inheritedAttributes = Object.assign(Object.assign({}, inheritAriaAttributes(this.el)), inheritAttributes$2(this.el, ["data-form-type", "title", "tabindex"]));
  }
  componentDidLoad() {
    this.originalIonInput = this.ionInput;
    this.runAutoGrow();
  }
  /**
   * Sets focus on the native `textarea` in `ion-textarea`. Use this method instead of the global
   * `textarea.focus()`.
   */
  async setFocus() {
    if (this.nativeInput) {
      this.nativeInput.focus();
    }
  }
  /**
   * Returns the native `<textarea>` element used under the hood.
   */
  getInputElement() {
    return Promise.resolve(this.nativeInput);
  }
  emitStyle() {
    if (this.legacyFormController.hasLegacyControl()) {
      this.ionStyle.emit({
        interactive: true,
        textarea: true,
        input: true,
        "interactive-disabled": this.disabled,
        "has-placeholder": this.placeholder !== void 0,
        "has-value": this.hasValue(),
        "has-focus": this.hasFocus
      });
    }
  }
  /**
   * Emits an `ionChange` event.
   *
   * This API should be called for user committed changes.
   * This API should not be used for external value changes.
   */
  emitValueChange(event) {
    const { value } = this;
    const newValue = value == null ? value : value.toString();
    this.focusedValue = newValue;
    this.ionChange.emit({ value: newValue, event });
  }
  /**
   * Emits an `ionInput` event.
   */
  emitInputChange(event) {
    const { value } = this;
    this.ionInput.emit({ value, event });
  }
  runAutoGrow() {
    if (this.nativeInput && this.autoGrow) {
      writeTask$1(() => {
        var _a2;
        if (this.textareaWrapper) {
          this.textareaWrapper.dataset.replicatedValue = (_a2 = this.value) !== null && _a2 !== void 0 ? _a2 : "";
        }
      });
    }
  }
  /**
   * Check if we need to clear the text input if clearOnEdit is enabled
   */
  checkClearOnEdit(ev) {
    if (!this.clearOnEdit) {
      return;
    }
    if (!this.didTextareaClearOnEdit && this.hasValue()) {
      this.value = "";
      this.emitInputChange(ev);
    }
    this.didTextareaClearOnEdit = true;
  }
  focusChange() {
    this.emitStyle();
  }
  hasValue() {
    return this.getValue() !== "";
  }
  getValue() {
    return this.value || "";
  }
  // TODO: FW-2876 - Remove this render function
  renderLegacyTextarea() {
    if (!this.hasLoggedDeprecationWarning) {
      printIonWarning(`ion-textarea now requires providing a label with either the "label" property or the "aria-label" attribute. To migrate, remove any usage of "ion-label" and pass the label text to either the "label" property or the "aria-label" attribute.

Example: <ion-textarea label="Comments"></ion-textarea>
Example with aria-label: <ion-textarea aria-label="Comments"></ion-textarea>

For textareas that do not render the label immediately next to the input, developers may continue to use "ion-label" but must manually associate the label with the textarea by using "aria-labelledby".

Developers can use the "legacy" property to continue using the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.`, this.el);
      this.hasLoggedDeprecationWarning = true;
    }
    const mode = getIonMode$2(this);
    const value = this.getValue();
    const labelId = this.inputId + "-lbl";
    const label = findItemLabel(this.el);
    if (label) {
      label.id = labelId;
    }
    return h$5(Host$1, { "aria-disabled": this.disabled ? "true" : null, class: createColorClasses$1(this.color, {
      [mode]: true,
      "legacy-textarea": true
    }) }, h$5("div", { class: "textarea-legacy-wrapper", ref: (el2) => this.textareaWrapper = el2 }, h$5("textarea", Object.assign({ class: "native-textarea", "aria-labelledby": label ? label.id : null, ref: (el2) => this.nativeInput = el2, autoCapitalize: this.autocapitalize, autoFocus: this.autofocus, enterKeyHint: this.enterkeyhint, inputMode: this.inputmode, disabled: this.disabled, maxLength: this.maxlength, minLength: this.minlength, name: this.name, placeholder: this.placeholder || "", readOnly: this.readonly, required: this.required, spellcheck: this.spellcheck, cols: this.cols, rows: this.rows, wrap: this.wrap, onInput: this.onInput, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, onKeyDown: this.onKeyDown }, this.inheritedAttributes), value)));
  }
  renderLabel() {
    const { label } = this;
    if (label === void 0) {
      return;
    }
    return h$5("div", { class: "label-text-wrapper" }, h$5("div", { class: "label-text" }, this.label));
  }
  /**
   * Renders the border container when fill="outline".
   */
  renderLabelContainer() {
    const mode = getIonMode$2(this);
    const hasOutlineFill = mode === "md" && this.fill === "outline";
    if (hasOutlineFill) {
      return [
        h$5("div", { class: "textarea-outline-container" }, h$5("div", { class: "textarea-outline-start" }), h$5("div", { class: "textarea-outline-notch" }, h$5("div", { class: "notch-spacer", "aria-hidden": "true" }, this.label)), h$5("div", { class: "textarea-outline-end" })),
        this.renderLabel()
      ];
    }
    return this.renderLabel();
  }
  /**
   * Renders the helper text or error text values
   */
  renderHintText() {
    const { helperText, errorText } = this;
    return [h$5("div", { class: "helper-text" }, helperText), h$5("div", { class: "error-text" }, errorText)];
  }
  renderCounter() {
    const { counter, maxlength, counterFormatter, value } = this;
    if (counter !== true || maxlength === void 0) {
      return;
    }
    return h$5("div", { class: "counter" }, getCounterText(value, maxlength, counterFormatter));
  }
  /**
   * Responsible for rendering helper text,
   * error text, and counter. This element should only
   * be rendered if hint text is set or counter is enabled.
   */
  renderBottomContent() {
    const { counter, helperText, errorText, maxlength } = this;
    const hasHintText = !!helperText || !!errorText;
    const hasCounter = counter === true && maxlength !== void 0;
    if (!hasHintText && !hasCounter) {
      return;
    }
    return h$5("div", { class: "textarea-bottom" }, this.renderHintText(), this.renderCounter());
  }
  renderTextarea() {
    const { inputId, disabled, fill, shape, labelPlacement } = this;
    const mode = getIonMode$2(this);
    const value = this.getValue();
    const inItem = hostContext("ion-item", this.el);
    const shouldRenderHighlight = mode === "md" && fill !== "outline" && !inItem;
    return h$5(Host$1, { class: createColorClasses$1(this.color, {
      [mode]: true,
      "has-value": this.hasValue(),
      "has-focus": this.hasFocus,
      [`textarea-fill-${fill}`]: fill !== void 0,
      [`textarea-shape-${shape}`]: shape !== void 0,
      [`textarea-label-placement-${labelPlacement}`]: true,
      "textarea-disabled": disabled
    }) }, h$5("label", { class: "textarea-wrapper" }, this.renderLabelContainer(), h$5("div", { class: "native-wrapper", ref: (el2) => this.textareaWrapper = el2 }, h$5("textarea", Object.assign({ class: "native-textarea", ref: (el2) => this.nativeInput = el2, id: inputId, disabled, autoCapitalize: this.autocapitalize, autoFocus: this.autofocus, enterKeyHint: this.enterkeyhint, inputMode: this.inputmode, minLength: this.minlength, maxLength: this.maxlength, name: this.name, placeholder: this.placeholder || "", readOnly: this.readonly, required: this.required, spellcheck: this.spellcheck, cols: this.cols, rows: this.rows, wrap: this.wrap, onInput: this.onInput, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, onKeyDown: this.onKeyDown }, this.inheritedAttributes), value)), shouldRenderHighlight && h$5("div", { class: "textarea-highlight" })), this.renderBottomContent());
  }
  render() {
    const { legacyFormController } = this;
    return legacyFormController.hasLegacyControl() ? this.renderLegacyTextarea() : this.renderTextarea();
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "debounce": ["debounceChanged"],
      "disabled": ["disabledChanged"],
      "value": ["valueChanged"]
    };
  }
  static get style() {
    return {
      ios: textareaIosCss,
      md: textareaMdCss
    };
  }
}, [34, "ion-textarea", {
  "color": [513],
  "autocapitalize": [1],
  "autofocus": [4],
  "clearOnEdit": [4, "clear-on-edit"],
  "debounce": [2],
  "disabled": [4],
  "fill": [1],
  "inputmode": [1],
  "enterkeyhint": [1],
  "maxlength": [2],
  "minlength": [2],
  "name": [1],
  "placeholder": [1],
  "readonly": [4],
  "required": [4],
  "spellcheck": [4],
  "cols": [2],
  "rows": [2],
  "wrap": [1],
  "autoGrow": [516, "auto-grow"],
  "value": [1025],
  "counter": [4],
  "counterFormatter": [16],
  "errorText": [1, "error-text"],
  "helperText": [1, "helper-text"],
  "label": [1],
  "labelPlacement": [1, "label-placement"],
  "legacy": [4],
  "shape": [1],
  "hasFocus": [32],
  "setFocus": [64],
  "getInputElement": [64]
}]);
let textareaIds = 0;
function defineCustomElement$1$d() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-textarea"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-textarea":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Textarea);
        }
        break;
    }
  });
}
const defineCustomElement$h = defineCustomElement$1$d;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const thumbnailCss = ":host{--size:48px;--border-radius:0;border-radius:var(--border-radius);display:block;width:var(--size);height:var(--size)}::slotted(ion-img),::slotted(img){border-radius:var(--border-radius);width:100%;height:100%;-o-object-fit:cover;object-fit:cover;overflow:hidden}";
const Thumbnail = /* @__PURE__ */ proxyCustomElement$1(class Thumbnail2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
  }
  render() {
    return h$5(Host$1, { class: getIonMode$2(this) }, h$5("slot", null));
  }
  static get style() {
    return thumbnailCss;
  }
}, [1, "ion-thumbnail"]);
function defineCustomElement$1$c() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-thumbnail"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-thumbnail":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Thumbnail);
        }
        break;
    }
  });
}
const defineCustomElement$g = defineCustomElement$1$c;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const titleIosCss = ":host{--color:initial;display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}.toolbar-title{display:block;width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;pointer-events:auto}:host(.title-small) .toolbar-title{white-space:normal}:host{top:0;-webkit-padding-start:90px;padding-inline-start:90px;-webkit-padding-end:90px;padding-inline-end:90px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);position:absolute;width:100%;height:100%;-webkit-transform:translateZ(0);transform:translateZ(0);font-size:17px;font-weight:600;text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}@supports (inset-inline-start: 0){:host{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host{left:0}:host-context([dir=rtl]){left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host:dir(rtl){left:unset;right:unset;right:0}}}:host(.title-small){-webkit-padding-start:9px;padding-inline-start:9px;-webkit-padding-end:9px;padding-inline-end:9px;padding-top:6px;padding-bottom:16px;position:relative;font-size:13px;font-weight:normal}:host(.title-large){-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:0;padding-bottom:0;-webkit-transform-origin:left center;transform-origin:left center;bottom:0;-ms-flex-align:end;align-items:flex-end;min-width:100%;padding-bottom:6px;font-size:34px;font-weight:700;text-align:start}:host(.title-large.title-rtl){-webkit-transform-origin:right center;transform-origin:right center}:host(.title-large.ion-cloned-element){--color:var(--ion-text-color, #000)}:host(.title-large) .toolbar-title{-webkit-transform-origin:inherit;transform-origin:inherit}:host-context([dir=rtl]):host(.title-large) .toolbar-title,:host-context([dir=rtl]).title-large .toolbar-title{-webkit-transform-origin:calc(100% - inherit);transform-origin:calc(100% - inherit)}@supports selector(:dir(rtl)){:host(.title-large) .toolbar-title:dir(rtl){-webkit-transform-origin:calc(100% - inherit);transform-origin:calc(100% - inherit)}}";
const titleMdCss = ":host{--color:initial;display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}.toolbar-title{display:block;width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;pointer-events:auto}:host(.title-small) .toolbar-title{white-space:normal}:host{-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:20px;padding-inline-end:20px;padding-top:0;padding-bottom:0;font-size:20px;font-weight:500;letter-spacing:0.0125em}:host(.title-small){width:100%;height:100%;font-size:15px;font-weight:normal}";
const ToolbarTitle = /* @__PURE__ */ proxyCustomElement$1(class ToolbarTitle2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.color = void 0;
    this.size = void 0;
  }
  sizeChanged() {
    this.emitStyle();
  }
  connectedCallback() {
    this.emitStyle();
  }
  emitStyle() {
    const size = this.getSize();
    this.ionStyle.emit({
      [`title-${size}`]: true
    });
  }
  getSize() {
    return this.size !== void 0 ? this.size : "default";
  }
  render() {
    const mode = getIonMode$2(this);
    const size = this.getSize();
    return h$5(Host$1, { class: createColorClasses$1(this.color, {
      [mode]: true,
      [`title-${size}`]: true,
      "title-rtl": document.dir === "rtl"
    }) }, h$5("div", { class: "toolbar-title" }, h$5("slot", null)));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "size": ["sizeChanged"]
    };
  }
  static get style() {
    return {
      ios: titleIosCss,
      md: titleMdCss
    };
  }
}, [33, "ion-title", {
  "color": [513],
  "size": [1]
}]);
function defineCustomElement$1$b() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-title"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-title":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ToolbarTitle);
        }
        break;
    }
  });
}
const defineCustomElement$f = defineCustomElement$1$b;
const toggleIosCss = ":host{-webkit-box-sizing:content-box !important;box-sizing:content-box !important;display:inline-block;position:relative;max-width:100%;outline:none;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.in-item:not(.legacy-toggle)){width:100%;height:100%}:host([slot=start]:not(.legacy-toggle)),:host([slot=end]:not(.legacy-toggle)){width:auto}:host(.legacy-toggle){contain:content;-ms-touch-action:none;touch-action:none}:host(.ion-focused) input{border:2px solid #5e9ed6}:host(.toggle-disabled){pointer-events:none}:host(.legacy-toggle) label{top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;opacity:0;pointer-events:none}@supports (inset-inline-start: 0){:host(.legacy-toggle) label{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host(.legacy-toggle) label{left:0}:host-context([dir=rtl]):host(.legacy-toggle) label,:host-context([dir=rtl]).legacy-toggle label{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(.legacy-toggle) label:dir(rtl){left:unset;right:unset;right:0}}}:host(.legacy-toggle) label::-moz-focus-inner{border:0}input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}.toggle-wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;cursor:inherit}.label-text-wrapper{pointer-events:none;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.label-text-wrapper-hidden{display:none}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}:host(.toggle-justify-space-between) .toggle-wrapper{-ms-flex-pack:justify;justify-content:space-between}:host(.toggle-justify-start) .toggle-wrapper{-ms-flex-pack:start;justify-content:start}:host(.toggle-justify-end) .toggle-wrapper{-ms-flex-pack:end;justify-content:end}:host(.toggle-label-placement-start) .toggle-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.toggle-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.toggle-label-placement-end) .toggle-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.toggle-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}:host(.toggle-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.toggle-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.toggle-icon-wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;height:100%;-webkit-transition:var(--handle-transition);transition:var(--handle-transition);will-change:transform}.toggle-icon{border-radius:var(--border-radius);display:block;position:relative;width:100%;height:100%;background:var(--track-background);overflow:inherit}:host(.toggle-checked) .toggle-icon{background:var(--track-background-checked)}.toggle-inner{border-radius:var(--handle-border-radius);position:absolute;left:var(--handle-spacing);width:var(--handle-width);height:var(--handle-height);max-height:var(--handle-max-height);-webkit-transition:var(--handle-transition);transition:var(--handle-transition);background:var(--handle-background);-webkit-box-shadow:var(--handle-box-shadow);box-shadow:var(--handle-box-shadow);contain:strict}:host(.toggle-ltr) .toggle-inner{left:var(--handle-spacing)}:host(.toggle-rtl) .toggle-inner{right:var(--handle-spacing)}:host(.toggle-ltr.toggle-checked) .toggle-icon-wrapper{-webkit-transform:translate3d(calc(100% - var(--handle-width)), 0, 0);transform:translate3d(calc(100% - var(--handle-width)), 0, 0)}:host(.toggle-rtl.toggle-checked) .toggle-icon-wrapper{-webkit-transform:translate3d(calc(-100% + var(--handle-width)), 0, 0);transform:translate3d(calc(-100% + var(--handle-width)), 0, 0)}:host(.toggle-checked) .toggle-inner{background:var(--handle-background-checked)}:host(.toggle-ltr.toggle-checked) .toggle-inner{-webkit-transform:translate3d(calc(var(--handle-spacing) * -2), 0, 0);transform:translate3d(calc(var(--handle-spacing) * -2), 0, 0)}:host(.toggle-rtl.toggle-checked) .toggle-inner{-webkit-transform:translate3d(calc(var(--handle-spacing) * 2), 0, 0);transform:translate3d(calc(var(--handle-spacing) * 2), 0, 0)}:host{--track-background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.088);--track-background-checked:var(--ion-color-primary, #3880ff);--border-radius:16px;--handle-background:#ffffff;--handle-background-checked:#ffffff;--handle-border-radius:25.5px;--handle-box-shadow:0 3px 12px rgba(0, 0, 0, 0.16), 0 3px 1px rgba(0, 0, 0, 0.1);--handle-height:calc(32px - (2px * 2));--handle-max-height:calc(100% - var(--handle-spacing) * 2);--handle-width:calc(32px - (2px * 2));--handle-spacing:2px;--handle-transition:transform 300ms, width 120ms ease-in-out 80ms, left 110ms ease-in-out 80ms, right 110ms ease-in-out 80ms}:host(.legacy-toggle){width:51px;height:32px;contain:strict;overflow:hidden}.native-wrapper .toggle-icon{width:51px;height:32px;overflow:hidden}:host(.ion-color.toggle-checked) .toggle-icon{background:var(--ion-color-base)}:host(.toggle-activated) .toggle-switch-icon{opacity:0}.toggle-icon{-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);-webkit-transition:background-color 300ms;transition:background-color 300ms}.toggle-inner{will-change:transform}.toggle-switch-icon{position:absolute;top:50%;width:11px;height:11px;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-transition:opacity 300ms, color 300ms;transition:opacity 300ms, color 300ms}.toggle-switch-icon{position:absolute;color:var(--ion-color-dark)}:host(.toggle-ltr) .toggle-switch-icon{right:6px}:host(.toggle-rtl) .toggle-switch-icon{right:initial;left:6px;}:host(.toggle-checked) .toggle-switch-icon.toggle-switch-icon-checked{color:var(--ion-color-contrast, #fff)}:host(.toggle-checked) .toggle-switch-icon:not(.toggle-switch-icon-checked){opacity:0}.toggle-switch-icon-checked{position:absolute;width:15px;height:15px;-webkit-transform:translateY(-50%) rotate(90deg);transform:translateY(-50%) rotate(90deg)}:host(.toggle-ltr) .toggle-switch-icon-checked{right:initial;left:4px;}:host(.toggle-rtl) .toggle-switch-icon-checked{right:4px}:host(.toggle-activated) .toggle-icon::before,:host(.toggle-checked) .toggle-icon::before{-webkit-transform:scale3d(0, 0, 0);transform:scale3d(0, 0, 0)}:host(.toggle-activated.toggle-checked) .toggle-inner::before{-webkit-transform:scale3d(0, 0, 0);transform:scale3d(0, 0, 0)}:host(.toggle-activated) .toggle-inner{width:calc(var(--handle-width) + 6px)}:host(.toggle-ltr.toggle-activated.toggle-checked) .toggle-icon-wrapper{-webkit-transform:translate3d(calc(100% - var(--handle-width) - 6px), 0, 0);transform:translate3d(calc(100% - var(--handle-width) - 6px), 0, 0)}:host(.toggle-rtl.toggle-activated.toggle-checked) .toggle-icon-wrapper{-webkit-transform:translate3d(calc(-100% + var(--handle-width) + 6px), 0, 0);transform:translate3d(calc(-100% + var(--handle-width) + 6px), 0, 0)}:host(.toggle-disabled){opacity:0.3}:host(.in-item.legacy-toggle){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:0;padding-inline-end:0;padding-top:6px;padding-bottom:5px}:host(.in-item.legacy-toggle[slot=start]){-webkit-padding-start:0;padding-inline-start:0;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:6px;padding-bottom:5px}";
const toggleMdCss = ":host{-webkit-box-sizing:content-box !important;box-sizing:content-box !important;display:inline-block;position:relative;max-width:100%;outline:none;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:2}:host(.in-item:not(.legacy-toggle)){width:100%;height:100%}:host([slot=start]:not(.legacy-toggle)),:host([slot=end]:not(.legacy-toggle)){width:auto}:host(.legacy-toggle){contain:content;-ms-touch-action:none;touch-action:none}:host(.ion-focused) input{border:2px solid #5e9ed6}:host(.toggle-disabled){pointer-events:none}:host(.legacy-toggle) label{top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;opacity:0;pointer-events:none}@supports (inset-inline-start: 0){:host(.legacy-toggle) label{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host(.legacy-toggle) label{left:0}:host-context([dir=rtl]):host(.legacy-toggle) label,:host-context([dir=rtl]).legacy-toggle label{left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host(.legacy-toggle) label:dir(rtl){left:unset;right:unset;right:0}}}:host(.legacy-toggle) label::-moz-focus-inner{border:0}input{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}.toggle-wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;height:inherit;-webkit-transition:background-color 15ms linear;transition:background-color 15ms linear;cursor:inherit}.label-text-wrapper{pointer-events:none;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.label-text-wrapper-hidden{display:none}.native-wrapper{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}:host(.toggle-justify-space-between) .toggle-wrapper{-ms-flex-pack:justify;justify-content:space-between}:host(.toggle-justify-start) .toggle-wrapper{-ms-flex-pack:start;justify-content:start}:host(.toggle-justify-end) .toggle-wrapper{-ms-flex-pack:end;justify-content:end}:host(.toggle-label-placement-start) .toggle-wrapper{-ms-flex-direction:row;flex-direction:row}:host(.toggle-label-placement-start) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.toggle-label-placement-end) .toggle-wrapper{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.toggle-label-placement-end) .label-text-wrapper{-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}:host(.toggle-label-placement-fixed) .label-text-wrapper{-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:0;margin-bottom:0}:host(.toggle-label-placement-fixed) .label-text-wrapper{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.toggle-icon-wrapper{display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:center;align-items:center;width:100%;height:100%;-webkit-transition:var(--handle-transition);transition:var(--handle-transition);will-change:transform}.toggle-icon{border-radius:var(--border-radius);display:block;position:relative;width:100%;height:100%;background:var(--track-background);overflow:inherit}:host(.toggle-checked) .toggle-icon{background:var(--track-background-checked)}.toggle-inner{border-radius:var(--handle-border-radius);position:absolute;left:var(--handle-spacing);width:var(--handle-width);height:var(--handle-height);max-height:var(--handle-max-height);-webkit-transition:var(--handle-transition);transition:var(--handle-transition);background:var(--handle-background);-webkit-box-shadow:var(--handle-box-shadow);box-shadow:var(--handle-box-shadow);contain:strict}:host(.toggle-ltr) .toggle-inner{left:var(--handle-spacing)}:host(.toggle-rtl) .toggle-inner{right:var(--handle-spacing)}:host(.toggle-ltr.toggle-checked) .toggle-icon-wrapper{-webkit-transform:translate3d(calc(100% - var(--handle-width)), 0, 0);transform:translate3d(calc(100% - var(--handle-width)), 0, 0)}:host(.toggle-rtl.toggle-checked) .toggle-icon-wrapper{-webkit-transform:translate3d(calc(-100% + var(--handle-width)), 0, 0);transform:translate3d(calc(-100% + var(--handle-width)), 0, 0)}:host(.toggle-checked) .toggle-inner{background:var(--handle-background-checked)}:host(.toggle-ltr.toggle-checked) .toggle-inner{-webkit-transform:translate3d(calc(var(--handle-spacing) * -2), 0, 0);transform:translate3d(calc(var(--handle-spacing) * -2), 0, 0)}:host(.toggle-rtl.toggle-checked) .toggle-inner{-webkit-transform:translate3d(calc(var(--handle-spacing) * 2), 0, 0);transform:translate3d(calc(var(--handle-spacing) * 2), 0, 0)}:host{--track-background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.39);--track-background-checked:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.5);--border-radius:14px;--handle-background:#ffffff;--handle-background-checked:var(--ion-color-primary, #3880ff);--handle-border-radius:50%;--handle-box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);--handle-width:20px;--handle-height:20px;--handle-max-height:calc(100% + 6px);--handle-spacing:0;--handle-transition:transform 160ms cubic-bezier(0.4, 0, 0.2, 1), background-color 160ms cubic-bezier(0.4, 0, 0.2, 1)}:host(.legacy-toggle){-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px;padding-top:12px;padding-bottom:12px;width:36px;height:14px;contain:strict}.native-wrapper .toggle-icon{width:36px;height:14px}:host(.ion-color.toggle-checked) .toggle-icon{background:rgba(var(--ion-color-base-rgb), 0.5)}:host(.ion-color.toggle-checked) .toggle-inner{background:var(--ion-color-base)}:host(.toggle-checked) .toggle-inner{color:var(--ion-color-contrast, #fff)}.toggle-icon{-webkit-transition:background-color 160ms;transition:background-color 160ms}.toggle-inner{will-change:background-color, transform;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;color:#000}.toggle-inner .toggle-switch-icon{-webkit-padding-start:1px;padding-inline-start:1px;-webkit-padding-end:1px;padding-inline-end:1px;padding-top:1px;padding-bottom:1px;width:100%;height:100%}:host(.toggle-disabled){opacity:0.3}:host(.in-item.legacy-toggle){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:0;padding-inline-end:0;padding-top:12px;padding-bottom:12px;cursor:pointer}:host(.in-item.legacy-toggle[slot=start]){-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:18px;padding-inline-end:18px;padding-top:12px;padding-bottom:12px}";
const Toggle = /* @__PURE__ */ proxyCustomElement$1(class Toggle2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionChange = createEvent(this, "ionChange", 7);
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.ionStyle = createEvent(this, "ionStyle", 7);
    this.inputId = `ion-tg-${toggleIds++}`;
    this.lastDrag = 0;
    this.inheritedAttributes = {};
    this.didLoad = false;
    this.hasLoggedDeprecationWarning = false;
    this.setupGesture = async () => {
      const { toggleTrack } = this;
      if (toggleTrack) {
        this.gesture = (await __vitePreload(() => Promise.resolve().then(() => index2), true ? void 0 : void 0)).createGesture({
          el: toggleTrack,
          gestureName: "toggle",
          gesturePriority: 100,
          threshold: 5,
          passive: false,
          onStart: () => this.onStart(),
          onMove: (ev) => this.onMove(ev),
          onEnd: (ev) => this.onEnd(ev)
        });
        this.disabledChanged();
      }
    };
    this.onClick = (ev) => {
      ev.preventDefault();
      if (this.lastDrag + 300 < Date.now()) {
        this.toggleChecked();
      }
    };
    this.onFocus = () => {
      this.ionFocus.emit();
    };
    this.onBlur = () => {
      this.ionBlur.emit();
    };
    this.getSwitchLabelIcon = (mode, checked) => {
      if (mode === "md") {
        return checked ? checkmarkOutline : removeOutline;
      }
      return checked ? removeOutline : ellipseOutline$1;
    };
    this.activated = false;
    this.color = void 0;
    this.name = this.inputId;
    this.checked = false;
    this.disabled = false;
    this.value = "on";
    this.enableOnOffLabels = config$1.get("toggleOnOffLabels");
    this.labelPlacement = "start";
    this.legacy = void 0;
    this.justify = "space-between";
  }
  disabledChanged() {
    this.emitStyle();
    if (this.gesture) {
      this.gesture.enable(!this.disabled);
    }
  }
  toggleChecked() {
    const { checked, value } = this;
    const isNowChecked = !checked;
    this.checked = isNowChecked;
    this.ionChange.emit({
      checked: isNowChecked,
      value
    });
  }
  async connectedCallback() {
    this.legacyFormController = createLegacyFormController(this.el);
    if (this.didLoad) {
      this.setupGesture();
    }
  }
  componentDidLoad() {
    this.setupGesture();
    this.didLoad = true;
  }
  disconnectedCallback() {
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
  }
  componentWillLoad() {
    this.emitStyle();
    if (!this.legacyFormController.hasLegacyControl()) {
      this.inheritedAttributes = Object.assign({}, inheritAriaAttributes(this.el));
    }
  }
  emitStyle() {
    if (this.legacyFormController.hasLegacyControl()) {
      this.ionStyle.emit({
        "interactive-disabled": this.disabled
      });
    }
  }
  onStart() {
    this.activated = true;
    this.setFocus();
  }
  onMove(detail) {
    if (shouldToggle(isRTL$1(this.el), this.checked, detail.deltaX, -10)) {
      this.toggleChecked();
      hapticSelection();
    }
  }
  onEnd(ev) {
    this.activated = false;
    this.lastDrag = Date.now();
    ev.event.preventDefault();
    ev.event.stopImmediatePropagation();
  }
  getValue() {
    return this.value || "";
  }
  setFocus() {
    if (this.focusEl) {
      this.focusEl.focus();
    }
  }
  renderOnOffSwitchLabels(mode, checked) {
    const icon = this.getSwitchLabelIcon(mode, checked);
    return h$5("ion-icon", { class: {
      "toggle-switch-icon": true,
      "toggle-switch-icon-checked": checked
    }, icon, "aria-hidden": "true" });
  }
  renderToggleControl() {
    const mode = getIonMode$2(this);
    const { enableOnOffLabels, checked } = this;
    return h$5("div", { class: "toggle-icon", part: "track", ref: (el2) => this.toggleTrack = el2 }, enableOnOffLabels && mode === "ios" && [this.renderOnOffSwitchLabels(mode, true), this.renderOnOffSwitchLabels(mode, false)], h$5("div", { class: "toggle-icon-wrapper" }, h$5("div", { class: "toggle-inner", part: "handle" }, enableOnOffLabels && mode === "md" && this.renderOnOffSwitchLabels(mode, checked))));
  }
  get hasLabel() {
    return this.el.textContent !== "";
  }
  render() {
    const { legacyFormController } = this;
    return legacyFormController.hasLegacyControl() ? this.renderLegacyToggle() : this.renderToggle();
  }
  renderToggle() {
    const { activated, color: color2, checked, disabled, el: el2, justify, labelPlacement, inputId, name } = this;
    const mode = getIonMode$2(this);
    const value = this.getValue();
    const rtl = isRTL$1(el2) ? "rtl" : "ltr";
    renderHiddenInput(true, el2, name, checked ? value : "", disabled);
    return h$5(Host$1, { onClick: this.onClick, class: createColorClasses$1(color2, {
      [mode]: true,
      "in-item": hostContext("ion-item", el2),
      "toggle-activated": activated,
      "toggle-checked": checked,
      "toggle-disabled": disabled,
      [`toggle-justify-${justify}`]: true,
      [`toggle-label-placement-${labelPlacement}`]: true,
      [`toggle-${rtl}`]: true
    }) }, h$5("label", { class: "toggle-wrapper" }, h$5("input", Object.assign({ type: "checkbox", role: "switch", "aria-checked": `${checked}`, checked, disabled, id: inputId, onFocus: () => this.onFocus(), onBlur: () => this.onBlur(), ref: (focusEl) => this.focusEl = focusEl }, this.inheritedAttributes)), h$5("div", { class: {
      "label-text-wrapper": true,
      "label-text-wrapper-hidden": !this.hasLabel
    } }, h$5("slot", null)), h$5("div", { class: "native-wrapper" }, this.renderToggleControl())));
  }
  renderLegacyToggle() {
    if (!this.hasLoggedDeprecationWarning) {
      printIonWarning(`ion-toggle now requires providing a label with either the default slot or the "aria-label" attribute. To migrate, remove any usage of "ion-label" and pass the label text to either the component or the "aria-label" attribute.

Example: <ion-toggle>Email</ion-toggle>
Example with aria-label: <ion-toggle aria-label="Email"></ion-toggle>

Developers can use the "legacy" property to continue using the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.`, this.el);
      if (this.legacy) {
        printIonWarning(`ion-toggle is being used with the "legacy" property enabled which will forcibly enable the legacy form markup. This property will be removed in an upcoming major release of Ionic where this form control will use the modern form markup.

Developers can dismiss this warning by removing their usage of the "legacy" property and using the new toggle syntax.`, this.el);
      }
      this.hasLoggedDeprecationWarning = true;
    }
    const { activated, color: color2, checked, disabled, el: el2, inputId, name } = this;
    const mode = getIonMode$2(this);
    const { label, labelId, labelText } = getAriaLabel(el2, inputId);
    const value = this.getValue();
    const rtl = isRTL$1(el2) ? "rtl" : "ltr";
    renderHiddenInput(true, el2, name, checked ? value : "", disabled);
    return h$5(Host$1, { onClick: this.onClick, "aria-labelledby": label ? labelId : null, "aria-checked": `${checked}`, "aria-hidden": disabled ? "true" : null, role: "switch", class: createColorClasses$1(color2, {
      [mode]: true,
      "in-item": hostContext("ion-item", el2),
      "toggle-activated": activated,
      "toggle-checked": checked,
      "toggle-disabled": disabled,
      "legacy-toggle": true,
      interactive: true,
      [`toggle-${rtl}`]: true
    }) }, this.renderToggleControl(), h$5("label", { htmlFor: inputId }, labelText), h$5("input", { type: "checkbox", role: "switch", "aria-checked": `${checked}`, disabled, id: inputId, onFocus: () => this.onFocus(), onBlur: () => this.onBlur(), ref: (focusEl) => this.focusEl = focusEl }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "disabled": ["disabledChanged"]
    };
  }
  static get style() {
    return {
      ios: toggleIosCss,
      md: toggleMdCss
    };
  }
}, [33, "ion-toggle", {
  "color": [513],
  "name": [1],
  "checked": [1028],
  "disabled": [4],
  "value": [1],
  "enableOnOffLabels": [4, "enable-on-off-labels"],
  "labelPlacement": [1, "label-placement"],
  "legacy": [4],
  "justify": [1],
  "activated": [32]
}]);
const shouldToggle = (rtl, checked, deltaX, margin) => {
  if (checked) {
    return !rtl && margin > deltaX || rtl && -margin < deltaX;
  } else {
    return !rtl && -margin < deltaX || rtl && margin > deltaX;
  }
};
let toggleIds = 0;
function defineCustomElement$1$a() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-toggle", "ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-toggle":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Toggle);
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$1b();
        }
        break;
    }
  });
}
const defineCustomElement$e = defineCustomElement$1$a;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const toolbarIosCss = ":host{--border-width:0;--border-style:solid;--opacity:1;--opacity-scale:1;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right);display:block;position:relative;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){color:var(--ion-color-contrast)}:host(.ion-color) .toolbar-background{background:var(--ion-color-base)}.toolbar-container{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:var(--min-height);contain:content;overflow:hidden;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}.toolbar-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;opacity:calc(var(--opacity) * var(--opacity-scale));z-index:-1;pointer-events:none}::slotted(ion-progress-bar){left:0;right:0;bottom:0;position:absolute}:host{--background:var(--ion-toolbar-background, var(--ion-color-step-50, #f7f7f7));--color:var(--ion-toolbar-color, var(--ion-text-color, #000));--border-color:var(--ion-toolbar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.2))));--padding-top:3px;--padding-bottom:3px;--padding-start:4px;--padding-end:4px;--min-height:44px}.toolbar-content{-ms-flex:1;flex:1;-ms-flex-order:4;order:4;min-width:0}:host(.toolbar-segment) .toolbar-content{display:-ms-inline-flexbox;display:inline-flex}:host(.toolbar-searchbar) .toolbar-container{padding-top:0;padding-bottom:0}:host(.toolbar-searchbar) ::slotted(*){-ms-flex-item-align:start;align-self:start}:host(.toolbar-searchbar) ::slotted(ion-chip){margin-top:3px}:host(.toolbar-searchbar) ::slotted(ion-back-button){height:38px}::slotted(ion-buttons){min-height:38px}::slotted([slot=start]){-ms-flex-order:2;order:2}::slotted([slot=secondary]){-ms-flex-order:3;order:3}::slotted([slot=primary]){-ms-flex-order:5;order:5;text-align:end}::slotted([slot=end]){-ms-flex-order:6;order:6;text-align:end}:host(.toolbar-title-large) .toolbar-container{-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:start;align-items:flex-start}:host(.toolbar-title-large) .toolbar-content ion-title{-ms-flex:1;flex:1;-ms-flex-order:8;order:8;min-width:100%}";
const toolbarMdCss = ":host{--border-width:0;--border-style:solid;--opacity:1;--opacity-scale:1;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right);display:block;position:relative;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){color:var(--ion-color-contrast)}:host(.ion-color) .toolbar-background{background:var(--ion-color-base)}.toolbar-container{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:var(--min-height);contain:content;overflow:hidden;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}.toolbar-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;opacity:calc(var(--opacity) * var(--opacity-scale));z-index:-1;pointer-events:none}::slotted(ion-progress-bar){left:0;right:0;bottom:0;position:absolute}:host{--background:var(--ion-toolbar-background, var(--ion-background-color, #fff));--color:var(--ion-toolbar-color, var(--ion-text-color, #424242));--border-color:var(--ion-toolbar-border-color, var(--ion-border-color, var(--ion-color-step-150, #c1c4cd)));--padding-top:0;--padding-bottom:0;--padding-start:0;--padding-end:0;--min-height:56px}.toolbar-content{-ms-flex:1;flex:1;-ms-flex-order:3;order:3;min-width:0;max-width:100%}::slotted(.buttons-first-slot){-webkit-margin-start:4px;margin-inline-start:4px}::slotted(.buttons-last-slot){-webkit-margin-end:4px;margin-inline-end:4px}::slotted([slot=start]){-ms-flex-order:2;order:2}::slotted([slot=secondary]){-ms-flex-order:4;order:4}::slotted([slot=primary]){-ms-flex-order:5;order:5;text-align:end}::slotted([slot=end]){-ms-flex-order:6;order:6;text-align:end}";
const Toolbar = /* @__PURE__ */ proxyCustomElement$1(class Toolbar2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.childrenStyles = /* @__PURE__ */ new Map();
    this.color = void 0;
  }
  componentWillLoad() {
    const buttons = Array.from(this.el.querySelectorAll("ion-buttons"));
    const firstButtons = buttons.find((button) => {
      return button.slot === "start";
    });
    if (firstButtons) {
      firstButtons.classList.add("buttons-first-slot");
    }
    const buttonsReversed = buttons.reverse();
    const lastButtons = buttonsReversed.find((button) => button.slot === "end") || buttonsReversed.find((button) => button.slot === "primary") || buttonsReversed.find((button) => button.slot === "secondary");
    if (lastButtons) {
      lastButtons.classList.add("buttons-last-slot");
    }
  }
  childrenStyle(ev) {
    ev.stopPropagation();
    const tagName = ev.target.tagName;
    const updatedStyles = ev.detail;
    const newStyles = {};
    const childStyles = this.childrenStyles.get(tagName) || {};
    let hasStyleChange = false;
    Object.keys(updatedStyles).forEach((key) => {
      const childKey = `toolbar-${key}`;
      const newValue = updatedStyles[key];
      if (newValue !== childStyles[childKey]) {
        hasStyleChange = true;
      }
      if (newValue) {
        newStyles[childKey] = true;
      }
    });
    if (hasStyleChange) {
      this.childrenStyles.set(tagName, newStyles);
      forceUpdate(this);
    }
  }
  render() {
    const mode = getIonMode$2(this);
    const childStyles = {};
    this.childrenStyles.forEach((value) => {
      Object.assign(childStyles, value);
    });
    return h$5(Host$1, { class: Object.assign(Object.assign({}, childStyles), createColorClasses$1(this.color, {
      [mode]: true,
      "in-toolbar": hostContext("ion-toolbar", this.el)
    })) }, h$5("div", { class: "toolbar-background" }), h$5("div", { class: "toolbar-container" }, h$5("slot", { name: "start" }), h$5("slot", { name: "secondary" }), h$5("div", { class: "toolbar-content" }, h$5("slot", null)), h$5("slot", { name: "primary" }), h$5("slot", { name: "end" })));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: toolbarIosCss,
      md: toolbarMdCss
    };
  }
}, [33, "ion-toolbar", {
  "color": [513]
}, [[0, "ionStyle", "childrenStyle"]]]);
function defineCustomElement$1$9() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-toolbar"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-toolbar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Toolbar);
        }
        break;
    }
  });
}
const defineCustomElement$d = defineCustomElement$1$9;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const IonButton$1 = Button;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const cardIosCss = ":host{--ion-safe-area-left:0px;--ion-safe-area-right:0px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;overflow:hidden}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.card-disabled){cursor:default;opacity:0.3;pointer-events:none}.card-native{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:inherit}.card-native::-moz-focus-inner{border:0}button,a{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}ion-ripple-effect{color:var(--ripple-color)}:host{--background:var(--ion-card-background, var(--ion-item-background, var(--ion-background-color, #fff)));--color:var(--ion-card-color, var(--ion-item-color, var(--ion-color-step-600, #666666)));-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px;margin-top:24px;margin-bottom:24px;border-radius:8px;-webkit-transition:-webkit-transform 500ms cubic-bezier(0.12, 0.72, 0.29, 1);transition:-webkit-transform 500ms cubic-bezier(0.12, 0.72, 0.29, 1);transition:transform 500ms cubic-bezier(0.12, 0.72, 0.29, 1);transition:transform 500ms cubic-bezier(0.12, 0.72, 0.29, 1), -webkit-transform 500ms cubic-bezier(0.12, 0.72, 0.29, 1);font-size:14px;-webkit-box-shadow:0 4px 16px rgba(0, 0, 0, 0.12);box-shadow:0 4px 16px rgba(0, 0, 0, 0.12)}:host(.ion-activated){-webkit-transform:scale3d(0.97, 0.97, 1);transform:scale3d(0.97, 0.97, 1)}";
const cardMdCss = ":host{--ion-safe-area-left:0px;--ion-safe-area-right:0px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;overflow:hidden}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.card-disabled){cursor:default;opacity:0.3;pointer-events:none}.card-native{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:inherit}.card-native::-moz-focus-inner{border:0}button,a{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}ion-ripple-effect{color:var(--ripple-color)}:host{--background:var(--ion-card-background, var(--ion-item-background, var(--ion-background-color, #fff)));--color:var(--ion-card-color, var(--ion-item-color, var(--ion-color-step-550, #737373)));-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:10px;margin-inline-end:10px;margin-top:10px;margin-bottom:10px;border-radius:4px;font-size:14px;-webkit-box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)}";
const Card = /* @__PURE__ */ proxyCustomElement$1(class Card2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.inheritedAriaAttributes = {};
    this.color = void 0;
    this.button = false;
    this.type = "button";
    this.disabled = false;
    this.download = void 0;
    this.href = void 0;
    this.rel = void 0;
    this.routerDirection = "forward";
    this.routerAnimation = void 0;
    this.target = void 0;
  }
  componentWillLoad() {
    this.inheritedAriaAttributes = inheritAttributes$2(this.el, ["aria-label"]);
  }
  isClickable() {
    return this.href !== void 0 || this.button;
  }
  renderCard(mode) {
    const clickable = this.isClickable();
    if (!clickable) {
      return [h$5("slot", null)];
    }
    const { href, routerAnimation, routerDirection, inheritedAriaAttributes } = this;
    const TagType = clickable ? href === void 0 ? "button" : "a" : "div";
    const attrs = TagType === "button" ? { type: this.type } : {
      download: this.download,
      href: this.href,
      rel: this.rel,
      target: this.target
    };
    return h$5(TagType, Object.assign({}, attrs, inheritedAriaAttributes, { class: "card-native", part: "native", disabled: this.disabled, onClick: (ev) => openURL(href, ev, routerDirection, routerAnimation) }), h$5("slot", null), clickable && mode === "md" && h$5("ion-ripple-effect", null));
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: createColorClasses$1(this.color, {
      [mode]: true,
      "card-disabled": this.disabled,
      "ion-activatable": this.isClickable()
    }) }, this.renderCard(mode));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: cardIosCss,
      md: cardMdCss
    };
  }
}, [33, "ion-card", {
  "color": [513],
  "button": [4],
  "type": [1],
  "disabled": [4],
  "download": [1],
  "href": [1],
  "rel": [1],
  "routerDirection": [1, "router-direction"],
  "routerAnimation": [16],
  "target": [1]
}]);
const IonCard$1 = Card;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const fabButtonIosCss = ':host{--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--background-hover:var(--ion-color-primary-contrast, #fff);--background-hover-opacity:.08;--transition:background-color, opacity 100ms linear;--ripple-color:currentColor;--border-radius:50%;--border-width:0;--border-style:none;--border-color:initial;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:56px;height:56px;font-size:14px;text-align:center;text-overflow:ellipsis;text-transform:none;white-space:nowrap;-webkit-font-kerning:none;font-kerning:none}.button-native{border-radius:var(--border-radius);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;-webkit-transform:var(--transform);transform:var(--transform);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);background-clip:padding-box;color:var(--color);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:strict;cursor:pointer;overflow:hidden;z-index:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-icon){line-height:1}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{left:0;right:0;top:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;-webkit-transition:all ease-in-out 300ms;transition:all ease-in-out 300ms;-webkit-transition-property:opacity, -webkit-transform;transition-property:opacity, -webkit-transform;transition-property:transform, opacity;transition-property:transform, opacity, -webkit-transform;z-index:1}:host(.fab-button-disabled){cursor:default;opacity:0.5;pointer-events:none}@media (any-hover: hover){:host(:hover) .button-native{color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(.ion-activated) .button-native{color:var(--color-activated)}:host(.ion-activated) .button-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}::slotted(ion-icon){line-height:1}:host(.fab-button-small){-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:8px;margin-inline-end:8px;margin-top:8px;margin-bottom:8px;width:40px;height:40px}.close-icon{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:0;margin-bottom:0;left:0;right:0;top:0;position:absolute;height:100%;-webkit-transform:scale(0.4) rotateZ(-45deg);transform:scale(0.4) rotateZ(-45deg);-webkit-transition:all ease-in-out 300ms;transition:all ease-in-out 300ms;-webkit-transition-property:opacity, -webkit-transform;transition-property:opacity, -webkit-transform;transition-property:transform, opacity;transition-property:transform, opacity, -webkit-transform;font-size:var(--close-icon-font-size);opacity:0;z-index:1}:host(.fab-button-close-active) .close-icon{-webkit-transform:scale(1) rotateZ(0deg);transform:scale(1) rotateZ(0deg);opacity:1}:host(.fab-button-close-active) .button-inner{-webkit-transform:scale(0.4) rotateZ(45deg);transform:scale(0.4) rotateZ(45deg);opacity:0}ion-ripple-effect{color:var(--ripple-color)}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.fab-button-translucent) .button-native{-webkit-backdrop-filter:var(--backdrop-filter);backdrop-filter:var(--backdrop-filter)}}:host(.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host{--background:var(--ion-color-primary, #3880ff);--background-activated:var(--ion-color-primary-shade, #3171e0);--background-focused:var(--ion-color-primary-shade, #3171e0);--background-hover:var(--ion-color-primary-tint, #4c8dff);--background-activated-opacity:1;--background-focused-opacity:1;--background-hover-opacity:1;--color:var(--ion-color-primary-contrast, #fff);--box-shadow:0 4px 16px rgba(0, 0, 0, 0.12);--transition:0.2s transform cubic-bezier(0.25, 1.11, 0.78, 1.59);--close-icon-font-size:28px}:host(.ion-activated){--box-shadow:0 4px 16px rgba(0, 0, 0, 0.12);--transform:scale(1.1);--transition:0.2s transform ease-out}::slotted(ion-icon){font-size:28px}:host(.fab-button-in-list){--background:var(--ion-color-light, #f4f5f8);--background-activated:var(--ion-color-light-shade, #d7d8da);--background-focused:var(--background-activated);--background-hover:var(--ion-color-light-tint, #f5f6f9);--color:var(--ion-color-light-contrast, #000);--color-activated:var(--ion-color-light-contrast, #000);--color-focused:var(--color-activated);--transition:transform 200ms ease 10ms, opacity 200ms ease 10ms}:host(.fab-button-in-list) ::slotted(ion-icon){font-size:18px}:host(.ion-color.ion-focused) .button-native::after{background:var(--ion-color-shade)}:host(.ion-color.ion-focused) .button-native,:host(.ion-color.ion-activated) .button-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-focused) .button-native::after,:host(.ion-color.ion-activated) .button-native::after{background:var(--ion-color-shade)}@media (any-hover: hover){:host(.ion-color:hover) .button-native{color:var(--ion-color-contrast)}:host(.ion-color:hover) .button-native::after{background:var(--ion-color-tint)}}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.fab-button-translucent){--background:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.9);--background-hover:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.8);--background-focused:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.82);--backdrop-filter:saturate(180%) blur(20px)}:host(.fab-button-translucent-in-list){--background:rgba(var(--ion-color-light-rgb, 244, 245, 248), 0.9);--background-hover:rgba(var(--ion-color-light-rgb, 244, 245, 248), 0.8);--background-focused:rgba(var(--ion-color-light-rgb, 244, 245, 248), 0.82)}}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){@media (any-hover: hover){:host(.fab-button-translucent.ion-color:hover) .button-native{background:rgba(var(--ion-color-base-rgb), 0.8)}}:host(.ion-color.fab-button-translucent) .button-native{background:rgba(var(--ion-color-base-rgb), 0.9)}:host(.ion-color.ion-focused.fab-button-translucent) .button-native,:host(.ion-color.ion-activated.fab-button-translucent) .button-native{background:var(--ion-color-base)}}';
const fabButtonMdCss = ':host{--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--background-hover:var(--ion-color-primary-contrast, #fff);--background-hover-opacity:.08;--transition:background-color, opacity 100ms linear;--ripple-color:currentColor;--border-radius:50%;--border-width:0;--border-style:none;--border-color:initial;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:56px;height:56px;font-size:14px;text-align:center;text-overflow:ellipsis;text-transform:none;white-space:nowrap;-webkit-font-kerning:none;font-kerning:none}.button-native{border-radius:var(--border-radius);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;-webkit-transform:var(--transform);transform:var(--transform);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);background-clip:padding-box;color:var(--color);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:strict;cursor:pointer;overflow:hidden;z-index:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-icon){line-height:1}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{left:0;right:0;top:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;-webkit-transition:all ease-in-out 300ms;transition:all ease-in-out 300ms;-webkit-transition-property:opacity, -webkit-transform;transition-property:opacity, -webkit-transform;transition-property:transform, opacity;transition-property:transform, opacity, -webkit-transform;z-index:1}:host(.fab-button-disabled){cursor:default;opacity:0.5;pointer-events:none}@media (any-hover: hover){:host(:hover) .button-native{color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(.ion-activated) .button-native{color:var(--color-activated)}:host(.ion-activated) .button-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}::slotted(ion-icon){line-height:1}:host(.fab-button-small){-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:8px;margin-inline-end:8px;margin-top:8px;margin-bottom:8px;width:40px;height:40px}.close-icon{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:0;margin-bottom:0;left:0;right:0;top:0;position:absolute;height:100%;-webkit-transform:scale(0.4) rotateZ(-45deg);transform:scale(0.4) rotateZ(-45deg);-webkit-transition:all ease-in-out 300ms;transition:all ease-in-out 300ms;-webkit-transition-property:opacity, -webkit-transform;transition-property:opacity, -webkit-transform;transition-property:transform, opacity;transition-property:transform, opacity, -webkit-transform;font-size:var(--close-icon-font-size);opacity:0;z-index:1}:host(.fab-button-close-active) .close-icon{-webkit-transform:scale(1) rotateZ(0deg);transform:scale(1) rotateZ(0deg);opacity:1}:host(.fab-button-close-active) .button-inner{-webkit-transform:scale(0.4) rotateZ(45deg);transform:scale(0.4) rotateZ(45deg);opacity:0}ion-ripple-effect{color:var(--ripple-color)}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.fab-button-translucent) .button-native{-webkit-backdrop-filter:var(--backdrop-filter);backdrop-filter:var(--backdrop-filter)}}:host(.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host{--background:var(--ion-color-primary, #3880ff);--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor;--background-activated-opacity:0;--background-focused-opacity:.24;--background-hover-opacity:.08;--color:var(--ion-color-primary-contrast, #fff);--box-shadow:0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12);--transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1), background-color 280ms cubic-bezier(0.4, 0, 0.2, 1), color 280ms cubic-bezier(0.4, 0, 0.2, 1), opacity 15ms linear 30ms, transform 270ms cubic-bezier(0, 0, 0.2, 1) 0ms;--close-icon-font-size:24px}:host(.ion-activated){--box-shadow:0 7px 8px -4px rgba(0, 0, 0, 0.2), 0 12px 17px 2px rgba(0, 0, 0, 0.14), 0 5px 22px 4px rgba(0, 0, 0, 0.12)}::slotted(ion-icon){font-size:24px}:host(.fab-button-in-list){--color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54);--color-activated:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54);--color-focused:var(--color-activated);--background:var(--ion-color-light, #f4f5f8);--background-activated:transparent;--background-focused:var(--ion-color-light-shade, #d7d8da);--background-hover:var(--ion-color-light-tint, #f5f6f9)}:host(.fab-button-in-list) ::slotted(ion-icon){font-size:18px}:host(.ion-color.ion-focused) .button-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-focused) .button-native::after{background:var(--ion-color-contrast)}:host(.ion-color.ion-activated) .button-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-activated) .button-native::after{background:transparent}@media (any-hover: hover){:host(.ion-color:hover) .button-native{color:var(--ion-color-contrast)}:host(.ion-color:hover) .button-native::after{background:var(--ion-color-contrast)}}';
const FabButton = /* @__PURE__ */ proxyCustomElement$1(class FabButton2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionFocus = createEvent(this, "ionFocus", 7);
    this.ionBlur = createEvent(this, "ionBlur", 7);
    this.fab = null;
    this.inheritedAttributes = {};
    this.onFocus = () => {
      this.ionFocus.emit();
    };
    this.onBlur = () => {
      this.ionBlur.emit();
    };
    this.onClick = () => {
      const { fab } = this;
      if (!fab) {
        return;
      }
      fab.toggle();
    };
    this.color = void 0;
    this.activated = false;
    this.disabled = false;
    this.download = void 0;
    this.href = void 0;
    this.rel = void 0;
    this.routerDirection = "forward";
    this.routerAnimation = void 0;
    this.target = void 0;
    this.show = false;
    this.translucent = false;
    this.type = "button";
    this.size = void 0;
    this.closeIcon = close$1;
  }
  connectedCallback() {
    this.fab = this.el.closest("ion-fab");
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAriaAttributes(this.el);
  }
  render() {
    const { el: el2, disabled, color: color2, href, activated, show, translucent, size, inheritedAttributes } = this;
    const inList = hostContext("ion-fab-list", el2);
    const mode = getIonMode$2(this);
    const TagType = href === void 0 ? "button" : "a";
    const attrs = TagType === "button" ? { type: this.type } : {
      download: this.download,
      href,
      rel: this.rel,
      target: this.target
    };
    return h$5(Host$1, { onClick: this.onClick, "aria-disabled": disabled ? "true" : null, class: createColorClasses$1(color2, {
      [mode]: true,
      "fab-button-in-list": inList,
      "fab-button-translucent-in-list": inList && translucent,
      "fab-button-close-active": activated,
      "fab-button-show": show,
      "fab-button-disabled": disabled,
      "fab-button-translucent": translucent,
      "ion-activatable": true,
      "ion-focusable": true,
      [`fab-button-${size}`]: size !== void 0
    }) }, h$5(TagType, Object.assign({}, attrs, { class: "button-native", part: "native", disabled, onFocus: this.onFocus, onBlur: this.onBlur, onClick: (ev) => openURL(href, ev, this.routerDirection, this.routerAnimation) }, inheritedAttributes), h$5("ion-icon", { "aria-hidden": "true", icon: this.closeIcon, part: "close-icon", class: "close-icon", lazy: false }), h$5("span", { class: "button-inner" }, h$5("slot", null)), mode === "md" && h$5("ion-ripple-effect", null)));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: fabButtonIosCss,
      md: fabButtonMdCss
    };
  }
}, [33, "ion-fab-button", {
  "color": [513],
  "activated": [4],
  "disabled": [4],
  "download": [1],
  "href": [1],
  "rel": [1],
  "routerDirection": [1, "router-direction"],
  "routerAnimation": [16],
  "target": [1],
  "show": [4],
  "translucent": [4],
  "type": [1],
  "size": [1],
  "closeIcon": [1, "close-icon"]
}]);
const IonFabButton$1 = FabButton;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const itemOptionIosCss = ":host{--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff);background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit)}:host(.in-list.item-options-end:last-child){-webkit-padding-end:calc(0.7em + var(--ion-safe-area-right));padding-inline-end:calc(0.7em + var(--ion-safe-area-right))}:host(.in-list.item-options-start:first-child){-webkit-padding-start:calc(0.7em + var(--ion-safe-area-left));padding-inline-start:calc(0.7em + var(--ion-safe-area-left))}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}.button-native{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;-webkit-padding-start:0.7em;padding-inline-start:0.7em;-webkit-padding-end:0.7em;padding-inline-end:0.7em;padding-top:0;padding-bottom:0;display:inline-block;position:relative;width:100%;height:100%;border:0;outline:none;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;-webkit-box-sizing:border-box;box-sizing:border-box}.button-inner{display:-ms-flexbox;display:flex;-ms-flex-flow:column nowrap;flex-flow:column nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.horizontal-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%}::slotted(*){-ms-flex-negative:0;flex-shrink:0}::slotted([slot=start]){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:5px;margin-inline-end:5px;margin-top:0;margin-bottom:0}::slotted([slot=end]){-webkit-margin-start:5px;margin-inline-start:5px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}::slotted([slot=icon-only]){padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:10px;margin-inline-end:10px;margin-top:0;margin-bottom:0;min-width:0.9em;font-size:1.8em}:host(.item-option-expandable){-ms-flex-negative:0;flex-shrink:0;-webkit-transition-duration:0;transition-duration:0;-webkit-transition-property:none;transition-property:none;-webkit-transition-timing-function:cubic-bezier(0.65, 0.05, 0.36, 1);transition-timing-function:cubic-bezier(0.65, 0.05, 0.36, 1)}:host(.item-option-disabled){pointer-events:none}:host(.item-option-disabled) .button-native{cursor:default;opacity:0.5;pointer-events:none}:host{font-size:16px}:host(.ion-activated){background:var(--ion-color-primary-shade, #3171e0)}:host(.ion-color.ion-activated){background:var(--ion-color-shade)}";
const itemOptionMdCss = ":host{--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff);background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit)}:host(.in-list.item-options-end:last-child){-webkit-padding-end:calc(0.7em + var(--ion-safe-area-right));padding-inline-end:calc(0.7em + var(--ion-safe-area-right))}:host(.in-list.item-options-start:first-child){-webkit-padding-start:calc(0.7em + var(--ion-safe-area-left));padding-inline-start:calc(0.7em + var(--ion-safe-area-left))}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}.button-native{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;-webkit-padding-start:0.7em;padding-inline-start:0.7em;-webkit-padding-end:0.7em;padding-inline-end:0.7em;padding-top:0;padding-bottom:0;display:inline-block;position:relative;width:100%;height:100%;border:0;outline:none;background:transparent;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;-webkit-box-sizing:border-box;box-sizing:border-box}.button-inner{display:-ms-flexbox;display:flex;-ms-flex-flow:column nowrap;flex-flow:column nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%}.horizontal-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%}::slotted(*){-ms-flex-negative:0;flex-shrink:0}::slotted([slot=start]){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:5px;margin-inline-end:5px;margin-top:0;margin-bottom:0}::slotted([slot=end]){-webkit-margin-start:5px;margin-inline-start:5px;-webkit-margin-end:0;margin-inline-end:0;margin-top:0;margin-bottom:0}::slotted([slot=icon-only]){padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:10px;margin-inline-end:10px;margin-top:0;margin-bottom:0;min-width:0.9em;font-size:1.8em}:host(.item-option-expandable){-ms-flex-negative:0;flex-shrink:0;-webkit-transition-duration:0;transition-duration:0;-webkit-transition-property:none;transition-property:none;-webkit-transition-timing-function:cubic-bezier(0.65, 0.05, 0.36, 1);transition-timing-function:cubic-bezier(0.65, 0.05, 0.36, 1)}:host(.item-option-disabled){pointer-events:none}:host(.item-option-disabled) .button-native{cursor:default;opacity:0.5;pointer-events:none}:host{font-size:14px;font-weight:500;text-transform:uppercase}";
const ItemOption = /* @__PURE__ */ proxyCustomElement$1(class ItemOption2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.onClick = (ev) => {
      const el2 = ev.target.closest("ion-item-option");
      if (el2) {
        ev.preventDefault();
      }
    };
    this.color = void 0;
    this.disabled = false;
    this.download = void 0;
    this.expandable = false;
    this.href = void 0;
    this.rel = void 0;
    this.target = void 0;
    this.type = "button";
  }
  render() {
    const { disabled, expandable, href } = this;
    const TagType = href === void 0 ? "button" : "a";
    const mode = getIonMode$2(this);
    const attrs = TagType === "button" ? { type: this.type } : {
      download: this.download,
      href: this.href,
      target: this.target
    };
    return h$5(Host$1, { onClick: this.onClick, class: createColorClasses$1(this.color, {
      [mode]: true,
      "item-option-disabled": disabled,
      "item-option-expandable": expandable,
      "ion-activatable": true
    }) }, h$5(TagType, Object.assign({}, attrs, { class: "button-native", part: "native", disabled }), h$5("span", { class: "button-inner" }, h$5("slot", { name: "top" }), h$5("div", { class: "horizontal-wrapper" }, h$5("slot", { name: "start" }), h$5("slot", { name: "icon-only" }), h$5("slot", null), h$5("slot", { name: "end" })), h$5("slot", { name: "bottom" })), mode === "md" && h$5("ion-ripple-effect", null)));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: itemOptionIosCss,
      md: itemOptionMdCss
    };
  }
}, [33, "ion-item-option", {
  "color": [513],
  "disabled": [4],
  "download": [1],
  "expandable": [4],
  "href": [1],
  "rel": [1],
  "target": [1],
  "type": [1]
}]);
const IonItemOption$1 = ItemOption;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const IonItem$1 = Item;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$c = defineCustomElement$n;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const iosEnterAnimation$2 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  wrapperAnimation.addElement(baseEl.querySelector(".loading-wrapper")).keyframes([
    { offset: 0, opacity: 0.01, transform: "scale(1.1)" },
    { offset: 1, opacity: 1, transform: "scale(1)" }
  ]);
  return baseAnimation2.addElement(baseEl).easing("ease-in-out").duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};
const iosLeaveAnimation$2 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", "var(--backdrop-opacity)", 0);
  wrapperAnimation.addElement(baseEl.querySelector(".loading-wrapper")).keyframes([
    { offset: 0, opacity: 0.99, transform: "scale(1)" },
    { offset: 1, opacity: 0, transform: "scale(0.9)" }
  ]);
  return baseAnimation2.addElement(baseEl).easing("ease-in-out").duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};
const mdEnterAnimation$2 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  wrapperAnimation.addElement(baseEl.querySelector(".loading-wrapper")).keyframes([
    { offset: 0, opacity: 0.01, transform: "scale(1.1)" },
    { offset: 1, opacity: 1, transform: "scale(1)" }
  ]);
  return baseAnimation2.addElement(baseEl).easing("ease-in-out").duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};
const mdLeaveAnimation$2 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const backdropAnimation = createAnimation();
  const wrapperAnimation = createAnimation();
  backdropAnimation.addElement(baseEl.querySelector("ion-backdrop")).fromTo("opacity", "var(--backdrop-opacity)", 0);
  wrapperAnimation.addElement(baseEl.querySelector(".loading-wrapper")).keyframes([
    { offset: 0, opacity: 0.99, transform: "scale(1)" },
    { offset: 1, opacity: 0, transform: "scale(0.9)" }
  ]);
  return baseAnimation2.addElement(baseEl).easing("ease-in-out").duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};
const loadingIosCss = ".sc-ion-loading-ios-h{--min-width:auto;--width:auto;--min-height:auto;--height:auto;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:fixed;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-loading-ios-h{display:none}.loading-wrapper.sc-ion-loading-ios{display:-ms-flexbox;display:flex;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);opacity:0;z-index:10}ion-spinner.sc-ion-loading-ios{color:var(--spinner-color)}.sc-ion-loading-ios-h{--background:var(--ion-overlay-background-color, var(--ion-color-step-100, #f9f9f9));--max-width:270px;--max-height:90%;--spinner-color:var(--ion-color-step-600, #666666);--backdrop-opacity:var(--ion-backdrop-opacity, 0.3);color:var(--ion-text-color, #000);font-size:14px}.loading-wrapper.sc-ion-loading-ios{border-radius:8px;-webkit-padding-start:34px;padding-inline-start:34px;-webkit-padding-end:34px;padding-inline-end:34px;padding-top:24px;padding-bottom:24px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.loading-translucent.sc-ion-loading-ios-h .loading-wrapper.sc-ion-loading-ios{background-color:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}}.loading-content.sc-ion-loading-ios{font-weight:bold}.loading-spinner.sc-ion-loading-ios+.loading-content.sc-ion-loading-ios{-webkit-margin-start:16px;margin-inline-start:16px}";
const loadingMdCss = ".sc-ion-loading-md-h{--min-width:auto;--width:auto;--min-height:auto;--height:auto;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:fixed;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;-ms-touch-action:none;touch-action:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-loading-md-h{display:none}.loading-wrapper.sc-ion-loading-md{display:-ms-flexbox;display:flex;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);opacity:0;z-index:10}ion-spinner.sc-ion-loading-md{color:var(--spinner-color)}.sc-ion-loading-md-h{--background:var(--ion-color-step-50, #f2f2f2);--max-width:280px;--max-height:90%;--spinner-color:var(--ion-color-primary, #3880ff);--backdrop-opacity:var(--ion-backdrop-opacity, 0.32);color:var(--ion-color-step-850, #262626);font-size:14px}.loading-wrapper.sc-ion-loading-md{border-radius:2px;-webkit-padding-start:24px;padding-inline-start:24px;-webkit-padding-end:24px;padding-inline-end:24px;padding-top:24px;padding-bottom:24px;-webkit-box-shadow:0 16px 20px rgba(0, 0, 0, 0.4);box-shadow:0 16px 20px rgba(0, 0, 0, 0.4)}.loading-spinner.sc-ion-loading-md+.loading-content.sc-ion-loading-md{-webkit-margin-start:16px;margin-inline-start:16px}";
const Loading = /* @__PURE__ */ proxyCustomElement$1(class Loading2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.didPresent = createEvent(this, "ionLoadingDidPresent", 7);
    this.willPresent = createEvent(this, "ionLoadingWillPresent", 7);
    this.willDismiss = createEvent(this, "ionLoadingWillDismiss", 7);
    this.didDismiss = createEvent(this, "ionLoadingDidDismiss", 7);
    this.didPresentShorthand = createEvent(this, "didPresent", 7);
    this.willPresentShorthand = createEvent(this, "willPresent", 7);
    this.willDismissShorthand = createEvent(this, "willDismiss", 7);
    this.didDismissShorthand = createEvent(this, "didDismiss", 7);
    this.delegateController = createDelegateController(this);
    this.triggerController = createTriggerController();
    this.customHTMLEnabled = config$1.get("innerHTMLTemplatesEnabled", ENABLE_HTML_CONTENT_DEFAULT);
    this.presented = false;
    this.onBackdropTap = () => {
      this.dismiss(void 0, BACKDROP);
    };
    this.overlayIndex = void 0;
    this.delegate = void 0;
    this.hasController = false;
    this.keyboardClose = true;
    this.enterAnimation = void 0;
    this.leaveAnimation = void 0;
    this.message = void 0;
    this.cssClass = void 0;
    this.duration = 0;
    this.backdropDismiss = false;
    this.showBackdrop = true;
    this.spinner = void 0;
    this.translucent = false;
    this.animated = true;
    this.htmlAttributes = void 0;
    this.isOpen = false;
    this.trigger = void 0;
  }
  onIsOpenChange(newValue, oldValue) {
    if (newValue === true && oldValue === false) {
      this.present();
    } else if (newValue === false && oldValue === true) {
      this.dismiss();
    }
  }
  triggerChanged() {
    const { trigger, el: el2, triggerController } = this;
    if (trigger) {
      triggerController.addClickListener(el2, trigger);
    }
  }
  connectedCallback() {
    prepareOverlay(this.el);
    this.triggerChanged();
  }
  componentWillLoad() {
    if (this.spinner === void 0) {
      const mode = getIonMode$2(this);
      this.spinner = config$1.get("loadingSpinner", config$1.get("spinner", mode === "ios" ? "lines" : "crescent"));
    }
    setOverlayId(this.el);
  }
  componentDidLoad() {
    if (this.isOpen === true) {
      raf(() => this.present());
    }
  }
  disconnectedCallback() {
    this.triggerController.removeClickListener();
  }
  /**
   * Present the loading overlay after it has been created.
   */
  async present() {
    if (this.currentTransition !== void 0) {
      await this.currentTransition;
    }
    await this.delegateController.attachViewToDom();
    this.currentTransition = present(this, "loadingEnter", iosEnterAnimation$2, mdEnterAnimation$2);
    await this.currentTransition;
    if (this.duration > 0) {
      this.durationTimeout = setTimeout(() => this.dismiss(), this.duration + 10);
    }
    this.currentTransition = void 0;
  }
  /**
   * Dismiss the loading overlay after it has been presented.
   *
   * @param data Any data to emit in the dismiss events.
   * @param role The role of the element that is dismissing the loading.
   * This can be useful in a button handler for determining which button was
   * clicked to dismiss the loading.
   * Some examples include: ``"cancel"`, `"destructive"`, "selected"`, and `"backdrop"`.
   */
  async dismiss(data2, role) {
    if (this.durationTimeout) {
      clearTimeout(this.durationTimeout);
    }
    this.currentTransition = dismiss(this, data2, role, "loadingLeave", iosLeaveAnimation$2, mdLeaveAnimation$2);
    const dismissed = await this.currentTransition;
    if (dismissed) {
      this.delegateController.removeViewFromDom();
    }
    return dismissed;
  }
  /**
   * Returns a promise that resolves when the loading did dismiss.
   */
  onDidDismiss() {
    return eventMethod(this.el, "ionLoadingDidDismiss");
  }
  /**
   * Returns a promise that resolves when the loading will dismiss.
   */
  onWillDismiss() {
    return eventMethod(this.el, "ionLoadingWillDismiss");
  }
  renderLoadingMessage(msgId) {
    const { customHTMLEnabled, message } = this;
    if (customHTMLEnabled) {
      return h$5("div", { class: "loading-content", id: msgId, innerHTML: sanitizeDOMString(message) });
    }
    return h$5("div", { class: "loading-content", id: msgId }, message);
  }
  render() {
    const { message, spinner, htmlAttributes, overlayIndex } = this;
    const mode = getIonMode$2(this);
    const msgId = `loading-${overlayIndex}-msg`;
    const ariaLabelledBy = message !== void 0 ? msgId : null;
    return h$5(Host$1, Object.assign({ role: "dialog", "aria-modal": "true", "aria-labelledby": ariaLabelledBy, tabindex: "-1" }, htmlAttributes, { style: {
      zIndex: `${4e4 + this.overlayIndex}`
    }, onIonBackdropTap: this.onBackdropTap, class: Object.assign(Object.assign({}, getClassMap(this.cssClass)), { [mode]: true, "overlay-hidden": true, "loading-translucent": this.translucent }) }), h$5("ion-backdrop", { visible: this.showBackdrop, tappable: this.backdropDismiss }), h$5("div", { tabindex: "0" }), h$5("div", { class: "loading-wrapper ion-overlay-wrapper" }, spinner && h$5("div", { class: "loading-spinner" }, h$5("ion-spinner", { name: spinner, "aria-hidden": "true" })), message !== void 0 && this.renderLoadingMessage(msgId)), h$5("div", { tabindex: "0" }));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "isOpen": ["onIsOpenChange"],
      "trigger": ["triggerChanged"]
    };
  }
  static get style() {
    return {
      ios: loadingIosCss,
      md: loadingMdCss
    };
  }
}, [34, "ion-loading", {
  "overlayIndex": [2, "overlay-index"],
  "delegate": [16],
  "hasController": [4, "has-controller"],
  "keyboardClose": [4, "keyboard-close"],
  "enterAnimation": [16],
  "leaveAnimation": [16],
  "message": [1],
  "cssClass": [1, "css-class"],
  "duration": [2],
  "backdropDismiss": [4, "backdrop-dismiss"],
  "showBackdrop": [4, "show-backdrop"],
  "spinner": [1025],
  "translucent": [4],
  "animated": [4],
  "htmlAttributes": [16],
  "isOpen": [4, "is-open"],
  "trigger": [1],
  "present": [64],
  "dismiss": [64],
  "onDidDismiss": [64],
  "onWillDismiss": [64]
}]);
function defineCustomElement$1$8() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-loading", "ion-backdrop", "ion-spinner"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-loading":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Loading);
        }
        break;
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          defineCustomElement$17();
        }
        break;
      case "ion-spinner":
        if (!customElements.get(tagName)) {
          defineCustomElement$I();
        }
        break;
    }
  });
}
const defineCustomElement$b = defineCustomElement$1$8;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const iosEnterAnimation$1 = (baseEl, position) => {
  const baseAnimation2 = createAnimation();
  const wrapperAnimation = createAnimation();
  const root2 = getElementRoot(baseEl);
  const wrapperEl = root2.querySelector(".toast-wrapper");
  const bottom = `calc(-10px - var(--ion-safe-area-bottom, 0px))`;
  const top = `calc(10px + var(--ion-safe-area-top, 0px))`;
  wrapperAnimation.addElement(wrapperEl);
  switch (position) {
    case "top":
      wrapperAnimation.fromTo("transform", "translateY(-100%)", `translateY(${top})`);
      break;
    case "middle":
      const topPosition = Math.floor(baseEl.clientHeight / 2 - wrapperEl.clientHeight / 2);
      wrapperEl.style.top = `${topPosition}px`;
      wrapperAnimation.fromTo("opacity", 0.01, 1);
      break;
    default:
      wrapperAnimation.fromTo("transform", "translateY(100%)", `translateY(${bottom})`);
      break;
  }
  return baseAnimation2.easing("cubic-bezier(.155,1.105,.295,1.12)").duration(400).addAnimation(wrapperAnimation);
};
const iosLeaveAnimation$1 = (baseEl, position) => {
  const baseAnimation2 = createAnimation();
  const wrapperAnimation = createAnimation();
  const root2 = getElementRoot(baseEl);
  const wrapperEl = root2.querySelector(".toast-wrapper");
  const bottom = `calc(-10px - var(--ion-safe-area-bottom, 0px))`;
  const top = `calc(10px + var(--ion-safe-area-top, 0px))`;
  wrapperAnimation.addElement(wrapperEl);
  switch (position) {
    case "top":
      wrapperAnimation.fromTo("transform", `translateY(${top})`, "translateY(-100%)");
      break;
    case "middle":
      wrapperAnimation.fromTo("opacity", 0.99, 0);
      break;
    default:
      wrapperAnimation.fromTo("transform", `translateY(${bottom})`, "translateY(100%)");
      break;
  }
  return baseAnimation2.easing("cubic-bezier(.36,.66,.04,1)").duration(300).addAnimation(wrapperAnimation);
};
const mdEnterAnimation$1 = (baseEl, position) => {
  const baseAnimation2 = createAnimation();
  const wrapperAnimation = createAnimation();
  const root2 = getElementRoot(baseEl);
  const wrapperEl = root2.querySelector(".toast-wrapper");
  const bottom = `calc(8px + var(--ion-safe-area-bottom, 0px))`;
  const top = `calc(8px + var(--ion-safe-area-top, 0px))`;
  wrapperAnimation.addElement(wrapperEl);
  switch (position) {
    case "top":
      wrapperEl.style.top = top;
      wrapperAnimation.fromTo("opacity", 0.01, 1);
      break;
    case "middle":
      const topPosition = Math.floor(baseEl.clientHeight / 2 - wrapperEl.clientHeight / 2);
      wrapperEl.style.top = `${topPosition}px`;
      wrapperAnimation.fromTo("opacity", 0.01, 1);
      break;
    default:
      wrapperEl.style.bottom = bottom;
      wrapperAnimation.fromTo("opacity", 0.01, 1);
      break;
  }
  return baseAnimation2.easing("cubic-bezier(.36,.66,.04,1)").duration(400).addAnimation(wrapperAnimation);
};
const mdLeaveAnimation$1 = (baseEl) => {
  const baseAnimation2 = createAnimation();
  const wrapperAnimation = createAnimation();
  const root2 = getElementRoot(baseEl);
  const wrapperEl = root2.querySelector(".toast-wrapper");
  wrapperAnimation.addElement(wrapperEl).fromTo("opacity", 0.99, 0);
  return baseAnimation2.easing("cubic-bezier(.36,.66,.04,1)").duration(300).addAnimation(wrapperAnimation);
};
const toastIosCss = ":host{--border-width:0;--border-style:none;--border-color:initial;--box-shadow:none;--min-width:auto;--width:auto;--min-height:auto;--height:auto;--max-height:auto;--white-space:normal;top:0;display:block;position:absolute;width:100%;height:100%;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);contain:strict;z-index:1001;pointer-events:none}@supports (inset-inline-start: 0){:host{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host{left:0}:host-context([dir=rtl]){left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host:dir(rtl){left:unset;right:unset;right:0}}}:host(.overlay-hidden){display:none}:host(.ion-color){--button-color:inherit;color:var(--ion-color-contrast)}:host(.ion-color) .toast-button-cancel{color:inherit}:host(.ion-color) .toast-wrapper{background:var(--ion-color-base)}.toast-wrapper{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow)}@supports (inset-inline-start: 0){.toast-wrapper{inset-inline-start:var(--start);inset-inline-end:var(--end)}}@supports not (inset-inline-start: 0){.toast-wrapper{left:var(--start);right:var(--end)}:host-context([dir=rtl]) .toast-wrapper{left:unset;right:unset;left:var(--end);right:var(--start)}[dir=rtl] .toast-wrapper{left:unset;right:unset;left:var(--end);right:var(--start)}@supports selector(:dir(rtl)){.toast-wrapper:dir(rtl){left:unset;right:unset;left:var(--end);right:var(--start)}}}.toast-container{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;pointer-events:auto;height:inherit;min-height:inherit;max-height:inherit;contain:content}.toast-layout-stacked .toast-container{-ms-flex-wrap:wrap;flex-wrap:wrap}.toast-layout-baseline .toast-content{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center}.toast-icon{-webkit-margin-start:16px;margin-inline-start:16px}.toast-message{-ms-flex:1;flex:1;white-space:var(--white-space)}.toast-button-group{display:-ms-flexbox;display:flex}.toast-layout-stacked .toast-button-group{-ms-flex-pack:end;justify-content:end;width:100%}.toast-button{border:0;outline:none;color:var(--button-color);z-index:0}.toast-icon,.toast-button-icon{font-size:1.4em}.toast-button-inner{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}@media (any-hover: hover){.toast-button:hover{cursor:pointer}}:host{--background:var(--ion-color-step-50, #f2f2f2);--border-radius:14px;--button-color:var(--ion-color-primary, #3880ff);--color:var(--ion-color-step-850, #262626);--max-width:700px;--start:10px;--end:10px;font-size:14px}.toast-wrapper{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:auto;margin-bottom:auto;display:block;position:absolute;z-index:10}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.toast-translucent) .toast-wrapper{background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}}.toast-wrapper.toast-top{-webkit-transform:translate3d(0,  -100%,  0);transform:translate3d(0,  -100%,  0);top:0}.toast-wrapper.toast-middle{opacity:0.01}.toast-wrapper.toast-bottom{-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0);bottom:0}.toast-content{-webkit-padding-start:15px;padding-inline-start:15px;-webkit-padding-end:15px;padding-inline-end:15px;padding-top:15px;padding-bottom:15px}.toast-header{margin-bottom:2px;font-weight:500}.toast-button{-webkit-padding-start:15px;padding-inline-start:15px;-webkit-padding-end:15px;padding-inline-end:15px;padding-top:10px;padding-bottom:10px;height:44px;-webkit-transition:background-color, opacity 100ms linear;transition:background-color, opacity 100ms linear;border:0;background-color:transparent;font-family:var(--ion-font-family);font-size:17px;font-weight:500;overflow:hidden}.toast-button.ion-activated{opacity:0.4}@media (any-hover: hover){.toast-button:hover{opacity:0.6}}";
const toastMdCss = ":host{--border-width:0;--border-style:none;--border-color:initial;--box-shadow:none;--min-width:auto;--width:auto;--min-height:auto;--height:auto;--max-height:auto;--white-space:normal;top:0;display:block;position:absolute;width:100%;height:100%;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);contain:strict;z-index:1001;pointer-events:none}@supports (inset-inline-start: 0){:host{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host{left:0}:host-context([dir=rtl]){left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host:dir(rtl){left:unset;right:unset;right:0}}}:host(.overlay-hidden){display:none}:host(.ion-color){--button-color:inherit;color:var(--ion-color-contrast)}:host(.ion-color) .toast-button-cancel{color:inherit}:host(.ion-color) .toast-wrapper{background:var(--ion-color-base)}.toast-wrapper{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow)}@supports (inset-inline-start: 0){.toast-wrapper{inset-inline-start:var(--start);inset-inline-end:var(--end)}}@supports not (inset-inline-start: 0){.toast-wrapper{left:var(--start);right:var(--end)}:host-context([dir=rtl]) .toast-wrapper{left:unset;right:unset;left:var(--end);right:var(--start)}[dir=rtl] .toast-wrapper{left:unset;right:unset;left:var(--end);right:var(--start)}@supports selector(:dir(rtl)){.toast-wrapper:dir(rtl){left:unset;right:unset;left:var(--end);right:var(--start)}}}.toast-container{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;pointer-events:auto;height:inherit;min-height:inherit;max-height:inherit;contain:content}.toast-layout-stacked .toast-container{-ms-flex-wrap:wrap;flex-wrap:wrap}.toast-layout-baseline .toast-content{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center}.toast-icon{-webkit-margin-start:16px;margin-inline-start:16px}.toast-message{-ms-flex:1;flex:1;white-space:var(--white-space)}.toast-button-group{display:-ms-flexbox;display:flex}.toast-layout-stacked .toast-button-group{-ms-flex-pack:end;justify-content:end;width:100%}.toast-button{border:0;outline:none;color:var(--button-color);z-index:0}.toast-icon,.toast-button-icon{font-size:1.4em}.toast-button-inner{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}@media (any-hover: hover){.toast-button:hover{cursor:pointer}}:host{--background:var(--ion-color-step-800, #333333);--border-radius:4px;--box-shadow:0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12);--button-color:var(--ion-color-primary, #3880ff);--color:var(--ion-color-step-50, #f2f2f2);--max-width:700px;--start:8px;--end:8px;font-size:14px}.toast-wrapper{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:auto;margin-bottom:auto;display:block;position:absolute;opacity:0.01;z-index:10}.toast-content{-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:14px;padding-bottom:14px}.toast-header{margin-bottom:2px;font-weight:500;line-height:20px}.toast-message{line-height:20px}.toast-layout-baseline .toast-button-group-start{-webkit-margin-start:8px;margin-inline-start:8px}.toast-layout-stacked .toast-button-group-start{-webkit-margin-end:8px;margin-inline-end:8px;margin-top:8px}.toast-layout-baseline .toast-button-group-end{-webkit-margin-end:8px;margin-inline-end:8px}.toast-layout-stacked .toast-button-group-end{-webkit-margin-end:8px;margin-inline-end:8px;margin-bottom:8px}.toast-button{-webkit-padding-start:15px;padding-inline-start:15px;-webkit-padding-end:15px;padding-inline-end:15px;padding-top:10px;padding-bottom:10px;position:relative;background-color:transparent;font-family:var(--ion-font-family);font-size:14px;font-weight:500;letter-spacing:0.84px;text-transform:uppercase;overflow:hidden}.toast-button-cancel{color:var(--ion-color-step-100, #e6e6e6)}.toast-button-icon-only{border-radius:50%;-webkit-padding-start:9px;padding-inline-start:9px;-webkit-padding-end:9px;padding-inline-end:9px;padding-top:9px;padding-bottom:9px;width:36px;height:36px}@media (any-hover: hover){.toast-button:hover{background-color:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.08)}.toast-button-cancel:hover{background-color:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.08)}}";
const Toast = /* @__PURE__ */ proxyCustomElement$1(class Toast2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.didPresent = createEvent(this, "ionToastDidPresent", 7);
    this.willPresent = createEvent(this, "ionToastWillPresent", 7);
    this.willDismiss = createEvent(this, "ionToastWillDismiss", 7);
    this.didDismiss = createEvent(this, "ionToastDidDismiss", 7);
    this.didPresentShorthand = createEvent(this, "didPresent", 7);
    this.willPresentShorthand = createEvent(this, "willPresent", 7);
    this.willDismissShorthand = createEvent(this, "willDismiss", 7);
    this.didDismissShorthand = createEvent(this, "didDismiss", 7);
    this.delegateController = createDelegateController(this);
    this.triggerController = createTriggerController();
    this.customHTMLEnabled = config$1.get("innerHTMLTemplatesEnabled", ENABLE_HTML_CONTENT_DEFAULT);
    this.presented = false;
    this.dispatchCancelHandler = (ev) => {
      const role = ev.detail.role;
      if (isCancel$2(role)) {
        const cancelButton = this.getButtons().find((b2) => b2.role === "cancel");
        this.callButtonHandler(cancelButton);
      }
    };
    this.revealContentToScreenReader = false;
    this.overlayIndex = void 0;
    this.delegate = void 0;
    this.hasController = false;
    this.color = void 0;
    this.enterAnimation = void 0;
    this.leaveAnimation = void 0;
    this.cssClass = void 0;
    this.duration = config$1.getNumber("toastDuration", 0);
    this.header = void 0;
    this.layout = "baseline";
    this.message = void 0;
    this.keyboardClose = false;
    this.position = "bottom";
    this.buttons = void 0;
    this.translucent = false;
    this.animated = true;
    this.icon = void 0;
    this.htmlAttributes = void 0;
    this.isOpen = false;
    this.trigger = void 0;
  }
  onIsOpenChange(newValue, oldValue) {
    if (newValue === true && oldValue === false) {
      this.present();
    } else if (newValue === false && oldValue === true) {
      this.dismiss();
    }
  }
  triggerChanged() {
    const { trigger, el: el2, triggerController } = this;
    if (trigger) {
      triggerController.addClickListener(el2, trigger);
    }
  }
  connectedCallback() {
    prepareOverlay(this.el);
    this.triggerChanged();
  }
  disconnectedCallback() {
    this.triggerController.removeClickListener();
  }
  componentWillLoad() {
    setOverlayId(this.el);
  }
  /**
   * Present the toast overlay after it has been created.
   */
  async present() {
    if (this.currentTransition !== void 0) {
      await this.currentTransition;
    }
    await this.delegateController.attachViewToDom();
    this.currentTransition = present(this, "toastEnter", iosEnterAnimation$1, mdEnterAnimation$1, this.position);
    await this.currentTransition;
    this.revealContentToScreenReader = true;
    this.currentTransition = void 0;
    if (this.duration > 0) {
      this.durationTimeout = setTimeout(() => this.dismiss(void 0, "timeout"), this.duration);
    }
  }
  /**
   * Dismiss the toast overlay after it has been presented.
   *
   * @param data Any data to emit in the dismiss events.
   * @param role The role of the element that is dismissing the toast.
   * This can be useful in a button handler for determining which button was
   * clicked to dismiss the toast.
   * Some examples include: ``"cancel"`, `"destructive"`, "selected"`, and `"backdrop"`.
   */
  async dismiss(data2, role) {
    if (this.durationTimeout) {
      clearTimeout(this.durationTimeout);
    }
    this.currentTransition = dismiss(this, data2, role, "toastLeave", iosLeaveAnimation$1, mdLeaveAnimation$1, this.position);
    const dismissed = await this.currentTransition;
    if (dismissed) {
      this.delegateController.removeViewFromDom();
      this.revealContentToScreenReader = false;
    }
    return dismissed;
  }
  /**
   * Returns a promise that resolves when the toast did dismiss.
   */
  onDidDismiss() {
    return eventMethod(this.el, "ionToastDidDismiss");
  }
  /**
   * Returns a promise that resolves when the toast will dismiss.
   */
  onWillDismiss() {
    return eventMethod(this.el, "ionToastWillDismiss");
  }
  getButtons() {
    const buttons = this.buttons ? this.buttons.map((b2) => {
      return typeof b2 === "string" ? { text: b2 } : b2;
    }) : [];
    return buttons;
  }
  async buttonClick(button) {
    const role = button.role;
    if (isCancel$2(role)) {
      return this.dismiss(void 0, role);
    }
    const shouldDismiss = await this.callButtonHandler(button);
    if (shouldDismiss) {
      return this.dismiss(void 0, role);
    }
    return Promise.resolve();
  }
  async callButtonHandler(button) {
    if (button === null || button === void 0 ? void 0 : button.handler) {
      try {
        const rtn = await safeCall$1(button.handler);
        if (rtn === false) {
          return false;
        }
      } catch (e3) {
        console.error(e3);
      }
    }
    return true;
  }
  renderButtons(buttons, side) {
    if (buttons.length === 0) {
      return;
    }
    const mode = getIonMode$2(this);
    const buttonGroupsClasses = {
      "toast-button-group": true,
      [`toast-button-group-${side}`]: true
    };
    return h$5("div", { class: buttonGroupsClasses }, buttons.map((b2) => h$5("button", { type: "button", class: buttonClass(b2), tabIndex: 0, onClick: () => this.buttonClick(b2), part: "button" }, h$5("div", { class: "toast-button-inner" }, b2.icon && h$5("ion-icon", { "aria-hidden": "true", icon: b2.icon, slot: b2.text === void 0 ? "icon-only" : void 0, class: "toast-button-icon" }), b2.text), mode === "md" && h$5("ion-ripple-effect", { type: b2.icon !== void 0 && b2.text === void 0 ? "unbounded" : "bounded" }))));
  }
  /**
   * Render the `message` property.
   * @param key - A key to give the element a stable identity. This is used to improve compatibility with screen readers.
   * @param ariaHidden - If "true" then content will be hidden from screen readers.
   */
  renderToastMessage(key, ariaHidden = null) {
    const { customHTMLEnabled, message } = this;
    if (customHTMLEnabled) {
      return h$5("div", { key, "aria-hidden": ariaHidden, class: "toast-message", part: "message", innerHTML: sanitizeDOMString(message) });
    }
    return h$5("div", { key, "aria-hidden": ariaHidden, class: "toast-message", part: "message" }, message);
  }
  /**
   * Render the `header` property.
   * @param key - A key to give the element a stable identity. This is used to improve compatibility with screen readers.
   * @param ariaHidden - If "true" then content will be hidden from screen readers.
   */
  renderHeader(key, ariaHidden = null) {
    return h$5("div", { key, class: "toast-header", "aria-hidden": ariaHidden, part: "header" }, this.header);
  }
  render() {
    const { layout, el: el2, revealContentToScreenReader, header, message } = this;
    const allButtons = this.getButtons();
    const startButtons = allButtons.filter((b2) => b2.side === "start");
    const endButtons = allButtons.filter((b2) => b2.side !== "start");
    const mode = getIonMode$2(this);
    const wrapperClass2 = {
      "toast-wrapper": true,
      [`toast-${this.position}`]: true,
      [`toast-layout-${layout}`]: true
    };
    if (layout === "stacked" && startButtons.length > 0 && endButtons.length > 0) {
      printIonWarning("This toast is using start and end buttons with the stacked toast layout. We recommend following the best practice of using either start or end buttons with the stacked toast layout.", el2);
    }
    return h$5(Host$1, Object.assign({ tabindex: "-1" }, this.htmlAttributes, { style: {
      zIndex: `${6e4 + this.overlayIndex}`
    }, class: createColorClasses$1(this.color, Object.assign(Object.assign({ [mode]: true }, getClassMap(this.cssClass)), { "overlay-hidden": true, "toast-translucent": this.translucent })), onIonToastWillDismiss: this.dispatchCancelHandler }), h$5("div", { class: wrapperClass2 }, h$5("div", { class: "toast-container", part: "container" }, this.renderButtons(startButtons, "start"), this.icon !== void 0 && h$5("ion-icon", { class: "toast-icon", part: "icon", icon: this.icon, lazy: false, "aria-hidden": "true" }), h$5("div", { class: "toast-content", role: "status", "aria-atomic": "true", "aria-live": "polite" }, !revealContentToScreenReader && header !== void 0 && this.renderHeader("oldHeader", "true"), !revealContentToScreenReader && message !== void 0 && this.renderToastMessage("oldMessage", "true"), revealContentToScreenReader && header !== void 0 && this.renderHeader("header"), revealContentToScreenReader && message !== void 0 && this.renderToastMessage("header")), this.renderButtons(endButtons, "end"))));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "isOpen": ["onIsOpenChange"],
      "trigger": ["triggerChanged"]
    };
  }
  static get style() {
    return {
      ios: toastIosCss,
      md: toastMdCss
    };
  }
}, [33, "ion-toast", {
  "overlayIndex": [2, "overlay-index"],
  "delegate": [16],
  "hasController": [4, "has-controller"],
  "color": [513],
  "enterAnimation": [16],
  "leaveAnimation": [16],
  "cssClass": [1, "css-class"],
  "duration": [2],
  "header": [1],
  "layout": [1],
  "message": [1],
  "keyboardClose": [4, "keyboard-close"],
  "position": [1],
  "buttons": [16],
  "translucent": [4],
  "animated": [4],
  "icon": [1],
  "htmlAttributes": [16],
  "isOpen": [4, "is-open"],
  "trigger": [1],
  "revealContentToScreenReader": [32],
  "present": [64],
  "dismiss": [64],
  "onDidDismiss": [64],
  "onWillDismiss": [64]
}]);
const buttonClass = (button) => {
  return Object.assign({ "toast-button": true, "toast-button-icon-only": button.icon !== void 0 && button.text === void 0, [`toast-button-${button.role}`]: button.role !== void 0, "ion-focusable": true, "ion-activatable": true }, getClassMap(button.cssClass));
};
function defineCustomElement$1$7() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-toast", "ion-icon", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-toast":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Toast);
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$1b();
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$Z();
        }
        break;
    }
  });
}
const defineCustomElement$a = defineCustomElement$1$7;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const KEYBOARD_DID_OPEN = "ionKeyboardDidShow";
const KEYBOARD_DID_CLOSE = "ionKeyboardDidHide";
const KEYBOARD_THRESHOLD = 150;
let previousVisualViewport = {};
let currentVisualViewport = {};
let keyboardOpen = false;
const resetKeyboardAssist = () => {
  previousVisualViewport = {};
  currentVisualViewport = {};
  keyboardOpen = false;
};
const startKeyboardAssist = (win2) => {
  startNativeListeners(win2);
  if (!win2.visualViewport) {
    return;
  }
  currentVisualViewport = copyVisualViewport(win2.visualViewport);
  win2.visualViewport.onresize = () => {
    trackViewportChanges(win2);
    if (keyboardDidOpen() || keyboardDidResize(win2)) {
      setKeyboardOpen(win2);
    } else if (keyboardDidClose(win2)) {
      setKeyboardClose(win2);
    }
  };
};
const startNativeListeners = (win2) => {
  win2.addEventListener("keyboardDidShow", (ev) => setKeyboardOpen(win2, ev));
  win2.addEventListener("keyboardDidHide", () => setKeyboardClose(win2));
};
const setKeyboardOpen = (win2, ev) => {
  fireKeyboardOpenEvent(win2, ev);
  keyboardOpen = true;
};
const setKeyboardClose = (win2) => {
  fireKeyboardCloseEvent(win2);
  keyboardOpen = false;
};
const keyboardDidOpen = () => {
  const scaledHeightDifference = (previousVisualViewport.height - currentVisualViewport.height) * currentVisualViewport.scale;
  return !keyboardOpen && previousVisualViewport.width === currentVisualViewport.width && scaledHeightDifference > KEYBOARD_THRESHOLD;
};
const keyboardDidResize = (win2) => {
  return keyboardOpen && !keyboardDidClose(win2);
};
const keyboardDidClose = (win2) => {
  return keyboardOpen && currentVisualViewport.height === win2.innerHeight;
};
const fireKeyboardOpenEvent = (win2, nativeEv) => {
  const keyboardHeight = nativeEv ? nativeEv.keyboardHeight : win2.innerHeight - currentVisualViewport.height;
  const ev = new CustomEvent(KEYBOARD_DID_OPEN, {
    detail: { keyboardHeight }
  });
  win2.dispatchEvent(ev);
};
const fireKeyboardCloseEvent = (win2) => {
  const ev = new CustomEvent(KEYBOARD_DID_CLOSE);
  win2.dispatchEvent(ev);
};
const trackViewportChanges = (win2) => {
  previousVisualViewport = Object.assign({}, currentVisualViewport);
  currentVisualViewport = copyVisualViewport(win2.visualViewport);
};
const copyVisualViewport = (visualViewport) => {
  return {
    width: Math.round(visualViewport.width),
    height: Math.round(visualViewport.height),
    offsetTop: visualViewport.offsetTop,
    offsetLeft: visualViewport.offsetLeft,
    pageTop: visualViewport.pageTop,
    pageLeft: visualViewport.pageLeft,
    scale: visualViewport.scale
  };
};
const keyboard2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  KEYBOARD_DID_CLOSE,
  KEYBOARD_DID_OPEN,
  copyVisualViewport,
  keyboardDidClose,
  keyboardDidOpen,
  keyboardDidResize,
  resetKeyboardAssist,
  setKeyboardClose,
  setKeyboardOpen,
  startKeyboardAssist,
  trackViewportChanges
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
var Style;
(function(Style2) {
  Style2["Dark"] = "DARK";
  Style2["Light"] = "LIGHT";
  Style2["Default"] = "DEFAULT";
})(Style || (Style = {}));
const StatusBar = {
  getEngine() {
    var _a2;
    return ((_a2 = win$2 === null || win$2 === void 0 ? void 0 : win$2.Capacitor) === null || _a2 === void 0 ? void 0 : _a2.isPluginAvailable("StatusBar")) && (win$2 === null || win$2 === void 0 ? void 0 : win$2.Capacitor.Plugins.StatusBar);
  },
  supportsDefaultStatusBarStyle() {
    var _a2;
    return !!((_a2 = win$2 === null || win$2 === void 0 ? void 0 : win$2.Capacitor) === null || _a2 === void 0 ? void 0 : _a2.PluginHeaders);
  },
  setStyle(options) {
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    engine.setStyle(options);
  },
  getStyle: async function() {
    const engine = this.getEngine();
    if (!engine) {
      return Style.Default;
    }
    const { style } = await engine.getInfo();
    return style;
  }
};
const getBackdropValueForSheet = (x2, backdropBreakpoint) => {
  if (backdropBreakpoint === 1) {
    return 0;
  }
  const slope = 1 / (1 - backdropBreakpoint);
  const b2 = -(backdropBreakpoint * slope);
  return x2 * slope + b2;
};
const setCardStatusBarDark = () => {
  if (!win$2 || win$2.innerWidth >= 768 || !StatusBar.supportsDefaultStatusBarStyle()) {
    return;
  }
  StatusBar.setStyle({ style: Style.Dark });
};
const setCardStatusBarDefault = (defaultStyle = Style.Default) => {
  if (!win$2 || win$2.innerWidth >= 768 || !StatusBar.supportsDefaultStatusBarStyle()) {
    return;
  }
  StatusBar.setStyle({ style: defaultStyle });
};
const handleCanDismiss = async (el2, animation2) => {
  if (typeof el2.canDismiss !== "function") {
    return;
  }
  const shouldDismiss = await el2.canDismiss(void 0, GESTURE);
  if (!shouldDismiss) {
    return;
  }
  if (animation2.isRunning()) {
    animation2.onFinish(() => {
      el2.dismiss(void 0, "handler");
    }, { oneTimeCallback: true });
  } else {
    el2.dismiss(void 0, "handler");
  }
};
const calculateSpringStep = (t2) => {
  return 255275e-8 * 2.71828 ** (-14.9619 * t2) - 1.00255 * 2.71828 ** (-0.0380968 * t2) + 1;
};
const SwipeToCloseDefaults = {
  MIN_PRESENTING_SCALE: 0.93
};
const createSwipeToCloseGesture = (el2, animation2, statusBarStyle, onDismiss) => {
  const DISMISS_THRESHOLD = 0.5;
  const height = el2.offsetHeight;
  let isOpen = false;
  let canDismissBlocksGesture = false;
  let contentEl = null;
  let scrollEl = null;
  const canDismissMaxStep = 0.2;
  let initialScrollY = true;
  let lastStep = 0;
  const getScrollY = () => {
    if (contentEl && isIonContent(contentEl)) {
      return contentEl.scrollY;
    } else {
      return true;
    }
  };
  const canStart = (detail) => {
    const target = detail.event.target;
    if (target === null || !target.closest) {
      return true;
    }
    contentEl = findClosestIonContent(target);
    if (contentEl) {
      if (isIonContent(contentEl)) {
        const root2 = getElementRoot(contentEl);
        scrollEl = root2.querySelector(".inner-scroll");
      } else {
        scrollEl = contentEl;
      }
      const hasRefresherInContent = !!contentEl.querySelector("ion-refresher");
      return !hasRefresherInContent && scrollEl.scrollTop === 0;
    }
    const footer = target.closest("ion-footer");
    if (footer === null) {
      return true;
    }
    return false;
  };
  const onStart = (detail) => {
    const { deltaY } = detail;
    initialScrollY = getScrollY();
    canDismissBlocksGesture = el2.canDismiss !== void 0 && el2.canDismiss !== true;
    if (deltaY > 0 && contentEl) {
      disableContentScrollY(contentEl);
    }
    animation2.progressStart(true, isOpen ? 1 : 0);
  };
  const onMove = (detail) => {
    const { deltaY } = detail;
    if (deltaY > 0 && contentEl) {
      disableContentScrollY(contentEl);
    }
    const step = detail.deltaY / height;
    const isAttemptingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;
    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    const processedStep = isAttemptingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;
    const clampedStep = clamp$1(1e-4, processedStep, maxStep);
    animation2.progressStep(clampedStep);
    if (clampedStep >= DISMISS_THRESHOLD && lastStep < DISMISS_THRESHOLD) {
      setCardStatusBarDefault(statusBarStyle);
    } else if (clampedStep < DISMISS_THRESHOLD && lastStep >= DISMISS_THRESHOLD) {
      setCardStatusBarDark();
    }
    lastStep = clampedStep;
  };
  const onEnd = (detail) => {
    const velocity = detail.velocityY;
    const step = detail.deltaY / height;
    const isAttemptingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;
    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    const processedStep = isAttemptingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;
    const clampedStep = clamp$1(1e-4, processedStep, maxStep);
    const threshold2 = (detail.deltaY + velocity * 1e3) / height;
    const shouldComplete3 = !isAttemptingDismissWithCanDismiss && threshold2 >= DISMISS_THRESHOLD;
    let newStepValue = shouldComplete3 ? -1e-3 : 1e-3;
    if (!shouldComplete3) {
      animation2.easing("cubic-bezier(1, 0, 0.68, 0.28)");
      newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], clampedStep)[0];
    } else {
      animation2.easing("cubic-bezier(0.32, 0.72, 0, 1)");
      newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], clampedStep)[0];
    }
    const duration = shouldComplete3 ? computeDuration(step * height, velocity) : computeDuration((1 - clampedStep) * height, velocity);
    isOpen = shouldComplete3;
    gesture.enable(false);
    if (contentEl) {
      resetContentScrollY(contentEl, initialScrollY);
    }
    animation2.onFinish(() => {
      if (!shouldComplete3) {
        gesture.enable(true);
      }
    }).progressEnd(shouldComplete3 ? 1 : 0, newStepValue, duration);
    if (isAttemptingDismissWithCanDismiss && clampedStep > maxStep / 4) {
      handleCanDismiss(el2, animation2);
    } else if (shouldComplete3) {
      onDismiss();
    }
  };
  const gesture = createGesture({
    el: el2,
    gestureName: "modalSwipeToClose",
    gesturePriority: 39,
    direction: "y",
    threshold: 10,
    canStart,
    onStart,
    onMove,
    onEnd
  });
  return gesture;
};
const computeDuration = (remaining, velocity) => {
  return clamp$1(400, remaining / Math.abs(velocity * 1.1), 500);
};
const createSheetEnterAnimation = (opts) => {
  const { currentBreakpoint, backdropBreakpoint } = opts;
  const shouldShowBackdrop = backdropBreakpoint === void 0 || backdropBreakpoint < currentBreakpoint;
  const initialBackdrop = shouldShowBackdrop ? `calc(var(--backdrop-opacity) * ${currentBreakpoint})` : "0";
  const backdropAnimation = createAnimation("backdropAnimation").fromTo("opacity", 0, initialBackdrop);
  if (shouldShowBackdrop) {
    backdropAnimation.beforeStyles({
      "pointer-events": "none"
    }).afterClearStyles(["pointer-events"]);
  }
  const wrapperAnimation = createAnimation("wrapperAnimation").keyframes([
    { offset: 0, opacity: 1, transform: "translateY(100%)" },
    { offset: 1, opacity: 1, transform: `translateY(${100 - currentBreakpoint * 100}%)` }
  ]);
  return { wrapperAnimation, backdropAnimation };
};
const createSheetLeaveAnimation = (opts) => {
  const { currentBreakpoint, backdropBreakpoint } = opts;
  const backdropValue = `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(currentBreakpoint, backdropBreakpoint)})`;
  const defaultBackdrop = [
    { offset: 0, opacity: backdropValue },
    { offset: 1, opacity: 0 }
  ];
  const customBackdrop = [
    { offset: 0, opacity: backdropValue },
    { offset: backdropBreakpoint, opacity: 0 },
    { offset: 1, opacity: 0 }
  ];
  const backdropAnimation = createAnimation("backdropAnimation").keyframes(backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop);
  const wrapperAnimation = createAnimation("wrapperAnimation").keyframes([
    { offset: 0, opacity: 1, transform: `translateY(${100 - currentBreakpoint * 100}%)` },
    { offset: 1, opacity: 1, transform: `translateY(100%)` }
  ]);
  return { wrapperAnimation, backdropAnimation };
};
const createEnterAnimation$1 = () => {
  const backdropAnimation = createAnimation().fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  const wrapperAnimation = createAnimation().fromTo("transform", "translateY(100vh)", "translateY(0vh)");
  return { backdropAnimation, wrapperAnimation };
};
const iosEnterAnimation = (baseEl, opts) => {
  const { presentingEl, currentBreakpoint } = opts;
  const root2 = getElementRoot(baseEl);
  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== void 0 ? createSheetEnterAnimation(opts) : createEnterAnimation$1();
  backdropAnimation.addElement(root2.querySelector("ion-backdrop"));
  wrapperAnimation.addElement(root2.querySelectorAll(".modal-wrapper, .modal-shadow")).beforeStyles({ opacity: 1 });
  const baseAnimation2 = createAnimation("entering-base").addElement(baseEl).easing("cubic-bezier(0.32,0.72,0,1)").duration(500).addAnimation(wrapperAnimation);
  if (presentingEl) {
    const isMobile2 = window.innerWidth < 768;
    const hasCardModal = presentingEl.tagName === "ION-MODAL" && presentingEl.presentingElement !== void 0;
    const presentingElRoot = getElementRoot(presentingEl);
    const presentingAnimation = createAnimation().beforeStyles({
      transform: "translateY(0)",
      "transform-origin": "top center",
      overflow: "hidden"
    });
    const bodyEl = document.body;
    if (isMobile2) {
      const transformOffset = !CSS.supports("width", "max(0px, 1px)") ? "30px" : "max(30px, var(--ion-safe-area-top))";
      const modalTransform = hasCardModal ? "-10px" : transformOffset;
      const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
      const finalTransform = `translateY(${modalTransform}) scale(${toPresentingScale})`;
      presentingAnimation.afterStyles({
        transform: finalTransform
      }).beforeAddWrite(() => bodyEl.style.setProperty("background-color", "black")).addElement(presentingEl).keyframes([
        { offset: 0, filter: "contrast(1)", transform: "translateY(0px) scale(1)", borderRadius: "0px" },
        { offset: 1, filter: "contrast(0.85)", transform: finalTransform, borderRadius: "10px 10px 0 0" }
      ]);
      baseAnimation2.addAnimation(presentingAnimation);
    } else {
      baseAnimation2.addAnimation(backdropAnimation);
      if (!hasCardModal) {
        wrapperAnimation.fromTo("opacity", "0", "1");
      } else {
        const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;
        const finalTransform = `translateY(-10px) scale(${toPresentingScale})`;
        presentingAnimation.afterStyles({
          transform: finalTransform
        }).addElement(presentingElRoot.querySelector(".modal-wrapper")).keyframes([
          { offset: 0, filter: "contrast(1)", transform: "translateY(0) scale(1)" },
          { offset: 1, filter: "contrast(0.85)", transform: finalTransform }
        ]);
        const shadowAnimation = createAnimation().afterStyles({
          transform: finalTransform
        }).addElement(presentingElRoot.querySelector(".modal-shadow")).keyframes([
          { offset: 0, opacity: "1", transform: "translateY(0) scale(1)" },
          { offset: 1, opacity: "0", transform: finalTransform }
        ]);
        baseAnimation2.addAnimation([presentingAnimation, shadowAnimation]);
      }
    }
  } else {
    baseAnimation2.addAnimation(backdropAnimation);
  }
  return baseAnimation2;
};
const createLeaveAnimation$1 = () => {
  const backdropAnimation = createAnimation().fromTo("opacity", "var(--backdrop-opacity)", 0);
  const wrapperAnimation = createAnimation().fromTo("transform", "translateY(0vh)", "translateY(100vh)");
  return { backdropAnimation, wrapperAnimation };
};
const iosLeaveAnimation = (baseEl, opts, duration = 500) => {
  const { presentingEl, currentBreakpoint } = opts;
  const root2 = getElementRoot(baseEl);
  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== void 0 ? createSheetLeaveAnimation(opts) : createLeaveAnimation$1();
  backdropAnimation.addElement(root2.querySelector("ion-backdrop"));
  wrapperAnimation.addElement(root2.querySelectorAll(".modal-wrapper, .modal-shadow")).beforeStyles({ opacity: 1 });
  const baseAnimation2 = createAnimation("leaving-base").addElement(baseEl).easing("cubic-bezier(0.32,0.72,0,1)").duration(duration).addAnimation(wrapperAnimation);
  if (presentingEl) {
    const isMobile2 = window.innerWidth < 768;
    const hasCardModal = presentingEl.tagName === "ION-MODAL" && presentingEl.presentingElement !== void 0;
    const presentingElRoot = getElementRoot(presentingEl);
    const presentingAnimation = createAnimation().beforeClearStyles(["transform"]).afterClearStyles(["transform"]).onFinish((currentStep) => {
      if (currentStep !== 1) {
        return;
      }
      presentingEl.style.setProperty("overflow", "");
      const numModals = Array.from(bodyEl.querySelectorAll("ion-modal")).filter((m2) => m2.presentingElement !== void 0).length;
      if (numModals <= 1) {
        bodyEl.style.setProperty("background-color", "");
      }
    });
    const bodyEl = document.body;
    if (isMobile2) {
      const transformOffset = !CSS.supports("width", "max(0px, 1px)") ? "30px" : "max(30px, var(--ion-safe-area-top))";
      const modalTransform = hasCardModal ? "-10px" : transformOffset;
      const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
      const finalTransform = `translateY(${modalTransform}) scale(${toPresentingScale})`;
      presentingAnimation.addElement(presentingEl).keyframes([
        { offset: 0, filter: "contrast(0.85)", transform: finalTransform, borderRadius: "10px 10px 0 0" },
        { offset: 1, filter: "contrast(1)", transform: "translateY(0px) scale(1)", borderRadius: "0px" }
      ]);
      baseAnimation2.addAnimation(presentingAnimation);
    } else {
      baseAnimation2.addAnimation(backdropAnimation);
      if (!hasCardModal) {
        wrapperAnimation.fromTo("opacity", "1", "0");
      } else {
        const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;
        const finalTransform = `translateY(-10px) scale(${toPresentingScale})`;
        presentingAnimation.addElement(presentingElRoot.querySelector(".modal-wrapper")).afterStyles({
          transform: "translate3d(0, 0, 0)"
        }).keyframes([
          { offset: 0, filter: "contrast(0.85)", transform: finalTransform },
          { offset: 1, filter: "contrast(1)", transform: "translateY(0) scale(1)" }
        ]);
        const shadowAnimation = createAnimation().addElement(presentingElRoot.querySelector(".modal-shadow")).afterStyles({
          transform: "translateY(0) scale(1)"
        }).keyframes([
          { offset: 0, opacity: "0", transform: finalTransform },
          { offset: 1, opacity: "1", transform: "translateY(0) scale(1)" }
        ]);
        baseAnimation2.addAnimation([presentingAnimation, shadowAnimation]);
      }
    }
  } else {
    baseAnimation2.addAnimation(backdropAnimation);
  }
  return baseAnimation2;
};
const createEnterAnimation = () => {
  const backdropAnimation = createAnimation().fromTo("opacity", 0.01, "var(--backdrop-opacity)").beforeStyles({
    "pointer-events": "none"
  }).afterClearStyles(["pointer-events"]);
  const wrapperAnimation = createAnimation().keyframes([
    { offset: 0, opacity: 0.01, transform: "translateY(40px)" },
    { offset: 1, opacity: 1, transform: `translateY(0px)` }
  ]);
  return { backdropAnimation, wrapperAnimation };
};
const mdEnterAnimation = (baseEl, opts) => {
  const { currentBreakpoint } = opts;
  const root2 = getElementRoot(baseEl);
  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== void 0 ? createSheetEnterAnimation(opts) : createEnterAnimation();
  backdropAnimation.addElement(root2.querySelector("ion-backdrop"));
  wrapperAnimation.addElement(root2.querySelector(".modal-wrapper"));
  return createAnimation().addElement(baseEl).easing("cubic-bezier(0.36,0.66,0.04,1)").duration(280).addAnimation([backdropAnimation, wrapperAnimation]);
};
const createLeaveAnimation = () => {
  const backdropAnimation = createAnimation().fromTo("opacity", "var(--backdrop-opacity)", 0);
  const wrapperAnimation = createAnimation().keyframes([
    { offset: 0, opacity: 0.99, transform: `translateY(0px)` },
    { offset: 1, opacity: 0, transform: "translateY(40px)" }
  ]);
  return { backdropAnimation, wrapperAnimation };
};
const mdLeaveAnimation = (baseEl, opts) => {
  const { currentBreakpoint } = opts;
  const root2 = getElementRoot(baseEl);
  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== void 0 ? createSheetLeaveAnimation(opts) : createLeaveAnimation();
  backdropAnimation.addElement(root2.querySelector("ion-backdrop"));
  wrapperAnimation.addElement(root2.querySelector(".modal-wrapper"));
  return createAnimation().easing("cubic-bezier(0.47,0,0.745,0.715)").duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
};
const createSheetGesture = (baseEl, backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, animation2, breakpoints2 = [], getCurrentBreakpoint, onDismiss, onBreakpointChange) => {
  const defaultBackdrop = [
    { offset: 0, opacity: "var(--backdrop-opacity)" },
    { offset: 1, opacity: 0.01 }
  ];
  const customBackdrop = [
    { offset: 0, opacity: "var(--backdrop-opacity)" },
    { offset: 1 - backdropBreakpoint, opacity: 0 },
    { offset: 1, opacity: 0 }
  ];
  const SheetDefaults = {
    WRAPPER_KEYFRAMES: [
      { offset: 0, transform: "translateY(0%)" },
      { offset: 1, transform: "translateY(100%)" }
    ],
    BACKDROP_KEYFRAMES: backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop
  };
  const contentEl = baseEl.querySelector("ion-content");
  const height = wrapperEl.clientHeight;
  let currentBreakpoint = initialBreakpoint;
  let offset2 = 0;
  let canDismissBlocksGesture = false;
  const canDismissMaxStep = 0.95;
  const wrapperAnimation = animation2.childAnimations.find((ani) => ani.id === "wrapperAnimation");
  const backdropAnimation = animation2.childAnimations.find((ani) => ani.id === "backdropAnimation");
  const maxBreakpoint = breakpoints2[breakpoints2.length - 1];
  const minBreakpoint = breakpoints2[0];
  const enableBackdrop = () => {
    baseEl.style.setProperty("pointer-events", "auto");
    backdropEl.style.setProperty("pointer-events", "auto");
    baseEl.classList.remove("ion-disable-focus-trap");
  };
  const disableBackdrop = () => {
    baseEl.style.setProperty("pointer-events", "none");
    backdropEl.style.setProperty("pointer-events", "none");
    baseEl.classList.add("ion-disable-focus-trap");
  };
  if (wrapperAnimation && backdropAnimation) {
    wrapperAnimation.keyframes([...SheetDefaults.WRAPPER_KEYFRAMES]);
    backdropAnimation.keyframes([...SheetDefaults.BACKDROP_KEYFRAMES]);
    animation2.progressStart(true, 1 - currentBreakpoint);
    const shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;
    if (shouldEnableBackdrop) {
      enableBackdrop();
    } else {
      disableBackdrop();
    }
  }
  if (contentEl && currentBreakpoint !== maxBreakpoint) {
    contentEl.scrollY = false;
  }
  const canStart = (detail) => {
    const content = detail.event.target.closest("ion-content");
    currentBreakpoint = getCurrentBreakpoint();
    if (currentBreakpoint === 1 && content) {
      return false;
    }
    return true;
  };
  const onStart = () => {
    canDismissBlocksGesture = baseEl.canDismiss !== void 0 && baseEl.canDismiss !== true && minBreakpoint === 0;
    if (contentEl) {
      contentEl.scrollY = false;
    }
    raf(() => {
      baseEl.focus();
    });
    animation2.progressStart(true, 1 - currentBreakpoint);
  };
  const onMove = (detail) => {
    const initialStep = 1 - currentBreakpoint;
    const secondToLastBreakpoint = breakpoints2.length > 1 ? 1 - breakpoints2[1] : void 0;
    const step = initialStep + detail.deltaY / height;
    const isAttemptingDismissWithCanDismiss = secondToLastBreakpoint !== void 0 && step >= secondToLastBreakpoint && canDismissBlocksGesture;
    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;
    const processedStep = isAttemptingDismissWithCanDismiss && secondToLastBreakpoint !== void 0 ? secondToLastBreakpoint + calculateSpringStep((step - secondToLastBreakpoint) / (maxStep - secondToLastBreakpoint)) : step;
    offset2 = clamp$1(1e-4, processedStep, maxStep);
    animation2.progressStep(offset2);
  };
  const onEnd = (detail) => {
    const velocity = detail.velocityY;
    const threshold2 = (detail.deltaY + velocity * 350) / height;
    const diff2 = currentBreakpoint - threshold2;
    const closest = breakpoints2.reduce((a2, b2) => {
      return Math.abs(b2 - diff2) < Math.abs(a2 - diff2) ? b2 : a2;
    });
    moveSheetToBreakpoint({
      breakpoint: closest,
      breakpointOffset: offset2,
      canDismiss: canDismissBlocksGesture
    });
  };
  const moveSheetToBreakpoint = (options) => {
    const { breakpoint, canDismiss, breakpointOffset } = options;
    const shouldPreventDismiss = canDismiss && breakpoint === 0;
    const snapToBreakpoint = shouldPreventDismiss ? currentBreakpoint : breakpoint;
    const shouldRemainOpen = snapToBreakpoint !== 0;
    currentBreakpoint = 0;
    if (wrapperAnimation && backdropAnimation) {
      wrapperAnimation.keyframes([
        { offset: 0, transform: `translateY(${breakpointOffset * 100}%)` },
        { offset: 1, transform: `translateY(${(1 - snapToBreakpoint) * 100}%)` }
      ]);
      backdropAnimation.keyframes([
        {
          offset: 0,
          opacity: `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(1 - breakpointOffset, backdropBreakpoint)})`
        },
        {
          offset: 1,
          opacity: `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(snapToBreakpoint, backdropBreakpoint)})`
        }
      ]);
      animation2.progressStep(0);
    }
    gesture.enable(false);
    if (shouldPreventDismiss) {
      handleCanDismiss(baseEl, animation2);
    } else if (!shouldRemainOpen) {
      onDismiss();
    }
    return new Promise((resolve) => {
      animation2.onFinish(() => {
        if (shouldRemainOpen) {
          if (wrapperAnimation && backdropAnimation) {
            raf(() => {
              wrapperAnimation.keyframes([...SheetDefaults.WRAPPER_KEYFRAMES]);
              backdropAnimation.keyframes([...SheetDefaults.BACKDROP_KEYFRAMES]);
              animation2.progressStart(true, 1 - snapToBreakpoint);
              currentBreakpoint = snapToBreakpoint;
              onBreakpointChange(currentBreakpoint);
              if (contentEl && currentBreakpoint === breakpoints2[breakpoints2.length - 1]) {
                contentEl.scrollY = true;
              }
              const shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;
              if (shouldEnableBackdrop) {
                enableBackdrop();
              } else {
                disableBackdrop();
              }
              gesture.enable(true);
              resolve();
            });
          } else {
            gesture.enable(true);
            resolve();
          }
        } else {
          resolve();
        }
      }, { oneTimeCallback: true }).progressEnd(1, 0, 500);
    });
  };
  const gesture = createGesture({
    el: wrapperEl,
    gestureName: "modalSheet",
    gesturePriority: 40,
    direction: "y",
    threshold: 10,
    canStart,
    onStart,
    onMove,
    onEnd
  });
  return {
    gesture,
    moveSheetToBreakpoint
  };
};
const modalIosCss = ':host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);contain:strict}.modal-wrapper,ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);border:0;background:var(--ion-color-step-350, #c0c0be);cursor:pointer;z-index:11}.modal-handle::before{-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px;padding-top:4px;padding-bottom:4px;position:absolute;width:36px;height:5px;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);content:""}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.4)}:host(.modal-card),:host(.modal-sheet){--border-radius:10px}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:10px}}.modal-wrapper{-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0)}@media screen and (max-width: 767px){@supports (width: max(0px, 1px)){:host(.modal-card){--height:calc(100% - max(30px, var(--ion-safe-area-top)) - 10px)}}@supports not (width: max(0px, 1px)){:host(.modal-card){--height:calc(100% - 40px)}}:host(.modal-card) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-card) .modal-wrapper,:host-context([dir=rtl]).modal-card .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}@supports selector(:dir(rtl)){:host(.modal-card) .modal-wrapper:dir(rtl){border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}}:host(.modal-card){--backdrop-opacity:0;--width:100%;-ms-flex-align:end;align-items:flex-end}:host(.modal-card) .modal-shadow{display:none}:host(.modal-card) ion-backdrop{pointer-events:none}}@media screen and (min-width: 768px){:host(.modal-card){--width:calc(100% - 120px);--height:calc(100% - (120px + var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));--max-width:720px;--max-height:1000px;--backdrop-opacity:0;--box-shadow:0px 0px 30px 10px rgba(0, 0, 0, 0.1);-webkit-transition:all 0.5s ease-in-out;transition:all 0.5s ease-in-out}:host(.modal-card) .modal-wrapper{-webkit-box-shadow:none;box-shadow:none}:host(.modal-card) .modal-shadow{-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow)}}:host(.modal-sheet) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-sheet) .modal-wrapper,:host-context([dir=rtl]).modal-sheet .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}@supports selector(:dir(rtl)){:host(.modal-sheet) .modal-wrapper:dir(rtl){border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}}';
const modalMdCss = ':host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);contain:strict}.modal-wrapper,ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);border:0;background:var(--ion-color-step-350, #c0c0be);cursor:pointer;z-index:11}.modal-handle::before{-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px;padding-top:4px;padding-bottom:4px;position:absolute;width:36px;height:5px;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);content:""}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:2px;--box-shadow:0 28px 48px rgba(0, 0, 0, 0.4)}}.modal-wrapper{-webkit-transform:translate3d(0,  40px,  0);transform:translate3d(0,  40px,  0);opacity:0.01}';
const Modal = /* @__PURE__ */ proxyCustomElement$1(class Modal2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.didPresent = createEvent(this, "ionModalDidPresent", 7);
    this.willPresent = createEvent(this, "ionModalWillPresent", 7);
    this.willDismiss = createEvent(this, "ionModalWillDismiss", 7);
    this.didDismiss = createEvent(this, "ionModalDidDismiss", 7);
    this.ionBreakpointDidChange = createEvent(this, "ionBreakpointDidChange", 7);
    this.didPresentShorthand = createEvent(this, "didPresent", 7);
    this.willPresentShorthand = createEvent(this, "willPresent", 7);
    this.willDismissShorthand = createEvent(this, "willDismiss", 7);
    this.didDismissShorthand = createEvent(this, "didDismiss", 7);
    this.ionMount = createEvent(this, "ionMount", 7);
    this.triggerController = createTriggerController();
    this.coreDelegate = CoreDelegate();
    this.isSheetModal = false;
    this.inheritedAttributes = {};
    this.inline = false;
    this.gestureAnimationDismissing = false;
    this.onHandleClick = () => {
      const { sheetTransition, handleBehavior } = this;
      if (handleBehavior !== "cycle" || sheetTransition !== void 0) {
        return;
      }
      this.moveToNextBreakpoint();
    };
    this.onBackdropTap = () => {
      const { sheetTransition } = this;
      if (sheetTransition !== void 0) {
        return;
      }
      this.dismiss(void 0, BACKDROP);
    };
    this.onLifecycle = (modalEvent) => {
      const el2 = this.usersElement;
      const name = LIFECYCLE_MAP[modalEvent.type];
      if (el2 && name) {
        const ev = new CustomEvent(name, {
          bubbles: false,
          cancelable: false,
          detail: modalEvent.detail
        });
        el2.dispatchEvent(ev);
      }
    };
    this.presented = false;
    this.hasController = false;
    this.overlayIndex = void 0;
    this.delegate = void 0;
    this.keyboardClose = true;
    this.enterAnimation = void 0;
    this.leaveAnimation = void 0;
    this.breakpoints = void 0;
    this.initialBreakpoint = void 0;
    this.backdropBreakpoint = 0;
    this.handle = void 0;
    this.handleBehavior = "none";
    this.component = void 0;
    this.componentProps = void 0;
    this.cssClass = void 0;
    this.backdropDismiss = true;
    this.showBackdrop = true;
    this.animated = true;
    this.presentingElement = void 0;
    this.htmlAttributes = void 0;
    this.isOpen = false;
    this.trigger = void 0;
    this.keepContentsMounted = false;
    this.canDismiss = true;
  }
  onIsOpenChange(newValue, oldValue) {
    if (newValue === true && oldValue === false) {
      this.present();
    } else if (newValue === false && oldValue === true) {
      this.dismiss();
    }
  }
  triggerChanged() {
    const { trigger, el: el2, triggerController } = this;
    if (trigger) {
      triggerController.addClickListener(el2, trigger);
    }
  }
  breakpointsChanged(breakpoints2) {
    if (breakpoints2 !== void 0) {
      this.sortedBreakpoints = breakpoints2.sort((a2, b2) => a2 - b2);
    }
  }
  connectedCallback() {
    const { el: el2 } = this;
    prepareOverlay(el2);
    this.triggerChanged();
  }
  disconnectedCallback() {
    this.triggerController.removeClickListener();
  }
  componentWillLoad() {
    const { breakpoints: breakpoints2, initialBreakpoint, el: el2 } = this;
    const isSheetModal = this.isSheetModal = breakpoints2 !== void 0 && initialBreakpoint !== void 0;
    this.inheritedAttributes = inheritAttributes$2(el2, ["aria-label", "role"]);
    if (isSheetModal) {
      this.currentBreakpoint = this.initialBreakpoint;
    }
    if (breakpoints2 !== void 0 && initialBreakpoint !== void 0 && !breakpoints2.includes(initialBreakpoint)) {
      printIonWarning("Your breakpoints array must include the initialBreakpoint value.");
    }
    setOverlayId(el2);
  }
  componentDidLoad() {
    if (this.isOpen === true) {
      raf(() => this.present());
    }
    this.breakpointsChanged(this.breakpoints);
  }
  /**
   * Determines whether or not an overlay
   * is being used inline or via a controller/JS
   * and returns the correct delegate.
   * By default, subsequent calls to getDelegate
   * will use a cached version of the delegate.
   * This is useful for calling dismiss after
   * present so that the correct delegate is given.
   */
  getDelegate(force = false) {
    if (this.workingDelegate && !force) {
      return {
        delegate: this.workingDelegate,
        inline: this.inline
      };
    }
    const parentEl = this.el.parentNode;
    const inline = this.inline = parentEl !== null && !this.hasController;
    const delegate = this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate;
    return { inline, delegate };
  }
  /**
   * Determines whether or not the
   * modal is allowed to dismiss based
   * on the state of the canDismiss prop.
   */
  async checkCanDismiss(data2, role) {
    const { canDismiss } = this;
    if (typeof canDismiss === "function") {
      return canDismiss(data2, role);
    }
    return canDismiss;
  }
  /**
   * Present the modal overlay after it has been created.
   */
  async present() {
    if (this.presented) {
      return;
    }
    const { presentingElement, el: el2 } = this;
    if (this.currentTransition !== void 0) {
      await this.currentTransition;
    }
    this.currentBreakpoint = this.initialBreakpoint;
    const { inline, delegate } = this.getDelegate(true);
    this.usersElement = await attachComponent(delegate, el2, this.component, ["ion-page"], this.componentProps, inline);
    this.ionMount.emit();
    if (hasLazyBuild(el2)) {
      await deepReady(this.usersElement);
    } else if (!this.keepContentsMounted) {
      await waitForMount();
    }
    writeTask$1(() => this.el.classList.add("show-modal"));
    this.currentTransition = present(this, "modalEnter", iosEnterAnimation, mdEnterAnimation, {
      presentingEl: presentingElement,
      currentBreakpoint: this.initialBreakpoint,
      backdropBreakpoint: this.backdropBreakpoint
    });
    if (typeof window !== "undefined") {
      this.keyboardOpenCallback = () => {
        if (this.gesture) {
          this.gesture.enable(false);
          raf(() => {
            if (this.gesture) {
              this.gesture.enable(true);
            }
          });
        }
      };
      window.addEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);
    }
    const hasCardModal = presentingElement !== void 0;
    if (hasCardModal && getIonMode$2(this) === "ios") {
      this.statusBarStyle = await StatusBar.getStyle();
      setCardStatusBarDark();
    }
    await this.currentTransition;
    if (this.isSheetModal) {
      this.initSheetGesture();
    } else if (hasCardModal) {
      this.initSwipeToClose();
    }
    this.currentTransition = void 0;
  }
  initSwipeToClose() {
    var _a2;
    if (getIonMode$2(this) !== "ios") {
      return;
    }
    const { el: el2 } = this;
    const animationBuilder = this.leaveAnimation || config$1.get("modalLeave", iosLeaveAnimation);
    const ani = this.animation = animationBuilder(el2, { presentingEl: this.presentingElement });
    const contentEl = findIonContent(el2);
    if (!contentEl) {
      printIonContentErrorMsg(el2);
      return;
    }
    const statusBarStyle = (_a2 = this.statusBarStyle) !== null && _a2 !== void 0 ? _a2 : Style.Default;
    this.gesture = createSwipeToCloseGesture(el2, ani, statusBarStyle, () => {
      this.gestureAnimationDismissing = true;
      this.animation.onFinish(async () => {
        await this.dismiss(void 0, GESTURE);
        this.gestureAnimationDismissing = false;
      });
    });
    this.gesture.enable(true);
  }
  initSheetGesture() {
    const { wrapperEl, initialBreakpoint, backdropBreakpoint } = this;
    if (!wrapperEl || initialBreakpoint === void 0) {
      return;
    }
    const animationBuilder = this.enterAnimation || config$1.get("modalEnter", iosEnterAnimation);
    const ani = this.animation = animationBuilder(this.el, {
      presentingEl: this.presentingElement,
      currentBreakpoint: initialBreakpoint,
      backdropBreakpoint
    });
    ani.progressStart(true, 1);
    const { gesture, moveSheetToBreakpoint } = createSheetGesture(this.el, this.backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, ani, this.sortedBreakpoints, () => {
      var _a2;
      return (_a2 = this.currentBreakpoint) !== null && _a2 !== void 0 ? _a2 : 0;
    }, () => this.sheetOnDismiss(), (breakpoint) => {
      if (this.currentBreakpoint !== breakpoint) {
        this.currentBreakpoint = breakpoint;
        this.ionBreakpointDidChange.emit({ breakpoint });
      }
    });
    this.gesture = gesture;
    this.moveSheetToBreakpoint = moveSheetToBreakpoint;
    this.gesture.enable(true);
  }
  sheetOnDismiss() {
    this.gestureAnimationDismissing = true;
    this.animation.onFinish(async () => {
      this.currentBreakpoint = 0;
      this.ionBreakpointDidChange.emit({ breakpoint: this.currentBreakpoint });
      await this.dismiss(void 0, GESTURE);
      this.gestureAnimationDismissing = false;
    });
  }
  /**
   * Dismiss the modal overlay after it has been presented.
   *
   * @param data Any data to emit in the dismiss events.
   * @param role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.
   */
  async dismiss(data2, role) {
    var _a2;
    if (this.gestureAnimationDismissing && role !== GESTURE) {
      return false;
    }
    if (role !== "handler" && !await this.checkCanDismiss(data2, role)) {
      return false;
    }
    const { presentingElement } = this;
    const hasCardModal = presentingElement !== void 0;
    if (hasCardModal && getIonMode$2(this) === "ios") {
      setCardStatusBarDefault(this.statusBarStyle);
    }
    if (typeof window !== "undefined" && this.keyboardOpenCallback) {
      window.removeEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);
      this.keyboardOpenCallback = void 0;
    }
    if (this.currentTransition !== void 0) {
      await this.currentTransition;
    }
    const enteringAnimation = activeAnimations.get(this) || [];
    this.currentTransition = dismiss(this, data2, role, "modalLeave", iosLeaveAnimation, mdLeaveAnimation, {
      presentingEl: presentingElement,
      currentBreakpoint: (_a2 = this.currentBreakpoint) !== null && _a2 !== void 0 ? _a2 : this.initialBreakpoint,
      backdropBreakpoint: this.backdropBreakpoint
    });
    const dismissed = await this.currentTransition;
    if (dismissed) {
      const { delegate } = this.getDelegate();
      await detachComponent(delegate, this.usersElement);
      writeTask$1(() => this.el.classList.remove("show-modal"));
      if (this.animation) {
        this.animation.destroy();
      }
      if (this.gesture) {
        this.gesture.destroy();
      }
      enteringAnimation.forEach((ani) => ani.destroy());
    }
    this.currentBreakpoint = void 0;
    this.currentTransition = void 0;
    this.animation = void 0;
    return dismissed;
  }
  /**
   * Returns a promise that resolves when the modal did dismiss.
   */
  onDidDismiss() {
    return eventMethod(this.el, "ionModalDidDismiss");
  }
  /**
   * Returns a promise that resolves when the modal will dismiss.
   */
  onWillDismiss() {
    return eventMethod(this.el, "ionModalWillDismiss");
  }
  /**
   * Move a sheet style modal to a specific breakpoint. The breakpoint value must
   * be a value defined in your `breakpoints` array.
   */
  async setCurrentBreakpoint(breakpoint) {
    if (!this.isSheetModal) {
      printIonWarning("setCurrentBreakpoint is only supported on sheet modals.");
      return;
    }
    if (!this.breakpoints.includes(breakpoint)) {
      printIonWarning(`Attempted to set invalid breakpoint value ${breakpoint}. Please double check that the breakpoint value is part of your defined breakpoints.`);
      return;
    }
    const { currentBreakpoint, moveSheetToBreakpoint, canDismiss, breakpoints: breakpoints2 } = this;
    if (currentBreakpoint === breakpoint) {
      return;
    }
    if (moveSheetToBreakpoint) {
      this.sheetTransition = moveSheetToBreakpoint({
        breakpoint,
        breakpointOffset: 1 - currentBreakpoint,
        canDismiss: canDismiss !== void 0 && canDismiss !== true && breakpoints2[0] === 0
      });
      await this.sheetTransition;
      this.sheetTransition = void 0;
    }
  }
  /**
   * Returns the current breakpoint of a sheet style modal
   */
  async getCurrentBreakpoint() {
    return this.currentBreakpoint;
  }
  async moveToNextBreakpoint() {
    const { breakpoints: breakpoints2, currentBreakpoint } = this;
    if (!breakpoints2 || currentBreakpoint == null) {
      return false;
    }
    const allowedBreakpoints = breakpoints2.filter((b2) => b2 !== 0);
    const currentBreakpointIndex = allowedBreakpoints.indexOf(currentBreakpoint);
    const nextBreakpointIndex = (currentBreakpointIndex + 1) % allowedBreakpoints.length;
    const nextBreakpoint = allowedBreakpoints[nextBreakpointIndex];
    await this.setCurrentBreakpoint(nextBreakpoint);
    return true;
  }
  render() {
    const { handle, isSheetModal, presentingElement, htmlAttributes, handleBehavior, inheritedAttributes } = this;
    const showHandle = handle !== false && isSheetModal;
    const mode = getIonMode$2(this);
    const isCardModal = presentingElement !== void 0 && mode === "ios";
    const isHandleCycle = handleBehavior === "cycle";
    return h$5(Host$1, Object.assign({ "no-router": true, tabindex: "-1" }, htmlAttributes, { style: {
      zIndex: `${2e4 + this.overlayIndex}`
    }, class: Object.assign({ [mode]: true, ["modal-default"]: !isCardModal && !isSheetModal, [`modal-card`]: isCardModal, [`modal-sheet`]: isSheetModal, "overlay-hidden": true }, getClassMap(this.cssClass)), onIonBackdropTap: this.onBackdropTap, onIonModalDidPresent: this.onLifecycle, onIonModalWillPresent: this.onLifecycle, onIonModalWillDismiss: this.onLifecycle, onIonModalDidDismiss: this.onLifecycle }), h$5("ion-backdrop", { ref: (el2) => this.backdropEl = el2, visible: this.showBackdrop, tappable: this.backdropDismiss, part: "backdrop" }), mode === "ios" && h$5("div", { class: "modal-shadow" }), h$5("div", Object.assign({
      /*
        role and aria-modal must be used on the
        same element. They must also be set inside the
        shadow DOM otherwise ion-button will not be highlighted
        when using VoiceOver: https://bugs.webkit.org/show_bug.cgi?id=247134
      */
      role: "dialog"
    }, inheritedAttributes, { "aria-modal": "true", class: "modal-wrapper ion-overlay-wrapper", part: "content", ref: (el2) => this.wrapperEl = el2 }), showHandle && h$5("button", {
      class: "modal-handle",
      // Prevents the handle from receiving keyboard focus when it does not cycle
      tabIndex: !isHandleCycle ? -1 : 0,
      "aria-label": "Activate to adjust the size of the dialog overlaying the screen",
      onClick: isHandleCycle ? this.onHandleClick : void 0,
      part: "handle"
    }), h$5("slot", null)));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "isOpen": ["onIsOpenChange"],
      "trigger": ["triggerChanged"]
    };
  }
  static get style() {
    return {
      ios: modalIosCss,
      md: modalMdCss
    };
  }
}, [33, "ion-modal", {
  "hasController": [4, "has-controller"],
  "overlayIndex": [2, "overlay-index"],
  "delegate": [16],
  "keyboardClose": [4, "keyboard-close"],
  "enterAnimation": [16],
  "leaveAnimation": [16],
  "breakpoints": [16],
  "initialBreakpoint": [2, "initial-breakpoint"],
  "backdropBreakpoint": [2, "backdrop-breakpoint"],
  "handle": [4],
  "handleBehavior": [1, "handle-behavior"],
  "component": [1],
  "componentProps": [16],
  "cssClass": [1, "css-class"],
  "backdropDismiss": [4, "backdrop-dismiss"],
  "showBackdrop": [4, "show-backdrop"],
  "animated": [4],
  "presentingElement": [16],
  "htmlAttributes": [16],
  "isOpen": [4, "is-open"],
  "trigger": [1],
  "keepContentsMounted": [4, "keep-contents-mounted"],
  "canDismiss": [4, "can-dismiss"],
  "presented": [32],
  "present": [64],
  "dismiss": [64],
  "onDidDismiss": [64],
  "onWillDismiss": [64],
  "setCurrentBreakpoint": [64],
  "getCurrentBreakpoint": [64]
}]);
const LIFECYCLE_MAP = {
  ionModalDidPresent: "ionViewDidEnter",
  ionModalWillPresent: "ionViewWillEnter",
  ionModalWillDismiss: "ionViewWillLeave",
  ionModalDidDismiss: "ionViewDidLeave"
};
function defineCustomElement$1$6() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-modal", "ion-backdrop"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-modal":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Modal);
        }
        break;
      case "ion-backdrop":
        if (!customElements.get(tagName)) {
          defineCustomElement$17();
        }
        break;
    }
  });
}
const defineCustomElement$9 = defineCustomElement$1$6;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const defineCustomElement$8 = defineCustomElement$Q;
const appCss = "html.plt-mobile ion-app{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}html.plt-mobile ion-app [contenteditable]{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text}ion-app.force-statusbar-padding{--ion-safe-area-top:20px}";
const App = /* @__PURE__ */ proxyCustomElement$1(class App2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
  }
  componentDidLoad() {
    {
      rIC(async () => {
        const isHybrid2 = isPlatform(window, "hybrid");
        if (!config$1.getBoolean("_testing")) {
          __vitePreload(() => import("./index9-732fe637.js"), true ? [] : void 0).then((module2) => module2.startTapClick(config$1));
        }
        if (config$1.getBoolean("statusTap", isHybrid2)) {
          __vitePreload(() => import("./status-tap-f1d1675b.js"), true ? [] : void 0).then((module2) => module2.startStatusTap());
        }
        if (config$1.getBoolean("inputShims", needInputShims())) {
          const platform = isPlatform(window, "ios") ? "ios" : "android";
          __vitePreload(() => import("./input-shims-f8ebbcbc.js"), true ? [] : void 0).then((module2) => module2.startInputShims(config$1, platform));
        }
        const hardwareBackButtonModule = await __vitePreload(() => Promise.resolve().then(() => hardwareBackButton), true ? void 0 : void 0);
        if (config$1.getBoolean("hardwareBackButton", isHybrid2)) {
          hardwareBackButtonModule.startHardwareBackButton();
        } else {
          hardwareBackButtonModule.blockHardwareBackButton();
        }
        if (typeof window !== "undefined") {
          __vitePreload(() => Promise.resolve().then(() => keyboard2), true ? void 0 : void 0).then((module2) => module2.startKeyboardAssist(window));
        }
        __vitePreload(() => Promise.resolve().then(() => focusVisible), true ? void 0 : void 0).then((module2) => this.focusVisible = module2.startFocusVisible());
      });
    }
  }
  /**
   * @internal
   * Used to set focus on an element that uses `ion-focusable`.
   * Do not use this if focusing the element as a result of a keyboard
   * event as the focus utility should handle this for us. This method
   * should be used when we want to programmatically focus an element as
   * a result of another user action. (Ex: We focus the first element
   * inside of a popover when the user presents it, but the popover is not always
   * presented as a result of keyboard action.)
   */
  async setFocus(elements) {
    if (this.focusVisible) {
      this.focusVisible.setFocus(elements);
    }
  }
  render() {
    const mode = getIonMode$2(this);
    return h$5(Host$1, { class: {
      [mode]: true,
      "ion-page": true,
      "force-statusbar-padding": config$1.getBoolean("_forceStatusbarPadding")
    } });
  }
  get el() {
    return this;
  }
  static get style() {
    return appCss;
  }
}, [0, "ion-app", {
  "setFocus": [64]
}]);
const needInputShims = () => {
  const needsShimsIOS = isPlatform(window, "ios") && isPlatform(window, "mobile");
  if (needsShimsIOS) {
    return true;
  }
  const isAndroidMobileWeb = isPlatform(window, "android") && isPlatform(window, "mobileweb");
  if (isAndroidMobileWeb) {
    return true;
  }
  return false;
};
const rIC = (callback) => {
  if ("requestIdleCallback" in window) {
    window.requestIdleCallback(callback);
  } else {
    setTimeout(callback, 32);
  }
};
function defineCustomElement$1$5() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-app"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-app":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, App);
        }
        break;
    }
  });
}
const defineCustomElement$7 = defineCustomElement$1$5;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const backButtonIosCss = ':host{--background:transparent;--color-focused:currentColor;--color-hover:currentColor;--icon-margin-top:0;--icon-margin-bottom:0;--icon-padding-top:0;--icon-padding-end:0;--icon-padding-bottom:0;--icon-padding-start:0;--margin-top:0;--margin-end:0;--margin-bottom:0;--margin-start:0;--min-width:auto;--min-height:auto;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;--opacity:1;--ripple-color:currentColor;--transition:background-color, opacity 100ms linear;display:none;min-width:var(--min-width);min-height:var(--min-height);color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;text-transform:none;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-font-kerning:none;font-kerning:none}ion-ripple-effect{color:var(--ripple-color)}:host(.ion-color) .button-native{color:var(--ion-color-base)}:host(.show-back-button){display:block}:host(.back-button-disabled){cursor:default;opacity:0.5;pointer-events:none}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;min-height:inherit;-webkit-transition:var(--transition);transition:var(--transition);border:0;outline:none;background:var(--background);line-height:1;cursor:pointer;opacity:var(--opacity);overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}ion-icon{-webkit-padding-start:var(--icon-padding-start);padding-inline-start:var(--icon-padding-start);-webkit-padding-end:var(--icon-padding-end);padding-inline-end:var(--icon-padding-end);padding-top:var(--icon-padding-top);padding-bottom:var(--icon-padding-bottom);-webkit-margin-start:var(--icon-margin-start);margin-inline-start:var(--icon-margin-start);-webkit-margin-end:var(--icon-margin-end);margin-inline-end:var(--icon-margin-end);margin-top:var(--icon-margin-top);margin-bottom:var(--icon-margin-bottom);display:inherit;font-size:var(--icon-font-size);font-weight:var(--icon-font-weight);pointer-events:none}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}@media (any-hover: hover){:host(:hover) .button-native{color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-color.ion-focused) .button-native{color:var(--ion-color-base)}@media (any-hover: hover){:host(.ion-color:hover) .button-native{color:var(--ion-color-base)}}:host(.in-toolbar:not(.in-toolbar-color)){color:var(--ion-toolbar-color, var(--color))}:host{--background-hover:transparent;--background-hover-opacity:1;--background-focused:currentColor;--background-focused-opacity:.1;--border-radius:4px;--color:var(--ion-color-primary, #3880ff);--icon-margin-end:1px;--icon-margin-start:-4px;--icon-font-size:1.6em;--min-height:32px;font-size:17px}.button-native{-webkit-transform:translateZ(0);transform:translateZ(0);overflow:visible;z-index:99}:host(.ion-activated) .button-native{opacity:0.4}@media (any-hover: hover){:host(:hover){opacity:0.6}}:host(.ion-color.ion-focused) .button-native::after{background:var(--ion-color-base)}';
const backButtonMdCss = ':host{--background:transparent;--color-focused:currentColor;--color-hover:currentColor;--icon-margin-top:0;--icon-margin-bottom:0;--icon-padding-top:0;--icon-padding-end:0;--icon-padding-bottom:0;--icon-padding-start:0;--margin-top:0;--margin-end:0;--margin-bottom:0;--margin-start:0;--min-width:auto;--min-height:auto;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;--opacity:1;--ripple-color:currentColor;--transition:background-color, opacity 100ms linear;display:none;min-width:var(--min-width);min-height:var(--min-height);color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;text-transform:none;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-font-kerning:none;font-kerning:none}ion-ripple-effect{color:var(--ripple-color)}:host(.ion-color) .button-native{color:var(--ion-color-base)}:host(.show-back-button){display:block}:host(.back-button-disabled){cursor:default;opacity:0.5;pointer-events:none}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;min-height:inherit;-webkit-transition:var(--transition);transition:var(--transition);border:0;outline:none;background:var(--background);line-height:1;cursor:pointer;opacity:var(--opacity);overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}ion-icon{-webkit-padding-start:var(--icon-padding-start);padding-inline-start:var(--icon-padding-start);-webkit-padding-end:var(--icon-padding-end);padding-inline-end:var(--icon-padding-end);padding-top:var(--icon-padding-top);padding-bottom:var(--icon-padding-bottom);-webkit-margin-start:var(--icon-margin-start);margin-inline-start:var(--icon-margin-start);-webkit-margin-end:var(--icon-margin-end);margin-inline-end:var(--icon-margin-end);margin-top:var(--icon-margin-top);margin-bottom:var(--icon-margin-bottom);display:inherit;font-size:var(--icon-font-size);font-weight:var(--icon-font-weight);pointer-events:none}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}@media (any-hover: hover){:host(:hover) .button-native{color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-color.ion-focused) .button-native{color:var(--ion-color-base)}@media (any-hover: hover){:host(.ion-color:hover) .button-native{color:var(--ion-color-base)}}:host(.in-toolbar:not(.in-toolbar-color)){color:var(--ion-toolbar-color, var(--color))}:host{--border-radius:4px;--background-focused:currentColor;--background-focused-opacity:.12;--background-hover:currentColor;--background-hover-opacity:0.04;--color:currentColor;--icon-margin-end:0;--icon-margin-start:0;--icon-font-size:24px;--icon-font-weight:normal;--min-height:32px;--min-width:44px;--padding-start:12px;--padding-end:12px;font-size:14px;font-weight:500;text-transform:uppercase}:host(.back-button-has-icon-only){--border-radius:50%;min-width:48px;height:48px}.button-native{-webkit-box-shadow:none;box-shadow:none}.button-text{-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px;padding-top:0;padding-bottom:0}ion-icon{line-height:0.67;text-align:start}@media (any-hover: hover){:host(.ion-color:hover) .button-native::after{background:var(--ion-color-base)}}:host(.ion-color.ion-focused) .button-native::after{background:var(--ion-color-base)}';
const BackButton = /* @__PURE__ */ proxyCustomElement$1(class BackButton2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.inheritedAttributes = {};
    this.onClick = async (ev) => {
      const nav = this.el.closest("ion-nav");
      ev.preventDefault();
      if (nav && await nav.canGoBack()) {
        return nav.pop({ animationBuilder: this.routerAnimation, skipIfBusy: true });
      }
      return openURL(this.defaultHref, ev, "back", this.routerAnimation);
    };
    this.color = void 0;
    this.defaultHref = void 0;
    this.disabled = false;
    this.icon = void 0;
    this.text = void 0;
    this.type = "button";
    this.routerAnimation = void 0;
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAriaAttributes(this.el);
    if (this.defaultHref === void 0) {
      this.defaultHref = config$1.get("backButtonDefaultHref");
    }
  }
  get backButtonIcon() {
    const icon = this.icon;
    if (icon != null) {
      return icon;
    }
    if (getIonMode$2(this) === "ios") {
      return config$1.get("backButtonIcon", chevronBack);
    }
    return config$1.get("backButtonIcon", arrowBackSharp);
  }
  get backButtonText() {
    const defaultBackButtonText = getIonMode$2(this) === "ios" ? "Back" : null;
    return this.text != null ? this.text : config$1.get("backButtonText", defaultBackButtonText);
  }
  get hasIconOnly() {
    return this.backButtonIcon && !this.backButtonText;
  }
  get rippleType() {
    if (this.hasIconOnly) {
      return "unbounded";
    }
    return "bounded";
  }
  render() {
    const { color: color2, defaultHref, disabled, type: type3, hasIconOnly, backButtonIcon, backButtonText, icon, inheritedAttributes } = this;
    const showBackButton = defaultHref !== void 0;
    const mode = getIonMode$2(this);
    const ariaLabel = inheritedAttributes["aria-label"] || backButtonText || "back";
    return h$5(Host$1, { onClick: this.onClick, class: createColorClasses$1(color2, {
      [mode]: true,
      button: true,
      "back-button-disabled": disabled,
      "back-button-has-icon-only": hasIconOnly,
      "in-toolbar": hostContext("ion-toolbar", this.el),
      "in-toolbar-color": hostContext("ion-toolbar[color]", this.el),
      "ion-activatable": true,
      "ion-focusable": true,
      "show-back-button": showBackButton
    }) }, h$5("button", { type: type3, disabled, class: "button-native", part: "native", "aria-label": ariaLabel }, h$5("span", { class: "button-inner" }, backButtonIcon && h$5("ion-icon", { part: "icon", icon: backButtonIcon, "aria-hidden": "true", lazy: false, "flip-rtl": icon === void 0 }), backButtonText && h$5("span", { part: "text", "aria-hidden": "true", class: "button-text" }, backButtonText)), mode === "md" && h$5("ion-ripple-effect", { type: this.rippleType })));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: backButtonIosCss,
      md: backButtonMdCss
    };
  }
}, [33, "ion-back-button", {
  "color": [513],
  "defaultHref": [1025, "default-href"],
  "disabled": [516],
  "icon": [1],
  "text": [1],
  "type": [1],
  "routerAnimation": [16]
}]);
function defineCustomElement$1$4() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-back-button", "ion-icon", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-back-button":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, BackButton);
        }
        break;
      case "ion-icon":
        if (!customElements.get(tagName)) {
          defineCustomElement$1b();
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$Z();
        }
        break;
    }
  });
}
const defineCustomElement$6 = defineCustomElement$1$4;
const routeOutletCss = ":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}";
const RouterOutlet = /* @__PURE__ */ proxyCustomElement$1(class RouterOutlet2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionNavWillLoad = createEvent(this, "ionNavWillLoad", 7);
    this.ionNavWillChange = createEvent(this, "ionNavWillChange", 3);
    this.ionNavDidChange = createEvent(this, "ionNavDidChange", 3);
    this.gestureOrAnimationInProgress = false;
    this.mode = getIonMode$2(this);
    this.delegate = void 0;
    this.animated = true;
    this.animation = void 0;
    this.swipeHandler = void 0;
  }
  swipeHandlerChanged() {
    if (this.gesture) {
      this.gesture.enable(this.swipeHandler !== void 0);
    }
  }
  async connectedCallback() {
    const onStart = () => {
      this.gestureOrAnimationInProgress = true;
      if (this.swipeHandler) {
        this.swipeHandler.onStart();
      }
    };
    this.gesture = (await __vitePreload(() => import("./swipe-back-32076500.js"), true ? [] : void 0)).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), (step) => {
      var _a2;
      return (_a2 = this.ani) === null || _a2 === void 0 ? void 0 : _a2.progressStep(step);
    }, (shouldComplete3, step, dur) => {
      if (this.ani) {
        this.ani.onFinish(() => {
          this.gestureOrAnimationInProgress = false;
          if (this.swipeHandler) {
            this.swipeHandler.onEnd(shouldComplete3);
          }
        }, { oneTimeCallback: true });
        let newStepValue = shouldComplete3 ? -1e-3 : 1e-3;
        if (!shouldComplete3) {
          this.ani.easing("cubic-bezier(1, 0, 0.68, 0.28)");
          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];
        } else {
          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];
        }
        this.ani.progressEnd(shouldComplete3 ? 1 : 0, newStepValue, dur);
      } else {
        this.gestureOrAnimationInProgress = false;
      }
    });
    this.swipeHandlerChanged();
  }
  componentWillLoad() {
    this.ionNavWillLoad.emit();
  }
  disconnectedCallback() {
    if (this.gesture) {
      this.gesture.destroy();
      this.gesture = void 0;
    }
  }
  /** @internal */
  async commit(enteringEl, leavingEl, opts) {
    const unlock = await this.lock();
    let changed = false;
    try {
      changed = await this.transition(enteringEl, leavingEl, opts);
    } catch (e3) {
      console.error(e3);
    }
    unlock();
    return changed;
  }
  /** @internal */
  async setRouteId(id2, params, direction, animation2) {
    const changed = await this.setRoot(id2, params, {
      duration: direction === "root" ? 0 : void 0,
      direction: direction === "back" ? "back" : "forward",
      animationBuilder: animation2
    });
    return {
      changed,
      element: this.activeEl
    };
  }
  /** @internal */
  async getRouteId() {
    const active = this.activeEl;
    return active ? {
      id: active.tagName,
      element: active,
      params: this.activeParams
    } : void 0;
  }
  async setRoot(component, params, opts) {
    if (this.activeComponent === component && shallowEqualStringMap(params, this.activeParams)) {
      return false;
    }
    const leavingEl = this.activeEl;
    const enteringEl = await attachComponent(this.delegate, this.el, component, ["ion-page", "ion-page-invisible"], params);
    this.activeComponent = component;
    this.activeEl = enteringEl;
    this.activeParams = params;
    await this.commit(enteringEl, leavingEl, opts);
    await detachComponent(this.delegate, leavingEl);
    return true;
  }
  async transition(enteringEl, leavingEl, opts = {}) {
    if (leavingEl === enteringEl) {
      return false;
    }
    this.ionNavWillChange.emit();
    const { el: el2, mode } = this;
    const animated = this.animated && config$1.getBoolean("animated", true);
    const animationBuilder = opts.animationBuilder || this.animation || config$1.get("navAnimation");
    await transition$1(Object.assign(Object.assign({
      mode,
      animated,
      enteringEl,
      leavingEl,
      baseEl: el2,
      /**
       * We need to wait for all Stencil components
       * to be ready only when using the lazy
       * loaded bundle.
       */
      deepWait: hasLazyBuild(el2),
      progressCallback: opts.progressAnimation ? (ani) => {
        if (ani !== void 0 && !this.gestureOrAnimationInProgress) {
          this.gestureOrAnimationInProgress = true;
          ani.onFinish(() => {
            this.gestureOrAnimationInProgress = false;
            if (this.swipeHandler) {
              this.swipeHandler.onEnd(false);
            }
          }, { oneTimeCallback: true });
          ani.progressEnd(0, 0, 0);
        } else {
          this.ani = ani;
        }
      } : void 0
    }, opts), { animationBuilder }));
    this.ionNavDidChange.emit();
    return true;
  }
  async lock() {
    const p2 = this.waitPromise;
    let resolve;
    this.waitPromise = new Promise((r2) => resolve = r2);
    if (p2 !== void 0) {
      await p2;
    }
    return resolve;
  }
  render() {
    return h$5("slot", null);
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "swipeHandler": ["swipeHandlerChanged"]
    };
  }
  static get style() {
    return routeOutletCss;
  }
}, [1, "ion-router-outlet", {
  "mode": [1025],
  "delegate": [16],
  "animated": [4],
  "animation": [16],
  "swipeHandler": [16],
  "commit": [64],
  "setRouteId": [64],
  "getRouteId": [64]
}]);
function defineCustomElement$1$3() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-router-outlet"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-router-outlet":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, RouterOutlet);
        }
        break;
    }
  });
}
const defineCustomElement$5 = defineCustomElement$1$3;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const tabBarIosCss = ":host{-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom, 0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-color-step-50, #f7f7f7));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:0.55px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.2))));--color:var(--ion-tab-bar-color, var(--ion-color-step-600, #666666));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:50px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.tab-bar-translucent){--background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(210%) blur(20px);backdrop-filter:saturate(210%) blur(20px)}:host(.ion-color.tab-bar-translucent){background:rgba(var(--ion-color-base-rgb), 0.8)}:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.6)}}";
const tabBarMdCss = ":host{-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom, 0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-background-color, #fff));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:1px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.07))));--color:var(--ion-tab-bar-color, var(--ion-color-step-650, #595959));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:56px}";
const TabBar = /* @__PURE__ */ proxyCustomElement$1(class TabBar2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionTabBarChanged = createEvent(this, "ionTabBarChanged", 7);
    this.keyboardCtrl = null;
    this.keyboardVisible = false;
    this.color = void 0;
    this.selectedTab = void 0;
    this.translucent = false;
  }
  selectedTabChanged() {
    if (this.selectedTab !== void 0) {
      this.ionTabBarChanged.emit({
        tab: this.selectedTab
      });
    }
  }
  componentWillLoad() {
    this.selectedTabChanged();
  }
  async connectedCallback() {
    this.keyboardCtrl = await createKeyboardController(async (keyboardOpen2, waitForResize) => {
      if (keyboardOpen2 === false && waitForResize !== void 0) {
        await waitForResize;
      }
      this.keyboardVisible = keyboardOpen2;
    });
  }
  disconnectedCallback() {
    if (this.keyboardCtrl) {
      this.keyboardCtrl.destroy();
    }
  }
  render() {
    const { color: color2, translucent, keyboardVisible } = this;
    const mode = getIonMode$2(this);
    const shouldHide = keyboardVisible && this.el.getAttribute("slot") !== "top";
    return h$5(Host$1, { role: "tablist", "aria-hidden": shouldHide ? "true" : null, class: createColorClasses$1(color2, {
      [mode]: true,
      "tab-bar-translucent": translucent,
      "tab-bar-hidden": shouldHide
    }) }, h$5("slot", null));
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "selectedTab": ["selectedTabChanged"]
    };
  }
  static get style() {
    return {
      ios: tabBarIosCss,
      md: tabBarMdCss
    };
  }
}, [33, "ion-tab-bar", {
  "color": [513],
  "selectedTab": [1, "selected-tab"],
  "translucent": [4],
  "keyboardVisible": [32]
}]);
function defineCustomElement$1$2() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-tab-bar"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-tab-bar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, TabBar);
        }
        break;
    }
  });
}
const defineCustomElement$4 = defineCustomElement$1$2;
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const tabButtonIosCss = ':host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:2px;--padding-bottom:0;--padding-start:2px;max-width:240px;font-size:10px}::slotted(ion-badge){-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px;padding-top:1px;padding-bottom:1px;top:4px;height:auto;font-size:12px;line-height:16px}@supports (inset-inline-start: 0){::slotted(ion-badge){inset-inline-start:calc(50% + 6px)}}@supports not (inset-inline-start: 0){::slotted(ion-badge){left:calc(50% + 6px)}:host-context([dir=rtl]) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}[dir=rtl] ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}@supports selector(:dir(rtl)){::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:calc(50% + 6px)}}}::slotted(ion-icon){margin-top:2px;margin-bottom:2px;font-size:30px}::slotted(ion-icon::before){vertical-align:top}::slotted(ion-label){margin-top:0;margin-bottom:1px;min-height:11px;font-weight:500}:host(.tab-has-label-only) ::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:12px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-label),:host(.tab-layout-icon-start) ::slotted(ion-label),:host(.tab-layout-icon-hide) ::slotted(ion-label){margin-top:2px;margin-bottom:2px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-icon),:host(.tab-layout-icon-start) ::slotted(ion-icon){min-width:24px;height:26px;margin-top:2px;margin-bottom:1px;font-size:24px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-bottom) ::slotted(ion-badge){inset-inline-start:calc(50% + 12px)}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:calc(50% + 12px)}:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 12px)}@supports selector(:dir(rtl)){:host(.tab-layout-icon-bottom) ::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:calc(50% + 12px)}}}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:1px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:4px}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){top:10px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){inset-inline-start:calc(50% + 35px)}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){left:calc(50% + 35px)}:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 35px)}@supports selector(:dir(rtl)){:host(.tab-layout-icon-start) ::slotted(ion-badge):dir(rtl),:host(.tab-layout-icon-end) ::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:calc(50% + 35px)}}}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){top:10px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){inset-inline-start:calc(50% + 30px)}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){left:calc(50% + 30px)}:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 30px)}@supports selector(:dir(rtl)){:host(.tab-layout-icon-hide) ::slotted(ion-badge):dir(rtl),:host(.tab-has-label-only) ::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:calc(50% + 30px)}}}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:10px}:host(.tab-layout-label-hide) ::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}';
const tabButtonMdCss = ':host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:12px;--padding-bottom:0;--padding-start:12px;max-width:168px;font-size:12px;font-weight:normal;letter-spacing:0.03em}::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;text-transform:none}::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:16px;margin-bottom:16px;-webkit-transform-origin:center center;transform-origin:center center;font-size:22px}:host-context([dir=rtl]) ::slotted(ion-icon){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}[dir=rtl] ::slotted(ion-icon){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}@supports selector(:dir(rtl)){::slotted(ion-icon):dir(rtl){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}}::slotted(ion-badge){border-radius:8px;-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:2px;padding-inline-end:2px;padding-top:3px;padding-bottom:2px;top:8px;min-width:12px;font-size:8px;font-weight:normal}@supports (inset-inline-start: 0){::slotted(ion-badge){inset-inline-start:calc(50% + 6px)}}@supports not (inset-inline-start: 0){::slotted(ion-badge){left:calc(50% + 6px)}:host-context([dir=rtl]) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}[dir=rtl] ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}@supports selector(:dir(rtl)){::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:calc(50% + 6px)}}}::slotted(ion-badge:empty){display:block;min-width:8px;height:8px}:host(.tab-layout-icon-top) ::slotted(ion-icon){margin-top:6px;margin-bottom:2px}:host(.tab-layout-icon-top) ::slotted(ion-label){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){top:8px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-bottom) ::slotted(ion-badge){inset-inline-start:70%}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:70%}:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge){left:unset;right:unset;right:70%}@supports selector(:dir(rtl)){:host(.tab-layout-icon-bottom) ::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:70%}}}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:6px;margin-bottom:0}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){top:16px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){inset-inline-start:80%}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){left:80%}:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge){left:unset;right:unset;right:80%}@supports selector(:dir(rtl)){:host(.tab-layout-icon-start) ::slotted(ion-badge):dir(rtl),:host(.tab-layout-icon-end) ::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:80%}}}:host(.tab-layout-icon-start) ::slotted(ion-icon){-webkit-margin-end:6px;margin-inline-end:6px}:host(.tab-layout-icon-end) ::slotted(ion-icon){-webkit-margin-start:6px;margin-inline-start:6px}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){top:16px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){inset-inline-start:70%}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){left:70%}:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge){left:unset;right:unset;right:70%}@supports selector(:dir(rtl)){:host(.tab-layout-icon-hide) ::slotted(ion-badge):dir(rtl),:host(.tab-has-label-only) ::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:70%}}}:host(.tab-layout-icon-hide) ::slotted(ion-label),:host(.tab-has-label-only) ::slotted(ion-label){margin-top:0;margin-bottom:0}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:16px}:host(.tab-layout-label-hide) ::slotted(ion-icon),:host(.tab-has-icon-only) ::slotted(ion-icon){margin-top:0;margin-bottom:0;font-size:24px}';
const TabButton = /* @__PURE__ */ proxyCustomElement$1(class TabButton2 extends H$1 {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ionTabButtonClick = createEvent(this, "ionTabButtonClick", 7);
    this.inheritedAttributes = {};
    this.onKeyUp = (ev) => {
      if (ev.key === "Enter" || ev.key === " ") {
        this.selectTab(ev);
      }
    };
    this.onClick = (ev) => {
      this.selectTab(ev);
    };
    this.disabled = false;
    this.download = void 0;
    this.href = void 0;
    this.rel = void 0;
    this.layout = void 0;
    this.selected = false;
    this.tab = void 0;
    this.target = void 0;
  }
  onTabBarChanged(ev) {
    const dispatchedFrom = ev.target;
    const parent = this.el.parentElement;
    if (ev.composedPath().includes(parent) || (dispatchedFrom === null || dispatchedFrom === void 0 ? void 0 : dispatchedFrom.contains(this.el))) {
      this.selected = this.tab === ev.detail.tab;
    }
  }
  componentWillLoad() {
    this.inheritedAttributes = Object.assign({}, inheritAttributes$2(this.el, ["aria-label"]));
    if (this.layout === void 0) {
      this.layout = config$1.get("tabButtonLayout", "icon-top");
    }
  }
  selectTab(ev) {
    if (this.tab !== void 0) {
      if (!this.disabled) {
        this.ionTabButtonClick.emit({
          tab: this.tab,
          href: this.href,
          selected: this.selected
        });
      }
      ev.preventDefault();
    }
  }
  get hasLabel() {
    return !!this.el.querySelector("ion-label");
  }
  get hasIcon() {
    return !!this.el.querySelector("ion-icon");
  }
  render() {
    const { disabled, hasIcon, hasLabel, href, rel, target, layout, selected, tab, inheritedAttributes } = this;
    const mode = getIonMode$2(this);
    const attrs = {
      download: this.download,
      href,
      rel,
      target
    };
    return h$5(Host$1, { onClick: this.onClick, onKeyup: this.onKeyUp, id: tab !== void 0 ? `tab-button-${tab}` : null, class: {
      [mode]: true,
      "tab-selected": selected,
      "tab-disabled": disabled,
      "tab-has-label": hasLabel,
      "tab-has-icon": hasIcon,
      "tab-has-label-only": hasLabel && !hasIcon,
      "tab-has-icon-only": hasIcon && !hasLabel,
      [`tab-layout-${layout}`]: true,
      "ion-activatable": true,
      "ion-selectable": true,
      "ion-focusable": true
    } }, h$5("a", Object.assign({}, attrs, { class: "button-native", part: "native", role: "tab", "aria-selected": selected ? "true" : null, "aria-disabled": disabled ? "true" : null, tabindex: disabled ? "-1" : void 0 }, inheritedAttributes), h$5("span", { class: "button-inner" }, h$5("slot", null)), mode === "md" && h$5("ion-ripple-effect", { type: "unbounded" })));
  }
  get el() {
    return this;
  }
  static get style() {
    return {
      ios: tabButtonIosCss,
      md: tabButtonMdCss
    };
  }
}, [33, "ion-tab-button", {
  "disabled": [4],
  "download": [1],
  "href": [1],
  "rel": [1],
  "layout": [1025],
  "selected": [1028],
  "tab": [1],
  "target": [1]
}, [[8, "ionTabBarChanged", "onTabBarChanged"]]]);
function defineCustomElement$1$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-tab-button", "ion-ripple-effect"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-tab-button":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, TabButton);
        }
        break;
      case "ion-ripple-effect":
        if (!customElements.get(tagName)) {
          defineCustomElement$Z();
        }
        break;
    }
  });
}
const defineCustomElement$3 = defineCustomElement$1$1;
const BUILD = {
  allRenderFn: false,
  cmpDidLoad: true,
  cmpDidUnload: false,
  cmpDidUpdate: true,
  cmpDidRender: true,
  cmpWillLoad: true,
  cmpWillUpdate: true,
  cmpWillRender: true,
  connectedCallback: true,
  disconnectedCallback: true,
  element: true,
  event: true,
  hasRenderFn: true,
  lifecycle: true,
  hostListener: true,
  hostListenerTargetWindow: true,
  hostListenerTargetDocument: true,
  hostListenerTargetBody: true,
  hostListenerTargetParent: false,
  hostListenerTarget: true,
  member: true,
  method: true,
  mode: true,
  observeAttribute: true,
  prop: true,
  propMutable: true,
  reflect: true,
  scoped: true,
  shadowDom: true,
  slot: true,
  cssAnnotations: true,
  state: true,
  style: true,
  svg: true,
  updatable: true,
  vdomAttribute: true,
  vdomXlink: true,
  vdomClass: true,
  vdomFunctional: true,
  vdomKey: true,
  vdomListener: true,
  vdomRef: true,
  vdomPropOrAttr: true,
  vdomRender: true,
  vdomStyle: true,
  vdomText: true,
  watchCallback: true,
  taskQueue: true,
  hotModuleReplacement: false,
  isDebug: false,
  isDev: false,
  isTesting: false,
  hydrateServerSide: false,
  hydrateClientSide: false,
  lifecycleDOMEvents: false,
  lazyLoad: false,
  profile: false,
  slotRelocation: true,
  appendChildSlotFix: false,
  cloneNodeFix: false,
  hydratedAttribute: false,
  hydratedClass: true,
  safari10: false,
  scriptDataOpts: false,
  scopedSlotTextContentFix: false,
  shadowDomShim: false,
  slotChildNodesFix: false,
  invisiblePrehydration: true,
  propBoolean: true,
  propNumber: true,
  propString: true,
  cssVarShim: false,
  constructableCSS: true,
  cmpShouldUpdate: true,
  devTools: false,
  dynamicImportShim: false,
  shadowDelegatesFocus: true,
  initializeNextTick: false,
  asyncLoading: false,
  asyncQueue: false,
  transformTagName: false,
  attachStyles: true
};
let scopeId;
let contentRef;
let hostTagName;
let useNativeShadowDom = false;
let checkSlotFallbackVisibility = false;
let checkSlotRelocate = false;
let isSvgMode = false;
let renderingRef = null;
let queuePending = false;
const getAssetPath = (path3) => {
  const assetUrl = new URL(path3, plt.$resourcesUrl$);
  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
};
const createTime = (fnName, tagName = "") => {
  {
    return () => {
      return;
    };
  }
};
const XLINK_NS = "http://www.w3.org/1999/xlink";
const EMPTY_OBJ = {};
const SVG_NS = "http://www.w3.org/2000/svg";
const HTML_NS = "http://www.w3.org/1999/xhtml";
const isDef = (v2) => v2 != null;
const isComplexType = (o3) => {
  o3 = typeof o3;
  return o3 === "object" || o3 === "function";
};
function queryNonceMetaTagContent(doc2) {
  var _a2, _b, _c;
  return (_c = (_b = (_a2 = doc2.head) === null || _a2 === void 0 ? void 0 : _a2.querySelector('meta[name="csp-nonce"]')) === null || _b === void 0 ? void 0 : _b.getAttribute("content")) !== null && _c !== void 0 ? _c : void 0;
}
const h$4 = (nodeName, vnodeData, ...children) => {
  let child = null;
  let key = null;
  let slotName = null;
  let simple2 = false;
  let lastSimple = false;
  const vNodeChildren = [];
  const walk3 = (c2) => {
    for (let i = 0; i < c2.length; i++) {
      child = c2[i];
      if (Array.isArray(child)) {
        walk3(child);
      } else if (child != null && typeof child !== "boolean") {
        if (simple2 = typeof nodeName !== "function" && !isComplexType(child)) {
          child = String(child);
        }
        if (simple2 && lastSimple) {
          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
        } else {
          vNodeChildren.push(simple2 ? newVNode(null, child) : child);
        }
        lastSimple = simple2;
      }
    }
  };
  walk3(children);
  if (vnodeData) {
    if (vnodeData.key) {
      key = vnodeData.key;
    }
    if (vnodeData.name) {
      slotName = vnodeData.name;
    }
    {
      const classData = vnodeData.className || vnodeData.class;
      if (classData) {
        vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k2) => classData[k2]).join(" ");
      }
    }
  }
  if (typeof nodeName === "function") {
    return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
  }
  const vnode = newVNode(nodeName, null);
  vnode.$attrs$ = vnodeData;
  if (vNodeChildren.length > 0) {
    vnode.$children$ = vNodeChildren;
  }
  {
    vnode.$key$ = key;
  }
  {
    vnode.$name$ = slotName;
  }
  return vnode;
};
const newVNode = (tag, text) => {
  const vnode = {
    $flags$: 0,
    $tag$: tag,
    $text$: text,
    $elm$: null,
    $children$: null
  };
  {
    vnode.$attrs$ = null;
  }
  {
    vnode.$key$ = null;
  }
  {
    vnode.$name$ = null;
  }
  return vnode;
};
const Host = {};
const isHost = (node) => node && node.$tag$ === Host;
const vdomFnUtils = {
  forEach: (children, cb2) => children.map(convertToPublic).forEach(cb2),
  map: (children, cb2) => children.map(convertToPublic).map(cb2).map(convertToPrivate)
};
const convertToPublic = (node) => ({
  vattrs: node.$attrs$,
  vchildren: node.$children$,
  vkey: node.$key$,
  vname: node.$name$,
  vtag: node.$tag$,
  vtext: node.$text$
});
const convertToPrivate = (node) => {
  if (typeof node.vtag === "function") {
    const vnodeData = Object.assign({}, node.vattrs);
    if (node.vkey) {
      vnodeData.key = node.vkey;
    }
    if (node.vname) {
      vnodeData.name = node.vname;
    }
    return h$4(node.vtag, vnodeData, ...node.vchildren || []);
  }
  const vnode = newVNode(node.vtag, node.vtext);
  vnode.$attrs$ = node.vattrs;
  vnode.$children$ = node.vchildren;
  vnode.$key$ = node.vkey;
  vnode.$name$ = node.vname;
  return vnode;
};
const computeMode = (elm) => modeResolutionChain.map((h2) => h2(elm)).find((m2) => !!m2);
const parsePropertyValue = (propValue, propType) => {
  if (propValue != null && !isComplexType(propValue)) {
    if (propType & 4) {
      return propValue === "false" ? false : propValue === "" || !!propValue;
    }
    if (propType & 2) {
      return parseFloat(propValue);
    }
    if (propType & 1) {
      return String(propValue);
    }
    return propValue;
  }
  return propValue;
};
const rootAppliedStyles = /* @__PURE__ */ new WeakMap();
const registerStyle = (scopeId2, cssText, allowCS) => {
  let style = styles.get(scopeId2);
  if (supportsConstructableStylesheets && allowCS) {
    style = style || new CSSStyleSheet();
    if (typeof style === "string") {
      style = cssText;
    } else {
      style.replaceSync(cssText);
    }
  } else {
    style = cssText;
  }
  styles.set(scopeId2, style);
};
const addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {
  var _a2;
  let scopeId2 = getScopeId(cmpMeta, mode);
  const style = styles.get(scopeId2);
  styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc;
  if (style) {
    if (typeof style === "string") {
      styleContainerNode = styleContainerNode.head || styleContainerNode;
      let appliedStyles = rootAppliedStyles.get(styleContainerNode);
      let styleElm;
      if (!appliedStyles) {
        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
      }
      if (!appliedStyles.has(scopeId2)) {
        {
          {
            styleElm = doc.createElement("style");
            styleElm.innerHTML = style;
          }
          const nonce = (_a2 = plt.$nonce$) !== null && _a2 !== void 0 ? _a2 : queryNonceMetaTagContent(doc);
          if (nonce != null) {
            styleElm.setAttribute("nonce", nonce);
          }
          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
        }
        if (appliedStyles) {
          appliedStyles.add(scopeId2);
        }
      }
    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
    }
  }
  return scopeId2;
};
const attachStyles = (hostRef) => {
  const cmpMeta = hostRef.$cmpMeta$;
  const elm = hostRef.$hostElement$;
  const flags2 = cmpMeta.$flags$;
  const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
  const scopeId2 = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$);
  if (flags2 & 10) {
    elm["s-sc"] = scopeId2;
    elm.classList.add(scopeId2 + "-h");
    if (flags2 & 2) {
      elm.classList.add(scopeId2 + "-s");
    }
  }
  endAttachStyles();
};
const getScopeId = (cmp, mode) => "sc-" + (mode && cmp.$flags$ & 32 ? cmp.$tagName$ + "-" + mode : cmp.$tagName$);
const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags2) => {
  if (oldValue !== newValue) {
    let isProp = isMemberInElement(elm, memberName);
    let ln2 = memberName.toLowerCase();
    if (memberName === "class") {
      const classList = elm.classList;
      const oldClasses = parseClassList(oldValue);
      const newClasses = parseClassList(newValue);
      classList.remove(...oldClasses.filter((c2) => c2 && !newClasses.includes(c2)));
      classList.add(...newClasses.filter((c2) => c2 && !oldClasses.includes(c2)));
    } else if (memberName === "style") {
      {
        for (const prop3 in oldValue) {
          if (!newValue || newValue[prop3] == null) {
            if (prop3.includes("-")) {
              elm.style.removeProperty(prop3);
            } else {
              elm.style[prop3] = "";
            }
          }
        }
      }
      for (const prop3 in newValue) {
        if (!oldValue || newValue[prop3] !== oldValue[prop3]) {
          if (prop3.includes("-")) {
            elm.style.setProperty(prop3, newValue[prop3]);
          } else {
            elm.style[prop3] = newValue[prop3];
          }
        }
      }
    } else if (memberName === "key")
      ;
    else if (memberName === "ref") {
      if (newValue) {
        newValue(elm);
      }
    } else if (!elm.__lookupSetter__(memberName) && memberName[0] === "o" && memberName[1] === "n") {
      if (memberName[2] === "-") {
        memberName = memberName.slice(3);
      } else if (isMemberInElement(win, ln2)) {
        memberName = ln2.slice(2);
      } else {
        memberName = ln2[2] + memberName.slice(3);
      }
      if (oldValue) {
        plt.rel(elm, memberName, oldValue, false);
      }
      if (newValue) {
        plt.ael(elm, memberName, newValue, false);
      }
    } else {
      const isComplex = isComplexType(newValue);
      if ((isProp || isComplex && newValue !== null) && !isSvg) {
        try {
          if (!elm.tagName.includes("-")) {
            const n2 = newValue == null ? "" : newValue;
            if (memberName === "list") {
              isProp = false;
            } else if (oldValue == null || elm[memberName] != n2) {
              elm[memberName] = n2;
            }
          } else {
            elm[memberName] = newValue;
          }
        } catch (e3) {
        }
      }
      let xlink = false;
      {
        if (ln2 !== (ln2 = ln2.replace(/^xlink\:?/, ""))) {
          memberName = ln2;
          xlink = true;
        }
      }
      if (newValue == null || newValue === false) {
        if (newValue !== false || elm.getAttribute(memberName) === "") {
          if (xlink) {
            elm.removeAttributeNS(XLINK_NS, memberName);
          } else {
            elm.removeAttribute(memberName);
          }
        }
      } else if ((!isProp || flags2 & 4 || isSvg) && !isComplex) {
        newValue = newValue === true ? "" : newValue;
        if (xlink) {
          elm.setAttributeNS(XLINK_NS, memberName, newValue);
        } else {
          elm.setAttribute(memberName, newValue);
        }
      }
    }
  }
};
const parseClassListRegex = /\s/;
const parseClassList = (value) => !value ? [] : value.split(parseClassListRegex);
const updateElement = (oldVnode, newVnode, isSvgMode2, memberName) => {
  const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
  {
    for (memberName in oldVnodeAttrs) {
      if (!(memberName in newVnodeAttrs)) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
      }
    }
  }
  for (memberName in newVnodeAttrs) {
    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
  }
};
const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
  const newVNode2 = newParentVNode.$children$[childIndex];
  let i = 0;
  let elm;
  let childNode;
  let oldVNode;
  if (!useNativeShadowDom) {
    checkSlotRelocate = true;
    if (newVNode2.$tag$ === "slot") {
      if (scopeId) {
        parentElm.classList.add(scopeId + "-s");
      }
      newVNode2.$flags$ |= newVNode2.$children$ ? (
        // slot element has fallback content
        2
      ) : (
        // slot element does not have fallback content
        1
      );
    }
  }
  if (newVNode2.$text$ !== null) {
    elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);
  } else if (newVNode2.$flags$ & 1) {
    elm = newVNode2.$elm$ = doc.createTextNode("");
  } else {
    if (!isSvgMode) {
      isSvgMode = newVNode2.$tag$ === "svg";
    }
    elm = newVNode2.$elm$ = doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$);
    if (isSvgMode && newVNode2.$tag$ === "foreignObject") {
      isSvgMode = false;
    }
    {
      updateElement(null, newVNode2, isSvgMode);
    }
    if (isDef(scopeId) && elm["s-si"] !== scopeId) {
      elm.classList.add(elm["s-si"] = scopeId);
    }
    if (newVNode2.$children$) {
      for (i = 0; i < newVNode2.$children$.length; ++i) {
        childNode = createElm(oldParentVNode, newVNode2, i, elm);
        if (childNode) {
          elm.appendChild(childNode);
        }
      }
    }
    {
      if (newVNode2.$tag$ === "svg") {
        isSvgMode = false;
      } else if (elm.tagName === "foreignObject") {
        isSvgMode = true;
      }
    }
  }
  {
    elm["s-hn"] = hostTagName;
    if (newVNode2.$flags$ & (2 | 1)) {
      elm["s-sr"] = true;
      elm["s-cr"] = contentRef;
      elm["s-sn"] = newVNode2.$name$ || "";
      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
        putBackInOriginalLocation(oldParentVNode.$elm$, false);
      }
    }
  }
  return elm;
};
const putBackInOriginalLocation = (parentElm, recursive) => {
  plt.$flags$ |= 1;
  const oldSlotChildNodes = parentElm.childNodes;
  for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {
    const childNode = oldSlotChildNodes[i];
    if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
      parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
      childNode["s-ol"].remove();
      childNode["s-ol"] = void 0;
      checkSlotRelocate = true;
    }
    if (recursive) {
      putBackInOriginalLocation(childNode, recursive);
    }
  }
  plt.$flags$ &= ~1;
};
const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
  let containerElm = parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
  let childNode;
  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
    containerElm = containerElm.shadowRoot;
  }
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnodes[startIdx]) {
      childNode = createElm(null, parentVNode, startIdx, parentElm);
      if (childNode) {
        vnodes[startIdx].$elm$ = childNode;
        containerElm.insertBefore(childNode, referenceNode(before));
      }
    }
  }
};
const removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnode = vnodes[startIdx]) {
      elm = vnode.$elm$;
      callNodeRefs(vnode);
      {
        checkSlotFallbackVisibility = true;
        if (elm["s-ol"]) {
          elm["s-ol"].remove();
        } else {
          putBackInOriginalLocation(elm, true);
        }
      }
      elm.remove();
    }
  }
};
const updateChildren = (parentElm, oldCh, newVNode2, newCh) => {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let idxInOld = 0;
  let i = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let node;
  let elmToMove;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newStartVnode)) {
      patch(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (isSameVnode(oldEndVnode, newEndVnode)) {
      patch(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newEndVnode)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
      }
      patch(oldStartVnode, newEndVnode);
      parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldEndVnode, newStartVnode)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
      }
      patch(oldEndVnode, newStartVnode);
      parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      idxInOld = -1;
      {
        for (i = oldStartIdx; i <= oldEndIdx; ++i) {
          if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
            idxInOld = i;
            break;
          }
        }
      }
      if (idxInOld >= 0) {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.$tag$ !== newStartVnode.$tag$) {
          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);
        } else {
          patch(elmToMove, newStartVnode);
          oldCh[idxInOld] = void 0;
          node = elmToMove.$elm$;
        }
        newStartVnode = newCh[++newStartIdx];
      } else {
        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);
        newStartVnode = newCh[++newStartIdx];
      }
      if (node) {
        {
          parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
        }
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
  }
};
const isSameVnode = (leftVNode, rightVNode) => {
  if (leftVNode.$tag$ === rightVNode.$tag$) {
    if (leftVNode.$tag$ === "slot") {
      return leftVNode.$name$ === rightVNode.$name$;
    }
    {
      return leftVNode.$key$ === rightVNode.$key$;
    }
  }
  return false;
};
const referenceNode = (node) => {
  return node && node["s-ol"] || node;
};
const parentReferenceNode = (node) => (node["s-ol"] ? node["s-ol"] : node).parentNode;
const patch = (oldVNode, newVNode2) => {
  const elm = newVNode2.$elm$ = oldVNode.$elm$;
  const oldChildren = oldVNode.$children$;
  const newChildren = newVNode2.$children$;
  const tag = newVNode2.$tag$;
  const text = newVNode2.$text$;
  let defaultHolder;
  if (text === null) {
    {
      isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
    }
    {
      if (tag === "slot")
        ;
      else {
        updateElement(oldVNode, newVNode2, isSvgMode);
      }
    }
    if (oldChildren !== null && newChildren !== null) {
      updateChildren(elm, oldChildren, newVNode2, newChildren);
    } else if (newChildren !== null) {
      if (oldVNode.$text$ !== null) {
        elm.textContent = "";
      }
      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
    } else if (oldChildren !== null) {
      removeVnodes(oldChildren, 0, oldChildren.length - 1);
    }
    if (isSvgMode && tag === "svg") {
      isSvgMode = false;
    }
  } else if (defaultHolder = elm["s-cr"]) {
    defaultHolder.parentNode.textContent = text;
  } else if (oldVNode.$text$ !== text) {
    elm.data = text;
  }
};
const updateFallbackSlotVisibility = (elm) => {
  const childNodes = elm.childNodes;
  let childNode;
  let i;
  let ilen;
  let j2;
  let slotNameAttr;
  let nodeType;
  for (i = 0, ilen = childNodes.length; i < ilen; i++) {
    childNode = childNodes[i];
    if (childNode.nodeType === 1) {
      if (childNode["s-sr"]) {
        slotNameAttr = childNode["s-sn"];
        childNode.hidden = false;
        for (j2 = 0; j2 < ilen; j2++) {
          nodeType = childNodes[j2].nodeType;
          if (childNodes[j2]["s-hn"] !== childNode["s-hn"] || slotNameAttr !== "") {
            if (nodeType === 1 && slotNameAttr === childNodes[j2].getAttribute("slot")) {
              childNode.hidden = true;
              break;
            }
          } else {
            if (nodeType === 1 || nodeType === 3 && childNodes[j2].textContent.trim() !== "") {
              childNode.hidden = true;
              break;
            }
          }
        }
      }
      updateFallbackSlotVisibility(childNode);
    }
  }
};
const relocateNodes = [];
const relocateSlotContent = (elm) => {
  let childNode;
  let node;
  let hostContentNodes;
  let slotNameAttr;
  let relocateNodeData;
  let j2;
  let i = 0;
  const childNodes = elm.childNodes;
  const ilen = childNodes.length;
  for (; i < ilen; i++) {
    childNode = childNodes[i];
    if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
      hostContentNodes = node.parentNode.childNodes;
      slotNameAttr = childNode["s-sn"];
      for (j2 = hostContentNodes.length - 1; j2 >= 0; j2--) {
        node = hostContentNodes[j2];
        if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"]) {
          if (isNodeLocatedInSlot(node, slotNameAttr)) {
            relocateNodeData = relocateNodes.find((r2) => r2.$nodeToRelocate$ === node);
            checkSlotFallbackVisibility = true;
            node["s-sn"] = node["s-sn"] || slotNameAttr;
            if (relocateNodeData) {
              relocateNodeData.$slotRefNode$ = childNode;
            } else {
              relocateNodes.push({
                $slotRefNode$: childNode,
                $nodeToRelocate$: node
              });
            }
            if (node["s-sr"]) {
              relocateNodes.map((relocateNode) => {
                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                  relocateNodeData = relocateNodes.find((r2) => r2.$nodeToRelocate$ === node);
                  if (relocateNodeData && !relocateNode.$slotRefNode$) {
                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                  }
                }
              });
            }
          } else if (!relocateNodes.some((r2) => r2.$nodeToRelocate$ === node)) {
            relocateNodes.push({
              $nodeToRelocate$: node
            });
          }
        }
      }
    }
    if (childNode.nodeType === 1) {
      relocateSlotContent(childNode);
    }
  }
};
const isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {
  if (nodeToRelocate.nodeType === 1) {
    if (nodeToRelocate.getAttribute("slot") === null && slotNameAttr === "") {
      return true;
    }
    if (nodeToRelocate.getAttribute("slot") === slotNameAttr) {
      return true;
    }
    return false;
  }
  if (nodeToRelocate["s-sn"] === slotNameAttr) {
    return true;
  }
  return slotNameAttr === "";
};
const callNodeRefs = (vNode) => {
  {
    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
    vNode.$children$ && vNode.$children$.map(callNodeRefs);
  }
};
const renderVdom = (hostRef, renderFnResults) => {
  const hostElm = hostRef.$hostElement$;
  const cmpMeta = hostRef.$cmpMeta$;
  const oldVNode = hostRef.$vnode$ || newVNode(null, null);
  const rootVnode = isHost(renderFnResults) ? renderFnResults : h$4(null, null, renderFnResults);
  hostTagName = hostElm.tagName;
  if (cmpMeta.$attrsToReflect$) {
    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
    cmpMeta.$attrsToReflect$.map(([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]);
  }
  rootVnode.$tag$ = null;
  rootVnode.$flags$ |= 4;
  hostRef.$vnode$ = rootVnode;
  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
  {
    scopeId = hostElm["s-sc"];
  }
  {
    contentRef = hostElm["s-cr"];
    useNativeShadowDom = (cmpMeta.$flags$ & 1) !== 0;
    checkSlotFallbackVisibility = false;
  }
  patch(oldVNode, rootVnode);
  {
    plt.$flags$ |= 1;
    if (checkSlotRelocate) {
      relocateSlotContent(rootVnode.$elm$);
      let relocateData;
      let nodeToRelocate;
      let orgLocationNode;
      let parentNodeRef;
      let insertBeforeNode;
      let refNode;
      let i = 0;
      for (; i < relocateNodes.length; i++) {
        relocateData = relocateNodes[i];
        nodeToRelocate = relocateData.$nodeToRelocate$;
        if (!nodeToRelocate["s-ol"]) {
          orgLocationNode = doc.createTextNode("");
          orgLocationNode["s-nr"] = nodeToRelocate;
          nodeToRelocate.parentNode.insertBefore(nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
        }
      }
      for (i = 0; i < relocateNodes.length; i++) {
        relocateData = relocateNodes[i];
        nodeToRelocate = relocateData.$nodeToRelocate$;
        if (relocateData.$slotRefNode$) {
          parentNodeRef = relocateData.$slotRefNode$.parentNode;
          insertBeforeNode = relocateData.$slotRefNode$.nextSibling;
          orgLocationNode = nodeToRelocate["s-ol"];
          while (orgLocationNode = orgLocationNode.previousSibling) {
            refNode = orgLocationNode["s-nr"];
            if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === refNode.parentNode) {
              refNode = refNode.nextSibling;
              if (!refNode || !refNode["s-nr"]) {
                insertBeforeNode = refNode;
                break;
              }
            }
          }
          if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
            if (nodeToRelocate !== insertBeforeNode) {
              if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
              }
              parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
            }
          }
        } else {
          if (nodeToRelocate.nodeType === 1) {
            nodeToRelocate.hidden = true;
          }
        }
      }
    }
    if (checkSlotFallbackVisibility) {
      updateFallbackSlotVisibility(rootVnode.$elm$);
    }
    plt.$flags$ &= ~1;
    relocateNodes.length = 0;
  }
};
const attachToAncestor = (hostRef, ancestorComponent) => {
};
const scheduleUpdate = (hostRef, isInitialLoad) => {
  {
    hostRef.$flags$ |= 16;
  }
  attachToAncestor(hostRef, hostRef.$ancestorComponent$);
  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
  return writeTask(dispatch);
};
const dispatchHooks = (hostRef, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
  const instance = elm;
  let promise3;
  if (isInitialLoad) {
    {
      promise3 = safeCall(instance, "componentWillLoad");
    }
  } else {
    {
      promise3 = safeCall(instance, "componentWillUpdate");
    }
  }
  {
    promise3 = then(promise3, () => safeCall(instance, "componentWillRender"));
  }
  endSchedule();
  return then(promise3, () => updateComponent(hostRef, instance, isInitialLoad));
};
const updateComponent = async (hostRef, instance, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
  elm["s-rc"];
  if (isInitialLoad) {
    attachStyles(hostRef);
  }
  const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
  {
    callRender(hostRef, instance, elm);
  }
  endRender();
  endUpdate();
  {
    postUpdateComponent(hostRef);
  }
};
const callRender = (hostRef, instance, elm) => {
  const allRenderFn = false;
  const lazyLoad = false;
  const taskQueue = true;
  const updatable = true;
  try {
    renderingRef = instance;
    instance = allRenderFn ? instance.render() : instance.render && instance.render();
    if (updatable && taskQueue) {
      hostRef.$flags$ &= ~16;
    }
    if (updatable || lazyLoad) {
      hostRef.$flags$ |= 2;
    }
    if (BUILD.hasRenderFn || BUILD.reflect) {
      if (BUILD.vdomRender || BUILD.reflect) {
        if (BUILD.hydrateServerSide)
          ;
        else {
          renderVdom(hostRef, instance);
        }
      }
    }
  } catch (e3) {
    consoleError(e3, hostRef.$hostElement$);
  }
  renderingRef = null;
  return null;
};
const postUpdateComponent = (hostRef) => {
  const tagName = hostRef.$cmpMeta$.$tagName$;
  const elm = hostRef.$hostElement$;
  const endPostUpdate = createTime("postUpdate", tagName);
  const instance = elm;
  hostRef.$ancestorComponent$;
  {
    safeCall(instance, "componentDidRender");
  }
  if (!(hostRef.$flags$ & 64)) {
    hostRef.$flags$ |= 64;
    {
      safeCall(instance, "componentDidLoad");
    }
    endPostUpdate();
  } else {
    {
      safeCall(instance, "componentDidUpdate");
    }
    endPostUpdate();
  }
};
const safeCall = (instance, method, arg) => {
  if (instance && instance[method]) {
    try {
      return instance[method](arg);
    } catch (e3) {
      consoleError(e3);
    }
  }
  return void 0;
};
const then = (promise3, thenFn) => {
  return promise3 && promise3.then ? promise3.then(thenFn) : thenFn();
};
const getValue$2 = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
const setValue = (ref, propName, newVal, cmpMeta) => {
  const hostRef = getHostRef(ref);
  const elm = ref;
  const oldVal = hostRef.$instanceValues$.get(propName);
  const flags2 = hostRef.$flags$;
  const instance = elm;
  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
  const didValueChange = newVal !== oldVal && !areBothNaN;
  if (didValueChange) {
    hostRef.$instanceValues$.set(propName, newVal);
    {
      if (cmpMeta.$watchers$ && flags2 & 128) {
        const watchMethods = cmpMeta.$watchers$[propName];
        if (watchMethods) {
          watchMethods.map((watchMethodName) => {
            try {
              instance[watchMethodName](newVal, oldVal, propName);
            } catch (e3) {
              consoleError(e3, elm);
            }
          });
        }
      }
      if ((flags2 & (2 | 16)) === 2) {
        if (instance.componentShouldUpdate) {
          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
            return;
          }
        }
        scheduleUpdate(hostRef, false);
      }
    }
  }
};
const proxyComponent = (Cstr, cmpMeta, flags2) => {
  if (cmpMeta.$members$) {
    if (Cstr.watchers) {
      cmpMeta.$watchers$ = Cstr.watchers;
    }
    const members = Object.entries(cmpMeta.$members$);
    const prototype2 = Cstr.prototype;
    members.map(([memberName, [memberFlags]]) => {
      if (memberFlags & 31 || memberFlags & 32) {
        Object.defineProperty(prototype2, memberName, {
          get() {
            return getValue$2(this, memberName);
          },
          set(newValue) {
            setValue(this, memberName, newValue, cmpMeta);
          },
          configurable: true,
          enumerable: true
        });
      }
    });
    {
      const attrNameToPropName = /* @__PURE__ */ new Map();
      prototype2.attributeChangedCallback = function(attrName, _oldValue, newValue) {
        plt.jmp(() => {
          const propName = attrNameToPropName.get(attrName);
          if (this.hasOwnProperty(propName)) {
            newValue = this[propName];
            delete this[propName];
          } else if (prototype2.hasOwnProperty(propName) && typeof this[propName] === "number" && this[propName] == newValue) {
            return;
          }
          this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
        });
      };
      Cstr.observedAttributes = members.filter(
        ([_2, m2]) => m2[0] & 15
        /* MEMBER_FLAGS.HasAttribute */
      ).map(([propName, m2]) => {
        const attrName = m2[1] || propName;
        attrNameToPropName.set(attrName, propName);
        if (m2[0] & 512) {
          cmpMeta.$attrsToReflect$.push([propName, attrName]);
        }
        return attrName;
      });
    }
  }
  return Cstr;
};
const initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
  if ((hostRef.$flags$ & 32) === 0) {
    {
      Cstr = elm.constructor;
      hostRef.$flags$ |= 32;
      customElements.whenDefined(cmpMeta.$tagName$).then(() => hostRef.$flags$ |= 128);
    }
    if (Cstr.style) {
      let style = Cstr.style;
      if (typeof style !== "string") {
        style = style[hostRef.$modeName$ = computeMode(elm)];
      }
      const scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);
      if (!styles.has(scopeId2)) {
        const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
        endRegisterStyles();
      }
    }
  }
  hostRef.$ancestorComponent$;
  const schedule = () => scheduleUpdate(hostRef, true);
  {
    schedule();
  }
};
const fireConnectedCallback = (instance) => {
};
const connectedCallback = (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    const cmpMeta = hostRef.$cmpMeta$;
    const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
    if (!(hostRef.$flags$ & 1)) {
      hostRef.$flags$ |= 1;
      {
        if (cmpMeta.$flags$ & (4 | 8)) {
          setContentReference(elm);
        }
      }
      if (cmpMeta.$members$) {
        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
            const value = elm[memberName];
            delete elm[memberName];
            elm[memberName] = value;
          }
        });
      }
      {
        initializeComponent(elm, hostRef, cmpMeta);
      }
    } else {
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
      fireConnectedCallback(hostRef.$lazyInstance$);
    }
    endConnected();
  }
};
const setContentReference = (elm) => {
  const contentRefElm = elm["s-cr"] = doc.createComment("");
  contentRefElm["s-cn"] = true;
  elm.insertBefore(contentRefElm, elm.firstChild);
};
const disconnectedCallback = (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    {
      if (hostRef.$rmListeners$) {
        hostRef.$rmListeners$.map((rmListener) => rmListener());
        hostRef.$rmListeners$ = void 0;
      }
    }
  }
};
const proxyCustomElement = (Cstr, compactMeta) => {
  const cmpMeta = {
    $flags$: compactMeta[0],
    $tagName$: compactMeta[1]
  };
  {
    cmpMeta.$members$ = compactMeta[2];
  }
  {
    cmpMeta.$listeners$ = compactMeta[3];
  }
  {
    cmpMeta.$watchers$ = Cstr.$watchers$;
  }
  {
    cmpMeta.$attrsToReflect$ = [];
  }
  const originalConnectedCallback = Cstr.prototype.connectedCallback;
  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
  Object.assign(Cstr.prototype, {
    __registerHost() {
      registerHost(this, cmpMeta);
    },
    connectedCallback() {
      connectedCallback(this);
      if (originalConnectedCallback) {
        originalConnectedCallback.call(this);
      }
    },
    disconnectedCallback() {
      disconnectedCallback(this);
      if (originalDisconnectedCallback) {
        originalDisconnectedCallback.call(this);
      }
    },
    __attachShadow() {
      {
        {
          this.attachShadow({
            mode: "open",
            delegatesFocus: !!(cmpMeta.$flags$ & 16)
          });
        }
      }
    }
  });
  Cstr.is = cmpMeta.$tagName$;
  return proxyComponent(Cstr, cmpMeta);
};
const addHostEventListeners = (elm, hostRef, listeners2, attachParentListeners) => {
  if (listeners2) {
    listeners2.map(([flags2, name, method]) => {
      const target = getHostListenerTarget(elm, flags2);
      const handler = hostListenerProxy(hostRef, method);
      const opts = hostListenerOpts(flags2);
      plt.ael(target, name, handler, opts);
      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
    });
  }
};
const hostListenerProxy = (hostRef, methodName) => (ev) => {
  try {
    if (BUILD.lazyLoad)
      ;
    else {
      hostRef.$hostElement$[methodName](ev);
    }
  } catch (e3) {
    consoleError(e3);
  }
};
const getHostListenerTarget = (elm, flags2) => {
  if (flags2 & 4)
    return doc;
  if (flags2 & 8)
    return win;
  if (flags2 & 16)
    return doc.body;
  return elm;
};
const hostListenerOpts = (flags2) => supportsListenerOptions ? {
  passive: (flags2 & 1) !== 0,
  capture: (flags2 & 2) !== 0
} : (flags2 & 2) !== 0;
const hostRefs = /* @__PURE__ */ new WeakMap();
const getHostRef = (ref) => hostRefs.get(ref);
const registerHost = (elm, cmpMeta) => {
  const hostRef = {
    $flags$: 0,
    $hostElement$: elm,
    $cmpMeta$: cmpMeta,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
  return hostRefs.set(elm, hostRef);
};
const isMemberInElement = (elm, memberName) => memberName in elm;
const consoleError = (e3, el2) => (0, console.error)(e3, el2);
const styles = /* @__PURE__ */ new Map();
const modeResolutionChain = [];
const win = typeof window !== "undefined" ? window : {};
const doc = win.document || { head: {} };
const H = win.HTMLElement || class {
};
const plt = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (h2) => h2(),
  raf: (h2) => requestAnimationFrame(h2),
  ael: (el2, eventName, listener, opts) => el2.addEventListener(eventName, listener, opts),
  rel: (el2, eventName, listener, opts) => el2.removeEventListener(eventName, listener, opts),
  ce: (eventName, opts) => new CustomEvent(eventName, opts)
};
const supportsListenerOptions = /* @__PURE__ */ (() => {
  let supportsListenerOptions2 = false;
  try {
    doc.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        supportsListenerOptions2 = true;
      }
    }));
  } catch (e3) {
  }
  return supportsListenerOptions2;
})();
const promiseResolve = (v2) => Promise.resolve(v2);
const supportsConstructableStylesheets = /* @__PURE__ */ (() => {
  try {
    new CSSStyleSheet();
    return typeof new CSSStyleSheet().replaceSync === "function";
  } catch (e3) {
  }
  return false;
})();
const queueDomReads = [];
const queueDomWrites = [];
const queueTask = (queue2, write) => (cb2) => {
  queue2.push(cb2);
  if (!queuePending) {
    queuePending = true;
    if (write && plt.$flags$ & 4) {
      nextTick$1(flush$1);
    } else {
      plt.raf(flush$1);
    }
  }
};
const consume = (queue2) => {
  for (let i = 0; i < queue2.length; i++) {
    try {
      queue2[i](performance.now());
    } catch (e3) {
      consoleError(e3);
    }
  }
  queue2.length = 0;
};
const flush$1 = () => {
  consume(queueDomReads);
  {
    consume(queueDomWrites);
    if (queuePending = queueDomReads.length > 0) {
      plt.raf(flush$1);
    }
  }
};
const nextTick$1 = (cb2) => promiseResolve().then(cb2);
const writeTask = /* @__PURE__ */ queueTask(queueDomWrites, true);
let CACHED_MAP;
const getIconMap = () => {
  if (typeof window === "undefined") {
    return /* @__PURE__ */ new Map();
  } else {
    if (!CACHED_MAP) {
      const win2 = window;
      win2.Ionicons = win2.Ionicons || {};
      CACHED_MAP = win2.Ionicons.map = win2.Ionicons.map || /* @__PURE__ */ new Map();
    }
    return CACHED_MAP;
  }
};
const getUrl = (i) => {
  let url = getSrc(i.src);
  if (url) {
    return url;
  }
  url = getName(i.name, i.icon, i.mode, i.ios, i.md);
  if (url) {
    return getNamedUrl(url);
  }
  if (i.icon) {
    url = getSrc(i.icon);
    if (url) {
      return url;
    }
    url = getSrc(i.icon[i.mode]);
    if (url) {
      return url;
    }
  }
  return null;
};
const getNamedUrl = (iconName) => {
  const url = getIconMap().get(iconName);
  if (url) {
    return url;
  }
  return getAssetPath(`svg/${iconName}.svg`);
};
const getName = (iconName, icon, mode, ios, md2) => {
  mode = (mode && toLower(mode)) === "ios" ? "ios" : "md";
  if (ios && mode === "ios") {
    iconName = toLower(ios);
  } else if (md2 && mode === "md") {
    iconName = toLower(md2);
  } else {
    if (!iconName && icon && !isSrc(icon)) {
      iconName = icon;
    }
    if (isStr(iconName)) {
      iconName = toLower(iconName);
    }
  }
  if (!isStr(iconName) || iconName.trim() === "") {
    return null;
  }
  const invalidChars = iconName.replace(/[a-z]|-|\d/gi, "");
  if (invalidChars !== "") {
    return null;
  }
  return iconName;
};
const getSrc = (src) => {
  if (isStr(src)) {
    src = src.trim();
    if (isSrc(src)) {
      return src;
    }
  }
  return null;
};
const isSrc = (str) => str.length > 0 && /(\/|\.)/.test(str);
const isStr = (val) => typeof val === "string";
const toLower = (val) => val.toLowerCase();
const inheritAttributes = (el2, attributes = []) => {
  const attributeObject = {};
  attributes.forEach((attr) => {
    if (el2.hasAttribute(attr)) {
      const value = el2.getAttribute(attr);
      if (value !== null) {
        attributeObject[attr] = el2.getAttribute(attr);
      }
      el2.removeAttribute(attr);
    }
  });
  return attributeObject;
};
const isRTL = (hostEl) => {
  if (hostEl) {
    if (hostEl.dir !== "") {
      return hostEl.dir.toLowerCase() === "rtl";
    }
  }
  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === "rtl";
};
const validateContent = (svgContent) => {
  const div = document.createElement("div");
  div.innerHTML = svgContent;
  for (let i = div.childNodes.length - 1; i >= 0; i--) {
    if (div.childNodes[i].nodeName.toLowerCase() !== "svg") {
      div.removeChild(div.childNodes[i]);
    }
  }
  const svgElm = div.firstElementChild;
  if (svgElm && svgElm.nodeName.toLowerCase() === "svg") {
    const svgClass = svgElm.getAttribute("class") || "";
    svgElm.setAttribute("class", (svgClass + " s-ion-icon").trim());
    if (isValid$3(svgElm)) {
      return div.innerHTML;
    }
  }
  return "";
};
const isValid$3 = (elm) => {
  if (elm.nodeType === 1) {
    if (elm.nodeName.toLowerCase() === "script") {
      return false;
    }
    for (let i = 0; i < elm.attributes.length; i++) {
      const name = elm.attributes[i].name;
      if (isStr(name) && name.toLowerCase().indexOf("on") === 0) {
        return false;
      }
    }
    for (let i = 0; i < elm.childNodes.length; i++) {
      if (!isValid$3(elm.childNodes[i])) {
        return false;
      }
    }
  }
  return true;
};
const isSvgDataUrl = (url) => url.startsWith("data:image/svg+xml");
const isEncodedDataUrl = (url) => url.indexOf(";utf8,") !== -1;
const ioniconContent = /* @__PURE__ */ new Map();
const requests = /* @__PURE__ */ new Map();
let parser$1;
const getSvgContent = (url, sanitize) => {
  let req = requests.get(url);
  if (!req) {
    if (typeof fetch !== "undefined" && typeof document !== "undefined") {
      if (isSvgDataUrl(url) && isEncodedDataUrl(url)) {
        if (!parser$1) {
          parser$1 = new DOMParser();
        }
        const doc2 = parser$1.parseFromString(url, "text/html");
        const svg = doc2.querySelector("svg");
        if (svg) {
          ioniconContent.set(url, svg.outerHTML);
        }
        return Promise.resolve();
      } else {
        req = fetch(url).then((rsp) => {
          if (rsp.ok) {
            return rsp.text().then((svgContent) => {
              if (svgContent && sanitize !== false) {
                svgContent = validateContent(svgContent);
              }
              ioniconContent.set(url, svgContent || "");
            });
          }
          ioniconContent.set(url, "");
        });
        requests.set(url, req);
      }
    } else {
      ioniconContent.set(url, "");
      return Promise.resolve();
    }
  }
  return req;
};
const iconCss = ":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}:host(.flip-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.icon-small){font-size:18px !important}:host(.icon-large){font-size:32px !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}";
const Icon2 = /* @__PURE__ */ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.iconName = null;
    this.inheritedAttributes = {};
    this.isVisible = false;
    this.mode = getIonMode();
    this.lazy = false;
    this.sanitize = true;
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAttributes(this.el, ["aria-label"]);
  }
  connectedCallback() {
    this.waitUntilVisible(this.el, "50px", () => {
      this.isVisible = true;
      this.loadIcon();
    });
  }
  disconnectedCallback() {
    if (this.io) {
      this.io.disconnect();
      this.io = void 0;
    }
  }
  waitUntilVisible(el2, rootMargin, cb2) {
    if (this.lazy && typeof window !== "undefined" && window.IntersectionObserver) {
      const io = this.io = new window.IntersectionObserver((data2) => {
        if (data2[0].isIntersecting) {
          io.disconnect();
          this.io = void 0;
          cb2();
        }
      }, { rootMargin });
      io.observe(el2);
    } else {
      cb2();
    }
  }
  loadIcon() {
    if (this.isVisible) {
      const url = getUrl(this);
      if (url) {
        if (ioniconContent.has(url)) {
          this.svgContent = ioniconContent.get(url);
        } else {
          getSvgContent(url, this.sanitize).then(() => this.svgContent = ioniconContent.get(url));
        }
      }
    }
    this.iconName = getName(this.name, this.icon, this.mode, this.ios, this.md);
  }
  render() {
    const { iconName, el: el2, inheritedAttributes } = this;
    const mode = this.mode || "md";
    const flipRtl = this.flipRtl || iconName && (iconName.indexOf("arrow") > -1 || iconName.indexOf("chevron") > -1) && this.flipRtl !== false;
    return h$4(Host, Object.assign({ role: "img", class: Object.assign(Object.assign({ [mode]: true }, createColorClasses(this.color)), { [`icon-${this.size}`]: !!this.size, "flip-rtl": !!flipRtl && isRTL(el2) }) }, inheritedAttributes), this.svgContent ? h$4("div", { class: "icon-inner", innerHTML: this.svgContent }) : h$4("div", { class: "icon-inner" }));
  }
  static get assetsDirs() {
    return ["svg"];
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "name": ["loadIcon"],
      "src": ["loadIcon"],
      "icon": ["loadIcon"],
      "ios": ["loadIcon"],
      "md": ["loadIcon"]
    };
  }
  static get style() {
    return iconCss;
  }
}, [1, "ion-icon", {
  "mode": [1025],
  "color": [1],
  "ios": [1],
  "md": [1],
  "flipRtl": [4, "flip-rtl"],
  "name": [513],
  "src": [1],
  "icon": [8],
  "size": [1],
  "lazy": [4],
  "sanitize": [4],
  "svgContent": [32],
  "isVisible": [32]
}]);
const getIonMode = () => typeof document !== "undefined" && document.documentElement.getAttribute("mode") || "md";
const createColorClasses = (color2) => {
  return color2 ? {
    "ion-color": true,
    [`ion-color-${color2}`]: true
  } : null;
};
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-icon":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Icon2);
        }
        break;
    }
  });
}
const defineCustomElement$2 = defineCustomElement$1;
const IonLifeCycleContext = /* @__PURE__ */ React.createContext({
  onIonViewWillEnter: () => {
    return;
  },
  ionViewWillEnter: () => {
    return;
  },
  onIonViewDidEnter: () => {
    return;
  },
  ionViewDidEnter: () => {
    return;
  },
  onIonViewWillLeave: () => {
    return;
  },
  ionViewWillLeave: () => {
    return;
  },
  onIonViewDidLeave: () => {
    return;
  },
  ionViewDidLeave: () => {
    return;
  }
});
const DefaultIonLifeCycleContext = class {
  constructor() {
    this.ionViewWillEnterCallbacks = [];
    this.ionViewDidEnterCallbacks = [];
    this.ionViewWillLeaveCallbacks = [];
    this.ionViewDidLeaveCallbacks = [];
  }
  onIonViewWillEnter(callback) {
    if (callback.id) {
      const index3 = this.ionViewWillEnterCallbacks.findIndex((x2) => x2.id === callback.id);
      if (index3 > -1) {
        this.ionViewWillEnterCallbacks[index3] = callback;
      } else {
        this.ionViewWillEnterCallbacks.push(callback);
      }
    } else {
      this.ionViewWillEnterCallbacks.push(callback);
    }
  }
  ionViewWillEnter() {
    this.ionViewWillEnterCallbacks.forEach((cb2) => cb2());
  }
  onIonViewDidEnter(callback) {
    if (callback.id) {
      const index3 = this.ionViewDidEnterCallbacks.findIndex((x2) => x2.id === callback.id);
      if (index3 > -1) {
        this.ionViewDidEnterCallbacks[index3] = callback;
      } else {
        this.ionViewDidEnterCallbacks.push(callback);
      }
    } else {
      this.ionViewDidEnterCallbacks.push(callback);
    }
  }
  ionViewDidEnter() {
    this.ionViewDidEnterCallbacks.forEach((cb2) => cb2());
  }
  onIonViewWillLeave(callback) {
    if (callback.id) {
      const index3 = this.ionViewWillLeaveCallbacks.findIndex((x2) => x2.id === callback.id);
      if (index3 > -1) {
        this.ionViewWillLeaveCallbacks[index3] = callback;
      } else {
        this.ionViewWillLeaveCallbacks.push(callback);
      }
    } else {
      this.ionViewWillLeaveCallbacks.push(callback);
    }
  }
  ionViewWillLeave() {
    this.ionViewWillLeaveCallbacks.forEach((cb2) => cb2());
  }
  onIonViewDidLeave(callback) {
    if (callback.id) {
      const index3 = this.ionViewDidLeaveCallbacks.findIndex((x2) => x2.id === callback.id);
      if (index3 > -1) {
        this.ionViewDidLeaveCallbacks[index3] = callback;
      } else {
        this.ionViewDidLeaveCallbacks.push(callback);
      }
    } else {
      this.ionViewDidLeaveCallbacks.push(callback);
    }
  }
  ionViewDidLeave() {
    this.ionViewDidLeaveCallbacks.forEach((cb2) => cb2());
    this.componentCanBeDestroyed();
  }
  onComponentCanBeDestroyed(callback) {
    this.componentCanBeDestroyedCallback = callback;
  }
  componentCanBeDestroyed() {
    if (this.componentCanBeDestroyedCallback) {
      this.componentCanBeDestroyedCallback();
    }
  }
};
const useIonViewWillEnter = (callback, deps = []) => {
  const context2 = reactExports.useContext(IonLifeCycleContext);
  const id2 = reactExports.useRef();
  id2.current = id2.current || Math.floor(Math.random() * 1e6);
  reactExports.useEffect(() => {
    callback.id = id2.current;
    context2.onIonViewWillEnter(callback);
  }, deps);
};
const useIonViewDidEnter = (callback, deps = []) => {
  const context2 = reactExports.useContext(IonLifeCycleContext);
  const id2 = reactExports.useRef();
  id2.current = id2.current || Math.floor(Math.random() * 1e6);
  reactExports.useEffect(() => {
    callback.id = id2.current;
    context2.onIonViewDidEnter(callback);
  }, deps);
};
const useIonViewDidLeave = (callback, deps = []) => {
  const context2 = reactExports.useContext(IonLifeCycleContext);
  const id2 = reactExports.useRef();
  id2.current = id2.current || Math.floor(Math.random() * 1e6);
  reactExports.useEffect(() => {
    callback.id = id2.current;
    context2.onIonViewDidLeave(callback);
  }, deps);
};
const NavContext = /* @__PURE__ */ React.createContext({
  getIonRedirect: () => void 0,
  getIonRoute: () => void 0,
  getPageManager: () => void 0,
  getStackManager: () => void 0,
  goBack: (route) => {
    if (typeof window !== "undefined") {
      if (typeof route === "string") {
        window.location.pathname = route;
      } else {
        window.history.back();
      }
    }
  },
  navigate: (path3) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path3;
    }
  },
  hasIonicRouter: () => false,
  routeInfo: void 0,
  setCurrentTab: () => void 0,
  changeTab: (_tab, path3) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path3;
    }
  },
  resetTab: (_tab, path3) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path3;
    }
  }
});
const dashToPascalCase = (str) => str.toLowerCase().split("-").map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1)).join("");
const camelToDashCase = (str) => str.replace(/([A-Z])/g, (m2) => `-${m2[0].toLowerCase()}`);
const attachProps = (node, newProps, oldProps = {}) => {
  if (node instanceof Element) {
    const className = getClassName(node.classList, newProps, oldProps);
    if (className !== "") {
      node.className = className;
    }
    Object.keys(newProps).forEach((name) => {
      if (name === "children" || name === "style" || name === "ref" || name === "class" || name === "className" || name === "forwardedRef") {
        return;
      }
      if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
        const eventName = name.substring(2);
        const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
        if (!isCoveredByReact(eventNameLc)) {
          syncEvent(node, eventNameLc, newProps[name]);
        }
      } else {
        node[name] = newProps[name];
        const propType = typeof newProps[name];
        if (propType === "string") {
          node.setAttribute(camelToDashCase(name), newProps[name]);
        }
      }
    });
  }
};
const getClassName = (classList, newProps, oldProps) => {
  const newClassProp = newProps.className || newProps.class;
  const oldClassProp = oldProps.className || oldProps.class;
  const currentClasses = arrayToMap(classList);
  const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(" ") : []);
  const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(" ") : []);
  const finalClassNames = [];
  currentClasses.forEach((currentClass) => {
    if (incomingPropClasses.has(currentClass)) {
      finalClassNames.push(currentClass);
      incomingPropClasses.delete(currentClass);
    } else if (!oldPropClasses.has(currentClass)) {
      finalClassNames.push(currentClass);
    }
  });
  incomingPropClasses.forEach((s2) => finalClassNames.push(s2));
  return finalClassNames.join(" ");
};
/**
 * Checks if an event is supported in the current execution environment.
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
const isCoveredByReact = (eventNameSuffix) => {
  if (typeof document === "undefined") {
    return true;
  } else {
    const eventName = "on" + eventNameSuffix;
    let isSupported = eventName in document;
    if (!isSupported) {
      const element = document.createElement("div");
      element.setAttribute(eventName, "return;");
      isSupported = typeof element[eventName] === "function";
    }
    return isSupported;
  }
};
const syncEvent = (node, eventName, newEventHandler) => {
  const eventStore = node.__events || (node.__events = {});
  const oldEventHandler = eventStore[eventName];
  if (oldEventHandler) {
    node.removeEventListener(eventName, oldEventHandler);
  }
  node.addEventListener(eventName, eventStore[eventName] = function handler(e3) {
    if (newEventHandler) {
      newEventHandler.call(this, e3);
    }
  });
};
const arrayToMap = (arr) => {
  const map3 = /* @__PURE__ */ new Map();
  arr.forEach((s2) => map3.set(s2, s2));
  return map3;
};
const setRef = (ref, value) => {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref != null) {
    ref.current = value;
  }
};
const mergeRefs = (...refs) => {
  return (value) => {
    refs.forEach((ref) => {
      setRef(ref, value);
    });
  };
};
const createForwardRef$1 = (ReactComponent, displayName) => {
  const forwardRef = (props3, ref) => {
    return React.createElement(ReactComponent, Object.assign({}, props3, { forwardedRef: ref }));
  };
  forwardRef.displayName = displayName;
  return React.forwardRef(forwardRef);
};
const defineCustomElement = (tagName, customElement) => {
  if (customElement !== void 0 && typeof customElements !== "undefined" && !customElements.get(tagName)) {
    customElements.define(tagName, customElement);
  }
};
const createReactComponent = (tagName, ReactComponentContext, manipulatePropsFunction, defineCustomElement2) => {
  if (defineCustomElement2 !== void 0) {
    defineCustomElement2();
  }
  const displayName = dashToPascalCase(tagName);
  const ReactComponent = class extends React.Component {
    constructor(props3) {
      super(props3);
      this.setComponentElRef = (element) => {
        this.componentEl = element;
      };
    }
    componentDidMount() {
      this.componentDidUpdate(this.props);
    }
    componentDidUpdate(prevProps) {
      attachProps(this.componentEl, this.props, prevProps);
    }
    render() {
      const _a2 = this.props, { children, forwardedRef, style, className, ref } = _a2, cProps = __rest$1(_a2, ["children", "forwardedRef", "style", "className", "ref"]);
      let propsToPass = Object.keys(cProps).reduce((acc, name) => {
        const value = cProps[name];
        if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
          const eventName = name.substring(2).toLowerCase();
          if (typeof document !== "undefined" && isCoveredByReact(eventName)) {
            acc[name] = value;
          }
        } else {
          const type3 = typeof value;
          if (type3 === "string" || type3 === "boolean" || type3 === "number") {
            acc[camelToDashCase(name)] = value;
          }
        }
        return acc;
      }, {});
      if (manipulatePropsFunction) {
        propsToPass = manipulatePropsFunction(this.props, propsToPass);
      }
      const newProps = Object.assign(Object.assign({}, propsToPass), { ref: mergeRefs(forwardedRef, this.setComponentElRef), style });
      return reactExports.createElement(tagName, newProps, children);
    }
    static get displayName() {
      return displayName;
    }
  };
  if (ReactComponentContext) {
    ReactComponent.contextType = ReactComponentContext;
  }
  return createForwardRef$1(ReactComponent, displayName);
};
const IonAccordion = /* @__PURE__ */ createReactComponent("ion-accordion", void 0, void 0, defineCustomElement$1a);
const IonAccordionGroup = /* @__PURE__ */ createReactComponent("ion-accordion-group", void 0, void 0, defineCustomElement$19);
const IonAvatar = /* @__PURE__ */ createReactComponent("ion-avatar", void 0, void 0, defineCustomElement$18);
const IonBadge = /* @__PURE__ */ createReactComponent("ion-badge", void 0, void 0, defineCustomElement$16);
const IonButtons = /* @__PURE__ */ createReactComponent("ion-buttons", void 0, void 0, defineCustomElement$14);
const IonCardContent = /* @__PURE__ */ createReactComponent("ion-card-content", void 0, void 0, defineCustomElement$13);
const IonCardHeader = /* @__PURE__ */ createReactComponent("ion-card-header", void 0, void 0, defineCustomElement$12);
const IonCardSubtitle = /* @__PURE__ */ createReactComponent("ion-card-subtitle", void 0, void 0, defineCustomElement$11);
const IonCardTitle = /* @__PURE__ */ createReactComponent("ion-card-title", void 0, void 0, defineCustomElement$10);
const IonCheckbox = /* @__PURE__ */ createReactComponent("ion-checkbox", void 0, void 0, defineCustomElement$_);
const IonCol = /* @__PURE__ */ createReactComponent("ion-col", void 0, void 0, defineCustomElement$Y);
const IonContent = /* @__PURE__ */ createReactComponent("ion-content", void 0, void 0, defineCustomElement$X);
const IonDatetime = /* @__PURE__ */ createReactComponent("ion-datetime", void 0, void 0, defineCustomElement$P);
const IonFab = /* @__PURE__ */ createReactComponent("ion-fab", void 0, void 0, defineCustomElement$O);
const IonFabList = /* @__PURE__ */ createReactComponent("ion-fab-list", void 0, void 0, defineCustomElement$N);
const IonFooter = /* @__PURE__ */ createReactComponent("ion-footer", void 0, void 0, defineCustomElement$M);
const IonGrid = /* @__PURE__ */ createReactComponent("ion-grid", void 0, void 0, defineCustomElement$L);
const IonHeader = /* @__PURE__ */ createReactComponent("ion-header", void 0, void 0, defineCustomElement$K);
const IonImg = /* @__PURE__ */ createReactComponent("ion-img", void 0, void 0, defineCustomElement$J);
const IonInput = /* @__PURE__ */ createReactComponent("ion-input", void 0, void 0, defineCustomElement$H);
const IonItemDivider = /* @__PURE__ */ createReactComponent("ion-item-divider", void 0, void 0, defineCustomElement$G);
const IonItemGroup = /* @__PURE__ */ createReactComponent("ion-item-group", void 0, void 0, defineCustomElement$F);
const IonItemOptions = /* @__PURE__ */ createReactComponent("ion-item-options", void 0, void 0, defineCustomElement$E);
const IonItemSliding = /* @__PURE__ */ createReactComponent("ion-item-sliding", void 0, void 0, defineCustomElement$D);
const IonLabel = /* @__PURE__ */ createReactComponent("ion-label", void 0, void 0, defineCustomElement$C);
const IonList = /* @__PURE__ */ createReactComponent("ion-list", void 0, void 0, defineCustomElement$A);
const IonListHeader = /* @__PURE__ */ createReactComponent("ion-list-header", void 0, void 0, defineCustomElement$y);
const IonMenu = /* @__PURE__ */ createReactComponent("ion-menu", void 0, void 0, defineCustomElement$x);
const IonMenuToggle = /* @__PURE__ */ createReactComponent("ion-menu-toggle", void 0, void 0, defineCustomElement$w);
const IonNote = /* @__PURE__ */ createReactComponent("ion-note", void 0, void 0, defineCustomElement$u);
const IonRange = /* @__PURE__ */ createReactComponent("ion-range", void 0, void 0, defineCustomElement$r);
const IonRow = /* @__PURE__ */ createReactComponent("ion-row", void 0, void 0, defineCustomElement$q);
const IonSearchbar = /* @__PURE__ */ createReactComponent("ion-searchbar", void 0, void 0, defineCustomElement$p);
const IonSelect = /* @__PURE__ */ createReactComponent("ion-select", void 0, void 0, defineCustomElement$l);
const IonSelectOption = /* @__PURE__ */ createReactComponent("ion-select-option", void 0, void 0, defineCustomElement$k);
const IonSpinner = /* @__PURE__ */ createReactComponent("ion-spinner", void 0, void 0, defineCustomElement$j);
const IonText = /* @__PURE__ */ createReactComponent("ion-text", void 0, void 0, defineCustomElement$i);
const IonTextarea = /* @__PURE__ */ createReactComponent("ion-textarea", void 0, void 0, defineCustomElement$h);
const IonThumbnail = /* @__PURE__ */ createReactComponent("ion-thumbnail", void 0, void 0, defineCustomElement$g);
const IonTitle = /* @__PURE__ */ createReactComponent("ion-title", void 0, void 0, defineCustomElement$f);
const IonToggle = /* @__PURE__ */ createReactComponent("ion-toggle", void 0, void 0, defineCustomElement$e);
const IonToolbar = /* @__PURE__ */ createReactComponent("ion-toolbar", void 0, void 0, defineCustomElement$d);
const createForwardRef = (ReactComponent, displayName) => {
  const forwardRef = (props3, ref) => {
    return React.createElement(ReactComponent, Object.assign({}, props3, { forwardedRef: ref }));
  };
  forwardRef.displayName = displayName;
  return React.forwardRef(forwardRef);
};
const getConfig = () => {
  if (typeof window !== "undefined") {
    const Ionic = window.Ionic;
    if (Ionic && Ionic.config) {
      return Ionic.config;
    }
  }
  return null;
};
const createRoutingComponent = (tagName, customElement) => {
  defineCustomElement(tagName, customElement);
  const displayName = dashToPascalCase(tagName);
  const ReactComponent = class extends React.Component {
    constructor(props3) {
      super(props3);
      this.handleClick = (e3) => {
        const { routerLink, routerDirection, routerOptions, routerAnimation } = this.props;
        if (routerLink !== void 0) {
          e3.preventDefault();
          this.context.navigate(routerLink, routerDirection, void 0, routerAnimation, routerOptions);
        }
      };
      this.ref = React.createRef();
      this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);
    }
    componentDidMount() {
      this.componentDidUpdate(this.props);
    }
    componentDidUpdate(prevProps) {
      const node = this.ref.current;
      attachProps(node, this.props, prevProps);
    }
    render() {
      const _a2 = this.props, { children, forwardedRef, style, className, ref } = _a2, cProps = __rest$1(_a2, ["children", "forwardedRef", "style", "className", "ref"]);
      const propsToPass = Object.keys(cProps).reduce((acc, name) => {
        if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
          const eventName = name.substring(2).toLowerCase();
          if (isCoveredByReact(eventName)) {
            acc[name] = cProps[name];
          }
        } else if (["string", "boolean", "number"].includes(typeof cProps[name])) {
          acc[camelToDashCase(name)] = cProps[name];
        }
        return acc;
      }, {});
      const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });
      if (this.props.routerLink && !this.props.href) {
        newProps.href = this.props.routerLink;
      }
      if (newProps.onClick) {
        const oldClick = newProps.onClick;
        newProps.onClick = (e3) => {
          oldClick(e3);
          if (!e3.defaultPrevented) {
            this.handleClick(e3);
          }
        };
      } else {
        newProps.onClick = this.handleClick;
      }
      return reactExports.createElement(tagName, newProps, children);
    }
    static get displayName() {
      return displayName;
    }
    static get contextType() {
      return NavContext;
    }
  };
  return createForwardRef(ReactComponent, displayName);
};
const IonButton = /* @__PURE__ */ createRoutingComponent("ion-button", IonButton$1);
const IonCard = /* @__PURE__ */ createRoutingComponent("ion-card", IonCard$1);
const IonFabButton = /* @__PURE__ */ createRoutingComponent("ion-fab-button", IonFabButton$1);
const IonItem = /* @__PURE__ */ createRoutingComponent("ion-item", IonItem$1);
const IonItemOption = /* @__PURE__ */ createRoutingComponent("ion-item-option", IonItemOption$1);
const detachProps = (node, props3) => {
  if (node instanceof Element) {
    Object.keys(props3).forEach((name) => {
      if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
        const eventName = name.substring(2);
        const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
        if (!isCoveredByReact(eventNameLc)) {
          detachEvent(node, eventNameLc);
        }
      }
    });
  }
};
const detachEvent = (node, eventName) => {
  const eventStore = node.__events || (node.__events = {});
  const eventHandler = eventStore[eventName];
  if (eventHandler) {
    node.removeEventListener(eventName, eventHandler);
    eventStore[eventName] = void 0;
  }
};
const createInlineOverlayComponent = (tagName, defineCustomElement2) => {
  if (defineCustomElement2) {
    defineCustomElement2();
  }
  const displayName = dashToPascalCase(tagName);
  const ReactComponent = class extends React.Component {
    constructor(props3) {
      super(props3);
      this.handleIonMount = () => {
        this.setState({ isOpen: true });
      };
      this.handleWillPresent = (evt) => {
        this.setState({ isOpen: true });
        this.props.onWillPresent && this.props.onWillPresent(evt);
      };
      this.handleDidDismiss = (evt) => {
        const wrapper = this.wrapperRef.current;
        const el2 = this.ref.current;
        if (wrapper && el2) {
          el2.append(wrapper);
          this.setState({ isOpen: false });
        }
        this.props.onDidDismiss && this.props.onDidDismiss(evt);
      };
      this.ref = React.createRef();
      this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);
      this.state = { isOpen: false };
      this.wrapperRef = React.createRef();
    }
    componentDidMount() {
      var _a2, _b, _c;
      this.componentDidUpdate(this.props);
      (_a2 = this.ref.current) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("ionMount", this.handleIonMount);
      (_b = this.ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener("willPresent", this.handleWillPresent);
      (_c = this.ref.current) === null || _c === void 0 ? void 0 : _c.addEventListener("didDismiss", this.handleDidDismiss);
    }
    componentDidUpdate(prevProps) {
      const node = this.ref.current;
      attachProps(node, this.props, prevProps);
    }
    componentWillUnmount() {
      const node = this.ref.current;
      if (node && this.state.isOpen) {
        node.removeEventListener("didDismiss", this.handleDidDismiss);
        node.remove();
        detachProps(node, this.props);
      }
    }
    render() {
      const _a2 = this.props, { children, forwardedRef, style, className, ref } = _a2, cProps = __rest$1(_a2, ["children", "forwardedRef", "style", "className", "ref"]);
      const propsToPass = Object.keys(cProps).reduce((acc, name) => {
        if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
          const eventName = name.substring(2).toLowerCase();
          if (isCoveredByReact(eventName)) {
            acc[name] = cProps[name];
          }
        } else if (["string", "boolean", "number"].includes(typeof cProps[name])) {
          acc[camelToDashCase(name)] = cProps[name];
        }
        return acc;
      }, {});
      const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });
      return reactExports.createElement("template", {}, reactExports.createElement(
        tagName,
        newProps,
        /**
         * We only want the inner component
         * to be mounted if the overlay is open,
         * so conditionally render the component
         * based on the isOpen state.
         */
        this.state.isOpen || this.props.keepContentsMounted ? reactExports.createElement("div", {
          id: "ion-react-wrapper",
          ref: this.wrapperRef,
          className: "ion-delegate-host",
          style: {
            display: "flex",
            flexDirection: "column",
            height: "100%"
          }
        }, children) : null
      ));
    }
    static get displayName() {
      return displayName;
    }
  };
  return createForwardRef(ReactComponent, displayName);
};
const IonAlert = /* @__PURE__ */ createInlineOverlayComponent("ion-alert", defineCustomElement$c);
const IonLoading = /* @__PURE__ */ createInlineOverlayComponent("ion-loading", defineCustomElement$b);
const IonToast = /* @__PURE__ */ createInlineOverlayComponent("ion-toast", defineCustomElement$a);
const IonModal = /* @__PURE__ */ createInlineOverlayComponent("ion-modal", defineCustomElement$9);
const IonPopover = /* @__PURE__ */ createInlineOverlayComponent("ion-popover", defineCustomElement$8);
const IonContext = React.createContext({
  addOverlay: () => {
    return;
  },
  removeOverlay: () => {
    return;
  }
});
const IonOverlayManager = ({ onAddOverlay, onRemoveOverlay }) => {
  const [overlays, setOverlays] = reactExports.useState({});
  const overlaysRef = reactExports.useRef({});
  overlaysRef.current = overlays;
  reactExports.useEffect(() => {
    onAddOverlay(addOverlay);
    onRemoveOverlay(removeOverlay);
  }, []);
  const addOverlay = (id2, component, containerElement) => {
    const newOverlays = Object.assign({}, overlaysRef.current);
    newOverlays[id2] = { component, containerElement };
    setOverlays(newOverlays);
  };
  const removeOverlay = (id2) => {
    const newOverlays = Object.assign({}, overlaysRef.current);
    delete newOverlays[id2];
    setOverlays(newOverlays);
  };
  const overlayKeys = Object.keys(overlays);
  return React.createElement(React.Fragment, null, overlayKeys.map((key) => {
    const overlay = overlays[key];
    return ReactDOM.createPortal(overlay.component, overlay.containerElement, `overlay-${key}`);
  }));
};
const IonTabButtonInner = /* @__PURE__ */ createReactComponent("ion-tab-button", void 0, void 0, defineCustomElement$3);
const IonTabBarInner = /* @__PURE__ */ createReactComponent("ion-tab-bar", void 0, void 0, defineCustomElement$4);
const IonBackButtonInner = /* @__PURE__ */ createReactComponent("ion-back-button", void 0, void 0, defineCustomElement$6);
const IonRouterOutletInner = /* @__PURE__ */ createReactComponent("ion-router-outlet", void 0, void 0, defineCustomElement$5);
const IonAppInner = /* @__PURE__ */ createReactComponent("ion-app", void 0, void 0, defineCustomElement$7);
const IonIconInner = /* @__PURE__ */ createReactComponent("ion-icon", void 0, void 0, defineCustomElement$2);
const IonApp = /* @__PURE__ */ (() => class extends React.Component {
  constructor(props3) {
    super(props3);
    this.ionContext = {
      addOverlay: (id2, overlay, containerElement) => {
        if (this.addOverlayCallback) {
          this.addOverlayCallback(id2, overlay, containerElement);
        }
      },
      removeOverlay: (id2) => {
        if (this.removeOverlayCallback) {
          this.removeOverlayCallback(id2);
        }
      }
    };
  }
  render() {
    return React.createElement(
      IonContext.Provider,
      { value: this.ionContext },
      React.createElement(IonAppInner, Object.assign({}, this.props), this.props.children),
      React.createElement(IonOverlayManager, { onAddOverlay: (callback) => {
        this.addOverlayCallback = callback;
      }, onRemoveOverlay: (callback) => {
        this.removeOverlayCallback = callback;
      } })
    );
  }
  static get displayName() {
    return "IonApp";
  }
})();
const StackContext = React.createContext({
  registerIonPage: () => void 0,
  isInOutlet: () => false
});
class PageManager extends React.PureComponent {
  constructor(props3) {
    super(props3);
    this.ionPageElementRef = React.createRef();
    this.stableMergedRefs = mergeRefs(this.ionPageElementRef, this.props.forwardedRef);
  }
  componentDidMount() {
    if (this.ionPageElementRef.current) {
      if (this.context.isInOutlet()) {
        this.ionPageElementRef.current.classList.add("ion-page-invisible");
      }
      this.context.registerIonPage(this.ionPageElementRef.current, this.props.routeInfo);
      this.ionPageElementRef.current.addEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
      this.ionPageElementRef.current.addEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
      this.ionPageElementRef.current.addEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
      this.ionPageElementRef.current.addEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
    }
  }
  componentWillUnmount() {
    if (this.ionPageElementRef.current) {
      this.ionPageElementRef.current.removeEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
      this.ionPageElementRef.current.removeEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
      this.ionPageElementRef.current.removeEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
      this.ionPageElementRef.current.removeEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
    }
  }
  ionViewWillEnterHandler() {
    this.ionLifeCycleContext.ionViewWillEnter();
  }
  ionViewDidEnterHandler() {
    this.ionLifeCycleContext.ionViewDidEnter();
  }
  ionViewWillLeaveHandler() {
    this.ionLifeCycleContext.ionViewWillLeave();
  }
  ionViewDidLeaveHandler() {
    this.ionLifeCycleContext.ionViewDidLeave();
  }
  render() {
    const _a2 = this.props, { className, children, routeInfo, forwardedRef } = _a2, props3 = __rest$1(_a2, ["className", "children", "routeInfo", "forwardedRef"]);
    return React.createElement(IonLifeCycleContext.Consumer, null, (context2) => {
      this.ionLifeCycleContext = context2;
      return React.createElement("div", Object.assign({ className: className ? `${className} ion-page` : `ion-page`, ref: this.stableMergedRefs }, props3), children);
    });
  }
  static get contextType() {
    return StackContext;
  }
}
class IonPageInternal extends React.Component {
  constructor(props3) {
    super(props3);
  }
  render() {
    const _a2 = this.props, { className, children, forwardedRef } = _a2, props3 = __rest$1(_a2, ["className", "children", "forwardedRef"]);
    return this.context.hasIonicRouter() ? React.createElement(PageManager, Object.assign({ className: className ? `${className}` : "", routeInfo: this.context.routeInfo, forwardedRef }, props3), children) : React.createElement("div", Object.assign({ className: className ? `ion-page ${className}` : "ion-page", ref: forwardedRef }, props3), children);
  }
  static get displayName() {
    return "IonPage";
  }
  static get contextType() {
    return NavContext;
  }
}
const IonPage = createForwardRef(IonPageInternal, "IonPage");
const ReactDelegate = (addView, removeView) => {
  const refMap = /* @__PURE__ */ new WeakMap();
  const attachViewToDom = async (parentElement, component, propsOrDataObj, cssClasses) => {
    const div = document.createElement("div");
    cssClasses && div.classList.add(...cssClasses);
    parentElement.appendChild(div);
    const componentWithProps = component(propsOrDataObj);
    const hostComponent = reactDomExports.createPortal(componentWithProps, div);
    refMap.set(div, hostComponent);
    addView(hostComponent);
    return Promise.resolve(div);
  };
  const removeViewFromDom = (_container, component) => {
    const hostComponent = refMap.get(component);
    hostComponent && removeView(hostComponent);
    component.remove();
    return Promise.resolve();
  };
  return {
    attachViewToDom,
    removeViewFromDom
  };
};
const IonNavInner = createReactComponent("ion-nav", void 0, void 0, defineCustomElement$v);
const IonNavInternal = (_a2) => {
  var { children, forwardedRef } = _a2, restOfProps = __rest$1(_a2, ["children", "forwardedRef"]);
  const [views, setViews] = reactExports.useState([]);
  const addView = (view3) => setViews((existingViews) => [...existingViews, view3]);
  const removeView = (view3) => setViews((existingViews) => existingViews.filter((v2) => v2 !== view3));
  const delegate = reactExports.useMemo(() => ReactDelegate(addView, removeView), []);
  return React.createElement(IonNavInner, Object.assign({ delegate, ref: forwardedRef }, restOfProps), views);
};
createForwardRef(IonNavInternal, "IonNav");
React.createContext({
  activeTab: void 0,
  selectTab: () => false
});
const HTMLElementSSR = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class OutletPageManager extends React.Component {
  constructor(props3) {
    super(props3);
    this.outletIsReady = false;
  }
  componentDidMount() {
    if (this.ionRouterOutlet) {
      if (!this.outletIsReady) {
        componentOnReady(this.ionRouterOutlet, () => {
          this.outletIsReady = true;
          this.context.registerIonPage(this.ionRouterOutlet, this.props.routeInfo);
        });
      }
      this.ionRouterOutlet.addEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
      this.ionRouterOutlet.addEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
      this.ionRouterOutlet.addEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
      this.ionRouterOutlet.addEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
    }
  }
  componentWillUnmount() {
    if (this.ionRouterOutlet) {
      this.ionRouterOutlet.removeEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
      this.ionRouterOutlet.removeEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
      this.ionRouterOutlet.removeEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
      this.ionRouterOutlet.removeEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
    }
  }
  ionViewWillEnterHandler() {
    this.ionLifeCycleContext.ionViewWillEnter();
  }
  ionViewDidEnterHandler() {
    this.ionLifeCycleContext.ionViewDidEnter();
  }
  ionViewWillLeaveHandler() {
    this.ionLifeCycleContext.ionViewWillLeave();
  }
  ionViewDidLeaveHandler() {
    this.ionLifeCycleContext.ionViewDidLeave();
  }
  render() {
    const _a2 = this.props, { StackManager: StackManager2, children, routeInfo } = _a2, props3 = __rest$1(_a2, ["StackManager", "children", "routeInfo"]);
    return React.createElement(IonLifeCycleContext.Consumer, null, (context2) => {
      this.ionLifeCycleContext = context2;
      return React.createElement(
        StackManager2,
        { routeInfo },
        React.createElement(IonRouterOutletInner, Object.assign({ setRef: (val) => this.ionRouterOutlet = val }, props3), children)
      );
    });
  }
  static get contextType() {
    return StackContext;
  }
}
class IonRouterOutletContainer extends React.Component {
  constructor(props3) {
    super(props3);
  }
  render() {
    const StackManager2 = this.context.getStackManager();
    const _a2 = this.props, { children, forwardedRef } = _a2, props3 = __rest$1(_a2, ["children", "forwardedRef"]);
    return this.context.hasIonicRouter() ? props3.ionPage ? React.createElement(OutletPageManager, Object.assign({ StackManager: StackManager2, routeInfo: this.context.routeInfo }, props3), children) : React.createElement(
      StackManager2,
      { routeInfo: this.context.routeInfo },
      React.createElement(IonRouterOutletInner, Object.assign({}, props3, { forwardedRef }), children)
    ) : React.createElement(IonRouterOutletInner, Object.assign({ ref: forwardedRef }, this.props), this.props.children);
  }
  static get contextType() {
    return NavContext;
  }
}
const IonRouterOutlet = createForwardRef(IonRouterOutletContainer, "IonRouterOutlet");
const IonTabButton = /* @__PURE__ */ (() => class extends React.Component {
  constructor(props3) {
    super(props3);
    this.handleIonTabButtonClick = this.handleIonTabButtonClick.bind(this);
  }
  handleIonTabButtonClick() {
    if (this.props.onClick) {
      this.props.onClick(new CustomEvent("ionTabButtonClick", {
        detail: {
          tab: this.props.tab,
          href: this.props.href,
          routeOptions: this.props.routerOptions
        }
      }));
    }
  }
  render() {
    const _a2 = this.props, rest = __rest$1(_a2, ["onClick"]);
    return React.createElement(IonTabButtonInner, Object.assign({ onIonTabButtonClick: this.handleIonTabButtonClick }, rest));
  }
  static get displayName() {
    return "IonTabButton";
  }
})();
class IonTabBarUnwrapped extends React.PureComponent {
  constructor(props3) {
    super(props3);
    this.setActiveTabOnContext = (_tab) => {
    };
    const tabs = {};
    React.Children.forEach(props3.children, (child) => {
      var _a2, _b, _c, _d;
      if (child != null && typeof child === "object" && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        tabs[child.props.tab] = {
          originalHref: child.props.href,
          currentHref: child.props.href,
          originalRouteOptions: child.props.href === ((_a2 = props3.routeInfo) === null || _a2 === void 0 ? void 0 : _a2.pathname) ? (_b = props3.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : void 0,
          currentRouteOptions: child.props.href === ((_c = props3.routeInfo) === null || _c === void 0 ? void 0 : _c.pathname) ? (_d = props3.routeInfo) === null || _d === void 0 ? void 0 : _d.routeOptions : void 0
        };
      }
    });
    this.state = {
      tabs
    };
    this.onTabButtonClick = this.onTabButtonClick.bind(this);
    this.renderTabButton = this.renderTabButton.bind(this);
    this.setActiveTabOnContext = this.setActiveTabOnContext.bind(this);
    this.selectTab = this.selectTab.bind(this);
  }
  componentDidMount() {
    const tabs = this.state.tabs;
    const tabKeys = Object.keys(tabs);
    const activeTab = tabKeys.find((key) => {
      const href = tabs[key].originalHref;
      return this.props.routeInfo.pathname.startsWith(href);
    });
    if (activeTab) {
      this.setState({
        activeTab
      });
    }
  }
  componentDidUpdate() {
    if (this.state.activeTab) {
      this.setActiveTabOnContext(this.state.activeTab);
    }
  }
  selectTab(tab) {
    const tabUrl = this.state.tabs[tab];
    if (tabUrl) {
      this.onTabButtonClick(new CustomEvent("ionTabButtonClick", {
        detail: {
          href: tabUrl.currentHref,
          tab,
          selected: tab === this.state.activeTab,
          routeOptions: void 0
        }
      }));
      return true;
    }
    return false;
  }
  static getDerivedStateFromProps(props3, state) {
    var _a2, _b, _c;
    const tabs = Object.assign({}, state.tabs);
    const tabKeys = Object.keys(state.tabs);
    const activeTab = tabKeys.find((key) => {
      const href = state.tabs[key].originalHref;
      return props3.routeInfo.pathname.startsWith(href);
    });
    React.Children.forEach(props3.children, (child) => {
      if (child != null && typeof child === "object" && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        const tab = tabs[child.props.tab];
        if (!tab || tab.originalHref !== child.props.href) {
          tabs[child.props.tab] = {
            originalHref: child.props.href,
            currentHref: child.props.href,
            originalRouteOptions: child.props.routeOptions,
            currentRouteOptions: child.props.routeOptions
          };
        }
      }
    });
    const { activeTab: prevActiveTab } = state;
    if (activeTab && prevActiveTab) {
      const prevHref = state.tabs[prevActiveTab].currentHref;
      const prevRouteOptions = state.tabs[prevActiveTab].currentRouteOptions;
      if (activeTab !== prevActiveTab || prevHref !== ((_a2 = props3.routeInfo) === null || _a2 === void 0 ? void 0 : _a2.pathname) || prevRouteOptions !== ((_b = props3.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions)) {
        tabs[activeTab] = {
          originalHref: tabs[activeTab].originalHref,
          currentHref: props3.routeInfo.pathname + (props3.routeInfo.search || ""),
          originalRouteOptions: tabs[activeTab].originalRouteOptions,
          currentRouteOptions: (_c = props3.routeInfo) === null || _c === void 0 ? void 0 : _c.routeOptions
        };
        if (props3.routeInfo.routeAction === "pop" && activeTab !== prevActiveTab) {
          tabs[prevActiveTab] = {
            originalHref: tabs[prevActiveTab].originalHref,
            currentHref: tabs[prevActiveTab].originalHref,
            originalRouteOptions: tabs[prevActiveTab].originalRouteOptions,
            currentRouteOptions: tabs[prevActiveTab].currentRouteOptions
          };
        }
      }
    }
    activeTab && props3.onSetCurrentTab(activeTab, props3.routeInfo);
    return {
      activeTab,
      tabs
    };
  }
  onTabButtonClick(e3, onClickFn) {
    const tappedTab = this.state.tabs[e3.detail.tab];
    const originalHref = tappedTab.originalHref;
    const currentHref = e3.detail.href;
    const { activeTab: prevActiveTab } = this.state;
    if (onClickFn) {
      onClickFn(e3);
    }
    if (prevActiveTab === e3.detail.tab) {
      if (originalHref !== currentHref) {
        this.context.resetTab(e3.detail.tab, originalHref, tappedTab.originalRouteOptions);
      }
    } else {
      if (this.props.onIonTabsWillChange) {
        this.props.onIonTabsWillChange(new CustomEvent("ionTabWillChange", { detail: { tab: e3.detail.tab } }));
      }
      if (this.props.onIonTabsDidChange) {
        this.props.onIonTabsDidChange(new CustomEvent("ionTabDidChange", { detail: { tab: e3.detail.tab } }));
      }
      this.setActiveTabOnContext(e3.detail.tab);
      this.context.changeTab(e3.detail.tab, currentHref, e3.detail.routeOptions);
    }
  }
  renderTabButton(activeTab) {
    return (child) => {
      var _a2, _b;
      if (child != null && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        const href = child.props.tab === activeTab ? (_a2 = this.props.routeInfo) === null || _a2 === void 0 ? void 0 : _a2.pathname : this.state.tabs[child.props.tab].currentHref;
        const routeOptions = child.props.tab === activeTab ? (_b = this.props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : this.state.tabs[child.props.tab].currentRouteOptions;
        return React.cloneElement(child, {
          href,
          routeOptions,
          onClick: (ev) => this.onTabButtonClick(ev, child.props.onClick)
        });
      }
      return null;
    };
  }
  render() {
    const { activeTab } = this.state;
    return React.createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: activeTab }), React.Children.map(this.props.children, this.renderTabButton(activeTab)));
  }
  static get contextType() {
    return NavContext;
  }
}
const IonTabBarContainer = React.memo((_a2) => {
  var { forwardedRef } = _a2, props3 = __rest$1(_a2, ["forwardedRef"]);
  const context2 = reactExports.useContext(NavContext);
  return React.createElement(IonTabBarUnwrapped, Object.assign({ ref: forwardedRef }, props3, { routeInfo: props3.routeInfo || context2.routeInfo || { pathname: window.location.pathname }, onSetCurrentTab: context2.setCurrentTab }), props3.children);
});
createForwardRef(IonTabBarContainer, "IonTabBar");
class IonTabsElement extends HTMLElementSSR {
  constructor() {
    super();
  }
}
if (typeof window !== "undefined" && window.customElements) {
  const element = window.customElements.get("ion-tabs");
  if (!element) {
    window.customElements.define("ion-tabs", IonTabsElement);
  }
}
const IonBackButton = /* @__PURE__ */ (() => class extends React.Component {
  constructor() {
    super(...arguments);
    this.clickButton = (e3) => {
      if (e3.target && e3.target.closest("ion-nav") !== null) {
        return;
      }
      const { defaultHref, routerAnimation } = this.props;
      if (this.context.hasIonicRouter()) {
        e3.stopPropagation();
        this.context.goBack(defaultHref, routerAnimation);
      } else if (defaultHref !== void 0) {
        window.location.href = defaultHref;
      }
    };
  }
  render() {
    return React.createElement(IonBackButtonInner, Object.assign({ onClick: this.clickButton }, this.props));
  }
  static get displayName() {
    return "IonBackButton";
  }
  static get contextType() {
    return NavContext;
  }
})();
class IonIconContainer extends React.PureComponent {
  constructor(props3) {
    super(props3);
    if (this.props.name) {
      console.warn('In Ionic React, you import icons from "ionicons/icons" and set the icon you imported to the "icon" property. Setting the "name" property has no effect.');
    }
  }
  render() {
    var _a2, _b;
    const _c = this.props, { icon, ios, md: md2, mode } = _c, rest = __rest$1(_c, ["icon", "ios", "md", "mode"]);
    let iconToUse;
    const config2 = getConfig();
    const iconMode = mode || (config2 === null || config2 === void 0 ? void 0 : config2.get("mode"));
    if (ios || md2) {
      if (iconMode === "ios") {
        iconToUse = (_a2 = ios !== null && ios !== void 0 ? ios : md2) !== null && _a2 !== void 0 ? _a2 : icon;
      } else {
        iconToUse = (_b = md2 !== null && md2 !== void 0 ? md2 : ios) !== null && _b !== void 0 ? _b : icon;
      }
    } else {
      iconToUse = icon;
    }
    return React.createElement(IonIconInner, Object.assign({ ref: this.props.forwardedRef, icon: iconToUse }, rest), this.props.children);
  }
  static get contextType() {
    return NavContext;
  }
}
const IonIcon = createForwardRef(IonIconContainer, "IonIcon");
class IonRoute extends React.PureComponent {
  render() {
    const IonRouteInner2 = this.context.getIonRoute();
    if (!this.context.hasIonicRouter() || !IonRoute) {
      console.error("You either do not have an Ionic Router package, or your router does not support using <IonRoute>");
      return null;
    }
    return React.createElement(IonRouteInner2, Object.assign({}, this.props));
  }
  static get contextType() {
    return NavContext;
  }
}
class IonRedirect extends React.PureComponent {
  render() {
    const IonRedirectInner = this.context.getIonRedirect();
    if (!this.context.hasIonicRouter() || !IonRedirect) {
      console.error("You either do not have an Ionic Router package, or your router does not support using <IonRedirect>");
      return null;
    }
    return React.createElement(IonRedirectInner, Object.assign({}, this.props));
  }
  static get contextType() {
    return NavContext;
  }
}
const IonRouterContext = React.createContext({
  routeInfo: void 0,
  push: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  back: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  canGoBack: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  nativeBack: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  }
});
function useIonRouter() {
  const context2 = reactExports.useContext(IonRouterContext);
  return reactExports.useMemo(() => ({
    back: context2.back,
    push: context2.push,
    goBack: context2.back,
    canGoBack: context2.canGoBack,
    routeInfo: context2.routeInfo
  }), [context2.back, context2.push, context2.canGoBack, context2.routeInfo]);
}
class CreateAnimation extends React.PureComponent {
  constructor(props3) {
    super(props3);
    this.nodes = /* @__PURE__ */ new Map();
    this.animation = createAnimation(props3.id);
  }
  setupAnimation(props3) {
    const animation2 = this.animation;
    if (this.nodes.size > 0) {
      animation2.addElement(Array.from(this.nodes.values()));
    }
    checkConfig(animation2, props3);
    checkPlayback(animation2, props3);
  }
  componentDidMount() {
    const props3 = this.props;
    this.setupAnimation(props3);
  }
  componentDidUpdate(prevProps) {
    const animation2 = this.animation;
    const props3 = this.props;
    checkConfig(animation2, props3, prevProps);
    checkProgress(animation2, props3, prevProps);
    checkPlayback(animation2, props3, prevProps);
  }
  render() {
    const { children } = this.props;
    return React.createElement(React.Fragment, null, React.Children.map(children, (child, id2) => React.cloneElement(child, { ref: (el2) => this.nodes.set(id2, el2) })));
  }
}
const checkConfig = (animation2, currentProps = {}, prevProps = {}) => {
  const reservedProps = [
    "children",
    "progressStart",
    "progressStep",
    "progressEnd",
    "pause",
    "stop",
    "destroy",
    "play",
    "from",
    "to",
    "fromTo",
    "onFinish"
  ];
  for (const key in currentProps) {
    if (
      // eslint-disable-next-line no-prototype-builtins
      currentProps.hasOwnProperty(key) && !reservedProps.includes(key) && currentProps[key] !== prevProps[key]
    ) {
      animation2[key](currentProps[key]);
    }
  }
  const fromValues = currentProps.from;
  if (fromValues && fromValues !== prevProps.from) {
    const values3 = Array.isArray(fromValues) ? fromValues : [fromValues];
    values3.forEach((val) => animation2.from(val.property, val.value));
  }
  const toValues = currentProps.to;
  if (toValues && toValues !== prevProps.to) {
    const values3 = Array.isArray(toValues) ? toValues : [toValues];
    values3.forEach((val) => animation2.to(val.property, val.value));
  }
  const fromToValues = currentProps.fromTo;
  if (fromToValues && fromToValues !== prevProps.fromTo) {
    const values3 = Array.isArray(fromToValues) ? fromToValues : [fromToValues];
    values3.forEach((val) => animation2.fromTo(val.property, val.fromValue, val.toValue));
  }
  const onFinishValues = currentProps.onFinish;
  if (onFinishValues && onFinishValues !== prevProps.onFinish) {
    const values3 = Array.isArray(onFinishValues) ? onFinishValues : [onFinishValues];
    values3.forEach((val) => animation2.onFinish(val.callback, val.opts));
  }
};
const checkProgress = (animation2, currentProps = {}, prevProps = {}) => {
  var _a2, _b, _c, _d, _e2;
  const { progressStart, progressStep, progressEnd } = currentProps;
  if (progressStart && (((_a2 = prevProps.progressStart) === null || _a2 === void 0 ? void 0 : _a2.forceLinearEasing) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.forceLinearEasing) || ((_b = prevProps.progressStart) === null || _b === void 0 ? void 0 : _b.step) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.step))) {
    animation2.progressStart(progressStart.forceLinearEasing, progressStart.step);
  }
  if (progressStep && ((_c = prevProps.progressStep) === null || _c === void 0 ? void 0 : _c.step) !== (progressStep === null || progressStep === void 0 ? void 0 : progressStep.step)) {
    animation2.progressStep(progressStep.step);
  }
  if (progressEnd && (((_d = prevProps.progressEnd) === null || _d === void 0 ? void 0 : _d.playTo) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.playTo) || ((_e2 = prevProps.progressEnd) === null || _e2 === void 0 ? void 0 : _e2.step) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.step) || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.dur) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.dur))) {
    animation2.progressEnd(progressEnd.playTo, progressEnd.step, progressEnd.dur);
  }
};
const checkPlayback = (animation2, currentProps = {}, prevProps = {}) => {
  if (!prevProps.play && currentProps.play) {
    animation2.play();
  }
  if (!prevProps.pause && currentProps.pause) {
    animation2.pause();
  }
  if (!prevProps.stop && currentProps.stop) {
    animation2.stop();
  }
  if (!prevProps.destroy && currentProps.destroy) {
    animation2.destroy();
  }
};
function useController(displayName, controller, defineCustomElement2) {
  const overlayRef = reactExports.useRef();
  const didDismissEventName = reactExports.useMemo(() => `on${displayName}DidDismiss`, [displayName]);
  const didPresentEventName = reactExports.useMemo(() => `on${displayName}DidPresent`, [displayName]);
  const willDismissEventName = reactExports.useMemo(() => `on${displayName}WillDismiss`, [displayName]);
  const willPresentEventName = reactExports.useMemo(() => `on${displayName}WillPresent`, [displayName]);
  defineCustomElement2();
  const present2 = reactExports.useCallback(async (options) => {
    if (overlayRef.current) {
      return;
    }
    const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = __rest$1(options, ["onDidDismiss", "onWillDismiss", "onDidPresent", "onWillPresent"]);
    const handleDismiss = (event) => {
      if (onDidDismiss) {
        onDidDismiss(event);
      }
      overlayRef.current = void 0;
    };
    overlayRef.current = await controller.create(Object.assign({}, rest));
    attachProps(overlayRef.current, {
      [didDismissEventName]: handleDismiss,
      [didPresentEventName]: (e3) => onDidPresent && onDidPresent(e3),
      [willDismissEventName]: (e3) => onWillDismiss && onWillDismiss(e3),
      [willPresentEventName]: (e3) => onWillPresent && onWillPresent(e3)
    });
    overlayRef.current.present();
  }, [controller]);
  const dismiss2 = reactExports.useCallback(async () => {
    overlayRef.current && await overlayRef.current.dismiss();
    overlayRef.current = void 0;
  }, []);
  return {
    present: present2,
    dismiss: dismiss2
  };
}
function useIonAlert() {
  const controller = useController("IonAlert", alertController, defineCustomElement$c);
  const present2 = reactExports.useCallback((messageOrOptions, buttons) => {
    if (typeof messageOrOptions === "string") {
      return controller.present({
        message: messageOrOptions,
        buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: "Ok" }]
      });
    } else {
      return controller.present(messageOrOptions);
    }
  }, [controller.present]);
  return [present2, controller.dismiss];
}
function useIonToast() {
  const controller = useController("IonToast", toastController, defineCustomElement$a);
  const present2 = reactExports.useCallback((messageOrOptions, duration) => {
    if (typeof messageOrOptions === "string") {
      return controller.present({
        message: messageOrOptions,
        duration
      });
    } else {
      return controller.present(messageOrOptions);
    }
  }, [controller.present]);
  return [present2, controller.dismiss];
}
const ids = { main: 0 };
const generateId = (type3 = "main") => {
  var _a2;
  const id2 = ((_a2 = ids[type3]) !== null && _a2 !== void 0 ? _a2 : 0) + 1;
  ids[type3] = id2;
  return id2.toString();
};
function useIonLoading() {
  const controller = useController("IonLoading", loadingController, defineCustomElement$b);
  const present2 = reactExports.useCallback((messageOrOptions = {}, duration, spinner) => {
    if (typeof messageOrOptions === "string") {
      return controller.present({
        message: messageOrOptions,
        duration,
        spinner
      });
    } else {
      return controller.present(messageOrOptions);
    }
  }, [controller.present]);
  return [present2, controller.dismiss];
}
const setupIonicReact = (config2 = {}) => {
  if (typeof document !== "undefined") {
    document.documentElement.classList.add("ion-ce");
  }
  initialize(Object.assign({}, config2));
};
const RouteManagerContext = /* @__PURE__ */ React.createContext({
  addViewItem: () => void 0,
  canGoBack: () => void 0,
  clearOutlet: () => void 0,
  createViewItem: () => void 0,
  findViewItemByPathname: () => void 0,
  findLeavingViewItemByRouteInfo: () => void 0,
  findViewItemByRouteInfo: () => void 0,
  getChildrenToRender: () => void 0,
  goBack: () => void 0,
  unMountViewItem: () => void 0
});
class ViewLifeCycleManager extends React.Component {
  constructor(props3) {
    super(props3);
    this.ionLifeCycleContext = new DefaultIonLifeCycleContext();
    this._isMounted = false;
    this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {
      if (!this.props.mount) {
        if (this._isMounted) {
          this.setState({
            show: false
          }, () => this.props.removeView());
        }
      }
    });
    this.state = {
      show: true
    };
  }
  componentDidMount() {
    this._isMounted = true;
  }
  componentWillUnmount() {
    this._isMounted = false;
  }
  render() {
    const { show } = this.state;
    return React.createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children);
  }
}
class LocationHistory {
  constructor() {
    this.locationHistory = [];
    this.tabHistory = {};
  }
  add(routeInfo) {
    if (routeInfo.routeAction === "push" || routeInfo.routeAction == null) {
      this._add(routeInfo);
    } else if (routeInfo.routeAction === "pop") {
      this._pop(routeInfo);
    } else if (routeInfo.routeAction === "replace") {
      this._replace(routeInfo);
    }
    if (routeInfo.routeDirection === "root") {
      this._clear();
      this._add(routeInfo);
    }
  }
  clearTabStack(tab) {
    const routeInfos = this._getRouteInfosByKey(tab);
    if (routeInfos) {
      routeInfos.forEach((ri2) => {
        this.locationHistory = this.locationHistory.filter((x2) => x2.id !== ri2.id);
      });
      this.tabHistory[tab] = [];
    }
  }
  update(routeInfo) {
    const locationIndex = this.locationHistory.findIndex((x2) => x2.id === routeInfo.id);
    if (locationIndex > -1) {
      this.locationHistory.splice(locationIndex, 1, routeInfo);
    }
    const tabArray = this.tabHistory[routeInfo.tab || ""];
    if (tabArray) {
      const tabIndex = tabArray.findIndex((x2) => x2.id === routeInfo.id);
      if (tabIndex > -1) {
        tabArray.splice(tabIndex, 1, routeInfo);
      } else {
        tabArray.push(routeInfo);
      }
    } else if (routeInfo.tab) {
      this.tabHistory[routeInfo.tab] = [routeInfo];
    }
  }
  _add(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    if (routeInfos) {
      if (this._areRoutesEqual(routeInfos[routeInfos.length - 1], routeInfo)) {
        routeInfos.pop();
      }
      routeInfos.push(routeInfo);
    }
    this.locationHistory.push(routeInfo);
  }
  _areRoutesEqual(route1, route2) {
    if (!route1 || !route2) {
      return false;
    }
    return route1.pathname === route2.pathname && route1.search === route2.search;
  }
  _pop(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    if (routeInfos) {
      routeInfos.pop();
      routeInfos.pop();
      routeInfos.push(routeInfo);
    }
    this.locationHistory.pop();
    this.locationHistory.pop();
    this.locationHistory.push(routeInfo);
  }
  _replace(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    routeInfos && routeInfos.pop();
    this.locationHistory.pop();
    this._add(routeInfo);
  }
  _clear() {
    const keys4 = Object.keys(this.tabHistory);
    keys4.forEach((k2) => this.tabHistory[k2] = []);
    this.locationHistory = [];
  }
  _getRouteInfosByKey(key) {
    let routeInfos;
    if (key) {
      routeInfos = this.tabHistory[key];
      if (!routeInfos) {
        routeInfos = this.tabHistory[key] = [];
      }
    }
    return routeInfos;
  }
  getFirstRouteInfoForTab(tab) {
    const routeInfos = this._getRouteInfosByKey(tab);
    if (routeInfos) {
      return routeInfos[0];
    }
    return void 0;
  }
  getCurrentRouteInfoForTab(tab) {
    const routeInfos = this._getRouteInfosByKey(tab);
    if (routeInfos) {
      return routeInfos[routeInfos.length - 1];
    }
    return void 0;
  }
  findLastLocation(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    if (routeInfos) {
      for (let i = routeInfos.length - 2; i >= 0; i--) {
        const ri2 = routeInfos[i];
        if (ri2) {
          if (ri2.pathname === routeInfo.pushedByRoute) {
            return ri2;
          }
        }
      }
    }
    for (let i = this.locationHistory.length - 2; i >= 0; i--) {
      const ri2 = this.locationHistory[i];
      if (ri2) {
        if (ri2.pathname === routeInfo.pushedByRoute) {
          return ri2;
        }
      }
    }
    return void 0;
  }
  previous() {
    return this.locationHistory[this.locationHistory.length - 2] || this.locationHistory[this.locationHistory.length - 1];
  }
  current() {
    return this.locationHistory[this.locationHistory.length - 1];
  }
  canGoBack() {
    return this.locationHistory.length > 1;
  }
}
class NavManager extends React.PureComponent {
  constructor(props3) {
    super(props3);
    this.ionRouterContextValue = {
      push: (pathname, routerDirection, routeAction, routerOptions, animationBuilder) => {
        this.navigate(pathname, routerDirection, routeAction, animationBuilder, routerOptions);
      },
      back: (animationBuilder) => {
        this.goBack(void 0, animationBuilder);
      },
      canGoBack: () => this.props.locationHistory.canGoBack(),
      nativeBack: () => this.props.onNativeBack(),
      routeInfo: this.props.routeInfo
    };
    this.state = {
      goBack: this.goBack.bind(this),
      hasIonicRouter: () => true,
      navigate: this.navigate.bind(this),
      getIonRedirect: this.getIonRedirect.bind(this),
      getIonRoute: this.getIonRoute.bind(this),
      getStackManager: this.getStackManager.bind(this),
      getPageManager: this.getPageManager.bind(this),
      routeInfo: this.props.routeInfo,
      setCurrentTab: this.props.onSetCurrentTab,
      changeTab: this.props.onChangeTab,
      resetTab: this.props.onResetTab
    };
  }
  componentDidMount() {
    if (typeof document !== "undefined") {
      this.handleHardwareBackButton = this.handleHardwareBackButton.bind(this);
      document.addEventListener("ionBackButton", this.handleHardwareBackButton);
    }
  }
  componentWillUnmount() {
    if (typeof document !== "undefined") {
      document.removeEventListener("ionBackButton", this.handleHardwareBackButton);
    }
  }
  handleHardwareBackButton(e3) {
    e3.detail.register(0, (processNextHandler) => {
      this.nativeGoBack();
      processNextHandler();
    });
  }
  goBack(route, animationBuilder) {
    this.props.onNavigateBack(route, animationBuilder);
  }
  nativeGoBack() {
    this.props.onNativeBack();
  }
  navigate(path3, direction = "forward", action = "push", animationBuilder, options, tab) {
    this.props.onNavigate(path3, action, direction, animationBuilder, options, tab);
  }
  getPageManager() {
    return PageManager;
  }
  getIonRedirect() {
    return this.props.ionRedirect;
  }
  getIonRoute() {
    return this.props.ionRoute;
  }
  getStackManager() {
    return this.props.stackManager;
  }
  render() {
    return React.createElement(
      NavContext.Provider,
      { value: Object.assign(Object.assign({}, this.state), { routeInfo: this.props.routeInfo }) },
      React.createElement(IonRouterContext.Provider, { value: Object.assign(Object.assign({}, this.ionRouterContextValue), { routeInfo: this.props.routeInfo }) }, this.props.children)
    );
  }
}
class ViewStacks {
  constructor() {
    this.viewStacks = {};
    this.add = this.add.bind(this);
    this.clear = this.clear.bind(this);
    this.getViewItemsForOutlet = this.getViewItemsForOutlet.bind(this);
    this.remove = this.remove.bind(this);
  }
  add(viewItem) {
    const { outletId } = viewItem;
    if (!this.viewStacks[outletId]) {
      this.viewStacks[outletId] = [viewItem];
    } else {
      this.viewStacks[outletId].push(viewItem);
    }
  }
  clear(outletId) {
    return setTimeout(() => {
      delete this.viewStacks[outletId];
    }, 500);
  }
  getViewItemsForOutlet(outletId) {
    return this.viewStacks[outletId] || [];
  }
  remove(viewItem) {
    const { outletId } = viewItem;
    const viewStack = this.viewStacks[outletId];
    if (viewStack) {
      const viewItemToRemove = viewStack.find((x2) => x2.id === viewItem.id);
      if (viewItemToRemove) {
        viewItemToRemove.mount = false;
        this.viewStacks[outletId] = viewStack.filter((x2) => x2.id !== viewItemToRemove.id);
      }
    }
  }
  getStackIds() {
    return Object.keys(this.viewStacks);
  }
  getAllViewItems() {
    const keys4 = this.getStackIds();
    const viewItems = [];
    keys4.forEach((k2) => {
      viewItems.push(...this.viewStacks[k2]);
    });
    return viewItems;
  }
}
function _typeof$y(obj) {
  "@babel/helpers - typeof";
  return _typeof$y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$y(obj);
}
function _toPrimitive$u(input, hint) {
  if (_typeof$y(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$y(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey$u(arg) {
  var key = _toPrimitive$u(arg, "string");
  return _typeof$y(key) === "symbol" ? key : String(key);
}
function _defineProperty$w(obj, key, value) {
  key = _toPropertyKey$u(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$r(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$r(Object(source), true).forEach(function(key) {
      _defineProperty$w(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$r(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function formatProdErrorMessage(code2) {
  return "Minified Redux error #" + code2 + "; visit https://redux.js.org/Errors?code=" + code2 + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject$2(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto2 = obj;
  while (Object.getPrototypeOf(proto2) !== null) {
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Object.getPrototypeOf(obj) === proto2;
}
function createStore(reducer2, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore)(reducer2, preloadedState);
  }
  if (typeof reducer2 !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer2;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index3 = nextListeners.indexOf(listener);
      nextListeners.splice(index3, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$2(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners2 = currentListeners = nextListeners;
    for (var i = 0; i < listeners2.length; i++) {
      var listener = listeners2[i];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
var legacy_createStore = createStore;
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function(key) {
    var reducer2 = reducers[key];
    var initialState = reducer2(void 0, {
      type: ActionTypes.INIT
    });
    if (typeof initialState === "undefined") {
      throw new Error(formatProdErrorMessage(12));
    }
    if (typeof reducer2(void 0, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(formatProdErrorMessage(13));
    }
  });
}
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);
  var shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e3) {
    shapeAssertionError = e3;
  }
  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    var hasChanged = false;
    var nextState = {};
    for (var _i2 = 0; _i2 < finalReducerKeys.length; _i2++) {
      var _key = finalReducerKeys[_i2];
      var reducer2 = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer2(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        action && action.type;
        throw new Error(formatProdErrorMessage(14));
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function bindActionCreator(actionCreator, dispatch) {
  return function() {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
function bindActionCreators$1(actionCreators, dispatch) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(formatProdErrorMessage(16));
  }
  var boundActionCreators = {};
  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
function compose$2() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a2, b2) {
    return function() {
      return a2(b2.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore2) {
    return function() {
      var store = createStore2.apply(void 0, arguments);
      var _dispatch = function dispatch() {
        throw new Error(formatProdErrorMessage(15));
      };
      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain3 = middlewares.map(function(middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose$2.apply(void 0, chain3)(store.dispatch);
      return _objectSpread2(_objectSpread2({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}
const redux = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __DO_NOT_USE__ActionTypes: ActionTypes,
  applyMiddleware,
  bindActionCreators: bindActionCreators$1,
  combineReducers,
  compose: compose$2,
  createStore,
  legacy_createStore
}, Symbol.toStringTag, { value: "Module" }));
var createSymbol = function createSymbol2(name) {
  return "@@redux-saga/" + name;
};
var CANCEL$1 = /* @__PURE__ */ createSymbol("CANCEL_PROMISE");
var CHANNEL_END_TYPE = /* @__PURE__ */ createSymbol("CHANNEL_END");
var IO = /* @__PURE__ */ createSymbol("IO");
var MATCH = /* @__PURE__ */ createSymbol("MATCH");
var MULTICAST = /* @__PURE__ */ createSymbol("MULTICAST");
var SAGA_ACTION = /* @__PURE__ */ createSymbol("SAGA_ACTION");
var SELF_CANCELLATION = /* @__PURE__ */ createSymbol("SELF_CANCELLATION");
var TASK = /* @__PURE__ */ createSymbol("TASK");
var TASK_CANCEL = /* @__PURE__ */ createSymbol("TASK_CANCEL");
var TERMINATE = /* @__PURE__ */ createSymbol("TERMINATE");
var SAGA_LOCATION = /* @__PURE__ */ createSymbol("LOCATION");
function _extends$q() {
  _extends$q = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$q.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$e(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var undef = function undef2(v2) {
  return v2 === null || v2 === void 0;
};
var notUndef = function notUndef2(v2) {
  return v2 !== null && v2 !== void 0;
};
var func = function func2(f2) {
  return typeof f2 === "function";
};
var string$2 = function string(s2) {
  return typeof s2 === "string";
};
var array$2 = Array.isArray;
var promise = function promise2(p2) {
  return p2 && func(p2.then);
};
var iterator = function iterator2(it2) {
  return it2 && func(it2.next) && func(it2.throw);
};
var pattern = function pattern2(pat) {
  return pat && (string$2(pat) || symbol$1(pat) || func(pat) || array$2(pat) && pat.every(pattern2));
};
var channel$1 = function channel(ch2) {
  return ch2 && func(ch2.take) && func(ch2.close);
};
var stringableFunc = function stringableFunc2(f2) {
  return func(f2) && f2.hasOwnProperty("toString");
};
var symbol$1 = function symbol(sym) {
  return Boolean(sym) && typeof Symbol === "function" && sym.constructor === Symbol && sym !== Symbol.prototype;
};
var multicast = function multicast2(ch2) {
  return channel$1(ch2) && ch2[MULTICAST];
};
var MAX_SIGNED_INT = 2147483647;
function delayP(ms2, val) {
  if (val === void 0) {
    val = true;
  }
  var timeoutId;
  var promise3 = new Promise(function(resolve) {
    timeoutId = setTimeout(resolve, Math.min(MAX_SIGNED_INT, ms2), val);
  });
  promise3[CANCEL$1] = function() {
    clearTimeout(timeoutId);
  };
  return promise3;
}
var konst = function konst2(v2) {
  return function() {
    return v2;
  };
};
var kTrue = /* @__PURE__ */ konst(true);
var noop$6 = function noop() {
};
var identity$c = function identity(v2) {
  return v2;
};
var assignWithSymbols = function assignWithSymbols2(target, source) {
  _extends$q(target, source);
  if (Object.getOwnPropertySymbols) {
    Object.getOwnPropertySymbols(source).forEach(function(s2) {
      target[s2] = source[s2];
    });
  }
};
var flatMap$1 = function flatMap(mapper, arr) {
  var _ref;
  return (_ref = []).concat.apply(_ref, arr.map(mapper));
};
function remove2(array3, item) {
  var index3 = array3.indexOf(item);
  if (index3 >= 0) {
    array3.splice(index3, 1);
  }
}
function once3(fn2) {
  var called = false;
  return function() {
    if (called) {
      return;
    }
    called = true;
    fn2();
  };
}
var kThrow = function kThrow2(err) {
  throw err;
};
var kReturn = function kReturn2(value) {
  return {
    value,
    done: true
  };
};
function makeIterator(next, thro, name) {
  if (thro === void 0) {
    thro = kThrow;
  }
  if (name === void 0) {
    name = "iterator";
  }
  var iterator3 = {
    meta: {
      name
    },
    next,
    throw: thro,
    return: kReturn,
    isSagaIterator: true
  };
  if (typeof Symbol !== "undefined") {
    iterator3[Symbol.iterator] = function() {
      return iterator3;
    };
  }
  return iterator3;
}
function logError(error, _ref2) {
  var sagaStack2 = _ref2.sagaStack;
  console.error(error);
  console.error(sagaStack2);
}
var createEmptyArray = function createEmptyArray2(n2) {
  return Array.apply(null, new Array(n2));
};
var wrapSagaDispatch = function wrapSagaDispatch2(dispatch) {
  return function(action) {
    return dispatch(Object.defineProperty(action, SAGA_ACTION, {
      value: true
    }));
  };
};
var shouldTerminate = function shouldTerminate2(res) {
  return res === TERMINATE;
};
var shouldCancel = function shouldCancel2(res) {
  return res === TASK_CANCEL;
};
var shouldComplete = function shouldComplete2(res) {
  return shouldTerminate(res) || shouldCancel(res);
};
function createAllStyleChildCallbacks(shape, parentCallback) {
  var keys4 = Object.keys(shape);
  var totalCount = keys4.length;
  var completedCount = 0;
  var completed;
  var results = array$2(shape) ? createEmptyArray(totalCount) : {};
  var childCallbacks = {};
  function checkEnd() {
    if (completedCount === totalCount) {
      completed = true;
      parentCallback(results);
    }
  }
  keys4.forEach(function(key) {
    var chCbAtKey = function chCbAtKey2(res, isErr) {
      if (completed) {
        return;
      }
      if (isErr || shouldComplete(res)) {
        parentCallback.cancel();
        parentCallback(res, isErr);
      } else {
        results[key] = res;
        completedCount++;
        checkEnd();
      }
    };
    chCbAtKey.cancel = noop$6;
    childCallbacks[key] = chCbAtKey;
  });
  parentCallback.cancel = function() {
    if (!completed) {
      completed = true;
      keys4.forEach(function(key) {
        return childCallbacks[key].cancel();
      });
    }
  };
  return childCallbacks;
}
function getMetaInfo(fn2) {
  return {
    name: fn2.name || "anonymous",
    location: getLocation$1(fn2)
  };
}
function getLocation$1(instrumented) {
  return instrumented[SAGA_LOCATION];
}
var BUFFER_OVERFLOW = "Channel's Buffer overflow!";
var ON_OVERFLOW_THROW = 1;
var ON_OVERFLOW_SLIDE = 3;
var ON_OVERFLOW_EXPAND = 4;
var zeroBuffer = {
  isEmpty: kTrue,
  put: noop$6,
  take: noop$6
};
function ringBuffer(limit, overflowAction) {
  if (limit === void 0) {
    limit = 10;
  }
  var arr = new Array(limit);
  var length3 = 0;
  var pushIndex = 0;
  var popIndex = 0;
  var push2 = function push3(it2) {
    arr[pushIndex] = it2;
    pushIndex = (pushIndex + 1) % limit;
    length3++;
  };
  var take3 = function take4() {
    if (length3 != 0) {
      var it2 = arr[popIndex];
      arr[popIndex] = null;
      length3--;
      popIndex = (popIndex + 1) % limit;
      return it2;
    }
  };
  var flush2 = function flush3() {
    var items = [];
    while (length3) {
      items.push(take3());
    }
    return items;
  };
  return {
    isEmpty: function isEmpty3() {
      return length3 == 0;
    },
    put: function put2(it2) {
      if (length3 < limit) {
        push2(it2);
      } else {
        var doubledLimit;
        switch (overflowAction) {
          case ON_OVERFLOW_THROW:
            throw new Error(BUFFER_OVERFLOW);
          case ON_OVERFLOW_SLIDE:
            arr[pushIndex] = it2;
            pushIndex = (pushIndex + 1) % limit;
            popIndex = pushIndex;
            break;
          case ON_OVERFLOW_EXPAND:
            doubledLimit = 2 * limit;
            arr = flush2();
            length3 = arr.length;
            pushIndex = arr.length;
            popIndex = 0;
            arr.length = doubledLimit;
            limit = doubledLimit;
            push2(it2);
            break;
        }
      }
    },
    take: take3,
    flush: flush2
  };
}
var none2 = function none3() {
  return zeroBuffer;
};
var expanding = function expanding2(initialSize) {
  return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);
};
var TAKE = "TAKE";
var PUT = "PUT";
var ALL = "ALL";
var RACE = "RACE";
var CALL = "CALL";
var CPS = "CPS";
var FORK = "FORK";
var JOIN = "JOIN";
var CANCEL = "CANCEL";
var SELECT = "SELECT";
var ACTION_CHANNEL = "ACTION_CHANNEL";
var CANCELLED$1 = "CANCELLED";
var FLUSH = "FLUSH";
var GET_CONTEXT = "GET_CONTEXT";
var SET_CONTEXT = "SET_CONTEXT";
var makeEffect = function makeEffect2(type3, payload) {
  var _ref;
  return _ref = {}, _ref[IO] = true, _ref.combinator = false, _ref.type = type3, _ref.payload = payload, _ref;
};
function take$1(patternOrChannel, multicastPattern) {
  if (patternOrChannel === void 0) {
    patternOrChannel = "*";
  }
  if (pattern(patternOrChannel)) {
    if (notUndef(multicastPattern)) {
      console.warn("take(pattern) takes one argument but two were provided. Consider passing an array for listening to several action types");
    }
    return makeEffect(TAKE, {
      pattern: patternOrChannel
    });
  }
  if (multicast(patternOrChannel) && notUndef(multicastPattern) && pattern(multicastPattern)) {
    return makeEffect(TAKE, {
      channel: patternOrChannel,
      pattern: multicastPattern
    });
  }
  if (channel$1(patternOrChannel)) {
    if (notUndef(multicastPattern)) {
      console.warn("take(channel) takes one argument but two were provided. Second argument is ignored.");
    }
    return makeEffect(TAKE, {
      channel: patternOrChannel
    });
  }
}
function put$1(channel$1$1, action) {
  if (undef(action)) {
    action = channel$1$1;
    channel$1$1 = void 0;
  }
  return makeEffect(PUT, {
    channel: channel$1$1,
    action
  });
}
function getFnCallDescriptor(fnDescriptor, args) {
  var context2 = null;
  var fn2;
  if (func(fnDescriptor)) {
    fn2 = fnDescriptor;
  } else {
    if (array$2(fnDescriptor)) {
      context2 = fnDescriptor[0];
      fn2 = fnDescriptor[1];
    } else {
      context2 = fnDescriptor.context;
      fn2 = fnDescriptor.fn;
    }
    if (context2 && string$2(fn2) && func(context2[fn2])) {
      fn2 = context2[fn2];
    }
  }
  return {
    context: context2,
    fn: fn2,
    args
  };
}
function call$1(fnDescriptor) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return makeEffect(CALL, getFnCallDescriptor(fnDescriptor, args));
}
function fork$1(fnDescriptor) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return makeEffect(FORK, getFnCallDescriptor(fnDescriptor, args));
}
function cancel$1(taskOrTasks) {
  if (taskOrTasks === void 0) {
    taskOrTasks = SELF_CANCELLATION;
  }
  return makeEffect(CANCEL, taskOrTasks);
}
function select$1(selector) {
  if (selector === void 0) {
    selector = identity$c;
  }
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  return makeEffect(SELECT, {
    selector,
    args
  });
}
function actionChannel$1(pattern$1, buffer$1) {
  return makeEffect(ACTION_CHANNEL, {
    pattern: pattern$1,
    buffer: buffer$1
  });
}
function cancelled$1() {
  return makeEffect(CANCELLED$1, {});
}
var delay$1 = /* @__PURE__ */ call$1.bind(null, delayP);
function deferred() {
  var def = {};
  def.promise = new Promise(function(resolve, reject3) {
    def.resolve = resolve;
    def.reject = reject3;
  });
  return def;
}
var queue = [];
var semaphore = 0;
function exec(task) {
  try {
    suspend();
    task();
  } finally {
    release();
  }
}
function asap(task) {
  queue.push(task);
  if (!semaphore) {
    suspend();
    flush();
  }
}
function immediately(task) {
  try {
    suspend();
    return task();
  } finally {
    flush();
  }
}
function suspend() {
  semaphore++;
}
function release() {
  semaphore--;
}
function flush() {
  release();
  var task;
  while (!semaphore && (task = queue.shift()) !== void 0) {
    exec(task);
  }
}
var array$1 = function array(patterns) {
  return function(input) {
    return patterns.some(function(p2) {
      return matcher(p2)(input);
    });
  };
};
var predicate = function predicate2(_predicate) {
  return function(input) {
    return _predicate(input);
  };
};
var string$1 = function string2(pattern3) {
  return function(input) {
    return input.type === String(pattern3);
  };
};
var symbol2 = function symbol3(pattern3) {
  return function(input) {
    return input.type === pattern3;
  };
};
var wildcard = function wildcard2() {
  return kTrue;
};
function matcher(pattern3) {
  var matcherCreator = pattern3 === "*" ? wildcard : string$2(pattern3) ? string$1 : array$2(pattern3) ? array$1 : stringableFunc(pattern3) ? string$1 : func(pattern3) ? predicate : symbol$1(pattern3) ? symbol2 : null;
  if (matcherCreator === null) {
    throw new Error("invalid pattern: " + pattern3);
  }
  return matcherCreator(pattern3);
}
var END = {
  type: CHANNEL_END_TYPE
};
var isEnd = function isEnd2(a2) {
  return a2 && a2.type === CHANNEL_END_TYPE;
};
function channel2(buffer$1) {
  if (buffer$1 === void 0) {
    buffer$1 = expanding();
  }
  var closed = false;
  var takers = [];
  function put2(input) {
    if (closed) {
      return;
    }
    if (takers.length === 0) {
      return buffer$1.put(input);
    }
    var cb2 = takers.shift();
    cb2(input);
  }
  function take3(cb2) {
    if (closed && buffer$1.isEmpty()) {
      cb2(END);
    } else if (!buffer$1.isEmpty()) {
      cb2(buffer$1.take());
    } else {
      takers.push(cb2);
      cb2.cancel = function() {
        remove2(takers, cb2);
      };
    }
  }
  function flush2(cb2) {
    if (closed && buffer$1.isEmpty()) {
      cb2(END);
      return;
    }
    cb2(buffer$1.flush());
  }
  function close2() {
    if (closed) {
      return;
    }
    closed = true;
    var arr = takers;
    takers = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      var taker = arr[i];
      taker(END);
    }
  }
  return {
    take: take3,
    put: put2,
    flush: flush2,
    close: close2
  };
}
function eventChannel(subscribe, buffer2) {
  if (buffer2 === void 0) {
    buffer2 = none2();
  }
  var closed = false;
  var unsubscribe;
  var chan = channel2(buffer2);
  var close2 = function close3() {
    if (closed) {
      return;
    }
    closed = true;
    if (func(unsubscribe)) {
      unsubscribe();
    }
    chan.close();
  };
  unsubscribe = subscribe(function(input) {
    if (isEnd(input)) {
      close2();
      return;
    }
    chan.put(input);
  });
  unsubscribe = once3(unsubscribe);
  if (closed) {
    unsubscribe();
  }
  return {
    take: chan.take,
    flush: chan.flush,
    close: close2
  };
}
function multicastChannel() {
  var _ref;
  var closed = false;
  var currentTakers = [];
  var nextTakers = currentTakers;
  var ensureCanMutateNextTakers = function ensureCanMutateNextTakers2() {
    if (nextTakers !== currentTakers) {
      return;
    }
    nextTakers = currentTakers.slice();
  };
  var close2 = function close3() {
    closed = true;
    var takers = currentTakers = nextTakers;
    nextTakers = [];
    takers.forEach(function(taker) {
      taker(END);
    });
  };
  return _ref = {}, _ref[MULTICAST] = true, _ref.put = function put2(input) {
    if (closed) {
      return;
    }
    if (isEnd(input)) {
      close2();
      return;
    }
    var takers = currentTakers = nextTakers;
    for (var i = 0, len = takers.length; i < len; i++) {
      var taker = takers[i];
      if (taker[MATCH](input)) {
        taker.cancel();
        taker(input);
      }
    }
  }, _ref.take = function take3(cb2, matcher2) {
    if (matcher2 === void 0) {
      matcher2 = wildcard;
    }
    if (closed) {
      cb2(END);
      return;
    }
    cb2[MATCH] = matcher2;
    ensureCanMutateNextTakers();
    nextTakers.push(cb2);
    cb2.cancel = once3(function() {
      ensureCanMutateNextTakers();
      remove2(nextTakers, cb2);
    });
  }, _ref.close = close2, _ref;
}
function stdChannel() {
  var chan = multicastChannel();
  var put2 = chan.put;
  chan.put = function(input) {
    if (input[SAGA_ACTION]) {
      put2(input);
      return;
    }
    asap(function() {
      put2(input);
    });
  };
  return chan;
}
var RUNNING = 0;
var CANCELLED = 1;
var ABORTED = 2;
var DONE = 3;
function resolvePromise(promise3, cb2) {
  var cancelPromise = promise3[CANCEL$1];
  if (func(cancelPromise)) {
    cb2.cancel = cancelPromise;
  }
  promise3.then(cb2, function(error) {
    cb2(error, true);
  });
}
var current = 0;
var nextSagaId = function() {
  return ++current;
};
var _effectRunnerMap;
function getIteratorMetaInfo(iterator3, fn2) {
  if (iterator3.isSagaIterator) {
    return {
      name: iterator3.meta.name
    };
  }
  return getMetaInfo(fn2);
}
function createTaskIterator(_ref) {
  var context2 = _ref.context, fn2 = _ref.fn, args = _ref.args;
  try {
    var result = fn2.apply(context2, args);
    if (iterator(result)) {
      return result;
    }
    var resolved = false;
    var next = function next2(arg) {
      if (!resolved) {
        resolved = true;
        return {
          value: result,
          done: !promise(result)
        };
      } else {
        return {
          value: arg,
          done: true
        };
      }
    };
    return makeIterator(next);
  } catch (err) {
    return makeIterator(function() {
      throw err;
    });
  }
}
function runPutEffect(env, _ref2, cb2) {
  var channel3 = _ref2.channel, action = _ref2.action, resolve = _ref2.resolve;
  asap(function() {
    var result;
    try {
      result = (channel3 ? channel3.put : env.dispatch)(action);
    } catch (error) {
      cb2(error, true);
      return;
    }
    if (resolve && promise(result)) {
      resolvePromise(result, cb2);
    } else {
      cb2(result);
    }
  });
}
function runTakeEffect(env, _ref3, cb2) {
  var _ref3$channel = _ref3.channel, channel3 = _ref3$channel === void 0 ? env.channel : _ref3$channel, pattern3 = _ref3.pattern, maybe = _ref3.maybe;
  var takeCb = function takeCb2(input) {
    if (input instanceof Error) {
      cb2(input, true);
      return;
    }
    if (isEnd(input) && !maybe) {
      cb2(TERMINATE);
      return;
    }
    cb2(input);
  };
  try {
    channel3.take(takeCb, notUndef(pattern3) ? matcher(pattern3) : null);
  } catch (err) {
    cb2(err, true);
    return;
  }
  cb2.cancel = takeCb.cancel;
}
function runCallEffect(env, _ref4, cb2, _ref5) {
  var context2 = _ref4.context, fn2 = _ref4.fn, args = _ref4.args;
  var task = _ref5.task;
  try {
    var result = fn2.apply(context2, args);
    if (promise(result)) {
      resolvePromise(result, cb2);
      return;
    }
    if (iterator(result)) {
      proc(
        env,
        result,
        task.context,
        current,
        getMetaInfo(fn2),
        /* isRoot */
        false,
        cb2
      );
      return;
    }
    cb2(result);
  } catch (error) {
    cb2(error, true);
  }
}
function runCPSEffect(env, _ref6, cb2) {
  var context2 = _ref6.context, fn2 = _ref6.fn, args = _ref6.args;
  try {
    var cpsCb = function cpsCb2(err, res) {
      if (undef(err)) {
        cb2(res);
      } else {
        cb2(err, true);
      }
    };
    fn2.apply(context2, args.concat(cpsCb));
    if (cpsCb.cancel) {
      cb2.cancel = cpsCb.cancel;
    }
  } catch (error) {
    cb2(error, true);
  }
}
function runForkEffect(env, _ref7, cb2, _ref8) {
  var context2 = _ref7.context, fn2 = _ref7.fn, args = _ref7.args, detached = _ref7.detached;
  var parent = _ref8.task;
  var taskIterator = createTaskIterator({
    context: context2,
    fn: fn2,
    args
  });
  var meta = getIteratorMetaInfo(taskIterator, fn2);
  immediately(function() {
    var child = proc(env, taskIterator, parent.context, current, meta, detached, void 0);
    if (detached) {
      cb2(child);
    } else {
      if (child.isRunning()) {
        parent.queue.addTask(child);
        cb2(child);
      } else if (child.isAborted()) {
        parent.queue.abort(child.error());
      } else {
        cb2(child);
      }
    }
  });
}
function runJoinEffect(env, taskOrTasks, cb2, _ref9) {
  var task = _ref9.task;
  var joinSingleTask = function joinSingleTask2(taskToJoin, cb3) {
    if (taskToJoin.isRunning()) {
      var joiner = {
        task,
        cb: cb3
      };
      cb3.cancel = function() {
        if (taskToJoin.isRunning())
          remove2(taskToJoin.joiners, joiner);
      };
      taskToJoin.joiners.push(joiner);
    } else {
      if (taskToJoin.isAborted()) {
        cb3(taskToJoin.error(), true);
      } else {
        cb3(taskToJoin.result());
      }
    }
  };
  if (array$2(taskOrTasks)) {
    if (taskOrTasks.length === 0) {
      cb2([]);
      return;
    }
    var childCallbacks = createAllStyleChildCallbacks(taskOrTasks, cb2);
    taskOrTasks.forEach(function(t2, i) {
      joinSingleTask(t2, childCallbacks[i]);
    });
  } else {
    joinSingleTask(taskOrTasks, cb2);
  }
}
function cancelSingleTask(taskToCancel) {
  if (taskToCancel.isRunning()) {
    taskToCancel.cancel();
  }
}
function runCancelEffect(env, taskOrTasks, cb2, _ref10) {
  var task = _ref10.task;
  if (taskOrTasks === SELF_CANCELLATION) {
    cancelSingleTask(task);
  } else if (array$2(taskOrTasks)) {
    taskOrTasks.forEach(cancelSingleTask);
  } else {
    cancelSingleTask(taskOrTasks);
  }
  cb2();
}
function runAllEffect(env, effects, cb2, _ref11) {
  var digestEffect = _ref11.digestEffect;
  var effectId = current;
  var keys4 = Object.keys(effects);
  if (keys4.length === 0) {
    cb2(array$2(effects) ? [] : {});
    return;
  }
  var childCallbacks = createAllStyleChildCallbacks(effects, cb2);
  keys4.forEach(function(key) {
    digestEffect(effects[key], effectId, childCallbacks[key], key);
  });
}
function runRaceEffect(env, effects, cb2, _ref12) {
  var digestEffect = _ref12.digestEffect;
  var effectId = current;
  var keys4 = Object.keys(effects);
  var response = array$2(effects) ? createEmptyArray(keys4.length) : {};
  var childCbs = {};
  var completed = false;
  keys4.forEach(function(key) {
    var chCbAtKey = function chCbAtKey2(res, isErr) {
      if (completed) {
        return;
      }
      if (isErr || shouldComplete(res)) {
        cb2.cancel();
        cb2(res, isErr);
      } else {
        cb2.cancel();
        completed = true;
        response[key] = res;
        cb2(response);
      }
    };
    chCbAtKey.cancel = noop$6;
    childCbs[key] = chCbAtKey;
  });
  cb2.cancel = function() {
    if (!completed) {
      completed = true;
      keys4.forEach(function(key) {
        return childCbs[key].cancel();
      });
    }
  };
  keys4.forEach(function(key) {
    if (completed) {
      return;
    }
    digestEffect(effects[key], effectId, childCbs[key], key);
  });
}
function runSelectEffect(env, _ref13, cb2) {
  var selector = _ref13.selector, args = _ref13.args;
  try {
    var state = selector.apply(void 0, [env.getState()].concat(args));
    cb2(state);
  } catch (error) {
    cb2(error, true);
  }
}
function runChannelEffect(env, _ref14, cb2) {
  var pattern3 = _ref14.pattern, buffer2 = _ref14.buffer;
  var chan = channel2(buffer2);
  var match5 = matcher(pattern3);
  var taker = function taker2(action) {
    if (!isEnd(action)) {
      env.channel.take(taker2, match5);
    }
    chan.put(action);
  };
  var close2 = chan.close;
  chan.close = function() {
    taker.cancel();
    close2();
  };
  env.channel.take(taker, match5);
  cb2(chan);
}
function runCancelledEffect(env, data2, cb2, _ref15) {
  var task = _ref15.task;
  cb2(task.isCancelled());
}
function runFlushEffect(env, channel3, cb2) {
  channel3.flush(cb2);
}
function runGetContextEffect(env, prop3, cb2, _ref16) {
  var task = _ref16.task;
  cb2(task.context[prop3]);
}
function runSetContextEffect(env, props3, cb2, _ref17) {
  var task = _ref17.task;
  assignWithSymbols(task.context, props3);
  cb2();
}
var effectRunnerMap = (_effectRunnerMap = {}, _effectRunnerMap[TAKE] = runTakeEffect, _effectRunnerMap[PUT] = runPutEffect, _effectRunnerMap[ALL] = runAllEffect, _effectRunnerMap[RACE] = runRaceEffect, _effectRunnerMap[CALL] = runCallEffect, _effectRunnerMap[CPS] = runCPSEffect, _effectRunnerMap[FORK] = runForkEffect, _effectRunnerMap[JOIN] = runJoinEffect, _effectRunnerMap[CANCEL] = runCancelEffect, _effectRunnerMap[SELECT] = runSelectEffect, _effectRunnerMap[ACTION_CHANNEL] = runChannelEffect, _effectRunnerMap[CANCELLED$1] = runCancelledEffect, _effectRunnerMap[FLUSH] = runFlushEffect, _effectRunnerMap[GET_CONTEXT] = runGetContextEffect, _effectRunnerMap[SET_CONTEXT] = runSetContextEffect, _effectRunnerMap);
function forkQueue(mainTask, onAbort, cont) {
  var tasks = [];
  var result;
  var completed = false;
  addTask(mainTask);
  var getTasks = function getTasks2() {
    return tasks;
  };
  function abort(err) {
    onAbort();
    cancelAll();
    cont(err, true);
  }
  function addTask(task) {
    tasks.push(task);
    task.cont = function(res, isErr) {
      if (completed) {
        return;
      }
      remove2(tasks, task);
      task.cont = noop$6;
      if (isErr) {
        abort(res);
      } else {
        if (task === mainTask) {
          result = res;
        }
        if (!tasks.length) {
          completed = true;
          cont(result);
        }
      }
    };
  }
  function cancelAll() {
    if (completed) {
      return;
    }
    completed = true;
    tasks.forEach(function(t2) {
      t2.cont = noop$6;
      t2.cancel();
    });
    tasks = [];
  }
  return {
    addTask,
    cancelAll,
    abort,
    getTasks
  };
}
function formatLocation(fileName, lineNumber) {
  return fileName + "?" + lineNumber;
}
function effectLocationAsString(effect) {
  var location = getLocation$1(effect);
  if (location) {
    var code2 = location.code, fileName = location.fileName, lineNumber = location.lineNumber;
    var source = code2 + "  " + formatLocation(fileName, lineNumber);
    return source;
  }
  return "";
}
function sagaLocationAsString(sagaMeta) {
  var name = sagaMeta.name, location = sagaMeta.location;
  if (location) {
    return name + "  " + formatLocation(location.fileName, location.lineNumber);
  }
  return name;
}
function cancelledTasksAsString(sagaStack2) {
  var cancelledTasks = flatMap$1(function(i) {
    return i.cancelledTasks;
  }, sagaStack2);
  if (!cancelledTasks.length) {
    return "";
  }
  return ["Tasks cancelled due to error:"].concat(cancelledTasks).join("\n");
}
var crashedEffect = null;
var sagaStack = [];
var addSagaFrame = function addSagaFrame2(frame) {
  frame.crashedEffect = crashedEffect;
  sagaStack.push(frame);
};
var clear = function clear2() {
  crashedEffect = null;
  sagaStack.length = 0;
};
var setCrashedEffect = function setCrashedEffect2(effect) {
  crashedEffect = effect;
};
var toString$7 = function toString2() {
  var firstSaga = sagaStack[0], otherSagas = sagaStack.slice(1);
  var crashedEffectLocation = firstSaga.crashedEffect ? effectLocationAsString(firstSaga.crashedEffect) : null;
  var errorMessage = "The above error occurred in task " + sagaLocationAsString(firstSaga.meta) + (crashedEffectLocation ? " \n when executing effect " + crashedEffectLocation : "");
  return [errorMessage].concat(otherSagas.map(function(s2) {
    return "    created by " + sagaLocationAsString(s2.meta);
  }), [cancelledTasksAsString(sagaStack)]).join("\n");
};
function newTask(env, mainTask, parentContext, parentEffectId, meta, isRoot, cont) {
  var _task;
  if (cont === void 0) {
    cont = noop$6;
  }
  var status = RUNNING;
  var taskResult;
  var taskError;
  var deferredEnd = null;
  var cancelledDueToErrorTasks = [];
  var context2 = Object.create(parentContext);
  var queue2 = forkQueue(mainTask, function onAbort() {
    cancelledDueToErrorTasks.push.apply(cancelledDueToErrorTasks, queue2.getTasks().map(function(t2) {
      return t2.meta.name;
    }));
  }, end);
  function cancel2() {
    if (status === RUNNING) {
      status = CANCELLED;
      queue2.cancelAll();
      end(TASK_CANCEL, false);
    }
  }
  function end(result, isErr) {
    if (!isErr) {
      if (result === TASK_CANCEL) {
        status = CANCELLED;
      } else if (status !== CANCELLED) {
        status = DONE;
      }
      taskResult = result;
      deferredEnd && deferredEnd.resolve(result);
    } else {
      status = ABORTED;
      addSagaFrame({
        meta,
        cancelledTasks: cancelledDueToErrorTasks
      });
      if (task.isRoot) {
        var sagaStack2 = toString$7();
        clear();
        env.onError(result, {
          sagaStack: sagaStack2
        });
      }
      taskError = result;
      deferredEnd && deferredEnd.reject(result);
    }
    task.cont(result, isErr);
    task.joiners.forEach(function(joiner) {
      joiner.cb(result, isErr);
    });
    task.joiners = null;
  }
  function setContext(props3) {
    assignWithSymbols(context2, props3);
  }
  function toPromise() {
    if (deferredEnd) {
      return deferredEnd.promise;
    }
    deferredEnd = deferred();
    if (status === ABORTED) {
      deferredEnd.reject(taskError);
    } else if (status !== RUNNING) {
      deferredEnd.resolve(taskResult);
    }
    return deferredEnd.promise;
  }
  var task = (_task = {}, _task[TASK] = true, _task.id = parentEffectId, _task.meta = meta, _task.isRoot = isRoot, _task.context = context2, _task.joiners = [], _task.queue = queue2, _task.cancel = cancel2, _task.cont = cont, _task.end = end, _task.setContext = setContext, _task.toPromise = toPromise, _task.isRunning = function isRunning() {
    return status === RUNNING;
  }, _task.isCancelled = function isCancelled() {
    return status === CANCELLED || status === RUNNING && mainTask.status === CANCELLED;
  }, _task.isAborted = function isAborted() {
    return status === ABORTED;
  }, _task.result = function result() {
    return taskResult;
  }, _task.error = function error() {
    return taskError;
  }, _task);
  return task;
}
function proc(env, iterator$1, parentContext, parentEffectId, meta, isRoot, cont) {
  var finalRunEffect = env.finalizeRunEffect(runEffect);
  next.cancel = noop$6;
  var mainTask = {
    meta,
    cancel: cancelMain,
    status: RUNNING
  };
  var task = newTask(env, mainTask, parentContext, parentEffectId, meta, isRoot, cont);
  var executingContext = {
    task,
    digestEffect
  };
  function cancelMain() {
    if (mainTask.status === RUNNING) {
      mainTask.status = CANCELLED;
      next(TASK_CANCEL);
    }
  }
  if (cont) {
    cont.cancel = task.cancel;
  }
  next();
  return task;
  function next(arg, isErr) {
    try {
      var result;
      if (isErr) {
        result = iterator$1.throw(arg);
        clear();
      } else if (shouldCancel(arg)) {
        mainTask.status = CANCELLED;
        next.cancel();
        result = func(iterator$1.return) ? iterator$1.return(TASK_CANCEL) : {
          done: true,
          value: TASK_CANCEL
        };
      } else if (shouldTerminate(arg)) {
        result = func(iterator$1.return) ? iterator$1.return() : {
          done: true
        };
      } else {
        result = iterator$1.next(arg);
      }
      if (!result.done) {
        digestEffect(result.value, parentEffectId, next);
      } else {
        if (mainTask.status !== CANCELLED) {
          mainTask.status = DONE;
        }
        mainTask.cont(result.value);
      }
    } catch (error) {
      if (mainTask.status === CANCELLED) {
        throw error;
      }
      mainTask.status = ABORTED;
      mainTask.cont(error, true);
    }
  }
  function runEffect(effect, effectId, currCb) {
    if (promise(effect)) {
      resolvePromise(effect, currCb);
    } else if (iterator(effect)) {
      proc(
        env,
        effect,
        task.context,
        effectId,
        meta,
        /* isRoot */
        false,
        currCb
      );
    } else if (effect && effect[IO]) {
      var effectRunner = effectRunnerMap[effect.type];
      effectRunner(env, effect.payload, currCb, executingContext);
    } else {
      currCb(effect);
    }
  }
  function digestEffect(effect, parentEffectId2, cb2, label) {
    if (label === void 0) {
      label = "";
    }
    var effectId = nextSagaId();
    env.sagaMonitor && env.sagaMonitor.effectTriggered({
      effectId,
      parentEffectId: parentEffectId2,
      label,
      effect
    });
    var effectSettled;
    function currCb(res, isErr) {
      if (effectSettled) {
        return;
      }
      effectSettled = true;
      cb2.cancel = noop$6;
      if (env.sagaMonitor) {
        if (isErr) {
          env.sagaMonitor.effectRejected(effectId, res);
        } else {
          env.sagaMonitor.effectResolved(effectId, res);
        }
      }
      if (isErr) {
        setCrashedEffect(effect);
      }
      cb2(res, isErr);
    }
    currCb.cancel = noop$6;
    cb2.cancel = function() {
      if (effectSettled) {
        return;
      }
      effectSettled = true;
      currCb.cancel();
      currCb.cancel = noop$6;
      env.sagaMonitor && env.sagaMonitor.effectCancelled(effectId);
    };
    finalRunEffect(effect, effectId, currCb);
  }
}
function runSaga(_ref, saga) {
  var _ref$channel = _ref.channel, channel3 = _ref$channel === void 0 ? stdChannel() : _ref$channel, dispatch = _ref.dispatch, getState = _ref.getState, _ref$context = _ref.context, context2 = _ref$context === void 0 ? {} : _ref$context, sagaMonitor = _ref.sagaMonitor, effectMiddlewares = _ref.effectMiddlewares, _ref$onError = _ref.onError, onError = _ref$onError === void 0 ? logError : _ref$onError;
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  var iterator$1 = saga.apply(void 0, args);
  var effectId = nextSagaId();
  if (sagaMonitor) {
    sagaMonitor.rootSagaStarted = sagaMonitor.rootSagaStarted || noop$6;
    sagaMonitor.effectTriggered = sagaMonitor.effectTriggered || noop$6;
    sagaMonitor.effectResolved = sagaMonitor.effectResolved || noop$6;
    sagaMonitor.effectRejected = sagaMonitor.effectRejected || noop$6;
    sagaMonitor.effectCancelled = sagaMonitor.effectCancelled || noop$6;
    sagaMonitor.actionDispatched = sagaMonitor.actionDispatched || noop$6;
    sagaMonitor.rootSagaStarted({
      effectId,
      saga,
      args
    });
  }
  var finalizeRunEffect;
  if (effectMiddlewares) {
    var middleware = compose$2.apply(void 0, effectMiddlewares);
    finalizeRunEffect = function finalizeRunEffect2(runEffect) {
      return function(effect, effectId2, currCb) {
        var plainRunEffect = function plainRunEffect2(eff) {
          return runEffect(eff, effectId2, currCb);
        };
        return middleware(plainRunEffect)(effect);
      };
    };
  } else {
    finalizeRunEffect = identity$c;
  }
  var env = {
    channel: channel3,
    dispatch: wrapSagaDispatch(dispatch),
    getState,
    sagaMonitor,
    onError,
    finalizeRunEffect
  };
  return immediately(function() {
    var task = proc(
      env,
      iterator$1,
      context2,
      effectId,
      getMetaInfo(saga),
      /* isRoot */
      true,
      void 0
    );
    if (sagaMonitor) {
      sagaMonitor.effectResolved(effectId, task);
    }
    return task;
  });
}
function sagaMiddlewareFactory(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$context = _ref.context, context2 = _ref$context === void 0 ? {} : _ref$context, _ref$channel = _ref.channel, channel3 = _ref$channel === void 0 ? stdChannel() : _ref$channel, sagaMonitor = _ref.sagaMonitor, options = _objectWithoutPropertiesLoose$e(_ref, ["context", "channel", "sagaMonitor"]);
  var boundRunSaga;
  function sagaMiddleware(_ref2) {
    var getState = _ref2.getState, dispatch = _ref2.dispatch;
    boundRunSaga = runSaga.bind(null, _extends$q({}, options, {
      context: context2,
      channel: channel3,
      dispatch,
      getState,
      sagaMonitor
    }));
    return function(next) {
      return function(action) {
        if (sagaMonitor && sagaMonitor.actionDispatched) {
          sagaMonitor.actionDispatched(action);
        }
        var result = next(action);
        channel3.put(action);
        return result;
      };
    };
  }
  sagaMiddleware.run = function() {
    return boundRunSaga.apply(void 0, arguments);
  };
  sagaMiddleware.setContext = function(props3) {
    assignWithSymbols(context2, props3);
  };
  return sagaMiddleware;
}
function _setPrototypeOf$f(o3, p2) {
  _setPrototypeOf$f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$f(o3, p2);
}
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$f(subClass, superClass);
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim2(props3, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim2.isRequired = shim2;
  function getShim() {
    return shim2;
  }
  var ReactPropTypes = {
    array: shim2,
    bigint: shim2,
    bool: shim2,
    func: shim2,
    number: shim2,
    object: shim2,
    string: shim2,
    symbol: shim2,
    any: shim2,
    arrayOf: getShim,
    element: shim2,
    elementType: shim2,
    instanceOf: getShim,
    node: shim2,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var propTypesExports = propTypes.exports;
const PropTypes$1 = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
function isAbsolute(pathname) {
  return pathname.charAt(0) === "/";
}
function spliceOne(list, index3) {
  for (var i = index3, k2 = i + 1, n2 = list.length; k2 < n2; i += 1, k2 += 1) {
    list[i] = list[k2];
  }
  list.pop();
}
function resolvePathname(to2, from2) {
  if (from2 === void 0)
    from2 = "";
  var toParts = to2 && to2.split("/") || [];
  var fromParts = from2 && from2.split("/") || [];
  var isToAbs = to2 && isAbsolute(to2);
  var isFromAbs = from2 && isAbsolute(from2);
  var mustEndAbs = isToAbs || isFromAbs;
  if (to2 && isAbsolute(to2)) {
    fromParts = toParts;
  } else if (toParts.length) {
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }
  if (!fromParts.length)
    return "/";
  var hasTrailingSlash;
  if (fromParts.length) {
    var last2 = fromParts[fromParts.length - 1];
    hasTrailingSlash = last2 === "." || last2 === ".." || last2 === "";
  } else {
    hasTrailingSlash = false;
  }
  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];
    if (part === ".") {
      spliceOne(fromParts, i);
    } else if (part === "..") {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }
  if (!mustEndAbs)
    for (; up--; up)
      fromParts.unshift("..");
  if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0])))
    fromParts.unshift("");
  var result = fromParts.join("/");
  if (hasTrailingSlash && result.substr(-1) !== "/")
    result += "/";
  return result;
}
function valueOf$2(obj) {
  return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);
}
function valueEqual(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 == null || b2 == null)
    return false;
  if (Array.isArray(a2)) {
    return Array.isArray(b2) && a2.length === b2.length && a2.every(function(item, index3) {
      return valueEqual(item, b2[index3]);
    });
  }
  if (typeof a2 === "object" || typeof b2 === "object") {
    var aValue = valueOf$2(a2);
    var bValue = valueOf$2(b2);
    if (aValue !== a2 || bValue !== b2)
      return valueEqual(aValue, bValue);
    return Object.keys(Object.assign({}, a2, b2)).every(function(key) {
      return valueEqual(a2[key], b2[key]);
    });
  }
  return false;
}
var isProduction = true;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}
function addLeadingSlash$2(path3) {
  return path3.charAt(0) === "/" ? path3 : "/" + path3;
}
function stripLeadingSlash(path3) {
  return path3.charAt(0) === "/" ? path3.substr(1) : path3;
}
function hasBasename(path3, prefix2) {
  return path3.toLowerCase().indexOf(prefix2.toLowerCase()) === 0 && "/?#".indexOf(path3.charAt(prefix2.length)) !== -1;
}
function stripBasename$2(path3, prefix2) {
  return hasBasename(path3, prefix2) ? path3.substr(prefix2.length) : path3;
}
function stripTrailingSlash(path3) {
  return path3.charAt(path3.length - 1) === "/" ? path3.slice(0, -1) : path3;
}
function parsePath(path3) {
  var pathname = path3 || "/";
  var search2 = "";
  var hash = "";
  var hashIndex = pathname.indexOf("#");
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }
  var searchIndex = pathname.indexOf("?");
  if (searchIndex !== -1) {
    search2 = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }
  return {
    pathname,
    search: search2 === "?" ? "" : search2,
    hash: hash === "#" ? "" : hash
  };
}
function createPath(location) {
  var pathname = location.pathname, search2 = location.search, hash = location.hash;
  var path3 = pathname || "/";
  if (search2 && search2 !== "?")
    path3 += search2.charAt(0) === "?" ? search2 : "?" + search2;
  if (hash && hash !== "#")
    path3 += hash.charAt(0) === "#" ? hash : "#" + hash;
  return path3;
}
function createLocation(path3, state, key, currentLocation) {
  var location;
  if (typeof path3 === "string") {
    location = parsePath(path3);
    location.state = state;
  } else {
    location = _extends$q({}, path3);
    if (location.pathname === void 0)
      location.pathname = "";
    if (location.search) {
      if (location.search.charAt(0) !== "?")
        location.search = "?" + location.search;
    } else {
      location.search = "";
    }
    if (location.hash) {
      if (location.hash.charAt(0) !== "#")
        location.hash = "#" + location.hash;
    } else {
      location.hash = "";
    }
    if (state !== void 0 && location.state === void 0)
      location.state = state;
  }
  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e3) {
    if (e3 instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
    } else {
      throw e3;
    }
  }
  if (key)
    location.key = key;
  if (currentLocation) {
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== "/") {
      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
    }
  } else {
    if (!location.pathname) {
      location.pathname = "/";
    }
  }
  return location;
}
function locationsAreEqual(a2, b2) {
  return a2.pathname === b2.pathname && a2.search === b2.search && a2.hash === b2.hash && a2.key === b2.key && valueEqual(a2.state, b2.state);
}
function createTransitionManager() {
  var prompt = null;
  function setPrompt(nextPrompt) {
    prompt = nextPrompt;
    return function() {
      if (prompt === nextPrompt)
        prompt = null;
    };
  }
  function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    if (prompt != null) {
      var result = typeof prompt === "function" ? prompt(location, action) : prompt;
      if (typeof result === "string") {
        if (typeof getUserConfirmation === "function") {
          getUserConfirmation(result, callback);
        } else {
          callback(true);
        }
      } else {
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }
  var listeners2 = [];
  function appendListener(fn2) {
    var isActive = true;
    function listener() {
      if (isActive)
        fn2.apply(void 0, arguments);
    }
    listeners2.push(listener);
    return function() {
      isActive = false;
      listeners2 = listeners2.filter(function(item) {
        return item !== listener;
      });
    };
  }
  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    listeners2.forEach(function(listener) {
      return listener.apply(void 0, args);
    });
  }
  return {
    setPrompt,
    confirmTransitionTo,
    appendListener,
    notifyListeners
  };
}
var canUseDOM$1 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message));
}
function supportsHistory() {
  var ua2 = window.navigator.userAgent;
  if ((ua2.indexOf("Android 2.") !== -1 || ua2.indexOf("Android 4.0") !== -1) && ua2.indexOf("Mobile Safari") !== -1 && ua2.indexOf("Chrome") === -1 && ua2.indexOf("Windows Phone") === -1)
    return false;
  return window.history && "pushState" in window.history;
}
function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf("Trident") === -1;
}
function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf("Firefox") === -1;
}
function isExtraneousPopstateEvent(event) {
  return event.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
}
var PopStateEvent = "popstate";
var HashChangeEvent = "hashchange";
function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e3) {
    return {};
  }
}
function createBrowserHistory(props3) {
  if (props3 === void 0) {
    props3 = {};
  }
  !canUseDOM$1 ? invariant(false) : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props3, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props3.basename ? stripTrailingSlash(addLeadingSlash$2(props3.basename)) : "";
  function getDOMLocation(historyState) {
    var _ref = historyState || {}, key = _ref.key, state = _ref.state;
    var _window$location = window.location, pathname = _window$location.pathname, search2 = _window$location.search, hash = _window$location.hash;
    var path3 = pathname + search2 + hash;
    if (basename)
      path3 = stripBasename$2(path3, basename);
    return createLocation(path3, state, key);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$q(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function handlePopState(event) {
    if (isExtraneousPopstateEvent(event))
      return;
    handlePop(getDOMLocation(event.state));
  }
  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }
  var forceNextPop = false;
  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
        if (ok2) {
          setState({
            action,
            location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1)
      toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1)
      fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go2(delta);
    }
  }
  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];
  function createHref(location) {
    return basename + createPath(location);
  }
  function push2(path3, state) {
    var action = "PUSH";
    var location = createLocation(path3, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var href = createHref(location);
      var key = location.key, state2 = location.state;
      if (canUseHistory) {
        globalHistory.pushState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location.key);
          allKeys = nextKeys;
          setState({
            action,
            location
          });
        }
      } else {
        window.location.href = href;
      }
    });
  }
  function replace3(path3, state) {
    var action = "REPLACE";
    var location = createLocation(path3, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var href = createHref(location);
      var key = location.key, state2 = location.state;
      if (canUseHistory) {
        globalHistory.replaceState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1)
            allKeys[prevIndex] = location.key;
          setState({
            action,
            location
          });
        }
      } else {
        window.location.replace(href);
      }
    });
  }
  function go2(n2) {
    globalHistory.go(n2);
  }
  function goBack2() {
    go2(-1);
  }
  function goForward2() {
    go2(1);
  }
  var listenerCount2 = 0;
  function checkDOMListeners(delta) {
    listenerCount2 += delta;
    if (listenerCount2 === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener)
        window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount2 === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener)
        window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push: push2,
    replace: replace3,
    go: go2,
    goBack: goBack2,
    goForward: goForward2,
    block,
    listen
  };
  return history;
}
var HashChangeEvent$1 = "hashchange";
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path3) {
      return path3.charAt(0) === "!" ? path3 : "!/" + stripLeadingSlash(path3);
    },
    decodePath: function decodePath(path3) {
      return path3.charAt(0) === "!" ? path3.substr(1) : path3;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash$2
  },
  slash: {
    encodePath: addLeadingSlash$2,
    decodePath: addLeadingSlash$2
  }
};
function stripHash(url) {
  var hashIndex = url.indexOf("#");
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}
function getHashPath() {
  var href = window.location.href;
  var hashIndex = href.indexOf("#");
  return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
}
function pushHashPath(path3) {
  window.location.hash = path3;
}
function replaceHashPath(path3) {
  window.location.replace(stripHash(window.location.href) + "#" + path3);
}
function createHashHistory(props3) {
  if (props3 === void 0) {
    props3 = {};
  }
  !canUseDOM$1 ? invariant(false) : void 0;
  var globalHistory = window.history;
  supportsGoWithoutReloadUsingHash();
  var _props = props3, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
  var basename = props3.basename ? stripTrailingSlash(addLeadingSlash$2(props3.basename)) : "";
  var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath2 = _HashPathCoders$hashT.encodePath, decodePath2 = _HashPathCoders$hashT.decodePath;
  function getDOMLocation() {
    var path4 = decodePath2(getHashPath());
    if (basename)
      path4 = stripBasename$2(path4, basename);
    return createLocation(path4);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$q(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  var forceNextPop = false;
  var ignorePath = null;
  function locationsAreEqual$$1(a2, b2) {
    return a2.pathname === b2.pathname && a2.search === b2.search && a2.hash === b2.hash;
  }
  function handleHashChange() {
    var path4 = getHashPath();
    var encodedPath2 = encodePath2(path4);
    if (path4 !== encodedPath2) {
      replaceHashPath(encodedPath2);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location))
        return;
      if (ignorePath === createPath(location))
        return;
      ignorePath = null;
      handlePop(location);
    }
  }
  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
        if (ok2) {
          setState({
            action,
            location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1)
      toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1)
      fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go2(delta);
    }
  }
  var path3 = getHashPath();
  var encodedPath = encodePath2(path3);
  if (path3 !== encodedPath)
    replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)];
  function createHref(location) {
    var baseTag = document.querySelector("base");
    var href = "";
    if (baseTag && baseTag.getAttribute("href")) {
      href = stripHash(window.location.href);
    }
    return href + "#" + encodePath2(basename + createPath(location));
  }
  function push2(path4, state) {
    var action = "PUSH";
    var location = createLocation(path4, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var path5 = createPath(location);
      var encodedPath2 = encodePath2(basename + path5);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path5;
        pushHashPath(encodedPath2);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path5);
        allPaths = nextPaths;
        setState({
          action,
          location
        });
      } else {
        setState();
      }
    });
  }
  function replace3(path4, state) {
    var action = "REPLACE";
    var location = createLocation(path4, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var path5 = createPath(location);
      var encodedPath2 = encodePath2(basename + path5);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path5;
        replaceHashPath(encodedPath2);
      }
      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1)
        allPaths[prevIndex] = path5;
      setState({
        action,
        location
      });
    });
  }
  function go2(n2) {
    globalHistory.go(n2);
  }
  function goBack2() {
    go2(-1);
  }
  function goForward2() {
    go2(1);
  }
  var listenerCount2 = 0;
  function checkDOMListeners(delta) {
    listenerCount2 += delta;
    if (listenerCount2 === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount2 === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push: push2,
    replace: replace3,
    go: go2,
    goBack: goBack2,
    goForward: goForward2,
    block,
    listen
  };
  return history;
}
function clamp2(n2, lowerBound, upperBound) {
  return Math.min(Math.max(n2, lowerBound), upperBound);
}
function createMemoryHistory(props3) {
  if (props3 === void 0) {
    props3 = {};
  }
  var _props = props3, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$q(history, nextState);
    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var index3 = clamp2(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function(entry) {
    return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
  });
  var createHref = createPath;
  function push2(path3, state) {
    var action = "PUSH";
    var location = createLocation(path3, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }
      setState({
        action,
        location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }
  function replace3(path3, state) {
    var action = "REPLACE";
    var location = createLocation(path3, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      history.entries[history.index] = location;
      setState({
        action,
        location
      });
    });
  }
  function go2(n2) {
    var nextIndex = clamp2(history.index + n2, 0, history.entries.length - 1);
    var action = "POP";
    var location = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok2) {
      if (ok2) {
        setState({
          action,
          location,
          index: nextIndex
        });
      } else {
        setState();
      }
    });
  }
  function goBack2() {
    go2(-1);
  }
  function goForward2() {
    go2(1);
  }
  function canGo(n2) {
    var nextIndex = history.index + n2;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    return transitionManager.setPrompt(prompt);
  }
  function listen(listener) {
    return transitionManager.appendListener(listener);
  }
  var history = {
    length: entries.length,
    action: "POP",
    location: entries[index3],
    index: index3,
    entries,
    createHref,
    push: push2,
    replace: replace3,
    go: go2,
    goBack: goBack2,
    goForward: goForward2,
    canGo,
    block,
    listen
  };
  return history;
}
var pathToRegexp$2 = { exports: {} };
var isarray$1 = Array.isArray || function(arr) {
  return Object.prototype.toString.call(arr) == "[object Array]";
};
var isarray = isarray$1;
pathToRegexp$2.exports = pathToRegexp;
pathToRegexp$2.exports.parse = parse$2;
pathToRegexp$2.exports.compile = compile;
pathToRegexp$2.exports.tokensToFunction = tokensToFunction;
pathToRegexp$2.exports.tokensToRegExp = tokensToRegExp;
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  "(\\\\.)",
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
].join("|"), "g");
function parse$2(str, options) {
  var tokens2 = [];
  var key = 0;
  var index3 = 0;
  var path3 = "";
  var defaultDelimiter = options && options.delimiter || "/";
  var res;
  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m2 = res[0];
    var escaped = res[1];
    var offset2 = res.index;
    path3 += str.slice(index3, offset2);
    index3 = offset2 + m2.length;
    if (escaped) {
      path3 += escaped[1];
      continue;
    }
    var next = str[index3];
    var prefix2 = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];
    if (path3) {
      tokens2.push(path3);
      path3 = "";
    }
    var partial2 = prefix2 != null && next != null && next !== prefix2;
    var repeat3 = modifier === "+" || modifier === "*";
    var optional = modifier === "?" || modifier === "*";
    var delimiter = res[2] || defaultDelimiter;
    var pattern3 = capture || group;
    tokens2.push({
      name: name || key++,
      prefix: prefix2 || "",
      delimiter,
      optional,
      repeat: repeat3,
      partial: partial2,
      asterisk: !!asterisk,
      pattern: pattern3 ? escapeGroup(pattern3) : asterisk ? ".*" : "[^" + escapeString(delimiter) + "]+?"
    });
  }
  if (index3 < str.length) {
    path3 += str.substr(index3);
  }
  if (path3) {
    tokens2.push(path3);
  }
  return tokens2;
}
function compile(str, options) {
  return tokensToFunction(parse$2(str, options), options);
}
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function tokensToFunction(tokens2, options) {
  var matches2 = new Array(tokens2.length);
  for (var i = 0; i < tokens2.length; i++) {
    if (typeof tokens2[i] === "object") {
      matches2[i] = new RegExp("^(?:" + tokens2[i].pattern + ")$", flags(options));
    }
  }
  return function(obj, opts) {
    var path3 = "";
    var data2 = obj || {};
    var options2 = opts || {};
    var encode2 = options2.pretty ? encodeURIComponentPretty : encodeURIComponent;
    for (var i2 = 0; i2 < tokens2.length; i2++) {
      var token2 = tokens2[i2];
      if (typeof token2 === "string") {
        path3 += token2;
        continue;
      }
      var value = data2[token2.name];
      var segment;
      if (value == null) {
        if (token2.optional) {
          if (token2.partial) {
            path3 += token2.prefix;
          }
          continue;
        } else {
          throw new TypeError('Expected "' + token2.name + '" to be defined');
        }
      }
      if (isarray(value)) {
        if (!token2.repeat) {
          throw new TypeError('Expected "' + token2.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
        }
        if (value.length === 0) {
          if (token2.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token2.name + '" to not be empty');
          }
        }
        for (var j2 = 0; j2 < value.length; j2++) {
          segment = encode2(value[j2]);
          if (!matches2[i2].test(segment)) {
            throw new TypeError('Expected all "' + token2.name + '" to match "' + token2.pattern + '", but received `' + JSON.stringify(segment) + "`");
          }
          path3 += (j2 === 0 ? token2.prefix : token2.delimiter) + segment;
        }
        continue;
      }
      segment = token2.asterisk ? encodeAsterisk(value) : encode2(value);
      if (!matches2[i2].test(segment)) {
        throw new TypeError('Expected "' + token2.name + '" to match "' + token2.pattern + '", but received "' + segment + '"');
      }
      path3 += token2.prefix + segment;
    }
    return path3;
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
}
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, "\\$1");
}
function attachKeys(re2, keys4) {
  re2.keys = keys4;
  return re2;
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path3, keys4) {
  var groups = path3.source.match(/\((?!\?)/g);
  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys4.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }
  return attachKeys(path3, keys4);
}
function arrayToRegexp(path3, keys4, options) {
  var parts = [];
  for (var i = 0; i < path3.length; i++) {
    parts.push(pathToRegexp(path3[i], keys4, options).source);
  }
  var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options));
  return attachKeys(regexp, keys4);
}
function stringToRegexp(path3, keys4, options) {
  return tokensToRegExp(parse$2(path3, options), keys4, options);
}
function tokensToRegExp(tokens2, keys4, options) {
  if (!isarray(keys4)) {
    options = /** @type {!Object} */
    keys4 || options;
    keys4 = [];
  }
  options = options || {};
  var strict = options.strict;
  var end = options.end !== false;
  var route = "";
  for (var i = 0; i < tokens2.length; i++) {
    var token2 = tokens2[i];
    if (typeof token2 === "string") {
      route += escapeString(token2);
    } else {
      var prefix2 = escapeString(token2.prefix);
      var capture = "(?:" + token2.pattern + ")";
      keys4.push(token2);
      if (token2.repeat) {
        capture += "(?:" + prefix2 + capture + ")*";
      }
      if (token2.optional) {
        if (!token2.partial) {
          capture = "(?:" + prefix2 + "(" + capture + "))?";
        } else {
          capture = prefix2 + "(" + capture + ")?";
        }
      } else {
        capture = prefix2 + "(" + capture + ")";
      }
      route += capture;
    }
  }
  var delimiter = escapeString(options.delimiter || "/");
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?";
  }
  if (end) {
    route += "$";
  } else {
    route += strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)";
  }
  return attachKeys(new RegExp("^" + route, flags(options)), keys4);
}
function pathToRegexp(path3, keys4, options) {
  if (!isarray(keys4)) {
    options = /** @type {!Object} */
    keys4 || options;
    keys4 = [];
  }
  options = options || {};
  if (path3 instanceof RegExp) {
    return regexpToRegexp(
      path3,
      /** @type {!Array} */
      keys4
    );
  }
  if (isarray(path3)) {
    return arrayToRegexp(
      /** @type {!Array} */
      path3,
      /** @type {!Array} */
      keys4,
      options
    );
  }
  return stringToRegexp(
    /** @type {string} */
    path3,
    /** @type {!Array} */
    keys4,
    options
  );
}
var pathToRegexpExports = pathToRegexp$2.exports;
const pathToRegexp$1 = /* @__PURE__ */ getDefaultExportFromCjs(pathToRegexpExports);
var reactIs$2 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$2 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$2 = b$1 ? Symbol.for("react.fragment") : 60107, f$2 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$3 = b$1 ? Symbol.for("react.provider") : 60109, k$4 = b$1 ? Symbol.for("react.context") : 60110, l$3 = b$1 ? Symbol.for("react.async_mode") : 60111, m$4 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$4 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$4 = b$1 ? Symbol.for("react.suspense") : 60113, q$4 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$2 = b$1 ? Symbol.for("react.memo") : 60115, t$3 = b$1 ? Symbol.for("react.lazy") : 60116, v$2 = b$1 ? Symbol.for("react.block") : 60121, w$1 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$1 = b$1 ? Symbol.for("react.scope") : 60119;
function z(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$2:
        switch (a2 = a2.type, a2) {
          case l$3:
          case m$4:
          case e$2:
          case g$1:
          case f$2:
          case p$4:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$4:
              case n$4:
              case t$3:
              case r$2:
              case h$3:
                return a2;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A(a2) {
  return z(a2) === m$4;
}
reactIs_production_min$1.AsyncMode = l$3;
reactIs_production_min$1.ConcurrentMode = m$4;
reactIs_production_min$1.ContextConsumer = k$4;
reactIs_production_min$1.ContextProvider = h$3;
reactIs_production_min$1.Element = c$2;
reactIs_production_min$1.ForwardRef = n$4;
reactIs_production_min$1.Fragment = e$2;
reactIs_production_min$1.Lazy = t$3;
reactIs_production_min$1.Memo = r$2;
reactIs_production_min$1.Portal = d$1;
reactIs_production_min$1.Profiler = g$1;
reactIs_production_min$1.StrictMode = f$2;
reactIs_production_min$1.Suspense = p$4;
reactIs_production_min$1.isAsyncMode = function(a2) {
  return A(a2) || z(a2) === l$3;
};
reactIs_production_min$1.isConcurrentMode = A;
reactIs_production_min$1.isContextConsumer = function(a2) {
  return z(a2) === k$4;
};
reactIs_production_min$1.isContextProvider = function(a2) {
  return z(a2) === h$3;
};
reactIs_production_min$1.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$2;
};
reactIs_production_min$1.isForwardRef = function(a2) {
  return z(a2) === n$4;
};
reactIs_production_min$1.isFragment = function(a2) {
  return z(a2) === e$2;
};
reactIs_production_min$1.isLazy = function(a2) {
  return z(a2) === t$3;
};
reactIs_production_min$1.isMemo = function(a2) {
  return z(a2) === r$2;
};
reactIs_production_min$1.isPortal = function(a2) {
  return z(a2) === d$1;
};
reactIs_production_min$1.isProfiler = function(a2) {
  return z(a2) === g$1;
};
reactIs_production_min$1.isStrictMode = function(a2) {
  return z(a2) === f$2;
};
reactIs_production_min$1.isSuspense = function(a2) {
  return z(a2) === p$4;
};
reactIs_production_min$1.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$2 || a2 === m$4 || a2 === g$1 || a2 === f$2 || a2 === p$4 || a2 === q$4 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$3 || a2.$$typeof === r$2 || a2.$$typeof === h$3 || a2.$$typeof === k$4 || a2.$$typeof === n$4 || a2.$$typeof === w$1 || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v$2);
};
reactIs_production_min$1.typeOf = z;
{
  reactIs$2.exports = reactIs_production_min$1;
}
var reactIsExports$1 = reactIs$2.exports;
var reactIs$1 = reactIsExports$1;
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
function getStatics(component) {
  if (reactIs$1.isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty$3 = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }
    var keys4 = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys4 = keys4.concat(getOwnPropertySymbols(sourceComponent));
    }
    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);
    for (var i = 0; i < keys4.length; ++i) {
      var key = keys4[i];
      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          defineProperty$3(targetComponent, key, descriptor);
        } catch (e3) {
        }
      }
    }
  }
  return targetComponent;
}
var hoistNonReactStatics_cjs = hoistNonReactStatics;
const hoistStatics = /* @__PURE__ */ getDefaultExportFromCjs(hoistNonReactStatics_cjs);
var MAX_SIGNED_31_BIT_INT$1 = 1073741823;
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? (
  // eslint-disable-next-line no-undef
  globalThis
) : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
function getUniqueId$1() {
  var key = "__global_unique_id__";
  return commonjsGlobal$1[key] = (commonjsGlobal$1[key] || 0) + 1;
}
function objectIs$1(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function createEventEmitter$1(value) {
  var handlers = [];
  return {
    on: function on3(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function(h2) {
        return h2 !== handler;
      });
    },
    get: function get3() {
      return value;
    },
    set: function set4(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function(handler) {
        return handler(value, changedBits);
      });
    }
  };
}
function onlyChild$1(children) {
  return Array.isArray(children) ? children[0] : children;
}
function createReactContext$1(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;
  var contextProp = "__create-react-context-" + getUniqueId$1() + "__";
  var Provider2 = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose$1(Provider3, _React$Component);
    function Provider3() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.emitter = createEventEmitter$1(_this.props.value);
      return _this;
    }
    var _proto = Provider3.prototype;
    _proto.getChildContext = function getChildContext() {
      var _ref;
      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };
    _proto.componentWillReceiveProps = function componentWillReceiveProps2(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;
        if (objectIs$1(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT$1;
          changedBits |= 0;
          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };
    _proto.render = function render() {
      return this.props.children;
    };
    return Provider3;
  }(React.Component);
  Provider2.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = PropTypes$1.object.isRequired, _Provider$childContex);
  var Consumer = /* @__PURE__ */ function(_React$Component2) {
    _inheritsLoose$1(Consumer2, _React$Component2);
    function Consumer2() {
      var _this2;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _this2 = _React$Component2.call.apply(_React$Component2, [this].concat(args)) || this;
      _this2.observedBits = void 0;
      _this2.state = {
        value: _this2.getValue()
      };
      _this2.onUpdate = function(newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };
      return _this2;
    }
    var _proto2 = Consumer2.prototype;
    _proto2.componentWillReceiveProps = function componentWillReceiveProps2(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT$1 : observedBits;
    };
    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT$1 : observedBits;
    };
    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };
    _proto2.getValue = function getValue2() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };
    _proto2.render = function render() {
      return onlyChild$1(this.props.children)(this.state.value);
    };
    return Consumer2;
  }(React.Component);
  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = PropTypes$1.object, _Consumer$contextType);
  return {
    Provider: Provider2,
    Consumer
  };
}
var createContext = React.createContext || createReactContext$1;
var createNamedContext$1 = function createNamedContext(name) {
  var context2 = createContext();
  context2.displayName = name;
  return context2;
};
var historyContext$1 = /* @__PURE__ */ createNamedContext$1("Router-History");
var context$1 = /* @__PURE__ */ createNamedContext$1("Router");
var Router$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Router2, _React$Component);
  Router2.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };
  function Router2(props3) {
    var _this;
    _this = _React$Component.call(this, props3) || this;
    _this.state = {
      location: props3.history.location
    };
    _this._isMounted = false;
    _this._pendingLocation = null;
    if (!props3.staticContext) {
      _this.unlisten = props3.history.listen(function(location) {
        _this._pendingLocation = location;
      });
    }
    return _this;
  }
  var _proto = Router2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;
    this._isMounted = true;
    if (this.unlisten) {
      this.unlisten();
    }
    if (!this.props.staticContext) {
      this.unlisten = this.props.history.listen(function(location) {
        if (_this2._isMounted) {
          _this2.setState({
            location
          });
        }
      });
    }
    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) {
      this.unlisten();
      this._isMounted = false;
      this._pendingLocation = null;
    }
  };
  _proto.render = function render() {
    return /* @__PURE__ */ React.createElement(context$1.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router2.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, /* @__PURE__ */ React.createElement(historyContext$1.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };
  return Router2;
}(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose$1(MemoryRouter, _React$Component);
  function MemoryRouter() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }
  var _proto = MemoryRouter.prototype;
  _proto.render = function render() {
    return /* @__PURE__ */ React.createElement(Router$1, {
      history: this.history,
      children: this.props.children
    });
  };
  return MemoryRouter;
})(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose$1(Lifecycle2, _React$Component);
  function Lifecycle2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Lifecycle2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount)
      this.props.onMount.call(this, this);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate)
      this.props.onUpdate.call(this, this, prevProps);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount)
      this.props.onUnmount.call(this, this);
  };
  _proto.render = function render() {
    return null;
  };
  return Lifecycle2;
})(React.Component);
var cache$1$1 = {};
var cacheLimit$1$1 = 1e4;
var cacheCount$1$1 = 0;
function compilePath$1$1(path3, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1$1[cacheKey] || (cache$1$1[cacheKey] = {});
  if (pathCache[path3])
    return pathCache[path3];
  var keys4 = [];
  var regexp = pathToRegexp$1(path3, keys4, options);
  var result = {
    regexp,
    keys: keys4
  };
  if (cacheCount$1$1 < cacheLimit$1$1) {
    pathCache[path3] = result;
    cacheCount$1$1++;
  }
  return result;
}
function matchPath$1(pathname, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }
  var _options = options, path3 = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths3 = [].concat(path3);
  return paths3.reduce(function(matched, path4) {
    if (!path4 && path4 !== "")
      return null;
    if (matched)
      return matched;
    var _compilePath = compilePath$1$1(path4, {
      end: exact,
      strict,
      sensitive
    }), regexp = _compilePath.regexp, keys4 = _compilePath.keys;
    var match5 = regexp.exec(pathname);
    if (!match5)
      return null;
    var url = match5[0], values3 = match5.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact)
      return null;
    return {
      path: path4,
      // the path used to match
      url: path4 === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact,
      // whether or not we matched exactly
      params: keys4.reduce(function(memo, key, index3) {
        memo[key.name] = values3[index3];
        return memo;
      }, {})
    };
  }, null);
}
function isEmptyChildren$1(children) {
  return React.Children.count(children) === 0;
}
var Route = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Route2, _React$Component);
  function Route2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Route2.prototype;
  _proto.render = function render() {
    var _this = this;
    return /* @__PURE__ */ React.createElement(context$1.Consumer, null, function(context$1$1) {
      !context$1$1 ? invariant(false) : void 0;
      var location = _this.props.location || context$1$1.location;
      var match5 = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath$1(location.pathname, _this.props) : context$1$1.match;
      var props3 = _extends$q({}, context$1$1, {
        location,
        match: match5
      });
      var _this$props = _this.props, children = _this$props.children, component = _this$props.component, render2 = _this$props.render;
      if (Array.isArray(children) && isEmptyChildren$1(children)) {
        children = null;
      }
      return /* @__PURE__ */ React.createElement(context$1.Provider, {
        value: props3
      }, props3.match ? children ? typeof children === "function" ? children(props3) : children : component ? /* @__PURE__ */ React.createElement(component, props3) : render2 ? render2(props3) : null : typeof children === "function" ? children(props3) : null);
    });
  };
  return Route2;
}(React.Component);
function addLeadingSlash$1(path3) {
  return path3.charAt(0) === "/" ? path3 : "/" + path3;
}
function addBasename$1(basename, location) {
  if (!basename)
    return location;
  return _extends$q({}, location, {
    pathname: addLeadingSlash$1(basename) + location.pathname
  });
}
function stripBasename$1(basename, location) {
  if (!basename)
    return location;
  var base = addLeadingSlash$1(basename);
  if (location.pathname.indexOf(base) !== 0)
    return location;
  return _extends$q({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}
function createURL$1(location) {
  return typeof location === "string" ? location : createPath(location);
}
function staticHandler$1(methodName) {
  return function() {
    invariant(false);
  };
}
function noop$5() {
}
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose$1(StaticRouter, _React$Component);
  function StaticRouter() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handlePush = function(location) {
      return _this.navigateTo(location, "PUSH");
    };
    _this.handleReplace = function(location) {
      return _this.navigateTo(location, "REPLACE");
    };
    _this.handleListen = function() {
      return noop$5;
    };
    _this.handleBlock = function() {
      return noop$5;
    };
    return _this;
  }
  var _proto = StaticRouter.prototype;
  _proto.navigateTo = function navigateTo(location, action) {
    var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
    context2.action = action;
    context2.location = addBasename$1(basename, createLocation(location));
    context2.url = createURL$1(context2.location);
  };
  _proto.render = function render() {
    var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose$e(_this$props2, ["basename", "context", "location"]);
    var history = {
      createHref: function createHref(path3) {
        return addLeadingSlash$1(basename + createURL$1(path3));
      },
      action: "POP",
      location: stripBasename$1(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler$1(),
      goBack: staticHandler$1(),
      goForward: staticHandler$1(),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return /* @__PURE__ */ React.createElement(Router$1, _extends$q({}, rest, {
      history,
      staticContext: context2
    }));
  };
  return StaticRouter;
})(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose$1(Switch, _React$Component);
  function Switch() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Switch.prototype;
  _proto.render = function render() {
    var _this = this;
    return /* @__PURE__ */ React.createElement(context$1.Consumer, null, function(context2) {
      !context2 ? invariant(false) : void 0;
      var location = _this.props.location || context2.location;
      var element, match5;
      React.Children.forEach(_this.props.children, function(child) {
        if (match5 == null && /* @__PURE__ */ React.isValidElement(child)) {
          element = child;
          var path3 = child.props.path || child.props.from;
          match5 = path3 ? matchPath$1(location.pathname, _extends$q({}, child.props, {
            path: path3
          })) : context2.match;
        }
      });
      return match5 ? /* @__PURE__ */ React.cloneElement(element, {
        location,
        computedMatch: match5
      }) : null;
    });
  };
  return Switch;
})(React.Component);
var useContext = React.useContext;
function useHistory() {
  return useContext(historyContext$1);
}
function useLocation() {
  return useContext(context$1).location;
}
function useParams() {
  var match5 = useContext(context$1).match;
  return match5 ? match5.params : {};
}
function useRouteMatch(path3) {
  var location = useLocation();
  var match5 = useContext(context$1).match;
  return path3 ? matchPath$1(location.pathname, path3) : match5;
}
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$1 = reactExports;
function h$2(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k$3 = "function" === typeof Object.is ? Object.is : h$2, l$2 = e$1.useState, m$3 = e$1.useEffect, n$3 = e$1.useLayoutEffect, p$3 = e$1.useDebugValue;
function q$3(a2, b2) {
  var d2 = b2(), f2 = l$2({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$3(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$1(c2) && g2({ inst: c2 });
  }, [a2, d2, b2]);
  m$3(function() {
    r$1(c2) && g2({ inst: c2 });
    return a2(function() {
      r$1(c2) && g2({ inst: c2 });
    });
  }, [a2]);
  p$3(d2);
  return d2;
}
function r$1(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k$3(a2, d2);
  } catch (f2) {
    return true;
  }
}
function t$2(a2, b2) {
  return b2();
}
var u$2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$2 : q$3;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$1.useSyncExternalStore ? e$1.useSyncExternalStore : u$2;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim.exports;
var withSelector = { exports: {} };
var withSelector_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$1 = reactExports, n$2 = shimExports;
function p$2(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var q$2 = "function" === typeof Object.is ? Object.is : p$2, r = n$2.useSyncExternalStore, t$1 = h$1.useRef, u$1 = h$1.useEffect, v$1 = h$1.useMemo, w = h$1.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e3, l2, g2) {
  var c2 = t$1(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else
    f2 = c2.current;
  c2 = v$1(function() {
    function a3(a4) {
      if (!c3) {
        c3 = true;
        d3 = a4;
        a4 = l2(a4);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a4))
            return k2 = b3;
        }
        return k2 = a4;
      }
      b3 = k2;
      if (q$2(d3, a4))
        return b3;
      var e4 = l2(a4);
      if (void 0 !== g2 && g2(b3, e4))
        return b3;
      d3 = a4;
      return k2 = e4;
    }
    var c3 = false, d3, k2, m2 = void 0 === e3 ? null : e3;
    return [function() {
      return a3(b2());
    }, null === m2 ? void 0 : function() {
      return a3(m2());
    }];
  }, [b2, e3, l2, g2]);
  var d2 = r(a2, c2[0], c2[1]);
  u$1(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w(d2);
  return d2;
};
{
  withSelector.exports = withSelector_production_min;
}
var withSelectorExports = withSelector.exports;
function defaultNoopBatch(callback) {
  callback();
}
let batch = defaultNoopBatch;
const setBatch = (newBatch) => batch = newBatch;
const getBatch = () => batch;
const ReactReduxContext = /* @__PURE__ */ reactExports.createContext(null);
function useReduxContext() {
  const contextValue = reactExports.useContext(ReactReduxContext);
  return contextValue;
}
const notInitialized = () => {
  throw new Error("uSES not initialized!");
};
let useSyncExternalStoreWithSelector = notInitialized;
const initializeUseSelector = (fn2) => {
  useSyncExternalStoreWithSelector = fn2;
};
const refEquality = (a2, b2) => a2 === b2;
function createSelectorHook(context2 = ReactReduxContext) {
  const useReduxContext$1 = context2 === ReactReduxContext ? useReduxContext : () => reactExports.useContext(context2);
  return function useSelector2(selector, equalityFn = refEquality) {
    const {
      store,
      subscription,
      getServerState
    } = useReduxContext$1();
    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, selector, equalityFn);
    reactExports.useDebugValue(selectedState);
    return selectedState;
  };
}
const useSelector = /* @__PURE__ */ createSelectorHook();
var reactIs = { exports: {} };
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = Symbol.for("react.element"), c$1 = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f$1 = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k$2 = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m$2 = Symbol.for("react.suspense"), n$1 = Symbol.for("react.suspense_list"), p$1 = Symbol.for("react.memo"), q$1 = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
u = Symbol.for("react.module.reference");
function v(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var r2 = a2.$$typeof;
    switch (r2) {
      case b:
        switch (a2 = a2.type, a2) {
          case d:
          case f$1:
          case e:
          case m$2:
          case n$1:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case h:
              case l$1:
              case q$1:
              case p$1:
              case g:
                return a2;
              default:
                return r2;
            }
        }
      case c$1:
        return r2;
    }
  }
}
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = g;
reactIs_production_min.Element = b;
reactIs_production_min.ForwardRef = l$1;
reactIs_production_min.Fragment = d;
reactIs_production_min.Lazy = q$1;
reactIs_production_min.Memo = p$1;
reactIs_production_min.Portal = c$1;
reactIs_production_min.Profiler = f$1;
reactIs_production_min.StrictMode = e;
reactIs_production_min.Suspense = m$2;
reactIs_production_min.SuspenseList = n$1;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a2) {
  return v(a2) === h;
};
reactIs_production_min.isContextProvider = function(a2) {
  return v(a2) === g;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b;
};
reactIs_production_min.isForwardRef = function(a2) {
  return v(a2) === l$1;
};
reactIs_production_min.isFragment = function(a2) {
  return v(a2) === d;
};
reactIs_production_min.isLazy = function(a2) {
  return v(a2) === q$1;
};
reactIs_production_min.isMemo = function(a2) {
  return v(a2) === p$1;
};
reactIs_production_min.isPortal = function(a2) {
  return v(a2) === c$1;
};
reactIs_production_min.isProfiler = function(a2) {
  return v(a2) === f$1;
};
reactIs_production_min.isStrictMode = function(a2) {
  return v(a2) === e;
};
reactIs_production_min.isSuspense = function(a2) {
  return v(a2) === m$2;
};
reactIs_production_min.isSuspenseList = function(a2) {
  return v(a2) === n$1;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d || a2 === f$1 || a2 === e || a2 === m$2 || a2 === n$1 || a2 === t || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q$1 || a2.$$typeof === p$1 || a2.$$typeof === g || a2.$$typeof === h || a2.$$typeof === l$1 || a2.$$typeof === u || void 0 !== a2.getModuleId) ? true : false;
};
reactIs_production_min.typeOf = v;
{
  reactIs.exports = reactIs_production_min;
}
var reactIsExports = reactIs.exports;
const _excluded$e = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {
  areStatesEqual,
  areOwnPropsEqual,
  areStatePropsEqual
}) {
  let hasRunAtLeastOnce = false;
  let state;
  let ownProps;
  let stateProps;
  let dispatchProps;
  let mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    const nextStateProps = mapStateToProps(state, ownProps);
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged)
      return handleNewPropsAndNewState();
    if (propsChanged)
      return handleNewProps();
    if (stateChanged)
      return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch, _ref) {
  let {
    initMapStateToProps,
    initMapDispatchToProps,
    initMergeProps
  } = _ref, options = _objectWithoutPropertiesLoose$e(_ref, _excluded$e);
  const mapStateToProps = initMapStateToProps(dispatch, options);
  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  const mergeProps = initMergeProps(dispatch, options);
  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
function bindActionCreators(actionCreators, dispatch) {
  const boundActionCreators = {};
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));
    }
  }
  return boundActionCreators;
}
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch) {
    const constant2 = getConstant(dispatch);
    function constantSelector() {
      return constant2;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, {
    displayName
  }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      let props3 = proxy(stateOrDispatch, ownProps);
      if (typeof props3 === "function") {
        proxy.mapToProps = props3;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props3);
        props3 = proxy(stateOrDispatch, ownProps);
      }
      return props3;
    };
    return proxy;
  };
}
function createInvalidArgFactory(arg, name) {
  return (dispatch, options) => {
    throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);
  };
}
function mapDispatchToPropsFactory(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant((dispatch) => (
    // @ts-ignore
    bindActionCreators(mapDispatchToProps, dispatch)
  )) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch) => ({
    dispatch
  })) : typeof mapDispatchToProps === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapDispatchToProps)
  ) : createInvalidArgFactory(mapDispatchToProps, "mapDispatchToProps");
}
function mapStateToPropsFactory(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapStateToProps)
  ) : createInvalidArgFactory(mapStateToProps, "mapStateToProps");
}
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends$q({}, ownProps, stateProps, dispatchProps);
}
function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, {
    displayName,
    areMergedPropsEqual
  }) {
    let hasRunOnce = false;
    let mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      if (hasRunOnce) {
        if (!areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
      }
      return mergedProps;
    };
  };
}
function mergePropsFactory(mergeProps) {
  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, "mergeProps");
}
function createListenerCollection() {
  const batch2 = getBatch();
  let first = null;
  let last2 = null;
  return {
    clear() {
      first = null;
      last2 = null;
    },
    notify() {
      batch2(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      let listeners2 = [];
      let listener = first;
      while (listener) {
        listeners2.push(listener);
        listener = listener.next;
      }
      return listeners2;
    },
    subscribe(callback) {
      let isSubscribed = true;
      let listener = last2 = {
        callback,
        next: null,
        prev: last2
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last2 = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
const nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners2 = nullListeners;
  function addNestedSub(listener) {
    trySubscribe();
    return listeners2.subscribe(listener);
  }
  function notifyNestedSubs() {
    listeners2.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return Boolean(unsubscribe);
  }
  function trySubscribe() {
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners2 = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    if (unsubscribe) {
      unsubscribe();
      unsubscribe = void 0;
      listeners2.clear();
      listeners2 = nullListeners;
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe,
    tryUnsubscribe,
    getListeners: () => listeners2
  };
  return subscription;
}
const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const useIsomorphicLayoutEffect$1 = canUseDOM ? reactExports.useLayoutEffect : reactExports.useEffect;
function is2(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || y2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function shallowEqual$1(objA, objB) {
  if (is2(objA, objB))
    return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length)
    return false;
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is2(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
const _excluded$d = ["reactReduxForwardedRef"];
let useSyncExternalStore = notInitialized;
const initializeConnect = (fn2) => {
  useSyncExternalStore = fn2;
};
const NO_SUBSCRIPTION_ARRAY = [null, null];
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect$1(() => effectFunc(...effectArgs), dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
  if (!shouldHandleStateChanges)
    return () => {
    };
  let didUnsubscribe = false;
  let lastThrownError = null;
  const checkForUpdates = () => {
    if (didUnsubscribe || !isMounted.current) {
      return;
    }
    const latestStoreState = store.getState();
    let newChildProps, error;
    try {
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e3) {
      error = e3;
      lastThrownError = e3;
    }
    if (!error) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      additionalSubscribeListener();
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  const unsubscribeWrapper = () => {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
function strictEqual(a2, b2) {
  return a2 === b2;
}
function connect(mapStateToProps, mapDispatchToProps, mergeProps, {
  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
  // @ts-ignore
  pure,
  areStatesEqual = strictEqual,
  areOwnPropsEqual = shallowEqual$1,
  areStatePropsEqual = shallowEqual$1,
  areMergedPropsEqual = shallowEqual$1,
  // use React's forwardRef to expose a ref of the wrapped component
  forwardRef = false,
  // the context consumer to use
  context: context2 = ReactReduxContext
} = {}) {
  const Context = context2;
  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);
  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);
  const initMergeProps = mergePropsFactory(mergeProps);
  const shouldHandleStateChanges = Boolean(mapStateToProps);
  const wrapWithConnect = (WrappedComponent) => {
    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    const displayName = `Connect(${wrappedComponentName})`;
    const selectorFactoryOptions = {
      shouldHandleStateChanges,
      displayName,
      wrappedComponentName,
      WrappedComponent,
      // @ts-ignore
      initMapStateToProps,
      // @ts-ignore
      initMapDispatchToProps,
      initMergeProps,
      areStatesEqual,
      areStatePropsEqual,
      areOwnPropsEqual,
      areMergedPropsEqual
    };
    function ConnectFunction(props3) {
      const [propsContext, reactReduxForwardedRef, wrapperProps] = reactExports.useMemo(() => {
        const {
          reactReduxForwardedRef: reactReduxForwardedRef2
        } = props3, wrapperProps2 = _objectWithoutPropertiesLoose$e(props3, _excluded$d);
        return [props3.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props3]);
      const ContextToUse = reactExports.useMemo(() => {
        return propsContext && propsContext.Consumer && // @ts-ignore
        reactIsExports.isContextConsumer(/* @__PURE__ */ React.createElement(propsContext.Consumer, null)) ? propsContext : Context;
      }, [propsContext, Context]);
      const contextValue = reactExports.useContext(ContextToUse);
      const didStoreComeFromProps = Boolean(props3.store) && Boolean(props3.store.getState) && Boolean(props3.store.dispatch);
      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
      const store = didStoreComeFromProps ? props3.store : contextValue.store;
      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
      const childPropsSelector = reactExports.useMemo(() => {
        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);
      }, [store]);
      const [subscription, notifyNestedSubs] = reactExports.useMemo(() => {
        if (!shouldHandleStateChanges)
          return NO_SUBSCRIPTION_ARRAY;
        const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);
        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store, didStoreComeFromProps, contextValue]);
      const overriddenContextValue = reactExports.useMemo(() => {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return _extends$q({}, contextValue, {
          subscription
        });
      }, [didStoreComeFromProps, contextValue, subscription]);
      const lastChildProps = reactExports.useRef();
      const lastWrapperProps = reactExports.useRef(wrapperProps);
      const childPropsFromStoreUpdate = reactExports.useRef();
      const renderIsScheduled = reactExports.useRef(false);
      reactExports.useRef(false);
      const isMounted = reactExports.useRef(false);
      const latestSubscriptionCallbackError = reactExports.useRef();
      useIsomorphicLayoutEffect$1(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      const actualChildPropsSelector = reactExports.useMemo(() => {
        const selector = () => {
          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
            return childPropsFromStoreUpdate.current;
          }
          return childPropsSelector(store.getState(), wrapperProps);
        };
        return selector;
      }, [store, wrapperProps]);
      const subscribeForReact = reactExports.useMemo(() => {
        const subscribe = (reactListener) => {
          if (!subscription) {
            return () => {
            };
          }
          return subscribeUpdates(
            shouldHandleStateChanges,
            store,
            subscription,
            // @ts-ignore
            childPropsSelector,
            lastWrapperProps,
            lastChildProps,
            renderIsScheduled,
            isMounted,
            childPropsFromStoreUpdate,
            notifyNestedSubs,
            reactListener
          );
        };
        return subscribe;
      }, [subscription]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);
      let actualChildProps;
      try {
        actualChildProps = useSyncExternalStore(
          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
          subscribeForReact,
          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
          actualChildPropsSelector,
          getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector
        );
      } catch (err) {
        if (latestSubscriptionCallbackError.current) {
          err.message += `
The error may be correlated with this previous error:
${latestSubscriptionCallbackError.current.stack}

`;
        }
        throw err;
      }
      useIsomorphicLayoutEffect$1(() => {
        latestSubscriptionCallbackError.current = void 0;
        childPropsFromStoreUpdate.current = void 0;
        lastChildProps.current = actualChildProps;
      });
      const renderedWrappedComponent = reactExports.useMemo(() => {
        return (
          // @ts-ignore
          /* @__PURE__ */ React.createElement(WrappedComponent, _extends$q({}, actualChildProps, {
            ref: reactReduxForwardedRef
          }))
        );
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      const renderedChild = reactExports.useMemo(() => {
        if (shouldHandleStateChanges) {
          return /* @__PURE__ */ React.createElement(ContextToUse.Provider, {
            value: overriddenContextValue
          }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    const _Connect = React.memo(ConnectFunction);
    const Connect = _Connect;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef) {
      const _forwarded = React.forwardRef(function forwardConnectRef(props3, ref) {
        return /* @__PURE__ */ React.createElement(Connect, _extends$q({}, props3, {
          reactReduxForwardedRef: ref
        }));
      });
      const forwarded = _forwarded;
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return hoistStatics(forwarded, WrappedComponent);
    }
    return hoistStatics(Connect, WrappedComponent);
  };
  return wrapWithConnect;
}
function Provider({
  store,
  context: context2,
  children,
  serverState
}) {
  const contextValue = reactExports.useMemo(() => {
    const subscription = createSubscription(store);
    return {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
  }, [store, serverState]);
  const previousState = reactExports.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect$1(() => {
    const {
      subscription
    } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context2 || ReactReduxContext;
  return /* @__PURE__ */ React.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
function createStoreHook(context2 = ReactReduxContext) {
  const useReduxContext$1 = (
    // @ts-ignore
    context2 === ReactReduxContext ? useReduxContext : () => reactExports.useContext(context2)
  );
  return function useStore2() {
    const {
      store
    } = useReduxContext$1();
    return store;
  };
}
const useStore = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context2 = ReactReduxContext) {
  const useStore$1 = (
    // @ts-ignore
    context2 === ReactReduxContext ? useStore : createStoreHook(context2)
  );
  return function useDispatch2() {
    const store = useStore$1();
    return store.dispatch;
  };
}
const useDispatch = /* @__PURE__ */ createDispatchHook();
initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
initializeConnect(shimExports.useSyncExternalStore);
setBatch(reactDomExports.unstable_batchedUpdates);
var lodash_isequalwith = { exports: {} };
lodash_isequalwith.exports;
(function(module2, exports) {
  var LARGE_ARRAY_SIZE2 = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", weakMapTag2 = "[object WeakMap]";
  var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint2 = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags2 = {};
  typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
  typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
  var freeGlobal2 = typeof commonjsGlobal$2 == "object" && commonjsGlobal$2 && commonjsGlobal$2.Object === Object && commonjsGlobal$2;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      return freeProcess && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  var nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
  function arraySome2(array3, predicate3) {
    var index3 = -1, length3 = array3 ? array3.length : 0;
    while (++index3 < length3) {
      if (predicate3(array3[index3], index3, array3)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes2(n2, iteratee) {
    var index3 = -1, result = Array(n2);
    while (++index3 < n2) {
      result[index3] = iteratee(index3);
    }
    return result;
  }
  function baseUnary2(func3) {
    return function(value) {
      return func3(value);
    };
  }
  function getValue2(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e3) {
      }
    }
    return result;
  }
  function mapToArray2(map3) {
    var index3 = -1, result = Array(map3.size);
    map3.forEach(function(value, key) {
      result[++index3] = [key, value];
    });
    return result;
  }
  function overArg2(func3, transform) {
    return function(arg) {
      return func3(transform(arg));
    };
  }
  function setToArray2(set4) {
    var index3 = -1, result = Array(set4.size);
    set4.forEach(function(value) {
      result[++index3] = value;
    });
    return result;
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var objectToString2 = objectProto2.toString;
  var reIsNative2 = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice;
  var nativeKeys2 = overArg2(Object.keys, Object);
  var DataView2 = getNative2(root2, "DataView"), Map2 = getNative2(root2, "Map"), Promise2 = getNative2(root2, "Promise"), Set2 = getNative2(root2, "Set"), WeakMap2 = getNative2(root2, "WeakMap"), nativeCreate2 = getNative2(Object, "create");
  var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash2(entries) {
    var index3 = -1, length3 = entries ? entries.length : 0;
    this.clear();
    while (++index3 < length3) {
      var entry = entries[index3];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
  }
  function hashDelete2(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet2(key) {
    var data2 = this.__data__;
    if (nativeCreate2) {
      var result = data2[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
  }
  function hashHas2(key) {
    var data2 = this.__data__;
    return nativeCreate2 ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
  }
  function hashSet2(key, value) {
    var data2 = this.__data__;
    data2[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index3 = -1, length3 = entries ? entries.length : 0;
    this.clear();
    while (++index3 < length3) {
      var entry = entries[index3];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
  }
  function listCacheDelete2(key) {
    var data2 = this.__data__, index3 = assocIndexOf2(data2, key);
    if (index3 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index3 == lastIndex) {
      data2.pop();
    } else {
      splice2.call(data2, index3, 1);
    }
    return true;
  }
  function listCacheGet2(key) {
    var data2 = this.__data__, index3 = assocIndexOf2(data2, key);
    return index3 < 0 ? void 0 : data2[index3][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data2 = this.__data__, index3 = assocIndexOf2(data2, key);
    if (index3 < 0) {
      data2.push([key, value]);
    } else {
      data2[index3][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index3 = -1, length3 = entries ? entries.length : 0;
    this.clear();
    while (++index3 < length3) {
      var entry = entries[index3];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    return getMapData2(this, key)["delete"](key);
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    getMapData2(this, key).set(key, value);
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function SetCache2(values3) {
    var index3 = -1, length3 = values3 ? values3.length : 0;
    this.__data__ = new MapCache2();
    while (++index3 < length3) {
      this.add(values3[index3]);
    }
  }
  function setCacheAdd2(value) {
    this.__data__.set(value, HASH_UNDEFINED2);
    return this;
  }
  function setCacheHas2(value) {
    return this.__data__.has(value);
  }
  SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
  SetCache2.prototype.has = setCacheHas2;
  function Stack2(entries) {
    this.__data__ = new ListCache2(entries);
  }
  function stackClear2() {
    this.__data__ = new ListCache2();
  }
  function stackDelete2(key) {
    return this.__data__["delete"](key);
  }
  function stackGet2(key) {
    return this.__data__.get(key);
  }
  function stackHas2(key) {
    return this.__data__.has(key);
  }
  function stackSet2(key, value) {
    var cache2 = this.__data__;
    if (cache2 instanceof ListCache2) {
      var pairs = cache2.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache2 = this.__data__ = new MapCache2(pairs);
    }
    cache2.set(key, value);
    return this;
  }
  Stack2.prototype.clear = stackClear2;
  Stack2.prototype["delete"] = stackDelete2;
  Stack2.prototype.get = stackGet2;
  Stack2.prototype.has = stackHas2;
  Stack2.prototype.set = stackSet2;
  function arrayLikeKeys2(value, inherited) {
    var result = isArray2(value) || isArguments2(value) ? baseTimes2(value.length, String) : [];
    var length3 = result.length, skipIndexes = !!length3;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex2(key, length3)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf2(array3, key) {
    var length3 = array3.length;
    while (length3--) {
      if (eq2(array3[length3][0], key)) {
        return length3;
      }
    }
    return -1;
  }
  function baseGetTag2(value) {
    return objectToString2.call(value);
  }
  function baseIsEqual2(value, other, customizer, bitmask, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObject2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep2(value, other, baseIsEqual2, customizer, bitmask, stack);
  }
  function baseIsEqualDeep2(object2, other, equalFunc, customizer, bitmask, stack) {
    var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = arrayTag2, othTag = arrayTag2;
    if (!objIsArr) {
      objTag = getTag2(object2);
      objTag = objTag == argsTag2 ? objectTag2 : objTag;
    }
    if (!othIsArr) {
      othTag = getTag2(other);
      othTag = othTag == argsTag2 ? objectTag2 : othTag;
    }
    var objIsObj = objTag == objectTag2 && !isHostObject(object2), othIsObj = othTag == objectTag2 && !isHostObject(other), isSameTag = objTag == othTag;
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack2());
      return objIsArr || isTypedArray2(object2) ? equalArrays2(object2, other, equalFunc, customizer, bitmask, stack) : equalByTag2(object2, other, objTag, equalFunc, customizer, bitmask, stack);
    }
    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack2());
        return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack2());
    return equalObjects2(object2, other, equalFunc, customizer, bitmask, stack);
  }
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern3 = isFunction2(value) || isHostObject(value) ? reIsNative2 : reIsHostCtor2;
    return pattern3.test(toSource2(value));
  }
  function baseIsTypedArray2(value) {
    return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[objectToString2.call(value)];
  }
  function baseKeys2(object2) {
    if (!isPrototype2(object2)) {
      return nativeKeys2(object2);
    }
    var result = [];
    for (var key in Object(object2)) {
      if (hasOwnProperty2.call(object2, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function equalArrays2(array3, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array3.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array3);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index3 = -1, result = true, seen2 = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache2() : void 0;
    stack.set(array3, other);
    stack.set(other, array3);
    while (++index3 < arrLength) {
      var arrValue = array3[index3], othValue = other[index3];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index3, other, array3, stack) : customizer(arrValue, othValue, index3, array3, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen2) {
        if (!arraySome2(other, function(othValue2, othIndex) {
          if (!seen2.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
            return seen2.add(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array3);
    stack["delete"](other);
    return result;
  }
  function equalByTag2(object2, other, tag, equalFunc, customizer, bitmask, stack) {
    switch (tag) {
      case dataViewTag2:
        if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
          return false;
        }
        object2 = object2.buffer;
        other = other.buffer;
      case arrayBufferTag2:
        if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag2:
      case dateTag2:
      case numberTag2:
        return eq2(+object2, +other);
      case errorTag2:
        return object2.name == other.name && object2.message == other.message;
      case regexpTag2:
      case stringTag2:
        return object2 == other + "";
      case mapTag2:
        var convert2 = mapToArray2;
      case setTag2:
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
        convert2 || (convert2 = setToArray2);
        if (object2.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object2);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= UNORDERED_COMPARE_FLAG;
        stack.set(object2, other);
        var result = equalArrays2(convert2(object2), convert2(other), equalFunc, customizer, bitmask, stack);
        stack["delete"](object2);
        return result;
      case symbolTag2:
        if (symbolValueOf2) {
          return symbolValueOf2.call(object2) == symbolValueOf2.call(other);
        }
    }
    return false;
  }
  function equalObjects2(object2, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys4(object2), objLength = objProps.length, othProps = keys4(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index3 = objLength;
    while (index3--) {
      var key = objProps[index3];
      if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object2);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object2, other);
    stack.set(other, object2);
    var skipCtor = isPartial;
    while (++index3 < objLength) {
      key = objProps[index3];
      var objValue = object2[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object2.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object2);
    stack["delete"](other);
    return result;
  }
  function getMapData2(map3, key) {
    var data2 = map3.__data__;
    return isKeyable2(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  function getNative2(object2, key) {
    var value = getValue2(object2, key);
    return baseIsNative2(value) ? value : void 0;
  }
  var getTag2 = baseGetTag2;
  if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
    getTag2 = function(value) {
      var result = objectToString2.call(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString2:
            return dataViewTag2;
          case mapCtorString2:
            return mapTag2;
          case promiseCtorString2:
            return promiseTag2;
          case setCtorString2:
            return setTag2;
          case weakMapCtorString2:
            return weakMapTag2;
        }
      }
      return result;
    };
  }
  function isIndex2(value, length3) {
    length3 = length3 == null ? MAX_SAFE_INTEGER2 : length3;
    return !!length3 && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
  }
  function isKeyable2(value) {
    var type3 = typeof value;
    return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func3) {
    return !!maskSrcKey2 && maskSrcKey2 in func3;
  }
  function isPrototype2(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto2;
  }
  function toSource2(func3) {
    if (func3 != null) {
      try {
        return funcToString2.call(func3);
      } catch (e3) {
      }
      try {
        return func3 + "";
      } catch (e3) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments2(value) {
    return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable2.call(value, "callee") || objectToString2.call(value) == argsTag2);
  }
  var isArray2 = Array.isArray;
  function isArrayLike3(value) {
    return value != null && isLength2(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike2(value) && isArrayLike3(value);
  }
  function isEqualWith2(value, other, customizer) {
    customizer = typeof customizer == "function" ? customizer : void 0;
    var result = customizer ? customizer(value, other) : void 0;
    return result === void 0 ? baseIsEqual2(value, other, customizer) : !!result;
  }
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString2.call(value) : "";
    return tag == funcTag2 || tag == genTag2;
  }
  function isLength2(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type3 = typeof value;
    return !!value && (type3 == "object" || type3 == "function");
  }
  function isObjectLike2(value) {
    return !!value && typeof value == "object";
  }
  var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
  function keys4(object2) {
    return isArrayLike3(object2) ? arrayLikeKeys2(object2) : baseKeys2(object2);
  }
  module2.exports = isEqualWith2;
})(lodash_isequalwith, lodash_isequalwith.exports);
var lodash_isequalwithExports = lodash_isequalwith.exports;
const isEqualWith = /* @__PURE__ */ getDefaultExportFromCjs(lodash_isequalwithExports);
var LOCATION_CHANGE = "@@router/LOCATION_CHANGE";
var onLocationChanged = function onLocationChanged2(location, action) {
  var isFirstRendering = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  return {
    type: LOCATION_CHANGE,
    payload: {
      location,
      action,
      isFirstRendering
    }
  };
};
var CALL_HISTORY_METHOD = "@@router/CALL_HISTORY_METHOD";
var updateLocation = function updateLocation2(method) {
  return function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return {
      type: CALL_HISTORY_METHOD,
      payload: {
        method,
        args
      }
    };
  };
};
var push = updateLocation("push");
var replace2 = updateLocation("replace");
var go = updateLocation("go");
var goBack = updateLocation("goBack");
var goForward = updateLocation("goForward");
var routerActions = {
  push,
  replace: replace2,
  go,
  goBack,
  goForward
};
function _typeof$x(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$x = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$x = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$x(obj);
}
var createSelectors = function createSelectors2(structure2) {
  var getIn3 = structure2.getIn, toJS2 = structure2.toJS;
  var isRouter = function isRouter2(value) {
    return value != null && _typeof$x(value) === "object" && getIn3(value, ["location"]) && getIn3(value, ["action"]);
  };
  var getRouter2 = function getRouter3(state) {
    var router = toJS2(getIn3(state, ["router"]));
    if (!isRouter(router)) {
      throw 'Could not find router reducer in state tree, it must be mounted under "router"';
    }
    return router;
  };
  var getLocation2 = function getLocation3(state) {
    return toJS2(getIn3(getRouter2(state), ["location"]));
  };
  var getAction2 = function getAction3(state) {
    return toJS2(getIn3(getRouter2(state), ["action"]));
  };
  var getSearch2 = function getSearch3(state) {
    return toJS2(getIn3(getRouter2(state), ["location", "search"]));
  };
  var getHash2 = function getHash3(state) {
    return toJS2(getIn3(getRouter2(state), ["location", "hash"]));
  };
  var createMatchSelector2 = function createMatchSelector3(path3) {
    var lastPathname = null;
    var lastMatch = null;
    return function(state) {
      var _ref = getLocation2(state) || {}, pathname = _ref.pathname;
      if (pathname === lastPathname) {
        return lastMatch;
      }
      lastPathname = pathname;
      var match5 = matchPath$1(pathname, path3);
      if (!match5 || !lastMatch || match5.url !== lastMatch.url || match5.isExact !== lastMatch.isExact) {
        lastMatch = match5;
      }
      return lastMatch;
    };
  };
  return {
    getLocation: getLocation2,
    getAction: getAction2,
    getRouter: getRouter2,
    getSearch: getSearch2,
    getHash: getHash2,
    createMatchSelector: createMatchSelector2
  };
};
const createSelectors$1 = createSelectors;
function _typeof$w(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$w = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$w = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$w(obj);
}
function _extends$p() {
  _extends$p = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$p.apply(this, arguments);
}
function _classCallCheck$g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$g(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$g(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$g(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$g(Constructor, staticProps);
  return Constructor;
}
function _createSuper$e(Derived) {
  return function() {
    var Super = _getPrototypeOf$e(Derived), result;
    if (_isNativeReflectConstruct$e()) {
      var NewTarget = _getPrototypeOf$e(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$e(this, result);
  };
}
function _possibleConstructorReturn$e(self2, call3) {
  if (call3 && (_typeof$w(call3) === "object" || typeof call3 === "function")) {
    return call3;
  }
  return _assertThisInitialized$e(self2);
}
function _assertThisInitialized$e(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$e(o3) {
  _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$e(o3);
}
function _inherits$e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$e(subClass, superClass);
}
function _setPrototypeOf$e(o3, p2) {
  _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$e(o3, p2);
}
var createConnectedRouter = function createConnectedRouter2(structure2) {
  var _createSelectors2 = createSelectors$1(structure2), getLocation2 = _createSelectors2.getLocation;
  var ConnectedRouter2 = /* @__PURE__ */ function(_PureComponent) {
    _inherits$e(ConnectedRouter3, _PureComponent);
    var _super = _createSuper$e(ConnectedRouter3);
    function ConnectedRouter3(props3) {
      var _this;
      _classCallCheck$g(this, ConnectedRouter3);
      _this = _super.call(this, props3);
      var store = props3.store, history = props3.history, onLocationChanged3 = props3.onLocationChanged, stateCompareFunction = props3.stateCompareFunction;
      _this.inTimeTravelling = false;
      _this.unsubscribe = store.subscribe(function() {
        var isTimeTravelDebuggingAllowed = !props3.noTimeTravelDebugging;
        var _getLocation = getLocation2(store.getState()), pathnameInStore = _getLocation.pathname, searchInStore = _getLocation.search, hashInStore = _getLocation.hash, stateInStore = _getLocation.state;
        var _history$location = history.location, pathnameInHistory = _history$location.pathname, searchInHistory = _history$location.search, hashInHistory = _history$location.hash, stateInHistory = _history$location.state;
        if (isTimeTravelDebuggingAllowed && props3.history.action === "PUSH" && (pathnameInHistory !== pathnameInStore || searchInHistory !== searchInStore || hashInHistory !== hashInStore || !isEqualWith(stateInStore, stateInHistory, stateCompareFunction))) {
          _this.inTimeTravelling = true;
          history.push({
            pathname: pathnameInStore,
            search: searchInStore,
            hash: hashInStore,
            state: stateInStore
          });
        }
      });
      var handleLocationChange = function handleLocationChange2(location, action) {
        var isFirstRendering = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        if (!_this.inTimeTravelling) {
          onLocationChanged3(location, action, isFirstRendering);
        } else {
          _this.inTimeTravelling = false;
        }
      };
      _this.unlisten = history.listen(handleLocationChange);
      if (!props3.noInitialPop) {
        handleLocationChange(history.location, history.action, true);
      }
      return _this;
    }
    _createClass$g(ConnectedRouter3, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.unlisten();
        this.unsubscribe();
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props, omitRouter = _this$props.omitRouter, history = _this$props.history, children = _this$props.children;
        if (omitRouter) {
          return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
        }
        return /* @__PURE__ */ React.createElement(Router$1, {
          history
        }, children);
      }
    }]);
    return ConnectedRouter3;
  }(reactExports.PureComponent);
  ConnectedRouter2.propTypes = {
    store: PropTypes$1.shape({
      getState: PropTypes$1.func.isRequired,
      subscribe: PropTypes$1.func.isRequired
    }).isRequired,
    history: PropTypes$1.shape({
      action: PropTypes$1.string.isRequired,
      listen: PropTypes$1.func.isRequired,
      location: PropTypes$1.object.isRequired,
      push: PropTypes$1.func.isRequired
    }).isRequired,
    basename: PropTypes$1.string,
    children: PropTypes$1.oneOfType([PropTypes$1.func, PropTypes$1.node]),
    onLocationChanged: PropTypes$1.func.isRequired,
    noInitialPop: PropTypes$1.bool,
    noTimeTravelDebugging: PropTypes$1.bool,
    stateCompareFunction: PropTypes$1.func,
    omitRouter: PropTypes$1.bool
  };
  var mapDispatchToProps = function mapDispatchToProps2(dispatch) {
    return {
      onLocationChanged: function onLocationChanged$1(location, action, isFirstRendering) {
        return dispatch(onLocationChanged(location, action, isFirstRendering));
      }
    };
  };
  var ConnectedRouterWithContext = function ConnectedRouterWithContext2(props3) {
    var Context = props3.context || ReactReduxContext;
    if (Context == null) {
      throw "Please upgrade to react-redux v6";
    }
    return /* @__PURE__ */ React.createElement(Context.Consumer, null, function(_ref) {
      var store = _ref.store;
      return /* @__PURE__ */ React.createElement(ConnectedRouter2, _extends$p({
        store
      }, props3));
    });
  };
  ConnectedRouterWithContext.propTypes = {
    context: PropTypes$1.object
  };
  return connect(null, mapDispatchToProps)(ConnectedRouterWithContext);
};
const createConnectedRouter$1 = createConnectedRouter;
function _slicedToArray$a(arr, i) {
  return _arrayWithHoles$b(arr) || _iterableToArrayLimit$a(arr, i) || _unsupportedIterableToArray$j(arr, i) || _nonIterableRest$b();
}
function _nonIterableRest$b() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$j(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$j(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(n2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$j(o3, minLen);
}
function _arrayLikeToArray$j(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$a(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _e2 = void 0;
  try {
    for (var _i2 = arr[Symbol.iterator](), _s2; !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
      _arr.push(_s2.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i2["return"] != null)
        _i2["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles$b(arr) {
  if (Array.isArray(arr))
    return arr;
}
function ownKeys$q(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$q(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$q(Object(source), true).forEach(function(key) {
        _defineProperty$v(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$q(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$v(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var injectQuery = function injectQuery2(location) {
  if (location && location.query) {
    return location;
  }
  var searchQuery = location && location.search;
  if (typeof searchQuery !== "string" || searchQuery.length === 0) {
    return _objectSpread$q({}, location, {
      query: {}
    });
  }
  var search2 = searchQuery.substring(1);
  var queries = search2.split("&");
  var query = queries.reduce(function(acc, currentQuery) {
    var _currentQuery$split = currentQuery.split("="), _currentQuery$split2 = _slicedToArray$a(_currentQuery$split, 2), queryKey = _currentQuery$split2[0], queryValue = _currentQuery$split2[1];
    return _objectSpread$q({}, acc, _defineProperty$v({}, queryKey, queryValue));
  }, {});
  return _objectSpread$q({}, location, {
    query
  });
};
var createConnectRouter = function createConnectRouter2(structure2) {
  var fromJS2 = structure2.fromJS, merge3 = structure2.merge;
  var createRouterReducer = function createRouterReducer2(history) {
    var initialRouterState = fromJS2({
      location: injectQuery(history.location),
      action: history.action
    });
    return function() {
      var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialRouterState;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, type3 = _ref.type, payload = _ref.payload;
      if (type3 === LOCATION_CHANGE) {
        var location = payload.location, action = payload.action, isFirstRendering = payload.isFirstRendering;
        return isFirstRendering ? state : merge3(state, {
          location: fromJS2(injectQuery(location)),
          action
        });
      }
      return state;
    };
  };
  return createRouterReducer;
};
const createConnectRouter$1 = createConnectRouter;
var getIn = function getIn2(state, path3) {
  if (!state) {
    return state;
  }
  var length3 = path3.length;
  if (!length3) {
    return void 0;
  }
  var result = state;
  for (var i = 0; i < length3 && !!result; ++i) {
    result = result[path3[i]];
  }
  return result;
};
const getIn$1 = getIn;
function ownKeys$p(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$p(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$p(Object(source), true).forEach(function(key) {
        _defineProperty$u(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$p(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$u(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var structure = {
  fromJS: function fromJS(value) {
    return value;
  },
  getIn: getIn$1,
  merge: function merge(state, payload) {
    return _objectSpread$p({}, state, {}, payload);
  },
  toJS: function toJS(value) {
    return value;
  }
};
const plainStructure = structure;
function _toConsumableArray$b(arr) {
  return _arrayWithoutHoles$b(arr) || _iterableToArray$c(arr) || _unsupportedIterableToArray$i(arr) || _nonIterableSpread$b();
}
function _nonIterableSpread$b() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$i(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$i(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(n2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$i(o3, minLen);
}
function _iterableToArray$c(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _arrayWithoutHoles$b(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$i(arr);
}
function _arrayLikeToArray$i(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var routerMiddleware = function routerMiddleware2(history) {
  return function(store) {
    return function(next) {
      return function(action) {
        if (action.type !== CALL_HISTORY_METHOD) {
          return next(action);
        }
        var _action$payload = action.payload, method = _action$payload.method, args = _action$payload.args;
        history[method].apply(history, _toConsumableArray$b(args));
      };
    };
  };
};
const routerMiddleware$1 = routerMiddleware;
var ConnectedRouter = /* @__PURE__ */ createConnectedRouter$1(plainStructure);
var connectRouter = /* @__PURE__ */ createConnectRouter$1(plainStructure);
var _createSelectors = /* @__PURE__ */ createSelectors$1(plainStructure), getLocation = _createSelectors.getLocation, getAction = _createSelectors.getAction, getHash = _createSelectors.getHash, getRouter = _createSelectors.getRouter, getSearch = _createSelectors.getSearch, createMatchSelector = _createSelectors.createMatchSelector;
const RR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CALL_HISTORY_METHOD,
  ConnectedRouter,
  LOCATION_CHANGE,
  connectRouter,
  createMatchSelector,
  getAction,
  getHash,
  getLocation,
  getRouter,
  getSearch,
  go,
  goBack,
  goForward,
  onLocationChanged,
  push,
  replace: replace2,
  routerActions,
  routerMiddleware: routerMiddleware$1
}, Symbol.toStringTag, { value: "Module" }));
var done = function done2(value) {
  return {
    done: true,
    value
  };
};
var qEnd = {};
function safeName(patternOrChannel) {
  if (channel$1(patternOrChannel)) {
    return "channel";
  }
  if (stringableFunc(patternOrChannel)) {
    return String(patternOrChannel);
  }
  if (func(patternOrChannel)) {
    return patternOrChannel.name;
  }
  return String(patternOrChannel);
}
function fsmIterator(fsm, startState, name) {
  var stateUpdater, errorState, effect, nextState = startState;
  function next(arg, error) {
    if (nextState === qEnd) {
      return done(arg);
    }
    if (error && !errorState) {
      nextState = qEnd;
      throw error;
    } else {
      stateUpdater && stateUpdater(arg);
      var currentState = error ? fsm[errorState](error) : fsm[nextState]();
      nextState = currentState.nextState;
      effect = currentState.effect;
      stateUpdater = currentState.stateUpdater;
      errorState = currentState.errorState;
      return nextState === qEnd ? done(arg) : effect;
    }
  }
  return makeIterator(next, function(error) {
    return next(null, error);
  }, name);
}
function takeEvery$1(patternOrChannel, worker) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  var yTake = {
    done: false,
    value: take$1(patternOrChannel)
  };
  var yFork = function yFork2(ac2) {
    return {
      done: false,
      value: fork$1.apply(void 0, [worker].concat(args, [ac2]))
    };
  };
  var action, setAction = function setAction2(ac2) {
    return action = ac2;
  };
  return fsmIterator({
    q1: function q1() {
      return {
        nextState: "q2",
        effect: yTake,
        stateUpdater: setAction
      };
    },
    q2: function q2() {
      return {
        nextState: "q1",
        effect: yFork(action)
      };
    }
  }, "q1", "takeEvery(" + safeName(patternOrChannel) + ", " + worker.name + ")");
}
function takeLatest$1(patternOrChannel, worker) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  var yTake = {
    done: false,
    value: take$1(patternOrChannel)
  };
  var yFork = function yFork2(ac2) {
    return {
      done: false,
      value: fork$1.apply(void 0, [worker].concat(args, [ac2]))
    };
  };
  var yCancel = function yCancel2(task2) {
    return {
      done: false,
      value: cancel$1(task2)
    };
  };
  var task, action;
  var setTask = function setTask2(t2) {
    return task = t2;
  };
  var setAction = function setAction2(ac2) {
    return action = ac2;
  };
  return fsmIterator({
    q1: function q1() {
      return {
        nextState: "q2",
        effect: yTake,
        stateUpdater: setAction
      };
    },
    q2: function q2() {
      return task ? {
        nextState: "q3",
        effect: yCancel(task)
      } : {
        nextState: "q1",
        effect: yFork(action),
        stateUpdater: setTask
      };
    },
    q3: function q3() {
      return {
        nextState: "q1",
        effect: yFork(action),
        stateUpdater: setTask
      };
    }
  }, "q1", "takeLatest(" + safeName(patternOrChannel) + ", " + worker.name + ")");
}
function takeEvery$1$1(patternOrChannel, worker) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  return fork$1.apply(void 0, [takeEvery$1, patternOrChannel, worker].concat(args));
}
function takeLatest$1$1(patternOrChannel, worker) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }
  return fork$1.apply(void 0, [takeLatest$1, patternOrChannel, worker].concat(args));
}
function* take2(...args) {
  return yield take$1(...args);
}
function* takeEvery(...args) {
  return yield takeEvery$1$1(...args);
}
function* takeLatest(...args) {
  return yield takeLatest$1$1(...args);
}
function* put(...args) {
  return yield put$1(...args);
}
function* call2(...args) {
  return yield call$1(...args);
}
function* fork(...args) {
  return yield fork$1(...args);
}
function* cancel(...args) {
  return yield cancel$1(...args);
}
function* select(...args) {
  return yield select$1(...args);
}
function* actionChannel(...args) {
  return yield actionChannel$1(...args);
}
function* cancelled(...args) {
  return yield cancelled$1(...args);
}
function* delay(...args) {
  return yield delay$1(...args);
}
function commonjsRequire(path3) {
  throw new Error('Could not dynamically require "' + path3 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var passwordGenerator = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module2, exports) {
  (function(root2) {
    var localName, consonant, password, vowel, rand, getRandomValues2;
    vowel = /[aeiou]$/i;
    consonant = /[bcdfghjklmnpqrstvwxyz]$/i;
    localName = root2.localPasswordGeneratorLibraryName || "generatePassword";
    password = function(length3, memorable, pattern3, prefix2) {
      var char = "", n2, i, validChars = [];
      if (length3 === null || typeof length3 === "undefined") {
        length3 = 10;
      }
      if (memorable === null || typeof memorable === "undefined") {
        memorable = true;
      }
      if (pattern3 === null || typeof pattern3 === "undefined") {
        pattern3 = /\w/;
      }
      if (prefix2 === null || typeof prefix2 === "undefined") {
        prefix2 = "";
      }
      if (!memorable) {
        for (i = 33; i <= 126; i += 1) {
          char = String.fromCharCode(i);
          if (char.match(pattern3)) {
            validChars.push(char);
          }
        }
        if (!validChars.length) {
          throw new Error("Could not find characters that match the password pattern " + pattern3 + ". Patterns must match individual characters, not the password as a whole.");
        }
      }
      while (prefix2.length < length3) {
        if (memorable) {
          if (prefix2.match(consonant)) {
            pattern3 = vowel;
          } else {
            pattern3 = consonant;
          }
          n2 = rand(33, 126);
          char = String.fromCharCode(n2);
        } else {
          char = validChars[rand(0, validChars.length)];
        }
        if (memorable) {
          char = char.toLowerCase();
        }
        if (char.match(pattern3)) {
          prefix2 = "" + prefix2 + char;
        }
      }
      return prefix2;
    };
    rand = function(min3, max3) {
      var key, value, arr = new Uint8Array(max3);
      getRandomValues2(arr);
      for (key in arr) {
        if (arr.hasOwnProperty(key)) {
          value = arr[key];
          if (value >= min3 && value < max3) {
            return value;
          }
        }
      }
      return rand(min3, max3);
    };
    getRandomValues2 = function(buf) {
      if (root2.crypto && root2.crypto.getRandomValues) {
        root2.crypto.getRandomValues(buf);
      } else if (typeof root2.msCrypto === "object" && typeof root2.msCrypto.getRandomValues === "function") {
        root2.msCrypto.getRandomValues(buf);
      } else if (module2.exports === password && typeof commonjsRequire !== "undefined") {
        var bytes = require$$0$1.randomBytes(buf.length);
        buf.set(bytes);
      } else {
        throw new Error("No secure random number generator available.");
      }
    };
    exports[localName] = password;
    {
      if (module2.exports) {
        module2.exports = password;
      }
    }
  })(commonjsGlobal$2);
})(passwordGenerator, passwordGenerator.exports);
var rngBrowser = { exports: {} };
var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
if (getRandomValues) {
  var rnds8 = new Uint8Array(16);
  rngBrowser.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  var rnds = new Array(16);
  rngBrowser.exports = function mathRNG() {
    for (var i = 0, r2; i < 16; i++) {
      if ((i & 3) === 0)
        r2 = Math.random() * 4294967296;
      rnds[i] = r2 >>> ((i & 3) << 3) & 255;
    }
    return rnds;
  };
}
var rngBrowserExports = rngBrowser.exports;
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 256).toString(16).substr(1);
}
function bytesToUuid$1(buf, offset2) {
  var i = offset2 || 0;
  var bth = byteToHex;
  return [
    bth[buf[i++]],
    bth[buf[i++]],
    bth[buf[i++]],
    bth[buf[i++]],
    "-",
    bth[buf[i++]],
    bth[buf[i++]],
    "-",
    bth[buf[i++]],
    bth[buf[i++]],
    "-",
    bth[buf[i++]],
    bth[buf[i++]],
    "-",
    bth[buf[i++]],
    bth[buf[i++]],
    bth[buf[i++]],
    bth[buf[i++]],
    bth[buf[i++]],
    bth[buf[i++]]
  ].join("");
}
var bytesToUuid_1 = bytesToUuid$1;
var rng = rngBrowserExports;
var bytesToUuid = bytesToUuid_1;
function v4(options, buf, offset2) {
  var i = buf && offset2 || 0;
  if (typeof options == "string") {
    buf = options === "binary" ? new Array(16) : null;
    options = null;
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    for (var ii2 = 0; ii2 < 16; ++ii2) {
      buf[i + ii2] = rnds[ii2];
    }
  }
  return buf || bytesToUuid(rnds);
}
var v4_1 = v4;
const uuid = /* @__PURE__ */ getDefaultExportFromCjs(v4_1);
var moize$1 = { exports: {} };
var microMemoize = { exports: {} };
var hasRequiredMicroMemoize;
function requireMicroMemoize() {
  if (hasRequiredMicroMemoize)
    return microMemoize.exports;
  hasRequiredMicroMemoize = 1;
  (function(module2, exports) {
    (function(global2, factory) {
      module2.exports = factory();
    })(commonjsGlobal$2, function() {
      var DEFAULT_OPTIONS_KEYS = {
        isEqual: true,
        isMatchingKey: true,
        isPromise: true,
        maxSize: true,
        onCacheAdd: true,
        onCacheChange: true,
        onCacheHit: true,
        transformKey: true
      };
      var slice3 = Array.prototype.slice;
      function cloneArray(arrayLike) {
        var length3 = arrayLike.length;
        if (!length3) {
          return [];
        }
        if (length3 === 1) {
          return [arrayLike[0]];
        }
        if (length3 === 2) {
          return [arrayLike[0], arrayLike[1]];
        }
        if (length3 === 3) {
          return [arrayLike[0], arrayLike[1], arrayLike[2]];
        }
        return slice3.call(arrayLike, 0);
      }
      function getCustomOptions(options) {
        var customOptions = {};
        for (var key in options) {
          if (!DEFAULT_OPTIONS_KEYS[key]) {
            customOptions[key] = options[key];
          }
        }
        return customOptions;
      }
      function isMemoized(fn2) {
        return typeof fn2 === "function" && fn2.isMemoized;
      }
      function isSameValueZero(object1, object2) {
        return object1 === object2 || object1 !== object1 && object2 !== object2;
      }
      function mergeOptions(existingOptions, newOptions) {
        var target = {};
        for (var key in existingOptions) {
          target[key] = existingOptions[key];
        }
        for (var key in newOptions) {
          target[key] = newOptions[key];
        }
        return target;
      }
      var Cache = (
        /** @class */
        function() {
          function Cache2(options) {
            this.keys = [];
            this.values = [];
            this.options = options;
            var isMatchingKeyFunction = typeof options.isMatchingKey === "function";
            if (isMatchingKeyFunction) {
              this.getKeyIndex = this._getKeyIndexFromMatchingKey;
            } else if (options.maxSize > 1) {
              this.getKeyIndex = this._getKeyIndexForMany;
            } else {
              this.getKeyIndex = this._getKeyIndexForSingle;
            }
            this.canTransformKey = typeof options.transformKey === "function";
            this.shouldCloneArguments = this.canTransformKey || isMatchingKeyFunction;
            this.shouldUpdateOnAdd = typeof options.onCacheAdd === "function";
            this.shouldUpdateOnChange = typeof options.onCacheChange === "function";
            this.shouldUpdateOnHit = typeof options.onCacheHit === "function";
          }
          Object.defineProperty(Cache2.prototype, "size", {
            get: function() {
              return this.keys.length;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Cache2.prototype, "snapshot", {
            get: function() {
              return {
                keys: cloneArray(this.keys),
                size: this.size,
                values: cloneArray(this.values)
              };
            },
            enumerable: false,
            configurable: true
          });
          Cache2.prototype._getKeyIndexFromMatchingKey = function(keyToMatch) {
            var _a2 = this.options, isMatchingKey = _a2.isMatchingKey, maxSize = _a2.maxSize;
            var keys4 = this.keys;
            var keysLength = keys4.length;
            if (!keysLength) {
              return -1;
            }
            if (isMatchingKey(keys4[0], keyToMatch)) {
              return 0;
            }
            if (maxSize > 1) {
              for (var index3 = 1; index3 < keysLength; index3++) {
                if (isMatchingKey(keys4[index3], keyToMatch)) {
                  return index3;
                }
              }
            }
            return -1;
          };
          Cache2.prototype._getKeyIndexForMany = function(keyToMatch) {
            var isEqual2 = this.options.isEqual;
            var keys4 = this.keys;
            var keysLength = keys4.length;
            if (!keysLength) {
              return -1;
            }
            if (keysLength === 1) {
              return this._getKeyIndexForSingle(keyToMatch);
            }
            var keyLength = keyToMatch.length;
            var existingKey;
            var argIndex;
            if (keyLength > 1) {
              for (var index3 = 0; index3 < keysLength; index3++) {
                existingKey = keys4[index3];
                if (existingKey.length === keyLength) {
                  argIndex = 0;
                  for (; argIndex < keyLength; argIndex++) {
                    if (!isEqual2(existingKey[argIndex], keyToMatch[argIndex])) {
                      break;
                    }
                  }
                  if (argIndex === keyLength) {
                    return index3;
                  }
                }
              }
            } else {
              for (var index3 = 0; index3 < keysLength; index3++) {
                existingKey = keys4[index3];
                if (existingKey.length === keyLength && isEqual2(existingKey[0], keyToMatch[0])) {
                  return index3;
                }
              }
            }
            return -1;
          };
          Cache2.prototype._getKeyIndexForSingle = function(keyToMatch) {
            var keys4 = this.keys;
            if (!keys4.length) {
              return -1;
            }
            var existingKey = keys4[0];
            var length3 = existingKey.length;
            if (keyToMatch.length !== length3) {
              return -1;
            }
            var isEqual2 = this.options.isEqual;
            if (length3 > 1) {
              for (var index3 = 0; index3 < length3; index3++) {
                if (!isEqual2(existingKey[index3], keyToMatch[index3])) {
                  return -1;
                }
              }
              return 0;
            }
            return isEqual2(existingKey[0], keyToMatch[0]) ? 0 : -1;
          };
          Cache2.prototype.orderByLru = function(key, value, startingIndex) {
            var keys4 = this.keys;
            var values3 = this.values;
            var currentLength = keys4.length;
            var index3 = startingIndex;
            while (index3--) {
              keys4[index3 + 1] = keys4[index3];
              values3[index3 + 1] = values3[index3];
            }
            keys4[0] = key;
            values3[0] = value;
            var maxSize = this.options.maxSize;
            if (currentLength === maxSize && startingIndex === currentLength) {
              keys4.pop();
              values3.pop();
            } else if (startingIndex >= maxSize) {
              keys4.length = values3.length = maxSize;
            }
          };
          Cache2.prototype.updateAsyncCache = function(memoized) {
            var _this = this;
            var _a2 = this.options, onCacheChange = _a2.onCacheChange, onCacheHit = _a2.onCacheHit;
            var firstKey = this.keys[0];
            var firstValue = this.values[0];
            this.values[0] = firstValue.then(function(value) {
              if (_this.shouldUpdateOnHit) {
                onCacheHit(_this, _this.options, memoized);
              }
              if (_this.shouldUpdateOnChange) {
                onCacheChange(_this, _this.options, memoized);
              }
              return value;
            }, function(error) {
              var keyIndex = _this.getKeyIndex(firstKey);
              if (keyIndex !== -1) {
                _this.keys.splice(keyIndex, 1);
                _this.values.splice(keyIndex, 1);
              }
              throw error;
            });
          };
          return Cache2;
        }()
      );
      function createMemoizedFunction(fn2, options) {
        if (options === void 0) {
          options = {};
        }
        if (isMemoized(fn2)) {
          return createMemoizedFunction(fn2.fn, mergeOptions(fn2.options, options));
        }
        if (typeof fn2 !== "function") {
          throw new TypeError("You must pass a function to `memoize`.");
        }
        var _a2 = options.isEqual, isEqual2 = _a2 === void 0 ? isSameValueZero : _a2, isMatchingKey = options.isMatchingKey, _b = options.isPromise, isPromise = _b === void 0 ? false : _b, _c = options.maxSize, maxSize = _c === void 0 ? 1 : _c, onCacheAdd = options.onCacheAdd, onCacheChange = options.onCacheChange, onCacheHit = options.onCacheHit, transformKey = options.transformKey;
        var normalizedOptions = mergeOptions({
          isEqual: isEqual2,
          isMatchingKey,
          isPromise,
          maxSize,
          onCacheAdd,
          onCacheChange,
          onCacheHit,
          transformKey
        }, getCustomOptions(options));
        var cache2 = new Cache(normalizedOptions);
        var keys4 = cache2.keys, values3 = cache2.values, canTransformKey = cache2.canTransformKey, shouldCloneArguments = cache2.shouldCloneArguments, shouldUpdateOnAdd = cache2.shouldUpdateOnAdd, shouldUpdateOnChange = cache2.shouldUpdateOnChange, shouldUpdateOnHit = cache2.shouldUpdateOnHit;
        var memoized = function() {
          var key = shouldCloneArguments ? cloneArray(arguments) : arguments;
          if (canTransformKey) {
            key = transformKey(key);
          }
          var keyIndex = keys4.length ? cache2.getKeyIndex(key) : -1;
          if (keyIndex !== -1) {
            if (shouldUpdateOnHit) {
              onCacheHit(cache2, normalizedOptions, memoized);
            }
            if (keyIndex) {
              cache2.orderByLru(keys4[keyIndex], values3[keyIndex], keyIndex);
              if (shouldUpdateOnChange) {
                onCacheChange(cache2, normalizedOptions, memoized);
              }
            }
          } else {
            var newValue = fn2.apply(this, arguments);
            var newKey = shouldCloneArguments ? key : cloneArray(arguments);
            cache2.orderByLru(newKey, newValue, keys4.length);
            if (isPromise) {
              cache2.updateAsyncCache(memoized);
            }
            if (shouldUpdateOnAdd) {
              onCacheAdd(cache2, normalizedOptions, memoized);
            }
            if (shouldUpdateOnChange) {
              onCacheChange(cache2, normalizedOptions, memoized);
            }
          }
          return values3[0];
        };
        memoized.cache = cache2;
        memoized.fn = fn2;
        memoized.isMemoized = true;
        memoized.options = normalizedOptions;
        return memoized;
      }
      return createMemoizedFunction;
    });
  })(microMemoize);
  return microMemoize.exports;
}
var fastEquals = { exports: {} };
var hasRequiredFastEquals;
function requireFastEquals() {
  if (hasRequiredFastEquals)
    return fastEquals.exports;
  hasRequiredFastEquals = 1;
  (function(module2, exports) {
    (function(global2, factory) {
      factory(exports);
    })(commonjsGlobal$2, function(exports2) {
      var HAS_WEAK_MAP_SUPPORT = typeof WeakMap === "function";
      var keys4 = Object.keys;
      function sameValueZeroEqual2(a2, b2) {
        return a2 === b2 || a2 !== a2 && b2 !== b2;
      }
      function isPlainObject2(value) {
        return value.constructor === Object || value.constructor == null;
      }
      function isPromiseLike2(value) {
        return !!value && typeof value.then === "function";
      }
      function isReactElement(value) {
        return !!(value && value.$$typeof);
      }
      function getNewCacheFallback() {
        var entries = [];
        return {
          delete: function(key) {
            for (var index3 = 0; index3 < entries.length; ++index3) {
              if (entries[index3][0] === key) {
                entries.splice(index3, 1);
                return;
              }
            }
          },
          get: function(key) {
            for (var index3 = 0; index3 < entries.length; ++index3) {
              if (entries[index3][0] === key) {
                return entries[index3][1];
              }
            }
          },
          set: function(key, value) {
            for (var index3 = 0; index3 < entries.length; ++index3) {
              if (entries[index3][0] === key) {
                entries[index3][1] = value;
                return;
              }
            }
            entries.push([key, value]);
          }
        };
      }
      var getNewCache = function(canUseWeakMap) {
        if (canUseWeakMap) {
          return function _getNewCache() {
            return /* @__PURE__ */ new WeakMap();
          };
        }
        return getNewCacheFallback;
      }(HAS_WEAK_MAP_SUPPORT);
      function createCircularEqualCreator(isEqual2) {
        return function createCircularEqual(comparator3) {
          var _comparator = isEqual2 || comparator3;
          return function circularEqual(a2, b2, indexOrKeyA, indexOrKeyB, parentA, parentB, cache2) {
            if (cache2 === void 0) {
              cache2 = getNewCache();
            }
            var isCacheableA = !!a2 && typeof a2 === "object";
            var isCacheableB = !!b2 && typeof b2 === "object";
            if (isCacheableA !== isCacheableB) {
              return false;
            }
            if (!isCacheableA && !isCacheableB) {
              return _comparator(a2, b2, cache2);
            }
            var cachedA = cache2.get(a2);
            if (cachedA && cache2.get(b2)) {
              return cachedA === b2;
            }
            cache2.set(a2, b2);
            cache2.set(b2, a2);
            var result = _comparator(a2, b2, cache2);
            cache2.delete(a2);
            cache2.delete(b2);
            return result;
          };
        };
      }
      function areArraysEqual2(a2, b2, isEqual2, meta) {
        var index3 = a2.length;
        if (b2.length !== index3) {
          return false;
        }
        while (index3-- > 0) {
          if (!isEqual2(a2[index3], b2[index3], index3, index3, a2, b2, meta)) {
            return false;
          }
        }
        return true;
      }
      function areMapsEqual2(a2, b2, isEqual2, meta) {
        var isValueEqual = a2.size === b2.size;
        if (isValueEqual && a2.size) {
          var matchedIndices_1 = {};
          var indexA_1 = 0;
          a2.forEach(function(aValue, aKey) {
            if (isValueEqual) {
              var hasMatch_1 = false;
              var matchIndexB_1 = 0;
              b2.forEach(function(bValue, bKey) {
                if (!hasMatch_1 && !matchedIndices_1[matchIndexB_1]) {
                  hasMatch_1 = isEqual2(aKey, bKey, indexA_1, matchIndexB_1, a2, b2, meta) && isEqual2(aValue, bValue, aKey, bKey, a2, b2, meta);
                  if (hasMatch_1) {
                    matchedIndices_1[matchIndexB_1] = true;
                  }
                }
                matchIndexB_1++;
              });
              indexA_1++;
              isValueEqual = hasMatch_1;
            }
          });
        }
        return isValueEqual;
      }
      var OWNER2 = "_owner";
      var hasOwnProperty2 = Function.prototype.bind.call(Function.prototype.call, Object.prototype.hasOwnProperty);
      function areObjectsEqual2(a2, b2, isEqual2, meta) {
        var keysA = keys4(a2);
        var index3 = keysA.length;
        if (keys4(b2).length !== index3) {
          return false;
        }
        if (index3) {
          var key = void 0;
          while (index3-- > 0) {
            key = keysA[index3];
            if (key === OWNER2) {
              var reactElementA = isReactElement(a2);
              var reactElementB = isReactElement(b2);
              if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {
                return false;
              }
            }
            if (!hasOwnProperty2(b2, key) || !isEqual2(a2[key], b2[key], key, key, a2, b2, meta)) {
              return false;
            }
          }
        }
        return true;
      }
      var areRegExpsEqual2 = function() {
        if (/foo/g.flags === "g") {
          return function areRegExpsEqual3(a2, b2) {
            return a2.source === b2.source && a2.flags === b2.flags;
          };
        }
        return function areRegExpsEqualFallback(a2, b2) {
          return a2.source === b2.source && a2.global === b2.global && a2.ignoreCase === b2.ignoreCase && a2.multiline === b2.multiline && a2.unicode === b2.unicode && a2.sticky === b2.sticky && a2.lastIndex === b2.lastIndex;
        };
      }();
      function areSetsEqual2(a2, b2, isEqual2, meta) {
        var isValueEqual = a2.size === b2.size;
        if (isValueEqual && a2.size) {
          var matchedIndices_2 = {};
          a2.forEach(function(aValue, aKey) {
            if (isValueEqual) {
              var hasMatch_2 = false;
              var matchIndex_1 = 0;
              b2.forEach(function(bValue, bKey) {
                if (!hasMatch_2 && !matchedIndices_2[matchIndex_1]) {
                  hasMatch_2 = isEqual2(aValue, bValue, aKey, bKey, a2, b2, meta);
                  if (hasMatch_2) {
                    matchedIndices_2[matchIndex_1] = true;
                  }
                }
                matchIndex_1++;
              });
              isValueEqual = hasMatch_2;
            }
          });
        }
        return isValueEqual;
      }
      var HAS_MAP_SUPPORT = typeof Map === "function";
      var HAS_SET_SUPPORT = typeof Set === "function";
      var valueOf2 = Object.prototype.valueOf;
      function createComparator2(createIsEqual) {
        var isEqual2 = (
          /* eslint-disable no-use-before-define */
          typeof createIsEqual === "function" ? createIsEqual(comparator3) : function(a2, b2, indexOrKeyA, indexOrKeyB, parentA, parentB, meta) {
            return comparator3(a2, b2, meta);
          }
        );
        function comparator3(a2, b2, meta) {
          if (a2 === b2) {
            return true;
          }
          if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
            if (isPlainObject2(a2) && isPlainObject2(b2)) {
              return areObjectsEqual2(a2, b2, isEqual2, meta);
            }
            var aShape = Array.isArray(a2);
            var bShape = Array.isArray(b2);
            if (aShape || bShape) {
              return aShape === bShape && areArraysEqual2(a2, b2, isEqual2, meta);
            }
            aShape = a2 instanceof Date;
            bShape = b2 instanceof Date;
            if (aShape || bShape) {
              return aShape === bShape && sameValueZeroEqual2(a2.getTime(), b2.getTime());
            }
            aShape = a2 instanceof RegExp;
            bShape = b2 instanceof RegExp;
            if (aShape || bShape) {
              return aShape === bShape && areRegExpsEqual2(a2, b2);
            }
            if (isPromiseLike2(a2) || isPromiseLike2(b2)) {
              return a2 === b2;
            }
            if (HAS_MAP_SUPPORT) {
              aShape = a2 instanceof Map;
              bShape = b2 instanceof Map;
              if (aShape || bShape) {
                return aShape === bShape && areMapsEqual2(a2, b2, isEqual2, meta);
              }
            }
            if (HAS_SET_SUPPORT) {
              aShape = a2 instanceof Set;
              bShape = b2 instanceof Set;
              if (aShape || bShape) {
                return aShape === bShape && areSetsEqual2(a2, b2, isEqual2, meta);
              }
            }
            if (a2.valueOf !== valueOf2 || b2.valueOf !== valueOf2) {
              return sameValueZeroEqual2(a2.valueOf(), b2.valueOf());
            }
            return areObjectsEqual2(a2, b2, isEqual2, meta);
          }
          return a2 !== a2 && b2 !== b2;
        }
        return comparator3;
      }
      var deepEqual2 = createComparator2();
      var shallowEqual2 = createComparator2(function() {
        return sameValueZeroEqual2;
      });
      var circularDeepEqual = createComparator2(createCircularEqualCreator());
      var circularShallowEqual = createComparator2(createCircularEqualCreator(sameValueZeroEqual2));
      exports2.circularDeepEqual = circularDeepEqual;
      exports2.circularShallowEqual = circularShallowEqual;
      exports2.createCustomEqual = createComparator2;
      exports2.deepEqual = deepEqual2;
      exports2.sameValueZeroEqual = sameValueZeroEqual2;
      exports2.shallowEqual = shallowEqual2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  })(fastEquals, fastEquals.exports);
  return fastEquals.exports;
}
(function(module2, exports) {
  (function(global2, factory) {
    module2.exports = factory(requireMicroMemoize(), requireFastEquals());
  })(commonjsGlobal$2, function(memoize3, fastEquals2) {
    function _extends2() {
      _extends2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var DEFAULT_OPTIONS = {
      isDeepEqual: false,
      isPromise: false,
      isReact: false,
      isSerialized: false,
      isShallowEqual: false,
      matchesArg: void 0,
      matchesKey: void 0,
      maxAge: void 0,
      maxArgs: void 0,
      maxSize: 1,
      onExpire: void 0,
      profileName: void 0,
      serializer: void 0,
      updateCacheForKey: void 0,
      transformArgs: void 0,
      updateExpire: false
    };
    function combine() {
      for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
        functions[_key] = arguments[_key];
      }
      return functions.reduce(function(f2, g2) {
        if (typeof f2 === "function") {
          return typeof g2 === "function" ? function() {
            f2.apply(this, arguments);
            g2.apply(this, arguments);
          } : f2;
        }
        if (typeof g2 === "function") {
          return g2;
        }
      });
    }
    function compose3() {
      for (var _len2 = arguments.length, functions = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        functions[_key2] = arguments[_key2];
      }
      return functions.reduce(function(f2, g2) {
        if (typeof f2 === "function") {
          return typeof g2 === "function" ? function() {
            return f2(g2.apply(this, arguments));
          } : f2;
        }
        if (typeof g2 === "function") {
          return g2;
        }
      });
    }
    function findExpirationIndex(expirations, key) {
      for (var index3 = 0; index3 < expirations.length; index3++) {
        if (expirations[index3].key === key) {
          return index3;
        }
      }
      return -1;
    }
    function createFindKeyIndex(isEqual2, isMatchingKey) {
      var areKeysEqual = typeof isMatchingKey === "function" ? isMatchingKey : function(cacheKey, key) {
        for (var index3 = 0; index3 < key.length; index3++) {
          if (!isEqual2(cacheKey[index3], key[index3])) {
            return false;
          }
        }
        return true;
      };
      return function(keys4, key) {
        for (var keysIndex = 0; keysIndex < keys4.length; keysIndex++) {
          if (keys4[keysIndex].length === key.length && areKeysEqual(keys4[keysIndex], key)) {
            return keysIndex;
          }
        }
        return -1;
      };
    }
    function mergeOptions(originalOptions, newOptions) {
      if (!newOptions || newOptions === DEFAULT_OPTIONS) {
        return originalOptions;
      }
      return _extends2({}, originalOptions, newOptions, {
        onCacheAdd: combine(originalOptions.onCacheAdd, newOptions.onCacheAdd),
        onCacheChange: combine(originalOptions.onCacheChange, newOptions.onCacheChange),
        onCacheHit: combine(originalOptions.onCacheHit, newOptions.onCacheHit),
        transformArgs: compose3(originalOptions.transformArgs, newOptions.transformArgs)
      });
    }
    function isMoized(fn2) {
      return typeof fn2 === "function" && fn2.isMoized;
    }
    function setName(fn2, originalFunctionName, profileName) {
      try {
        var name = profileName || originalFunctionName || "anonymous";
        Object.defineProperty(fn2, "name", {
          configurable: true,
          enumerable: false,
          value: "moized(" + name + ")",
          writable: true
        });
      } catch (_unused) {
      }
    }
    function clearExpiration(expirations, key, shouldRemove) {
      var expirationIndex = findExpirationIndex(expirations, key);
      if (expirationIndex !== -1) {
        clearTimeout(expirations[expirationIndex].timeoutId);
        if (shouldRemove) {
          expirations.splice(expirationIndex, 1);
        }
      }
    }
    function createTimeout(expirationMethod, maxAge2) {
      var timeoutId = setTimeout(expirationMethod, maxAge2);
      if (typeof timeoutId.unref === "function") {
        timeoutId.unref();
      }
      return timeoutId;
    }
    function createOnCacheAddSetExpiration(expirations, options, isEqual2, isMatchingKey) {
      var maxAge2 = options.maxAge;
      return function onCacheAdd(cache2, moizedOptions, moized) {
        var key = cache2.keys[0];
        if (findExpirationIndex(expirations, key) === -1) {
          var expirationMethod = function expirationMethod2() {
            var findKeyIndex = createFindKeyIndex(isEqual2, isMatchingKey);
            var keyIndex = findKeyIndex(cache2.keys, key);
            var value = cache2.values[keyIndex];
            if (~keyIndex) {
              cache2.keys.splice(keyIndex, 1);
              cache2.values.splice(keyIndex, 1);
              if (typeof options.onCacheChange === "function") {
                options.onCacheChange(cache2, moizedOptions, moized);
              }
            }
            clearExpiration(expirations, key, true);
            if (typeof options.onExpire === "function" && options.onExpire(key) === false) {
              cache2.keys.unshift(key);
              cache2.values.unshift(value);
              onCacheAdd(cache2, moizedOptions, moized);
              if (typeof options.onCacheChange === "function") {
                options.onCacheChange(cache2, moizedOptions, moized);
              }
            }
          };
          expirations.push({
            expirationMethod,
            key,
            timeoutId: createTimeout(expirationMethod, maxAge2)
          });
        }
      };
    }
    function createOnCacheHitResetExpiration(expirations, options) {
      return function onCacheHit(cache2) {
        var key = cache2.keys[0];
        var expirationIndex = findExpirationIndex(expirations, key);
        if (~expirationIndex) {
          clearExpiration(expirations, key, false);
          expirations[expirationIndex].timeoutId = createTimeout(expirations[expirationIndex].expirationMethod, options.maxAge);
        }
      };
    }
    function getMaxAgeOptions(expirations, options, isEqual2, isMatchingKey) {
      var onCacheAdd = typeof options.maxAge === "number" && isFinite(options.maxAge) ? createOnCacheAddSetExpiration(expirations, options, isEqual2, isMatchingKey) : void 0;
      return {
        onCacheAdd,
        onCacheHit: onCacheAdd && options.updateExpire ? createOnCacheHitResetExpiration(expirations, options) : void 0
      };
    }
    var statsCache = {
      anonymousProfileNameCounter: 1,
      isCollectingStats: false,
      profiles: {}
    };
    var hasWarningDisplayed = false;
    function clearStats(profileName) {
      if (profileName) {
        delete statsCache.profiles[profileName];
      } else {
        statsCache.profiles = {};
      }
    }
    function collectStats(isCollectingStats) {
      if (isCollectingStats === void 0) {
        isCollectingStats = true;
      }
      statsCache.isCollectingStats = isCollectingStats;
    }
    function createOnCacheAddIncrementCalls(options) {
      var profileName = options.profileName;
      return function() {
        if (profileName && !statsCache.profiles[profileName]) {
          statsCache.profiles[profileName] = {
            calls: 0,
            hits: 0
          };
        }
        statsCache.profiles[profileName].calls++;
      };
    }
    function createOnCacheHitIncrementCallsAndHits(options) {
      return function() {
        var profiles = statsCache.profiles;
        var profileName = options.profileName;
        if (!profiles[profileName]) {
          profiles[profileName] = {
            calls: 0,
            hits: 0
          };
        }
        profiles[profileName].calls++;
        profiles[profileName].hits++;
      };
    }
    function getDefaultProfileName(fn2) {
      return fn2.displayName || fn2.name || "Anonymous " + statsCache.anonymousProfileNameCounter++;
    }
    function getUsagePercentage(calls, hits) {
      return calls ? (hits / calls * 100).toFixed(4) + "%" : "0.0000%";
    }
    function getStats(profileName) {
      if (!statsCache.isCollectingStats && !hasWarningDisplayed) {
        console.warn('Stats are not currently being collected, please run "collectStats" to enable them.');
        hasWarningDisplayed = true;
      }
      var profiles = statsCache.profiles;
      if (profileName) {
        if (!profiles[profileName]) {
          return {
            calls: 0,
            hits: 0,
            usage: "0.0000%"
          };
        }
        var profile = profiles[profileName];
        return _extends2({}, profile, {
          usage: getUsagePercentage(profile.calls, profile.hits)
        });
      }
      var completeStats = Object.keys(statsCache.profiles).reduce(function(completeProfiles, profileName2) {
        completeProfiles.calls += profiles[profileName2].calls;
        completeProfiles.hits += profiles[profileName2].hits;
        return completeProfiles;
      }, {
        calls: 0,
        hits: 0
      });
      return _extends2({}, completeStats, {
        profiles: Object.keys(profiles).reduce(function(computedProfiles, profileName2) {
          computedProfiles[profileName2] = getStats(profileName2);
          return computedProfiles;
        }, {}),
        usage: getUsagePercentage(completeStats.calls, completeStats.hits)
      });
    }
    function getStatsOptions(options) {
      return statsCache.isCollectingStats ? {
        onCacheAdd: createOnCacheAddIncrementCalls(options),
        onCacheHit: createOnCacheHitIncrementCallsAndHits(options)
      } : {};
    }
    var ALWAYS_SKIPPED_PROPERTIES = {
      arguments: true,
      callee: true,
      caller: true,
      constructor: true,
      length: true,
      name: true,
      prototype: true
    };
    function copyStaticProperties(originalFn, newFn, skippedProperties) {
      if (skippedProperties === void 0) {
        skippedProperties = [];
      }
      Object.getOwnPropertyNames(originalFn).forEach(function(property2) {
        if (!ALWAYS_SKIPPED_PROPERTIES[property2] && skippedProperties.indexOf(property2) === -1) {
          var descriptor = Object.getOwnPropertyDescriptor(originalFn, property2);
          if (descriptor.get || descriptor.set) {
            Object.defineProperty(newFn, property2, descriptor);
          } else {
            newFn[property2] = originalFn[property2];
          }
        }
      });
    }
    function addInstanceMethods(memoized, _ref) {
      var expirations = _ref.expirations;
      var options = memoized.options;
      var findKeyIndex = createFindKeyIndex(options.isEqual, options.isMatchingKey);
      var moized = memoized;
      moized.clear = function() {
        var onCacheChange = moized._microMemoizeOptions.onCacheChange, cache2 = moized.cache;
        cache2.keys.length = 0;
        cache2.values.length = 0;
        if (onCacheChange) {
          onCacheChange(cache2, moized.options, moized);
        }
        return true;
      };
      moized.clearStats = function() {
        clearStats(moized.options.profileName);
      };
      moized.get = function(key) {
        var transformKey = moized._microMemoizeOptions.transformKey, cache2 = moized.cache;
        var cacheKey = transformKey ? transformKey(key) : key;
        var keyIndex = findKeyIndex(cache2.keys, cacheKey);
        return keyIndex !== -1 ? moized.apply(this, key) : void 0;
      };
      moized.getStats = function() {
        return getStats(moized.options.profileName);
      };
      moized.has = function(key) {
        var transformKey = moized._microMemoizeOptions.transformKey;
        var cacheKey = transformKey ? transformKey(key) : key;
        return findKeyIndex(moized.cache.keys, cacheKey) !== -1;
      };
      moized.keys = function() {
        return moized.cacheSnapshot.keys;
      };
      moized.remove = function(key) {
        var _moized$_microMemoize = moized._microMemoizeOptions, onCacheChange = _moized$_microMemoize.onCacheChange, transformKey = _moized$_microMemoize.transformKey, cache2 = moized.cache;
        var keyIndex = findKeyIndex(cache2.keys, transformKey ? transformKey(key) : key);
        if (keyIndex === -1) {
          return false;
        }
        var existingKey = cache2.keys[keyIndex];
        cache2.keys.splice(keyIndex, 1);
        cache2.values.splice(keyIndex, 1);
        if (onCacheChange) {
          onCacheChange(cache2, moized.options, moized);
        }
        clearExpiration(expirations, existingKey, true);
        return true;
      };
      moized.set = function(key, value) {
        var _microMemoizeOptions = moized._microMemoizeOptions, cache2 = moized.cache, options2 = moized.options;
        var onCacheAdd = _microMemoizeOptions.onCacheAdd, onCacheChange = _microMemoizeOptions.onCacheChange, transformKey = _microMemoizeOptions.transformKey;
        var cacheKey = transformKey ? transformKey(key) : key;
        var keyIndex = findKeyIndex(cache2.keys, cacheKey);
        if (keyIndex === -1) {
          var cutoff = options2.maxSize - 1;
          if (cache2.size > cutoff) {
            cache2.keys.length = cutoff;
            cache2.values.length = cutoff;
          }
          cache2.keys.unshift(cacheKey);
          cache2.values.unshift(value);
          if (options2.isPromise) {
            cache2.updateAsyncCache(moized);
          }
          if (onCacheAdd) {
            onCacheAdd(cache2, options2, moized);
          }
          if (onCacheChange) {
            onCacheChange(cache2, options2, moized);
          }
        } else {
          var existingKey = cache2.keys[keyIndex];
          cache2.values[keyIndex] = value;
          if (keyIndex > 0) {
            cache2.orderByLru(existingKey, value, keyIndex);
          }
          if (options2.isPromise) {
            cache2.updateAsyncCache(moized);
          }
          if (typeof onCacheChange === "function") {
            onCacheChange(cache2, options2, moized);
          }
        }
      };
      moized.values = function() {
        return moized.cacheSnapshot.values;
      };
    }
    function addInstanceProperties(memoized, _ref2) {
      var expirations = _ref2.expirations, moizeOptions = _ref2.options, originalFunction = _ref2.originalFunction;
      var microMemoizeOptions = memoized.options;
      Object.defineProperties(memoized, {
        _microMemoizeOptions: {
          configurable: true,
          get: function get3() {
            return microMemoizeOptions;
          }
        },
        cacheSnapshot: {
          configurable: true,
          get: function get3() {
            var currentCache = memoized.cache;
            return {
              keys: currentCache.keys.slice(0),
              size: currentCache.size,
              values: currentCache.values.slice(0)
            };
          }
        },
        expirations: {
          configurable: true,
          get: function get3() {
            return expirations;
          }
        },
        expirationsSnapshot: {
          configurable: true,
          get: function get3() {
            return expirations.slice(0);
          }
        },
        isMoized: {
          configurable: true,
          get: function get3() {
            return true;
          }
        },
        options: {
          configurable: true,
          get: function get3() {
            return moizeOptions;
          }
        },
        originalFunction: {
          configurable: true,
          get: function get3() {
            return originalFunction;
          }
        }
      });
      var moized = memoized;
      copyStaticProperties(originalFunction, moized);
    }
    function createMoizeInstance(memoized, configuration) {
      addInstanceMethods(memoized, configuration);
      addInstanceProperties(memoized, configuration);
      return memoized;
    }
    var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for ? Symbol.for("react.element") : 60103;
    function createMoizedComponent(moizer, fn2, options) {
      var reactMoizer = moizer(_extends2({
        maxArgs: 2,
        isShallowEqual: true
      }, options, {
        isReact: false
      }));
      if (!fn2.displayName) {
        fn2.displayName = fn2.name || "Component";
      }
      function Moized(props3, context2, updater) {
        this.props = props3;
        this.context = context2;
        this.updater = updater;
        this.MoizedComponent = reactMoizer(fn2);
      }
      Moized.prototype.isReactComponent = {};
      Moized.prototype.render = function() {
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type: this.MoizedComponent,
          props: this.props,
          ref: null,
          key: null,
          _owner: null
        };
      };
      copyStaticProperties(fn2, Moized, ["contextType", "contextTypes"]);
      Moized.displayName = "Moized(" + (fn2.displayName || fn2.name || "Component") + ")";
      setName(Moized, fn2.name, options.profileName);
      return Moized;
    }
    function createGetInitialArgs(size) {
      return function(args) {
        if (size >= args.length) {
          return args;
        }
        if (size === 0) {
          return [];
        }
        if (size === 1) {
          return [args[0]];
        }
        if (size === 2) {
          return [args[0], args[1]];
        }
        if (size === 3) {
          return [args[0], args[1], args[2]];
        }
        var clone3 = [];
        for (var index3 = 0; index3 < size; index3++) {
          clone3[index3] = args[index3];
        }
        return clone3;
      };
    }
    function getCutoff(array3, value) {
      var length3 = array3.length;
      for (var index3 = 0; index3 < length3; ++index3) {
        if (array3[index3] === value) {
          return index3 + 1;
        }
      }
      return 0;
    }
    function createDefaultReplacer() {
      var cache2 = [];
      var keys4 = [];
      return function defaultReplacer(key, value) {
        var type3 = typeof value;
        if (type3 === "function" || type3 === "symbol") {
          return value.toString();
        }
        if (typeof value === "object") {
          if (cache2.length) {
            var thisCutoff = getCutoff(cache2, this);
            if (thisCutoff === 0) {
              cache2[cache2.length] = this;
            } else {
              cache2.splice(thisCutoff);
              keys4.splice(thisCutoff);
            }
            keys4[keys4.length] = key;
            var valueCutoff = getCutoff(cache2, value);
            if (valueCutoff !== 0) {
              return "[ref=" + (keys4.slice(0, valueCutoff).join(".") || ".") + "]";
            }
          } else {
            cache2[0] = value;
            keys4[0] = key;
          }
          return value;
        }
        return "" + value;
      };
    }
    function getStringifiedArgument(arg) {
      var typeOfArg = typeof arg;
      return arg && (typeOfArg === "object" || typeOfArg === "function") ? JSON.stringify(arg, createDefaultReplacer()) : arg;
    }
    function defaultArgumentSerializer(args) {
      var key = "|";
      for (var index3 = 0; index3 < args.length; index3++) {
        key += getStringifiedArgument(args[index3]) + "|";
      }
      return [key];
    }
    function getSerializerFunction(options) {
      return typeof options.serializer === "function" ? options.serializer : defaultArgumentSerializer;
    }
    function getIsSerializedKeyEqual(cacheKey, key) {
      return cacheKey[0] === key[0];
    }
    function createOnCacheOperation(fn2) {
      if (typeof fn2 === "function") {
        return function(_cacheIgnored, _microMemoizeOptionsIgnored, memoized) {
          return fn2(memoized.cache, memoized.options, memoized);
        };
      }
    }
    function getIsEqual(options) {
      return options.matchesArg || options.isDeepEqual && fastEquals2.deepEqual || options.isShallowEqual && fastEquals2.shallowEqual || fastEquals2.sameValueZeroEqual;
    }
    function getIsMatchingKey(options) {
      return options.matchesKey || options.isSerialized && getIsSerializedKeyEqual || void 0;
    }
    function getTransformKey(options) {
      return compose3(options.isSerialized && getSerializerFunction(options), typeof options.transformArgs === "function" && options.transformArgs, typeof options.maxArgs === "number" && createGetInitialArgs(options.maxArgs));
    }
    function createRefreshableMoized(moized) {
      var updateCacheForKey = moized.options.updateCacheForKey;
      var refreshableMoized = function refreshableMoized2() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (!updateCacheForKey(args)) {
          return moized.apply(this, args);
        }
        var result = moized.fn.apply(this, args);
        moized.set(args, result);
        return result;
      };
      copyStaticProperties(moized, refreshableMoized);
      return refreshableMoized;
    }
    var _excluded4 = ["matchesArg", "isDeepEqual", "isPromise", "isReact", "isSerialized", "isShallowEqual", "matchesKey", "maxAge", "maxArgs", "maxSize", "onCacheAdd", "onCacheChange", "onCacheHit", "onExpire", "profileName", "serializer", "updateCacheForKey", "transformArgs", "updateExpire"];
    var moize2 = function moize3(fn2, passedOptions) {
      var options = passedOptions || DEFAULT_OPTIONS;
      if (isMoized(fn2)) {
        var moizeable = fn2.originalFunction;
        var mergedOptions = mergeOptions(fn2.options, options);
        return moize3(moizeable, mergedOptions);
      }
      if (typeof fn2 === "object") {
        return function(curriedFn, curriedOptions) {
          if (typeof curriedFn === "function") {
            var _mergedOptions = mergeOptions(fn2, curriedOptions);
            return moize3(curriedFn, _mergedOptions);
          }
          var mergedOptions2 = mergeOptions(fn2, curriedFn);
          return moize3(mergedOptions2);
        };
      }
      if (options.isReact) {
        return createMoizedComponent(moize3, fn2, options);
      }
      var coalescedOptions = _extends2({}, DEFAULT_OPTIONS, options, {
        maxAge: typeof options.maxAge === "number" && options.maxAge >= 0 ? options.maxAge : DEFAULT_OPTIONS.maxAge,
        maxArgs: typeof options.maxArgs === "number" && options.maxArgs >= 0 ? options.maxArgs : DEFAULT_OPTIONS.maxArgs,
        maxSize: typeof options.maxSize === "number" && options.maxSize >= 0 ? options.maxSize : DEFAULT_OPTIONS.maxSize,
        profileName: options.profileName || getDefaultProfileName(fn2)
      });
      var expirations = [];
      coalescedOptions.matchesArg;
      coalescedOptions.isDeepEqual;
      var isPromise = coalescedOptions.isPromise;
      coalescedOptions.isReact;
      coalescedOptions.isSerialized;
      coalescedOptions.isShallowEqual;
      coalescedOptions.matchesKey;
      coalescedOptions.maxAge;
      coalescedOptions.maxArgs;
      var maxSize = coalescedOptions.maxSize, onCacheAdd = coalescedOptions.onCacheAdd, onCacheChange = coalescedOptions.onCacheChange, onCacheHit = coalescedOptions.onCacheHit;
      coalescedOptions.onExpire;
      coalescedOptions.profileName;
      coalescedOptions.serializer;
      var updateCacheForKey = coalescedOptions.updateCacheForKey;
      coalescedOptions.transformArgs;
      coalescedOptions.updateExpire;
      var customOptions = _objectWithoutPropertiesLoose2(coalescedOptions, _excluded4);
      var isEqual2 = getIsEqual(coalescedOptions);
      var isMatchingKey = getIsMatchingKey(coalescedOptions);
      var maxAgeOptions = getMaxAgeOptions(expirations, coalescedOptions, isEqual2, isMatchingKey);
      var statsOptions = getStatsOptions(coalescedOptions);
      var transformKey = getTransformKey(coalescedOptions);
      var microMemoizeOptions = _extends2({}, customOptions, {
        isEqual: isEqual2,
        isMatchingKey,
        isPromise,
        maxSize,
        onCacheAdd: createOnCacheOperation(combine(onCacheAdd, maxAgeOptions.onCacheAdd, statsOptions.onCacheAdd)),
        onCacheChange: createOnCacheOperation(onCacheChange),
        onCacheHit: createOnCacheOperation(combine(onCacheHit, maxAgeOptions.onCacheHit, statsOptions.onCacheHit)),
        transformKey
      });
      var memoized = memoize3(fn2, microMemoizeOptions);
      var moized = createMoizeInstance(memoized, {
        expirations,
        options: coalescedOptions,
        originalFunction: fn2
      });
      if (updateCacheForKey) {
        moized = createRefreshableMoized(moized);
      }
      setName(moized, fn2.name, options.profileName);
      return moized;
    };
    moize2.clearStats = clearStats;
    moize2.collectStats = collectStats;
    moize2.compose = function() {
      return compose3.apply(void 0, arguments) || moize2;
    };
    moize2.deep = moize2({
      isDeepEqual: true
    });
    moize2.getStats = getStats;
    moize2.infinite = moize2({
      maxSize: Infinity
    });
    moize2.isCollectingStats = function isCollectingStats() {
      return statsCache.isCollectingStats;
    };
    moize2.isMoized = function isMoized2(fn2) {
      return typeof fn2 === "function" && !!fn2.isMoized;
    };
    moize2.matchesArg = function(argMatcher) {
      return moize2({
        matchesArg: argMatcher
      });
    };
    moize2.matchesKey = function(keyMatcher) {
      return moize2({
        matchesKey: keyMatcher
      });
    };
    function maxAge(maxAge2, expireOptions) {
      if (expireOptions === true) {
        return moize2({
          maxAge: maxAge2,
          updateExpire: expireOptions
        });
      }
      if (typeof expireOptions === "object") {
        var onExpire = expireOptions.onExpire, updateExpire = expireOptions.updateExpire;
        return moize2({
          maxAge: maxAge2,
          onExpire,
          updateExpire
        });
      }
      if (typeof expireOptions === "function") {
        return moize2({
          maxAge: maxAge2,
          onExpire: expireOptions,
          updateExpire: true
        });
      }
      return moize2({
        maxAge: maxAge2
      });
    }
    moize2.maxAge = maxAge;
    moize2.maxArgs = function maxArgs(maxArgs) {
      return moize2({
        maxArgs
      });
    };
    moize2.maxSize = function maxSize(maxSize) {
      return moize2({
        maxSize
      });
    };
    moize2.profile = function(profileName) {
      return moize2({
        profileName
      });
    };
    moize2.promise = moize2({
      isPromise: true,
      updateExpire: true
    });
    moize2.react = moize2({
      isReact: true
    });
    moize2.serialize = moize2({
      isSerialized: true
    });
    moize2.serializeWith = function(serializer) {
      return moize2({
        isSerialized: true,
        serializer
      });
    };
    moize2.shallow = moize2({
      isShallowEqual: true
    });
    moize2.transformArgs = function(transformArgs) {
      return moize2({
        transformArgs
      });
    };
    moize2.updateCacheForKey = function(updateCacheForKey) {
      return moize2({
        updateCacheForKey
      });
    };
    Object.defineProperty(moize2, "default", {
      configurable: false,
      enumerable: false,
      value: moize2,
      writable: false
    });
    return moize2;
  });
})(moize$1);
var moizeExports = moize$1.exports;
const moize = /* @__PURE__ */ getDefaultExportFromCjs(moizeExports);
var chroma$1 = { exports: {} };
/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */
(function(module2, exports) {
  (function(global2, factory) {
    module2.exports = factory();
  })(commonjsGlobal$2, function() {
    var limit$2 = function(x2, min4, max4) {
      if (min4 === void 0)
        min4 = 0;
      if (max4 === void 0)
        max4 = 1;
      return x2 < min4 ? min4 : x2 > max4 ? max4 : x2;
    };
    var limit$1 = limit$2;
    var clip_rgb$3 = function(rgb3) {
      rgb3._clipped = false;
      rgb3._unclipped = rgb3.slice(0);
      for (var i2 = 0; i2 <= 3; i2++) {
        if (i2 < 3) {
          if (rgb3[i2] < 0 || rgb3[i2] > 255) {
            rgb3._clipped = true;
          }
          rgb3[i2] = limit$1(rgb3[i2], 0, 255);
        } else if (i2 === 3) {
          rgb3[i2] = limit$1(rgb3[i2], 0, 1);
        }
      }
      return rgb3;
    };
    var classToType = {};
    for (var i$1 = 0, list$1 = ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Undefined", "Null"]; i$1 < list$1.length; i$1 += 1) {
      var name = list$1[i$1];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }
    var type$p = function(obj) {
      return classToType[Object.prototype.toString.call(obj)] || "object";
    };
    var type$o = type$p;
    var unpack$B = function(args, keyOrder) {
      if (keyOrder === void 0)
        keyOrder = null;
      if (args.length >= 3) {
        return Array.prototype.slice.call(args);
      }
      if (type$o(args[0]) == "object" && keyOrder) {
        return keyOrder.split("").filter(function(k2) {
          return args[0][k2] !== void 0;
        }).map(function(k2) {
          return args[0][k2];
        });
      }
      return args[0];
    };
    var type$n = type$p;
    var last$4 = function(args) {
      if (args.length < 2) {
        return null;
      }
      var l2 = args.length - 1;
      if (type$n(args[l2]) == "string") {
        return args[l2].toLowerCase();
      }
      return null;
    };
    var PI$2 = Math.PI;
    var utils2 = {
      clip_rgb: clip_rgb$3,
      limit: limit$2,
      type: type$p,
      unpack: unpack$B,
      last: last$4,
      PI: PI$2,
      TWOPI: PI$2 * 2,
      PITHIRD: PI$2 / 3,
      DEG2RAD: PI$2 / 180,
      RAD2DEG: 180 / PI$2
    };
    var input$h = {
      format: {},
      autodetect: []
    };
    var last$3 = utils2.last;
    var clip_rgb$2 = utils2.clip_rgb;
    var type$m = utils2.type;
    var _input = input$h;
    var Color$D = function Color3() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var me2 = this;
      if (type$m(args[0]) === "object" && args[0].constructor && args[0].constructor === this.constructor) {
        return args[0];
      }
      var mode = last$3(args);
      var autodetect = false;
      if (!mode) {
        autodetect = true;
        if (!_input.sorted) {
          _input.autodetect = _input.autodetect.sort(function(a2, b2) {
            return b2.p - a2.p;
          });
          _input.sorted = true;
        }
        for (var i2 = 0, list2 = _input.autodetect; i2 < list2.length; i2 += 1) {
          var chk = list2[i2];
          mode = chk.test.apply(chk, args);
          if (mode) {
            break;
          }
        }
      }
      if (_input.format[mode]) {
        var rgb3 = _input.format[mode].apply(null, autodetect ? args : args.slice(0, -1));
        me2._rgb = clip_rgb$2(rgb3);
      } else {
        throw new Error("unknown format: " + args);
      }
      if (me2._rgb.length === 3) {
        me2._rgb.push(1);
      }
    };
    Color$D.prototype.toString = function toString4() {
      if (type$m(this.hex) == "function") {
        return this.hex();
      }
      return "[" + this._rgb.join(",") + "]";
    };
    var Color_1 = Color$D;
    var chroma$k = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(chroma$k.Color, [null].concat(args)))();
    };
    chroma$k.Color = Color_1;
    chroma$k.version = "2.4.2";
    var chroma_1 = chroma$k;
    var unpack$A = utils2.unpack;
    var max$22 = Math.max;
    var rgb2cmyk$1 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var ref = unpack$A(args, "rgb");
      var r2 = ref[0];
      var g2 = ref[1];
      var b2 = ref[2];
      r2 = r2 / 255;
      g2 = g2 / 255;
      b2 = b2 / 255;
      var k2 = 1 - max$22(r2, max$22(g2, b2));
      var f2 = k2 < 1 ? 1 / (1 - k2) : 0;
      var c2 = (1 - r2 - k2) * f2;
      var m2 = (1 - g2 - k2) * f2;
      var y2 = (1 - b2 - k2) * f2;
      return [c2, m2, y2, k2];
    };
    var rgb2cmyk_1 = rgb2cmyk$1;
    var unpack$z = utils2.unpack;
    var cmyk2rgb = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      args = unpack$z(args, "cmyk");
      var c2 = args[0];
      var m2 = args[1];
      var y2 = args[2];
      var k2 = args[3];
      var alpha3 = args.length > 4 ? args[4] : 1;
      if (k2 === 1) {
        return [0, 0, 0, alpha3];
      }
      return [
        c2 >= 1 ? 0 : 255 * (1 - c2) * (1 - k2),
        // r
        m2 >= 1 ? 0 : 255 * (1 - m2) * (1 - k2),
        // g
        y2 >= 1 ? 0 : 255 * (1 - y2) * (1 - k2),
        // b
        alpha3
      ];
    };
    var cmyk2rgb_1 = cmyk2rgb;
    var chroma$j = chroma_1;
    var Color$C = Color_1;
    var input$g = input$h;
    var unpack$y = utils2.unpack;
    var type$l = utils2.type;
    var rgb2cmyk = rgb2cmyk_1;
    Color$C.prototype.cmyk = function() {
      return rgb2cmyk(this._rgb);
    };
    chroma$j.cmyk = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$C, [null].concat(args, ["cmyk"])))();
    };
    input$g.format.cmyk = cmyk2rgb_1;
    input$g.autodetect.push({
      p: 2,
      test: function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        args = unpack$y(args, "cmyk");
        if (type$l(args) === "array" && args.length === 4) {
          return "cmyk";
        }
      }
    });
    var unpack$x = utils2.unpack;
    var last$22 = utils2.last;
    var rnd = function(a2) {
      return Math.round(a2 * 100) / 100;
    };
    var hsl2css$1 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var hsla2 = unpack$x(args, "hsla");
      var mode = last$22(args) || "lsa";
      hsla2[0] = rnd(hsla2[0] || 0);
      hsla2[1] = rnd(hsla2[1] * 100) + "%";
      hsla2[2] = rnd(hsla2[2] * 100) + "%";
      if (mode === "hsla" || hsla2.length > 3 && hsla2[3] < 1) {
        hsla2[3] = hsla2.length > 3 ? hsla2[3] : 1;
        mode = "hsla";
      } else {
        hsla2.length = 3;
      }
      return mode + "(" + hsla2.join(",") + ")";
    };
    var hsl2css_1 = hsl2css$1;
    var unpack$w = utils2.unpack;
    var rgb2hsl$3 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      args = unpack$w(args, "rgba");
      var r2 = args[0];
      var g2 = args[1];
      var b2 = args[2];
      r2 /= 255;
      g2 /= 255;
      b2 /= 255;
      var min4 = Math.min(r2, g2, b2);
      var max4 = Math.max(r2, g2, b2);
      var l2 = (max4 + min4) / 2;
      var s2, h2;
      if (max4 === min4) {
        s2 = 0;
        h2 = Number.NaN;
      } else {
        s2 = l2 < 0.5 ? (max4 - min4) / (max4 + min4) : (max4 - min4) / (2 - max4 - min4);
      }
      if (r2 == max4) {
        h2 = (g2 - b2) / (max4 - min4);
      } else if (g2 == max4) {
        h2 = 2 + (b2 - r2) / (max4 - min4);
      } else if (b2 == max4) {
        h2 = 4 + (r2 - g2) / (max4 - min4);
      }
      h2 *= 60;
      if (h2 < 0) {
        h2 += 360;
      }
      if (args.length > 3 && args[3] !== void 0) {
        return [h2, s2, l2, args[3]];
      }
      return [h2, s2, l2];
    };
    var rgb2hsl_1 = rgb2hsl$3;
    var unpack$v = utils2.unpack;
    var last$12 = utils2.last;
    var hsl2css = hsl2css_1;
    var rgb2hsl$2 = rgb2hsl_1;
    var round$6 = Math.round;
    var rgb2css$1 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var rgba2 = unpack$v(args, "rgba");
      var mode = last$12(args) || "rgb";
      if (mode.substr(0, 3) == "hsl") {
        return hsl2css(rgb2hsl$2(rgba2), mode);
      }
      rgba2[0] = round$6(rgba2[0]);
      rgba2[1] = round$6(rgba2[1]);
      rgba2[2] = round$6(rgba2[2]);
      if (mode === "rgba" || rgba2.length > 3 && rgba2[3] < 1) {
        rgba2[3] = rgba2.length > 3 ? rgba2[3] : 1;
        mode = "rgba";
      }
      return mode + "(" + rgba2.slice(0, mode === "rgb" ? 3 : 4).join(",") + ")";
    };
    var rgb2css_1 = rgb2css$1;
    var unpack$u = utils2.unpack;
    var round$5 = Math.round;
    var hsl2rgb$1 = function() {
      var assign;
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      args = unpack$u(args, "hsl");
      var h2 = args[0];
      var s2 = args[1];
      var l2 = args[2];
      var r2, g2, b2;
      if (s2 === 0) {
        r2 = g2 = b2 = l2 * 255;
      } else {
        var t3 = [0, 0, 0];
        var c2 = [0, 0, 0];
        var t2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var t12 = 2 * l2 - t2;
        var h_ = h2 / 360;
        t3[0] = h_ + 1 / 3;
        t3[1] = h_;
        t3[2] = h_ - 1 / 3;
        for (var i2 = 0; i2 < 3; i2++) {
          if (t3[i2] < 0) {
            t3[i2] += 1;
          }
          if (t3[i2] > 1) {
            t3[i2] -= 1;
          }
          if (6 * t3[i2] < 1) {
            c2[i2] = t12 + (t2 - t12) * 6 * t3[i2];
          } else if (2 * t3[i2] < 1) {
            c2[i2] = t2;
          } else if (3 * t3[i2] < 2) {
            c2[i2] = t12 + (t2 - t12) * (2 / 3 - t3[i2]) * 6;
          } else {
            c2[i2] = t12;
          }
        }
        assign = [round$5(c2[0] * 255), round$5(c2[1] * 255), round$5(c2[2] * 255)], r2 = assign[0], g2 = assign[1], b2 = assign[2];
      }
      if (args.length > 3) {
        return [r2, g2, b2, args[3]];
      }
      return [r2, g2, b2, 1];
    };
    var hsl2rgb_1 = hsl2rgb$1;
    var hsl2rgb2 = hsl2rgb_1;
    var input$f = input$h;
    var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
    var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
    var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
    var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
    var round$4 = Math.round;
    var css2rgb$1 = function(css) {
      css = css.toLowerCase().trim();
      var m2;
      if (input$f.format.named) {
        try {
          return input$f.format.named(css);
        } catch (e3) {
        }
      }
      if (m2 = css.match(RE_RGB)) {
        var rgb3 = m2.slice(1, 4);
        for (var i2 = 0; i2 < 3; i2++) {
          rgb3[i2] = +rgb3[i2];
        }
        rgb3[3] = 1;
        return rgb3;
      }
      if (m2 = css.match(RE_RGBA)) {
        var rgb$12 = m2.slice(1, 5);
        for (var i$12 = 0; i$12 < 4; i$12++) {
          rgb$12[i$12] = +rgb$12[i$12];
        }
        return rgb$12;
      }
      if (m2 = css.match(RE_RGB_PCT)) {
        var rgb$2 = m2.slice(1, 4);
        for (var i$2 = 0; i$2 < 3; i$2++) {
          rgb$2[i$2] = round$4(rgb$2[i$2] * 2.55);
        }
        rgb$2[3] = 1;
        return rgb$2;
      }
      if (m2 = css.match(RE_RGBA_PCT)) {
        var rgb$3 = m2.slice(1, 5);
        for (var i$3 = 0; i$3 < 3; i$3++) {
          rgb$3[i$3] = round$4(rgb$3[i$3] * 2.55);
        }
        rgb$3[3] = +rgb$3[3];
        return rgb$3;
      }
      if (m2 = css.match(RE_HSL)) {
        var hsl3 = m2.slice(1, 4);
        hsl3[1] *= 0.01;
        hsl3[2] *= 0.01;
        var rgb$4 = hsl2rgb2(hsl3);
        rgb$4[3] = 1;
        return rgb$4;
      }
      if (m2 = css.match(RE_HSLA)) {
        var hsl$1 = m2.slice(1, 4);
        hsl$1[1] *= 0.01;
        hsl$1[2] *= 0.01;
        var rgb$5 = hsl2rgb2(hsl$1);
        rgb$5[3] = +m2[4];
        return rgb$5;
      }
    };
    css2rgb$1.test = function(s2) {
      return RE_RGB.test(s2) || RE_RGBA.test(s2) || RE_RGB_PCT.test(s2) || RE_RGBA_PCT.test(s2) || RE_HSL.test(s2) || RE_HSLA.test(s2);
    };
    var css2rgb_1 = css2rgb$1;
    var chroma$i = chroma_1;
    var Color$B = Color_1;
    var input$e = input$h;
    var type$k = utils2.type;
    var rgb2css = rgb2css_1;
    var css2rgb = css2rgb_1;
    Color$B.prototype.css = function(mode) {
      return rgb2css(this._rgb, mode);
    };
    chroma$i.css = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$B, [null].concat(args, ["css"])))();
    };
    input$e.format.css = css2rgb;
    input$e.autodetect.push({
      p: 5,
      test: function(h2) {
        var rest = [], len = arguments.length - 1;
        while (len-- > 0)
          rest[len] = arguments[len + 1];
        if (!rest.length && type$k(h2) === "string" && css2rgb.test(h2)) {
          return "css";
        }
      }
    });
    var Color$A = Color_1;
    var chroma$h = chroma_1;
    var input$d = input$h;
    var unpack$t = utils2.unpack;
    input$d.format.gl = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var rgb3 = unpack$t(args, "rgba");
      rgb3[0] *= 255;
      rgb3[1] *= 255;
      rgb3[2] *= 255;
      return rgb3;
    };
    chroma$h.gl = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$A, [null].concat(args, ["gl"])))();
    };
    Color$A.prototype.gl = function() {
      var rgb3 = this._rgb;
      return [rgb3[0] / 255, rgb3[1] / 255, rgb3[2] / 255, rgb3[3]];
    };
    var unpack$s = utils2.unpack;
    var rgb2hcg$1 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var ref = unpack$s(args, "rgb");
      var r2 = ref[0];
      var g2 = ref[1];
      var b2 = ref[2];
      var min4 = Math.min(r2, g2, b2);
      var max4 = Math.max(r2, g2, b2);
      var delta = max4 - min4;
      var c2 = delta * 100 / 255;
      var _g = min4 / (255 - delta) * 100;
      var h2;
      if (delta === 0) {
        h2 = Number.NaN;
      } else {
        if (r2 === max4) {
          h2 = (g2 - b2) / delta;
        }
        if (g2 === max4) {
          h2 = 2 + (b2 - r2) / delta;
        }
        if (b2 === max4) {
          h2 = 4 + (r2 - g2) / delta;
        }
        h2 *= 60;
        if (h2 < 0) {
          h2 += 360;
        }
      }
      return [h2, c2, _g];
    };
    var rgb2hcg_1 = rgb2hcg$1;
    var unpack$r = utils2.unpack;
    var floor$3 = Math.floor;
    var hcg2rgb = function() {
      var assign, assign$1, assign$2, assign$3, assign$4, assign$5;
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      args = unpack$r(args, "hcg");
      var h2 = args[0];
      var c2 = args[1];
      var _g = args[2];
      var r2, g2, b2;
      _g = _g * 255;
      var _c = c2 * 255;
      if (c2 === 0) {
        r2 = g2 = b2 = _g;
      } else {
        if (h2 === 360) {
          h2 = 0;
        }
        if (h2 > 360) {
          h2 -= 360;
        }
        if (h2 < 0) {
          h2 += 360;
        }
        h2 /= 60;
        var i2 = floor$3(h2);
        var f2 = h2 - i2;
        var p2 = _g * (1 - c2);
        var q2 = p2 + _c * (1 - f2);
        var t2 = p2 + _c * f2;
        var v2 = p2 + _c;
        switch (i2) {
          case 0:
            assign = [v2, t2, p2], r2 = assign[0], g2 = assign[1], b2 = assign[2];
            break;
          case 1:
            assign$1 = [q2, v2, p2], r2 = assign$1[0], g2 = assign$1[1], b2 = assign$1[2];
            break;
          case 2:
            assign$2 = [p2, v2, t2], r2 = assign$2[0], g2 = assign$2[1], b2 = assign$2[2];
            break;
          case 3:
            assign$3 = [p2, q2, v2], r2 = assign$3[0], g2 = assign$3[1], b2 = assign$3[2];
            break;
          case 4:
            assign$4 = [t2, p2, v2], r2 = assign$4[0], g2 = assign$4[1], b2 = assign$4[2];
            break;
          case 5:
            assign$5 = [v2, p2, q2], r2 = assign$5[0], g2 = assign$5[1], b2 = assign$5[2];
            break;
        }
      }
      return [r2, g2, b2, args.length > 3 ? args[3] : 1];
    };
    var hcg2rgb_1 = hcg2rgb;
    var unpack$q = utils2.unpack;
    var type$j = utils2.type;
    var chroma$g = chroma_1;
    var Color$z = Color_1;
    var input$c = input$h;
    var rgb2hcg = rgb2hcg_1;
    Color$z.prototype.hcg = function() {
      return rgb2hcg(this._rgb);
    };
    chroma$g.hcg = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$z, [null].concat(args, ["hcg"])))();
    };
    input$c.format.hcg = hcg2rgb_1;
    input$c.autodetect.push({
      p: 1,
      test: function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        args = unpack$q(args, "hcg");
        if (type$j(args) === "array" && args.length === 3) {
          return "hcg";
        }
      }
    });
    var unpack$p = utils2.unpack;
    var last2 = utils2.last;
    var round$3 = Math.round;
    var rgb2hex$2 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var ref = unpack$p(args, "rgba");
      var r2 = ref[0];
      var g2 = ref[1];
      var b2 = ref[2];
      var a2 = ref[3];
      var mode = last2(args) || "auto";
      if (a2 === void 0) {
        a2 = 1;
      }
      if (mode === "auto") {
        mode = a2 < 1 ? "rgba" : "rgb";
      }
      r2 = round$3(r2);
      g2 = round$3(g2);
      b2 = round$3(b2);
      var u2 = r2 << 16 | g2 << 8 | b2;
      var str = "000000" + u2.toString(16);
      str = str.substr(str.length - 6);
      var hxa = "0" + round$3(a2 * 255).toString(16);
      hxa = hxa.substr(hxa.length - 2);
      switch (mode.toLowerCase()) {
        case "rgba":
          return "#" + str + hxa;
        case "argb":
          return "#" + hxa + str;
        default:
          return "#" + str;
      }
    };
    var rgb2hex_1 = rgb2hex$2;
    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;
    var hex2rgb$1 = function(hex2) {
      if (hex2.match(RE_HEX)) {
        if (hex2.length === 4 || hex2.length === 7) {
          hex2 = hex2.substr(1);
        }
        if (hex2.length === 3) {
          hex2 = hex2.split("");
          hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2];
        }
        var u2 = parseInt(hex2, 16);
        var r2 = u2 >> 16;
        var g2 = u2 >> 8 & 255;
        var b2 = u2 & 255;
        return [r2, g2, b2, 1];
      }
      if (hex2.match(RE_HEXA)) {
        if (hex2.length === 5 || hex2.length === 9) {
          hex2 = hex2.substr(1);
        }
        if (hex2.length === 4) {
          hex2 = hex2.split("");
          hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2] + hex2[3] + hex2[3];
        }
        var u$12 = parseInt(hex2, 16);
        var r$12 = u$12 >> 24 & 255;
        var g$12 = u$12 >> 16 & 255;
        var b$12 = u$12 >> 8 & 255;
        var a2 = Math.round((u$12 & 255) / 255 * 100) / 100;
        return [r$12, g$12, b$12, a2];
      }
      throw new Error("unknown hex color: " + hex2);
    };
    var hex2rgb_1 = hex2rgb$1;
    var chroma$f = chroma_1;
    var Color$y = Color_1;
    var type$i = utils2.type;
    var input$b = input$h;
    var rgb2hex$1 = rgb2hex_1;
    Color$y.prototype.hex = function(mode) {
      return rgb2hex$1(this._rgb, mode);
    };
    chroma$f.hex = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$y, [null].concat(args, ["hex"])))();
    };
    input$b.format.hex = hex2rgb_1;
    input$b.autodetect.push({
      p: 4,
      test: function(h2) {
        var rest = [], len = arguments.length - 1;
        while (len-- > 0)
          rest[len] = arguments[len + 1];
        if (!rest.length && type$i(h2) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(h2.length) >= 0) {
          return "hex";
        }
      }
    });
    var unpack$o = utils2.unpack;
    var TWOPI$2 = utils2.TWOPI;
    var min$22 = Math.min;
    var sqrt$4 = Math.sqrt;
    var acos = Math.acos;
    var rgb2hsi$1 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var ref = unpack$o(args, "rgb");
      var r2 = ref[0];
      var g2 = ref[1];
      var b2 = ref[2];
      r2 /= 255;
      g2 /= 255;
      b2 /= 255;
      var h2;
      var min_ = min$22(r2, g2, b2);
      var i2 = (r2 + g2 + b2) / 3;
      var s2 = i2 > 0 ? 1 - min_ / i2 : 0;
      if (s2 === 0) {
        h2 = NaN;
      } else {
        h2 = (r2 - g2 + (r2 - b2)) / 2;
        h2 /= sqrt$4((r2 - g2) * (r2 - g2) + (r2 - b2) * (g2 - b2));
        h2 = acos(h2);
        if (b2 > g2) {
          h2 = TWOPI$2 - h2;
        }
        h2 /= TWOPI$2;
      }
      return [h2 * 360, s2, i2];
    };
    var rgb2hsi_1 = rgb2hsi$1;
    var unpack$n = utils2.unpack;
    var limit = utils2.limit;
    var TWOPI$1 = utils2.TWOPI;
    var PITHIRD = utils2.PITHIRD;
    var cos$4 = Math.cos;
    var hsi2rgb = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      args = unpack$n(args, "hsi");
      var h2 = args[0];
      var s2 = args[1];
      var i2 = args[2];
      var r2, g2, b2;
      if (isNaN(h2)) {
        h2 = 0;
      }
      if (isNaN(s2)) {
        s2 = 0;
      }
      if (h2 > 360) {
        h2 -= 360;
      }
      if (h2 < 0) {
        h2 += 360;
      }
      h2 /= 360;
      if (h2 < 1 / 3) {
        b2 = (1 - s2) / 3;
        r2 = (1 + s2 * cos$4(TWOPI$1 * h2) / cos$4(PITHIRD - TWOPI$1 * h2)) / 3;
        g2 = 1 - (b2 + r2);
      } else if (h2 < 2 / 3) {
        h2 -= 1 / 3;
        r2 = (1 - s2) / 3;
        g2 = (1 + s2 * cos$4(TWOPI$1 * h2) / cos$4(PITHIRD - TWOPI$1 * h2)) / 3;
        b2 = 1 - (r2 + g2);
      } else {
        h2 -= 2 / 3;
        g2 = (1 - s2) / 3;
        b2 = (1 + s2 * cos$4(TWOPI$1 * h2) / cos$4(PITHIRD - TWOPI$1 * h2)) / 3;
        r2 = 1 - (g2 + b2);
      }
      r2 = limit(i2 * r2 * 3);
      g2 = limit(i2 * g2 * 3);
      b2 = limit(i2 * b2 * 3);
      return [r2 * 255, g2 * 255, b2 * 255, args.length > 3 ? args[3] : 1];
    };
    var hsi2rgb_1 = hsi2rgb;
    var unpack$m = utils2.unpack;
    var type$h = utils2.type;
    var chroma$e = chroma_1;
    var Color$x = Color_1;
    var input$a = input$h;
    var rgb2hsi = rgb2hsi_1;
    Color$x.prototype.hsi = function() {
      return rgb2hsi(this._rgb);
    };
    chroma$e.hsi = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$x, [null].concat(args, ["hsi"])))();
    };
    input$a.format.hsi = hsi2rgb_1;
    input$a.autodetect.push({
      p: 2,
      test: function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        args = unpack$m(args, "hsi");
        if (type$h(args) === "array" && args.length === 3) {
          return "hsi";
        }
      }
    });
    var unpack$l = utils2.unpack;
    var type$g = utils2.type;
    var chroma$d = chroma_1;
    var Color$w = Color_1;
    var input$9 = input$h;
    var rgb2hsl$1 = rgb2hsl_1;
    Color$w.prototype.hsl = function() {
      return rgb2hsl$1(this._rgb);
    };
    chroma$d.hsl = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$w, [null].concat(args, ["hsl"])))();
    };
    input$9.format.hsl = hsl2rgb_1;
    input$9.autodetect.push({
      p: 2,
      test: function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        args = unpack$l(args, "hsl");
        if (type$g(args) === "array" && args.length === 3) {
          return "hsl";
        }
      }
    });
    var unpack$k = utils2.unpack;
    var min$12 = Math.min;
    var max$12 = Math.max;
    var rgb2hsl = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      args = unpack$k(args, "rgb");
      var r2 = args[0];
      var g2 = args[1];
      var b2 = args[2];
      var min_ = min$12(r2, g2, b2);
      var max_ = max$12(r2, g2, b2);
      var delta = max_ - min_;
      var h2, s2, v2;
      v2 = max_ / 255;
      if (max_ === 0) {
        h2 = Number.NaN;
        s2 = 0;
      } else {
        s2 = delta / max_;
        if (r2 === max_) {
          h2 = (g2 - b2) / delta;
        }
        if (g2 === max_) {
          h2 = 2 + (b2 - r2) / delta;
        }
        if (b2 === max_) {
          h2 = 4 + (r2 - g2) / delta;
        }
        h2 *= 60;
        if (h2 < 0) {
          h2 += 360;
        }
      }
      return [h2, s2, v2];
    };
    var rgb2hsv$1 = rgb2hsl;
    var unpack$j = utils2.unpack;
    var floor$2 = Math.floor;
    var hsv2rgb = function() {
      var assign, assign$1, assign$2, assign$3, assign$4, assign$5;
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      args = unpack$j(args, "hsv");
      var h2 = args[0];
      var s2 = args[1];
      var v2 = args[2];
      var r2, g2, b2;
      v2 *= 255;
      if (s2 === 0) {
        r2 = g2 = b2 = v2;
      } else {
        if (h2 === 360) {
          h2 = 0;
        }
        if (h2 > 360) {
          h2 -= 360;
        }
        if (h2 < 0) {
          h2 += 360;
        }
        h2 /= 60;
        var i2 = floor$2(h2);
        var f2 = h2 - i2;
        var p2 = v2 * (1 - s2);
        var q2 = v2 * (1 - s2 * f2);
        var t2 = v2 * (1 - s2 * (1 - f2));
        switch (i2) {
          case 0:
            assign = [v2, t2, p2], r2 = assign[0], g2 = assign[1], b2 = assign[2];
            break;
          case 1:
            assign$1 = [q2, v2, p2], r2 = assign$1[0], g2 = assign$1[1], b2 = assign$1[2];
            break;
          case 2:
            assign$2 = [p2, v2, t2], r2 = assign$2[0], g2 = assign$2[1], b2 = assign$2[2];
            break;
          case 3:
            assign$3 = [p2, q2, v2], r2 = assign$3[0], g2 = assign$3[1], b2 = assign$3[2];
            break;
          case 4:
            assign$4 = [t2, p2, v2], r2 = assign$4[0], g2 = assign$4[1], b2 = assign$4[2];
            break;
          case 5:
            assign$5 = [v2, p2, q2], r2 = assign$5[0], g2 = assign$5[1], b2 = assign$5[2];
            break;
        }
      }
      return [r2, g2, b2, args.length > 3 ? args[3] : 1];
    };
    var hsv2rgb_1 = hsv2rgb;
    var unpack$i = utils2.unpack;
    var type$f = utils2.type;
    var chroma$c = chroma_1;
    var Color$v = Color_1;
    var input$8 = input$h;
    var rgb2hsv = rgb2hsv$1;
    Color$v.prototype.hsv = function() {
      return rgb2hsv(this._rgb);
    };
    chroma$c.hsv = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$v, [null].concat(args, ["hsv"])))();
    };
    input$8.format.hsv = hsv2rgb_1;
    input$8.autodetect.push({
      p: 2,
      test: function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        args = unpack$i(args, "hsv");
        if (type$f(args) === "array" && args.length === 3) {
          return "hsv";
        }
      }
    });
    var labConstants = {
      // Corresponds roughly to RGB brighter/darker
      Kn: 18,
      // D65 standard referent
      Xn: 0.95047,
      Yn: 1,
      Zn: 1.08883,
      t0: 0.137931034,
      // 4 / 29
      t1: 0.206896552,
      // 6 / 29
      t2: 0.12841855,
      // 3 * t1 * t1
      t3: 8856452e-9
      // t1 * t1 * t1
    };
    var LAB_CONSTANTS$3 = labConstants;
    var unpack$h = utils2.unpack;
    var pow$a = Math.pow;
    var rgb2lab$2 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var ref = unpack$h(args, "rgb");
      var r2 = ref[0];
      var g2 = ref[1];
      var b2 = ref[2];
      var ref$1 = rgb2xyz(r2, g2, b2);
      var x2 = ref$1[0];
      var y2 = ref$1[1];
      var z2 = ref$1[2];
      var l2 = 116 * y2 - 16;
      return [l2 < 0 ? 0 : l2, 500 * (x2 - y2), 200 * (y2 - z2)];
    };
    var rgb_xyz = function(r2) {
      if ((r2 /= 255) <= 0.04045) {
        return r2 / 12.92;
      }
      return pow$a((r2 + 0.055) / 1.055, 2.4);
    };
    var xyz_lab = function(t2) {
      if (t2 > LAB_CONSTANTS$3.t3) {
        return pow$a(t2, 1 / 3);
      }
      return t2 / LAB_CONSTANTS$3.t2 + LAB_CONSTANTS$3.t0;
    };
    var rgb2xyz = function(r2, g2, b2) {
      r2 = rgb_xyz(r2);
      g2 = rgb_xyz(g2);
      b2 = rgb_xyz(b2);
      var x2 = xyz_lab((0.4124564 * r2 + 0.3575761 * g2 + 0.1804375 * b2) / LAB_CONSTANTS$3.Xn);
      var y2 = xyz_lab((0.2126729 * r2 + 0.7151522 * g2 + 0.072175 * b2) / LAB_CONSTANTS$3.Yn);
      var z2 = xyz_lab((0.0193339 * r2 + 0.119192 * g2 + 0.9503041 * b2) / LAB_CONSTANTS$3.Zn);
      return [x2, y2, z2];
    };
    var rgb2lab_1 = rgb2lab$2;
    var LAB_CONSTANTS$2 = labConstants;
    var unpack$g = utils2.unpack;
    var pow$9 = Math.pow;
    var lab2rgb$1 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      args = unpack$g(args, "lab");
      var l2 = args[0];
      var a2 = args[1];
      var b2 = args[2];
      var x2, y2, z2, r2, g2, b_;
      y2 = (l2 + 16) / 116;
      x2 = isNaN(a2) ? y2 : y2 + a2 / 500;
      z2 = isNaN(b2) ? y2 : y2 - b2 / 200;
      y2 = LAB_CONSTANTS$2.Yn * lab_xyz(y2);
      x2 = LAB_CONSTANTS$2.Xn * lab_xyz(x2);
      z2 = LAB_CONSTANTS$2.Zn * lab_xyz(z2);
      r2 = xyz_rgb(3.2404542 * x2 - 1.5371385 * y2 - 0.4985314 * z2);
      g2 = xyz_rgb(-0.969266 * x2 + 1.8760108 * y2 + 0.041556 * z2);
      b_ = xyz_rgb(0.0556434 * x2 - 0.2040259 * y2 + 1.0572252 * z2);
      return [r2, g2, b_, args.length > 3 ? args[3] : 1];
    };
    var xyz_rgb = function(r2) {
      return 255 * (r2 <= 304e-5 ? 12.92 * r2 : 1.055 * pow$9(r2, 1 / 2.4) - 0.055);
    };
    var lab_xyz = function(t2) {
      return t2 > LAB_CONSTANTS$2.t1 ? t2 * t2 * t2 : LAB_CONSTANTS$2.t2 * (t2 - LAB_CONSTANTS$2.t0);
    };
    var lab2rgb_1 = lab2rgb$1;
    var unpack$f = utils2.unpack;
    var type$e = utils2.type;
    var chroma$b = chroma_1;
    var Color$u = Color_1;
    var input$7 = input$h;
    var rgb2lab$1 = rgb2lab_1;
    Color$u.prototype.lab = function() {
      return rgb2lab$1(this._rgb);
    };
    chroma$b.lab = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$u, [null].concat(args, ["lab"])))();
    };
    input$7.format.lab = lab2rgb_1;
    input$7.autodetect.push({
      p: 2,
      test: function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        args = unpack$f(args, "lab");
        if (type$e(args) === "array" && args.length === 3) {
          return "lab";
        }
      }
    });
    var unpack$e = utils2.unpack;
    var RAD2DEG = utils2.RAD2DEG;
    var sqrt$3 = Math.sqrt;
    var atan2$2 = Math.atan2;
    var round$2 = Math.round;
    var lab2lch$2 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var ref = unpack$e(args, "lab");
      var l2 = ref[0];
      var a2 = ref[1];
      var b2 = ref[2];
      var c2 = sqrt$3(a2 * a2 + b2 * b2);
      var h2 = (atan2$2(b2, a2) * RAD2DEG + 360) % 360;
      if (round$2(c2 * 1e4) === 0) {
        h2 = Number.NaN;
      }
      return [l2, c2, h2];
    };
    var lab2lch_1 = lab2lch$2;
    var unpack$d = utils2.unpack;
    var rgb2lab = rgb2lab_1;
    var lab2lch$1 = lab2lch_1;
    var rgb2lch$1 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var ref = unpack$d(args, "rgb");
      var r2 = ref[0];
      var g2 = ref[1];
      var b2 = ref[2];
      var ref$1 = rgb2lab(r2, g2, b2);
      var l2 = ref$1[0];
      var a2 = ref$1[1];
      var b_ = ref$1[2];
      return lab2lch$1(l2, a2, b_);
    };
    var rgb2lch_1 = rgb2lch$1;
    var unpack$c = utils2.unpack;
    var DEG2RAD = utils2.DEG2RAD;
    var sin$3 = Math.sin;
    var cos$3 = Math.cos;
    var lch2lab$2 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var ref = unpack$c(args, "lch");
      var l2 = ref[0];
      var c2 = ref[1];
      var h2 = ref[2];
      if (isNaN(h2)) {
        h2 = 0;
      }
      h2 = h2 * DEG2RAD;
      return [l2, cos$3(h2) * c2, sin$3(h2) * c2];
    };
    var lch2lab_1 = lch2lab$2;
    var unpack$b = utils2.unpack;
    var lch2lab$1 = lch2lab_1;
    var lab2rgb = lab2rgb_1;
    var lch2rgb$1 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      args = unpack$b(args, "lch");
      var l2 = args[0];
      var c2 = args[1];
      var h2 = args[2];
      var ref = lch2lab$1(l2, c2, h2);
      var L2 = ref[0];
      var a2 = ref[1];
      var b_ = ref[2];
      var ref$1 = lab2rgb(L2, a2, b_);
      var r2 = ref$1[0];
      var g2 = ref$1[1];
      var b2 = ref$1[2];
      return [r2, g2, b2, args.length > 3 ? args[3] : 1];
    };
    var lch2rgb_1 = lch2rgb$1;
    var unpack$a = utils2.unpack;
    var lch2rgb = lch2rgb_1;
    var hcl2rgb = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var hcl = unpack$a(args, "hcl").reverse();
      return lch2rgb.apply(void 0, hcl);
    };
    var hcl2rgb_1 = hcl2rgb;
    var unpack$9 = utils2.unpack;
    var type$d = utils2.type;
    var chroma$a = chroma_1;
    var Color$t = Color_1;
    var input$6 = input$h;
    var rgb2lch = rgb2lch_1;
    Color$t.prototype.lch = function() {
      return rgb2lch(this._rgb);
    };
    Color$t.prototype.hcl = function() {
      return rgb2lch(this._rgb).reverse();
    };
    chroma$a.lch = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$t, [null].concat(args, ["lch"])))();
    };
    chroma$a.hcl = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$t, [null].concat(args, ["hcl"])))();
    };
    input$6.format.lch = lch2rgb_1;
    input$6.format.hcl = hcl2rgb_1;
    ["lch", "hcl"].forEach(function(m2) {
      return input$6.autodetect.push({
        p: 2,
        test: function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$9(args, m2);
          if (type$d(args) === "array" && args.length === 3) {
            return m2;
          }
        }
      });
    });
    var w3cx11$1 = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflower: "#6495ed",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      laserlemon: "#ffff54",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrod: "#fafad2",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      maroon2: "#7f0000",
      maroon3: "#b03060",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      purple2: "#7f007f",
      purple3: "#a020f0",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    var w3cx11_1 = w3cx11$1;
    var Color$s = Color_1;
    var input$5 = input$h;
    var type$c = utils2.type;
    var w3cx11 = w3cx11_1;
    var hex2rgb = hex2rgb_1;
    var rgb2hex = rgb2hex_1;
    Color$s.prototype.name = function() {
      var hex2 = rgb2hex(this._rgb, "rgb");
      for (var i2 = 0, list2 = Object.keys(w3cx11); i2 < list2.length; i2 += 1) {
        var n2 = list2[i2];
        if (w3cx11[n2] === hex2) {
          return n2.toLowerCase();
        }
      }
      return hex2;
    };
    input$5.format.named = function(name2) {
      name2 = name2.toLowerCase();
      if (w3cx11[name2]) {
        return hex2rgb(w3cx11[name2]);
      }
      throw new Error("unknown color name: " + name2);
    };
    input$5.autodetect.push({
      p: 5,
      test: function(h2) {
        var rest = [], len = arguments.length - 1;
        while (len-- > 0)
          rest[len] = arguments[len + 1];
        if (!rest.length && type$c(h2) === "string" && w3cx11[h2.toLowerCase()]) {
          return "named";
        }
      }
    });
    var unpack$8 = utils2.unpack;
    var rgb2num$1 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var ref = unpack$8(args, "rgb");
      var r2 = ref[0];
      var g2 = ref[1];
      var b2 = ref[2];
      return (r2 << 16) + (g2 << 8) + b2;
    };
    var rgb2num_1 = rgb2num$1;
    var type$b = utils2.type;
    var num2rgb = function(num2) {
      if (type$b(num2) == "number" && num2 >= 0 && num2 <= 16777215) {
        var r2 = num2 >> 16;
        var g2 = num2 >> 8 & 255;
        var b2 = num2 & 255;
        return [r2, g2, b2, 1];
      }
      throw new Error("unknown num color: " + num2);
    };
    var num2rgb_1 = num2rgb;
    var chroma$9 = chroma_1;
    var Color$r = Color_1;
    var input$4 = input$h;
    var type$a = utils2.type;
    var rgb2num = rgb2num_1;
    Color$r.prototype.num = function() {
      return rgb2num(this._rgb);
    };
    chroma$9.num = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$r, [null].concat(args, ["num"])))();
    };
    input$4.format.num = num2rgb_1;
    input$4.autodetect.push({
      p: 5,
      test: function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        if (args.length === 1 && type$a(args[0]) === "number" && args[0] >= 0 && args[0] <= 16777215) {
          return "num";
        }
      }
    });
    var chroma$8 = chroma_1;
    var Color$q = Color_1;
    var input$3 = input$h;
    var unpack$7 = utils2.unpack;
    var type$9 = utils2.type;
    var round$12 = Math.round;
    Color$q.prototype.rgb = function(rnd2) {
      if (rnd2 === void 0)
        rnd2 = true;
      if (rnd2 === false) {
        return this._rgb.slice(0, 3);
      }
      return this._rgb.slice(0, 3).map(round$12);
    };
    Color$q.prototype.rgba = function(rnd2) {
      if (rnd2 === void 0)
        rnd2 = true;
      return this._rgb.slice(0, 4).map(function(v2, i2) {
        return i2 < 3 ? rnd2 === false ? v2 : round$12(v2) : v2;
      });
    };
    chroma$8.rgb = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$q, [null].concat(args, ["rgb"])))();
    };
    input$3.format.rgb = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var rgba2 = unpack$7(args, "rgba");
      if (rgba2[3] === void 0) {
        rgba2[3] = 1;
      }
      return rgba2;
    };
    input$3.autodetect.push({
      p: 3,
      test: function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        args = unpack$7(args, "rgba");
        if (type$9(args) === "array" && (args.length === 3 || args.length === 4 && type$9(args[3]) == "number" && args[3] >= 0 && args[3] <= 1)) {
          return "rgb";
        }
      }
    });
    var log$1 = Math.log;
    var temperature2rgb$1 = function(kelvin) {
      var temp = kelvin / 100;
      var r2, g2, b2;
      if (temp < 66) {
        r2 = 255;
        g2 = temp < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g2 = temp - 2) + 104.49216199393888 * log$1(g2);
        b2 = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b2 = temp - 10) + 115.67994401066147 * log$1(b2);
      } else {
        r2 = 351.97690566805693 + 0.114206453784165 * (r2 = temp - 55) - 40.25366309332127 * log$1(r2);
        g2 = 325.4494125711974 + 0.07943456536662342 * (g2 = temp - 50) - 28.0852963507957 * log$1(g2);
        b2 = 255;
      }
      return [r2, g2, b2, 1];
    };
    var temperature2rgb_1 = temperature2rgb$1;
    var temperature2rgb = temperature2rgb_1;
    var unpack$6 = utils2.unpack;
    var round2 = Math.round;
    var rgb2temperature$1 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var rgb3 = unpack$6(args, "rgb");
      var r2 = rgb3[0], b2 = rgb3[2];
      var minTemp = 1e3;
      var maxTemp = 4e4;
      var eps = 0.4;
      var temp;
      while (maxTemp - minTemp > eps) {
        temp = (maxTemp + minTemp) * 0.5;
        var rgb$12 = temperature2rgb(temp);
        if (rgb$12[2] / rgb$12[0] >= b2 / r2) {
          maxTemp = temp;
        } else {
          minTemp = temp;
        }
      }
      return round2(temp);
    };
    var rgb2temperature_1 = rgb2temperature$1;
    var chroma$7 = chroma_1;
    var Color$p = Color_1;
    var input$2 = input$h;
    var rgb2temperature = rgb2temperature_1;
    Color$p.prototype.temp = Color$p.prototype.kelvin = Color$p.prototype.temperature = function() {
      return rgb2temperature(this._rgb);
    };
    chroma$7.temp = chroma$7.kelvin = chroma$7.temperature = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$p, [null].concat(args, ["temp"])))();
    };
    input$2.format.temp = input$2.format.kelvin = input$2.format.temperature = temperature2rgb_1;
    var unpack$5 = utils2.unpack;
    var cbrt = Math.cbrt;
    var pow$8 = Math.pow;
    var sign$12 = Math.sign;
    var rgb2oklab$2 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var ref = unpack$5(args, "rgb");
      var r2 = ref[0];
      var g2 = ref[1];
      var b2 = ref[2];
      var ref$1 = [rgb2lrgb(r2 / 255), rgb2lrgb(g2 / 255), rgb2lrgb(b2 / 255)];
      var lr = ref$1[0];
      var lg2 = ref$1[1];
      var lb2 = ref$1[2];
      var l2 = cbrt(0.4122214708 * lr + 0.5363325363 * lg2 + 0.0514459929 * lb2);
      var m2 = cbrt(0.2119034982 * lr + 0.6806995451 * lg2 + 0.1073969566 * lb2);
      var s2 = cbrt(0.0883024619 * lr + 0.2817188376 * lg2 + 0.6299787005 * lb2);
      return [
        0.2104542553 * l2 + 0.793617785 * m2 - 0.0040720468 * s2,
        1.9779984951 * l2 - 2.428592205 * m2 + 0.4505937099 * s2,
        0.0259040371 * l2 + 0.7827717662 * m2 - 0.808675766 * s2
      ];
    };
    var rgb2oklab_1 = rgb2oklab$2;
    function rgb2lrgb(c2) {
      var abs3 = Math.abs(c2);
      if (abs3 < 0.04045) {
        return c2 / 12.92;
      }
      return (sign$12(c2) || 1) * pow$8((abs3 + 0.055) / 1.055, 2.4);
    }
    var unpack$4 = utils2.unpack;
    var pow$7 = Math.pow;
    var sign2 = Math.sign;
    var oklab2rgb$1 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      args = unpack$4(args, "lab");
      var L2 = args[0];
      var a2 = args[1];
      var b2 = args[2];
      var l2 = pow$7(L2 + 0.3963377774 * a2 + 0.2158037573 * b2, 3);
      var m2 = pow$7(L2 - 0.1055613458 * a2 - 0.0638541728 * b2, 3);
      var s2 = pow$7(L2 - 0.0894841775 * a2 - 1.291485548 * b2, 3);
      return [
        255 * lrgb2rgb(4.0767416621 * l2 - 3.3077115913 * m2 + 0.2309699292 * s2),
        255 * lrgb2rgb(-1.2684380046 * l2 + 2.6097574011 * m2 - 0.3413193965 * s2),
        255 * lrgb2rgb(-0.0041960863 * l2 - 0.7034186147 * m2 + 1.707614701 * s2),
        args.length > 3 ? args[3] : 1
      ];
    };
    var oklab2rgb_1 = oklab2rgb$1;
    function lrgb2rgb(c2) {
      var abs3 = Math.abs(c2);
      if (abs3 > 31308e-7) {
        return (sign2(c2) || 1) * (1.055 * pow$7(abs3, 1 / 2.4) - 0.055);
      }
      return c2 * 12.92;
    }
    var unpack$3 = utils2.unpack;
    var type$8 = utils2.type;
    var chroma$6 = chroma_1;
    var Color$o = Color_1;
    var input$1 = input$h;
    var rgb2oklab$1 = rgb2oklab_1;
    Color$o.prototype.oklab = function() {
      return rgb2oklab$1(this._rgb);
    };
    chroma$6.oklab = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$o, [null].concat(args, ["oklab"])))();
    };
    input$1.format.oklab = oklab2rgb_1;
    input$1.autodetect.push({
      p: 3,
      test: function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        args = unpack$3(args, "oklab");
        if (type$8(args) === "array" && args.length === 3) {
          return "oklab";
        }
      }
    });
    var unpack$2 = utils2.unpack;
    var rgb2oklab = rgb2oklab_1;
    var lab2lch = lab2lch_1;
    var rgb2oklch$1 = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var ref = unpack$2(args, "rgb");
      var r2 = ref[0];
      var g2 = ref[1];
      var b2 = ref[2];
      var ref$1 = rgb2oklab(r2, g2, b2);
      var l2 = ref$1[0];
      var a2 = ref$1[1];
      var b_ = ref$1[2];
      return lab2lch(l2, a2, b_);
    };
    var rgb2oklch_1 = rgb2oklch$1;
    var unpack$1 = utils2.unpack;
    var lch2lab = lch2lab_1;
    var oklab2rgb = oklab2rgb_1;
    var oklch2rgb = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      args = unpack$1(args, "lch");
      var l2 = args[0];
      var c2 = args[1];
      var h2 = args[2];
      var ref = lch2lab(l2, c2, h2);
      var L2 = ref[0];
      var a2 = ref[1];
      var b_ = ref[2];
      var ref$1 = oklab2rgb(L2, a2, b_);
      var r2 = ref$1[0];
      var g2 = ref$1[1];
      var b2 = ref$1[2];
      return [r2, g2, b2, args.length > 3 ? args[3] : 1];
    };
    var oklch2rgb_1 = oklch2rgb;
    var unpack = utils2.unpack;
    var type$7 = utils2.type;
    var chroma$5 = chroma_1;
    var Color$n = Color_1;
    var input = input$h;
    var rgb2oklch = rgb2oklch_1;
    Color$n.prototype.oklch = function() {
      return rgb2oklch(this._rgb);
    };
    chroma$5.oklch = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      return new (Function.prototype.bind.apply(Color$n, [null].concat(args, ["oklch"])))();
    };
    input.format.oklch = oklch2rgb_1;
    input.autodetect.push({
      p: 3,
      test: function() {
        var args = [], len = arguments.length;
        while (len--)
          args[len] = arguments[len];
        args = unpack(args, "oklch");
        if (type$7(args) === "array" && args.length === 3) {
          return "oklch";
        }
      }
    });
    var Color$m = Color_1;
    var type$6 = utils2.type;
    Color$m.prototype.alpha = function(a2, mutate) {
      if (mutate === void 0)
        mutate = false;
      if (a2 !== void 0 && type$6(a2) === "number") {
        if (mutate) {
          this._rgb[3] = a2;
          return this;
        }
        return new Color$m([this._rgb[0], this._rgb[1], this._rgb[2], a2], "rgb");
      }
      return this._rgb[3];
    };
    var Color$l = Color_1;
    Color$l.prototype.clipped = function() {
      return this._rgb._clipped || false;
    };
    var Color$k = Color_1;
    var LAB_CONSTANTS$1 = labConstants;
    Color$k.prototype.darken = function(amount) {
      if (amount === void 0)
        amount = 1;
      var me2 = this;
      var lab2 = me2.lab();
      lab2[0] -= LAB_CONSTANTS$1.Kn * amount;
      return new Color$k(lab2, "lab").alpha(me2.alpha(), true);
    };
    Color$k.prototype.brighten = function(amount) {
      if (amount === void 0)
        amount = 1;
      return this.darken(-amount);
    };
    Color$k.prototype.darker = Color$k.prototype.darken;
    Color$k.prototype.brighter = Color$k.prototype.brighten;
    var Color$j = Color_1;
    Color$j.prototype.get = function(mc2) {
      var ref = mc2.split(".");
      var mode = ref[0];
      var channel3 = ref[1];
      var src = this[mode]();
      if (channel3) {
        var i2 = mode.indexOf(channel3) - (mode.substr(0, 2) === "ok" ? 2 : 0);
        if (i2 > -1) {
          return src[i2];
        }
        throw new Error("unknown channel " + channel3 + " in mode " + mode);
      } else {
        return src;
      }
    };
    var Color$i = Color_1;
    var type$5 = utils2.type;
    var pow$6 = Math.pow;
    var EPS2 = 1e-7;
    var MAX_ITER = 20;
    Color$i.prototype.luminance = function(lum) {
      if (lum !== void 0 && type$5(lum) === "number") {
        if (lum === 0) {
          return new Color$i([0, 0, 0, this._rgb[3]], "rgb");
        }
        if (lum === 1) {
          return new Color$i([255, 255, 255, this._rgb[3]], "rgb");
        }
        var cur_lum = this.luminance();
        var mode = "rgb";
        var max_iter = MAX_ITER;
        var test3 = function(low, high) {
          var mid = low.interpolate(high, 0.5, mode);
          var lm = mid.luminance();
          if (Math.abs(lum - lm) < EPS2 || !max_iter--) {
            return mid;
          }
          return lm > lum ? test3(low, mid) : test3(mid, high);
        };
        var rgb3 = (cur_lum > lum ? test3(new Color$i([0, 0, 0]), this) : test3(this, new Color$i([255, 255, 255]))).rgb();
        return new Color$i(rgb3.concat([this._rgb[3]]));
      }
      return rgb2luminance.apply(void 0, this._rgb.slice(0, 3));
    };
    var rgb2luminance = function(r2, g2, b2) {
      r2 = luminance_x(r2);
      g2 = luminance_x(g2);
      b2 = luminance_x(b2);
      return 0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2;
    };
    var luminance_x = function(x2) {
      x2 /= 255;
      return x2 <= 0.03928 ? x2 / 12.92 : pow$6((x2 + 0.055) / 1.055, 2.4);
    };
    var interpolator$1 = {};
    var Color$h = Color_1;
    var type$4 = utils2.type;
    var interpolator = interpolator$1;
    var mix$1 = function(col1, col2, f2) {
      if (f2 === void 0)
        f2 = 0.5;
      var rest = [], len = arguments.length - 3;
      while (len-- > 0)
        rest[len] = arguments[len + 3];
      var mode = rest[0] || "lrgb";
      if (!interpolator[mode] && !rest.length) {
        mode = Object.keys(interpolator)[0];
      }
      if (!interpolator[mode]) {
        throw new Error("interpolation mode " + mode + " is not defined");
      }
      if (type$4(col1) !== "object") {
        col1 = new Color$h(col1);
      }
      if (type$4(col2) !== "object") {
        col2 = new Color$h(col2);
      }
      return interpolator[mode](col1, col2, f2).alpha(col1.alpha() + f2 * (col2.alpha() - col1.alpha()));
    };
    var Color$g = Color_1;
    var mix = mix$1;
    Color$g.prototype.mix = Color$g.prototype.interpolate = function(col2, f2) {
      if (f2 === void 0)
        f2 = 0.5;
      var rest = [], len = arguments.length - 2;
      while (len-- > 0)
        rest[len] = arguments[len + 2];
      return mix.apply(void 0, [this, col2, f2].concat(rest));
    };
    var Color$f = Color_1;
    Color$f.prototype.premultiply = function(mutate) {
      if (mutate === void 0)
        mutate = false;
      var rgb3 = this._rgb;
      var a2 = rgb3[3];
      if (mutate) {
        this._rgb = [rgb3[0] * a2, rgb3[1] * a2, rgb3[2] * a2, a2];
        return this;
      } else {
        return new Color$f([rgb3[0] * a2, rgb3[1] * a2, rgb3[2] * a2, a2], "rgb");
      }
    };
    var Color$e = Color_1;
    var LAB_CONSTANTS = labConstants;
    Color$e.prototype.saturate = function(amount) {
      if (amount === void 0)
        amount = 1;
      var me2 = this;
      var lch2 = me2.lch();
      lch2[1] += LAB_CONSTANTS.Kn * amount;
      if (lch2[1] < 0) {
        lch2[1] = 0;
      }
      return new Color$e(lch2, "lch").alpha(me2.alpha(), true);
    };
    Color$e.prototype.desaturate = function(amount) {
      if (amount === void 0)
        amount = 1;
      return this.saturate(-amount);
    };
    var Color$d = Color_1;
    var type$3 = utils2.type;
    Color$d.prototype.set = function(mc2, value, mutate) {
      if (mutate === void 0)
        mutate = false;
      var ref = mc2.split(".");
      var mode = ref[0];
      var channel3 = ref[1];
      var src = this[mode]();
      if (channel3) {
        var i2 = mode.indexOf(channel3) - (mode.substr(0, 2) === "ok" ? 2 : 0);
        if (i2 > -1) {
          if (type$3(value) == "string") {
            switch (value.charAt(0)) {
              case "+":
                src[i2] += +value;
                break;
              case "-":
                src[i2] += +value;
                break;
              case "*":
                src[i2] *= +value.substr(1);
                break;
              case "/":
                src[i2] /= +value.substr(1);
                break;
              default:
                src[i2] = +value;
            }
          } else if (type$3(value) === "number") {
            src[i2] = value;
          } else {
            throw new Error("unsupported value for Color.set");
          }
          var out = new Color$d(src, mode);
          if (mutate) {
            this._rgb = out._rgb;
            return this;
          }
          return out;
        }
        throw new Error("unknown channel " + channel3 + " in mode " + mode);
      } else {
        return src;
      }
    };
    var Color$c = Color_1;
    var rgb2 = function(col1, col2, f2) {
      var xyz0 = col1._rgb;
      var xyz1 = col2._rgb;
      return new Color$c(
        xyz0[0] + f2 * (xyz1[0] - xyz0[0]),
        xyz0[1] + f2 * (xyz1[1] - xyz0[1]),
        xyz0[2] + f2 * (xyz1[2] - xyz0[2]),
        "rgb"
      );
    };
    interpolator$1.rgb = rgb2;
    var Color$b = Color_1;
    var sqrt$2 = Math.sqrt;
    var pow$5 = Math.pow;
    var lrgb = function(col1, col2, f2) {
      var ref = col1._rgb;
      var x1 = ref[0];
      var y1 = ref[1];
      var z1 = ref[2];
      var ref$1 = col2._rgb;
      var x2 = ref$1[0];
      var y2 = ref$1[1];
      var z2 = ref$1[2];
      return new Color$b(
        sqrt$2(pow$5(x1, 2) * (1 - f2) + pow$5(x2, 2) * f2),
        sqrt$2(pow$5(y1, 2) * (1 - f2) + pow$5(y2, 2) * f2),
        sqrt$2(pow$5(z1, 2) * (1 - f2) + pow$5(z2, 2) * f2),
        "rgb"
      );
    };
    interpolator$1.lrgb = lrgb;
    var Color$a = Color_1;
    var lab = function(col1, col2, f2) {
      var xyz0 = col1.lab();
      var xyz1 = col2.lab();
      return new Color$a(
        xyz0[0] + f2 * (xyz1[0] - xyz0[0]),
        xyz0[1] + f2 * (xyz1[1] - xyz0[1]),
        xyz0[2] + f2 * (xyz1[2] - xyz0[2]),
        "lab"
      );
    };
    interpolator$1.lab = lab;
    var Color$9 = Color_1;
    var _hsx = function(col1, col2, f2, m2) {
      var assign, assign$1;
      var xyz0, xyz1;
      if (m2 === "hsl") {
        xyz0 = col1.hsl();
        xyz1 = col2.hsl();
      } else if (m2 === "hsv") {
        xyz0 = col1.hsv();
        xyz1 = col2.hsv();
      } else if (m2 === "hcg") {
        xyz0 = col1.hcg();
        xyz1 = col2.hcg();
      } else if (m2 === "hsi") {
        xyz0 = col1.hsi();
        xyz1 = col2.hsi();
      } else if (m2 === "lch" || m2 === "hcl") {
        m2 = "hcl";
        xyz0 = col1.hcl();
        xyz1 = col2.hcl();
      } else if (m2 === "oklch") {
        xyz0 = col1.oklch().reverse();
        xyz1 = col2.oklch().reverse();
      }
      var hue0, hue1, sat0, sat1, lbv0, lbv1;
      if (m2.substr(0, 1) === "h" || m2 === "oklch") {
        assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2];
        assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2];
      }
      var sat, hue, lbv, dh2;
      if (!isNaN(hue0) && !isNaN(hue1)) {
        if (hue1 > hue0 && hue1 - hue0 > 180) {
          dh2 = hue1 - (hue0 + 360);
        } else if (hue1 < hue0 && hue0 - hue1 > 180) {
          dh2 = hue1 + 360 - hue0;
        } else {
          dh2 = hue1 - hue0;
        }
        hue = hue0 + f2 * dh2;
      } else if (!isNaN(hue0)) {
        hue = hue0;
        if ((lbv1 == 1 || lbv1 == 0) && m2 != "hsv") {
          sat = sat0;
        }
      } else if (!isNaN(hue1)) {
        hue = hue1;
        if ((lbv0 == 1 || lbv0 == 0) && m2 != "hsv") {
          sat = sat1;
        }
      } else {
        hue = Number.NaN;
      }
      if (sat === void 0) {
        sat = sat0 + f2 * (sat1 - sat0);
      }
      lbv = lbv0 + f2 * (lbv1 - lbv0);
      return m2 === "oklch" ? new Color$9([lbv, sat, hue], m2) : new Color$9([hue, sat, lbv], m2);
    };
    var interpolate_hsx$5 = _hsx;
    var lch = function(col1, col2, f2) {
      return interpolate_hsx$5(col1, col2, f2, "lch");
    };
    interpolator$1.lch = lch;
    interpolator$1.hcl = lch;
    var Color$8 = Color_1;
    var num = function(col1, col2, f2) {
      var c1 = col1.num();
      var c2 = col2.num();
      return new Color$8(c1 + f2 * (c2 - c1), "num");
    };
    interpolator$1.num = num;
    var interpolate_hsx$4 = _hsx;
    var hcg = function(col1, col2, f2) {
      return interpolate_hsx$4(col1, col2, f2, "hcg");
    };
    interpolator$1.hcg = hcg;
    var interpolate_hsx$3 = _hsx;
    var hsi = function(col1, col2, f2) {
      return interpolate_hsx$3(col1, col2, f2, "hsi");
    };
    interpolator$1.hsi = hsi;
    var interpolate_hsx$2 = _hsx;
    var hsl2 = function(col1, col2, f2) {
      return interpolate_hsx$2(col1, col2, f2, "hsl");
    };
    interpolator$1.hsl = hsl2;
    var interpolate_hsx$1 = _hsx;
    var hsv = function(col1, col2, f2) {
      return interpolate_hsx$1(col1, col2, f2, "hsv");
    };
    interpolator$1.hsv = hsv;
    var Color$7 = Color_1;
    var oklab = function(col1, col2, f2) {
      var xyz0 = col1.oklab();
      var xyz1 = col2.oklab();
      return new Color$7(
        xyz0[0] + f2 * (xyz1[0] - xyz0[0]),
        xyz0[1] + f2 * (xyz1[1] - xyz0[1]),
        xyz0[2] + f2 * (xyz1[2] - xyz0[2]),
        "oklab"
      );
    };
    interpolator$1.oklab = oklab;
    var interpolate_hsx = _hsx;
    var oklch = function(col1, col2, f2) {
      return interpolate_hsx(col1, col2, f2, "oklch");
    };
    interpolator$1.oklch = oklch;
    var Color$6 = Color_1;
    var clip_rgb$1 = utils2.clip_rgb;
    var pow$4 = Math.pow;
    var sqrt$12 = Math.sqrt;
    var PI$1 = Math.PI;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var atan2$1 = Math.atan2;
    var average = function(colors, mode, weights) {
      if (mode === void 0)
        mode = "lrgb";
      if (weights === void 0)
        weights = null;
      var l2 = colors.length;
      if (!weights) {
        weights = Array.from(new Array(l2)).map(function() {
          return 1;
        });
      }
      var k2 = l2 / weights.reduce(function(a2, b2) {
        return a2 + b2;
      });
      weights.forEach(function(w2, i3) {
        weights[i3] *= k2;
      });
      colors = colors.map(function(c2) {
        return new Color$6(c2);
      });
      if (mode === "lrgb") {
        return _average_lrgb(colors, weights);
      }
      var first = colors.shift();
      var xyz = first.get(mode);
      var cnt = [];
      var dx = 0;
      var dy = 0;
      for (var i2 = 0; i2 < xyz.length; i2++) {
        xyz[i2] = (xyz[i2] || 0) * weights[0];
        cnt.push(isNaN(xyz[i2]) ? 0 : weights[0]);
        if (mode.charAt(i2) === "h" && !isNaN(xyz[i2])) {
          var A2 = xyz[i2] / 180 * PI$1;
          dx += cos$2(A2) * weights[0];
          dy += sin$2(A2) * weights[0];
        }
      }
      var alpha3 = first.alpha() * weights[0];
      colors.forEach(function(c2, ci2) {
        var xyz2 = c2.get(mode);
        alpha3 += c2.alpha() * weights[ci2 + 1];
        for (var i3 = 0; i3 < xyz.length; i3++) {
          if (!isNaN(xyz2[i3])) {
            cnt[i3] += weights[ci2 + 1];
            if (mode.charAt(i3) === "h") {
              var A3 = xyz2[i3] / 180 * PI$1;
              dx += cos$2(A3) * weights[ci2 + 1];
              dy += sin$2(A3) * weights[ci2 + 1];
            } else {
              xyz[i3] += xyz2[i3] * weights[ci2 + 1];
            }
          }
        }
      });
      for (var i$12 = 0; i$12 < xyz.length; i$12++) {
        if (mode.charAt(i$12) === "h") {
          var A$12 = atan2$1(dy / cnt[i$12], dx / cnt[i$12]) / PI$1 * 180;
          while (A$12 < 0) {
            A$12 += 360;
          }
          while (A$12 >= 360) {
            A$12 -= 360;
          }
          xyz[i$12] = A$12;
        } else {
          xyz[i$12] = xyz[i$12] / cnt[i$12];
        }
      }
      alpha3 /= l2;
      return new Color$6(xyz, mode).alpha(alpha3 > 0.99999 ? 1 : alpha3, true);
    };
    var _average_lrgb = function(colors, weights) {
      var l2 = colors.length;
      var xyz = [0, 0, 0, 0];
      for (var i2 = 0; i2 < colors.length; i2++) {
        var col = colors[i2];
        var f2 = weights[i2] / l2;
        var rgb3 = col._rgb;
        xyz[0] += pow$4(rgb3[0], 2) * f2;
        xyz[1] += pow$4(rgb3[1], 2) * f2;
        xyz[2] += pow$4(rgb3[2], 2) * f2;
        xyz[3] += rgb3[3] * f2;
      }
      xyz[0] = sqrt$12(xyz[0]);
      xyz[1] = sqrt$12(xyz[1]);
      xyz[2] = sqrt$12(xyz[2]);
      if (xyz[3] > 0.9999999) {
        xyz[3] = 1;
      }
      return new Color$6(clip_rgb$1(xyz));
    };
    var chroma$4 = chroma_1;
    var type$2 = utils2.type;
    var pow$3 = Math.pow;
    var scale$2 = function(colors) {
      var _mode = "rgb";
      var _nacol = chroma$4("#ccc");
      var _spread = 0;
      var _domain = [0, 1];
      var _pos = [];
      var _padding = [0, 0];
      var _classes = false;
      var _colors = [];
      var _out = false;
      var _min2 = 0;
      var _max2 = 1;
      var _correctLightness = false;
      var _colorCache = {};
      var _useCache = true;
      var _gamma = 1;
      var setColors = function(colors2) {
        colors2 = colors2 || ["#fff", "#000"];
        if (colors2 && type$2(colors2) === "string" && chroma$4.brewer && chroma$4.brewer[colors2.toLowerCase()]) {
          colors2 = chroma$4.brewer[colors2.toLowerCase()];
        }
        if (type$2(colors2) === "array") {
          if (colors2.length === 1) {
            colors2 = [colors2[0], colors2[0]];
          }
          colors2 = colors2.slice(0);
          for (var c2 = 0; c2 < colors2.length; c2++) {
            colors2[c2] = chroma$4(colors2[c2]);
          }
          _pos.length = 0;
          for (var c$12 = 0; c$12 < colors2.length; c$12++) {
            _pos.push(c$12 / (colors2.length - 1));
          }
        }
        resetCache();
        return _colors = colors2;
      };
      var getClass = function(value) {
        if (_classes != null) {
          var n2 = _classes.length - 1;
          var i2 = 0;
          while (i2 < n2 && value >= _classes[i2]) {
            i2++;
          }
          return i2 - 1;
        }
        return 0;
      };
      var tMapLightness = function(t2) {
        return t2;
      };
      var tMapDomain = function(t2) {
        return t2;
      };
      var getColor = function(val, bypassMap) {
        var col, t2;
        if (bypassMap == null) {
          bypassMap = false;
        }
        if (isNaN(val) || val === null) {
          return _nacol;
        }
        if (!bypassMap) {
          if (_classes && _classes.length > 2) {
            var c2 = getClass(val);
            t2 = c2 / (_classes.length - 2);
          } else if (_max2 !== _min2) {
            t2 = (val - _min2) / (_max2 - _min2);
          } else {
            t2 = 1;
          }
        } else {
          t2 = val;
        }
        t2 = tMapDomain(t2);
        if (!bypassMap) {
          t2 = tMapLightness(t2);
        }
        if (_gamma !== 1) {
          t2 = pow$3(t2, _gamma);
        }
        t2 = _padding[0] + t2 * (1 - _padding[0] - _padding[1]);
        t2 = Math.min(1, Math.max(0, t2));
        var k2 = Math.floor(t2 * 1e4);
        if (_useCache && _colorCache[k2]) {
          col = _colorCache[k2];
        } else {
          if (type$2(_colors) === "array") {
            for (var i2 = 0; i2 < _pos.length; i2++) {
              var p2 = _pos[i2];
              if (t2 <= p2) {
                col = _colors[i2];
                break;
              }
              if (t2 >= p2 && i2 === _pos.length - 1) {
                col = _colors[i2];
                break;
              }
              if (t2 > p2 && t2 < _pos[i2 + 1]) {
                t2 = (t2 - p2) / (_pos[i2 + 1] - p2);
                col = chroma$4.interpolate(_colors[i2], _colors[i2 + 1], t2, _mode);
                break;
              }
            }
          } else if (type$2(_colors) === "function") {
            col = _colors(t2);
          }
          if (_useCache) {
            _colorCache[k2] = col;
          }
        }
        return col;
      };
      var resetCache = function() {
        return _colorCache = {};
      };
      setColors(colors);
      var f2 = function(v2) {
        var c2 = chroma$4(getColor(v2));
        if (_out && c2[_out]) {
          return c2[_out]();
        } else {
          return c2;
        }
      };
      f2.classes = function(classes2) {
        if (classes2 != null) {
          if (type$2(classes2) === "array") {
            _classes = classes2;
            _domain = [classes2[0], classes2[classes2.length - 1]];
          } else {
            var d2 = chroma$4.analyze(_domain);
            if (classes2 === 0) {
              _classes = [d2.min, d2.max];
            } else {
              _classes = chroma$4.limits(d2, "e", classes2);
            }
          }
          return f2;
        }
        return _classes;
      };
      f2.domain = function(domain) {
        if (!arguments.length) {
          return _domain;
        }
        _min2 = domain[0];
        _max2 = domain[domain.length - 1];
        _pos = [];
        var k2 = _colors.length;
        if (domain.length === k2 && _min2 !== _max2) {
          for (var i2 = 0, list2 = Array.from(domain); i2 < list2.length; i2 += 1) {
            var d2 = list2[i2];
            _pos.push((d2 - _min2) / (_max2 - _min2));
          }
        } else {
          for (var c2 = 0; c2 < k2; c2++) {
            _pos.push(c2 / (k2 - 1));
          }
          if (domain.length > 2) {
            var tOut = domain.map(function(d3, i3) {
              return i3 / (domain.length - 1);
            });
            var tBreaks = domain.map(function(d3) {
              return (d3 - _min2) / (_max2 - _min2);
            });
            if (!tBreaks.every(function(val, i3) {
              return tOut[i3] === val;
            })) {
              tMapDomain = function(t2) {
                if (t2 <= 0 || t2 >= 1) {
                  return t2;
                }
                var i3 = 0;
                while (t2 >= tBreaks[i3 + 1]) {
                  i3++;
                }
                var f3 = (t2 - tBreaks[i3]) / (tBreaks[i3 + 1] - tBreaks[i3]);
                var out = tOut[i3] + f3 * (tOut[i3 + 1] - tOut[i3]);
                return out;
              };
            }
          }
        }
        _domain = [_min2, _max2];
        return f2;
      };
      f2.mode = function(_m) {
        if (!arguments.length) {
          return _mode;
        }
        _mode = _m;
        resetCache();
        return f2;
      };
      f2.range = function(colors2, _pos2) {
        setColors(colors2);
        return f2;
      };
      f2.out = function(_o) {
        _out = _o;
        return f2;
      };
      f2.spread = function(val) {
        if (!arguments.length) {
          return _spread;
        }
        _spread = val;
        return f2;
      };
      f2.correctLightness = function(v2) {
        if (v2 == null) {
          v2 = true;
        }
        _correctLightness = v2;
        resetCache();
        if (_correctLightness) {
          tMapLightness = function(t2) {
            var L0 = getColor(0, true).lab()[0];
            var L1 = getColor(1, true).lab()[0];
            var pol = L0 > L1;
            var L_actual = getColor(t2, true).lab()[0];
            var L_ideal = L0 + (L1 - L0) * t2;
            var L_diff = L_actual - L_ideal;
            var t02 = 0;
            var t12 = 1;
            var max_iter = 20;
            while (Math.abs(L_diff) > 0.01 && max_iter-- > 0) {
              (function() {
                if (pol) {
                  L_diff *= -1;
                }
                if (L_diff < 0) {
                  t02 = t2;
                  t2 += (t12 - t2) * 0.5;
                } else {
                  t12 = t2;
                  t2 += (t02 - t2) * 0.5;
                }
                L_actual = getColor(t2, true).lab()[0];
                return L_diff = L_actual - L_ideal;
              })();
            }
            return t2;
          };
        } else {
          tMapLightness = function(t2) {
            return t2;
          };
        }
        return f2;
      };
      f2.padding = function(p2) {
        if (p2 != null) {
          if (type$2(p2) === "number") {
            p2 = [p2, p2];
          }
          _padding = p2;
          return f2;
        } else {
          return _padding;
        }
      };
      f2.colors = function(numColors, out) {
        if (arguments.length < 2) {
          out = "hex";
        }
        var result = [];
        if (arguments.length === 0) {
          result = _colors.slice(0);
        } else if (numColors === 1) {
          result = [f2(0.5)];
        } else if (numColors > 1) {
          var dm = _domain[0];
          var dd2 = _domain[1] - dm;
          result = __range__(0, numColors, false).map(function(i3) {
            return f2(dm + i3 / (numColors - 1) * dd2);
          });
        } else {
          colors = [];
          var samples = [];
          if (_classes && _classes.length > 2) {
            for (var i2 = 1, end = _classes.length, asc = 1 <= end; asc ? i2 < end : i2 > end; asc ? i2++ : i2--) {
              samples.push((_classes[i2 - 1] + _classes[i2]) * 0.5);
            }
          } else {
            samples = _domain;
          }
          result = samples.map(function(v2) {
            return f2(v2);
          });
        }
        if (chroma$4[out]) {
          result = result.map(function(c2) {
            return c2[out]();
          });
        }
        return result;
      };
      f2.cache = function(c2) {
        if (c2 != null) {
          _useCache = c2;
          return f2;
        } else {
          return _useCache;
        }
      };
      f2.gamma = function(g2) {
        if (g2 != null) {
          _gamma = g2;
          return f2;
        } else {
          return _gamma;
        }
      };
      f2.nodata = function(d2) {
        if (d2 != null) {
          _nacol = chroma$4(d2);
          return f2;
        } else {
          return _nacol;
        }
      };
      return f2;
    };
    function __range__(left, right, inclusive) {
      var range4 = [];
      var ascending2 = left < right;
      var end = !inclusive ? right : ascending2 ? right + 1 : right - 1;
      for (var i2 = left; ascending2 ? i2 < end : i2 > end; ascending2 ? i2++ : i2--) {
        range4.push(i2);
      }
      return range4;
    }
    var Color$5 = Color_1;
    var scale$1 = scale$2;
    var binom_row = function(n2) {
      var row = [1, 1];
      for (var i2 = 1; i2 < n2; i2++) {
        var newrow = [1];
        for (var j2 = 1; j2 <= row.length; j2++) {
          newrow[j2] = (row[j2] || 0) + row[j2 - 1];
        }
        row = newrow;
      }
      return row;
    };
    var bezier = function(colors) {
      var assign, assign$1, assign$2;
      var I2, lab0, lab1, lab2;
      colors = colors.map(function(c2) {
        return new Color$5(c2);
      });
      if (colors.length === 2) {
        assign = colors.map(function(c2) {
          return c2.lab();
        }), lab0 = assign[0], lab1 = assign[1];
        I2 = function(t2) {
          var lab4 = [0, 1, 2].map(function(i2) {
            return lab0[i2] + t2 * (lab1[i2] - lab0[i2]);
          });
          return new Color$5(lab4, "lab");
        };
      } else if (colors.length === 3) {
        assign$1 = colors.map(function(c2) {
          return c2.lab();
        }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2];
        I2 = function(t2) {
          var lab4 = [0, 1, 2].map(function(i2) {
            return (1 - t2) * (1 - t2) * lab0[i2] + 2 * (1 - t2) * t2 * lab1[i2] + t2 * t2 * lab2[i2];
          });
          return new Color$5(lab4, "lab");
        };
      } else if (colors.length === 4) {
        var lab3;
        assign$2 = colors.map(function(c2) {
          return c2.lab();
        }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3];
        I2 = function(t2) {
          var lab4 = [0, 1, 2].map(function(i2) {
            return (1 - t2) * (1 - t2) * (1 - t2) * lab0[i2] + 3 * (1 - t2) * (1 - t2) * t2 * lab1[i2] + 3 * (1 - t2) * t2 * t2 * lab2[i2] + t2 * t2 * t2 * lab3[i2];
          });
          return new Color$5(lab4, "lab");
        };
      } else if (colors.length >= 5) {
        var labs, row, n2;
        labs = colors.map(function(c2) {
          return c2.lab();
        });
        n2 = colors.length - 1;
        row = binom_row(n2);
        I2 = function(t2) {
          var u2 = 1 - t2;
          var lab4 = [0, 1, 2].map(function(i2) {
            return labs.reduce(function(sum2, el2, j2) {
              return sum2 + row[j2] * Math.pow(u2, n2 - j2) * Math.pow(t2, j2) * el2[i2];
            }, 0);
          });
          return new Color$5(lab4, "lab");
        };
      } else {
        throw new RangeError("No point in running bezier with only one color.");
      }
      return I2;
    };
    var bezier_1 = function(colors) {
      var f2 = bezier(colors);
      f2.scale = function() {
        return scale$1(f2);
      };
      return f2;
    };
    var chroma$3 = chroma_1;
    var blend = function(bottom, top, mode) {
      if (!blend[mode]) {
        throw new Error("unknown blend mode " + mode);
      }
      return blend[mode](bottom, top);
    };
    var blend_f = function(f2) {
      return function(bottom, top) {
        var c0 = chroma$3(top).rgb();
        var c1 = chroma$3(bottom).rgb();
        return chroma$3.rgb(f2(c0, c1));
      };
    };
    var each = function(f2) {
      return function(c0, c1) {
        var out = [];
        out[0] = f2(c0[0], c1[0]);
        out[1] = f2(c0[1], c1[1]);
        out[2] = f2(c0[2], c1[2]);
        return out;
      };
    };
    var normal = function(a2) {
      return a2;
    };
    var multiply3 = function(a2, b2) {
      return a2 * b2 / 255;
    };
    var darken = function(a2, b2) {
      return a2 > b2 ? b2 : a2;
    };
    var lighten = function(a2, b2) {
      return a2 > b2 ? a2 : b2;
    };
    var screen = function(a2, b2) {
      return 255 * (1 - (1 - a2 / 255) * (1 - b2 / 255));
    };
    var overlay = function(a2, b2) {
      return b2 < 128 ? 2 * a2 * b2 / 255 : 255 * (1 - 2 * (1 - a2 / 255) * (1 - b2 / 255));
    };
    var burn = function(a2, b2) {
      return 255 * (1 - (1 - b2 / 255) / (a2 / 255));
    };
    var dodge = function(a2, b2) {
      if (a2 === 255) {
        return 255;
      }
      a2 = 255 * (b2 / 255) / (1 - a2 / 255);
      return a2 > 255 ? 255 : a2;
    };
    blend.normal = blend_f(each(normal));
    blend.multiply = blend_f(each(multiply3));
    blend.screen = blend_f(each(screen));
    blend.overlay = blend_f(each(overlay));
    blend.darken = blend_f(each(darken));
    blend.lighten = blend_f(each(lighten));
    blend.dodge = blend_f(each(dodge));
    blend.burn = blend_f(each(burn));
    var blend_1 = blend;
    var type$12 = utils2.type;
    var clip_rgb = utils2.clip_rgb;
    var TWOPI = utils2.TWOPI;
    var pow$2 = Math.pow;
    var sin$1 = Math.sin;
    var cos$1 = Math.cos;
    var chroma$2 = chroma_1;
    var cubehelix = function(start, rotations, hue, gamma2, lightness) {
      if (start === void 0)
        start = 300;
      if (rotations === void 0)
        rotations = -1.5;
      if (hue === void 0)
        hue = 1;
      if (gamma2 === void 0)
        gamma2 = 1;
      if (lightness === void 0)
        lightness = [0, 1];
      var dh2 = 0, dl2;
      if (type$12(lightness) === "array") {
        dl2 = lightness[1] - lightness[0];
      } else {
        dl2 = 0;
        lightness = [lightness, lightness];
      }
      var f2 = function(fract) {
        var a2 = TWOPI * ((start + 120) / 360 + rotations * fract);
        var l2 = pow$2(lightness[0] + dl2 * fract, gamma2);
        var h2 = dh2 !== 0 ? hue[0] + fract * dh2 : hue;
        var amp = h2 * l2 * (1 - l2) / 2;
        var cos_a = cos$1(a2);
        var sin_a = sin$1(a2);
        var r2 = l2 + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
        var g2 = l2 + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
        var b2 = l2 + amp * (1.97294 * cos_a);
        return chroma$2(clip_rgb([r2 * 255, g2 * 255, b2 * 255, 1]));
      };
      f2.start = function(s2) {
        if (s2 == null) {
          return start;
        }
        start = s2;
        return f2;
      };
      f2.rotations = function(r2) {
        if (r2 == null) {
          return rotations;
        }
        rotations = r2;
        return f2;
      };
      f2.gamma = function(g2) {
        if (g2 == null) {
          return gamma2;
        }
        gamma2 = g2;
        return f2;
      };
      f2.hue = function(h2) {
        if (h2 == null) {
          return hue;
        }
        hue = h2;
        if (type$12(hue) === "array") {
          dh2 = hue[1] - hue[0];
          if (dh2 === 0) {
            hue = hue[1];
          }
        } else {
          dh2 = 0;
        }
        return f2;
      };
      f2.lightness = function(h2) {
        if (h2 == null) {
          return lightness;
        }
        if (type$12(h2) === "array") {
          lightness = h2;
          dl2 = h2[1] - h2[0];
        } else {
          lightness = [h2, h2];
          dl2 = 0;
        }
        return f2;
      };
      f2.scale = function() {
        return chroma$2.scale(f2);
      };
      f2.hue(hue);
      return f2;
    };
    var Color$4 = Color_1;
    var digits = "0123456789abcdef";
    var floor$1 = Math.floor;
    var random = Math.random;
    var random_1 = function() {
      var code2 = "#";
      for (var i2 = 0; i2 < 6; i2++) {
        code2 += digits.charAt(floor$1(random() * 16));
      }
      return new Color$4(code2, "hex");
    };
    var type3 = type$p;
    var log2 = Math.log;
    var pow$1 = Math.pow;
    var floor = Math.floor;
    var abs$12 = Math.abs;
    var analyze = function(data2, key2) {
      if (key2 === void 0)
        key2 = null;
      var r2 = {
        min: Number.MAX_VALUE,
        max: Number.MAX_VALUE * -1,
        sum: 0,
        values: [],
        count: 0
      };
      if (type3(data2) === "object") {
        data2 = Object.values(data2);
      }
      data2.forEach(function(val) {
        if (key2 && type3(val) === "object") {
          val = val[key2];
        }
        if (val !== void 0 && val !== null && !isNaN(val)) {
          r2.values.push(val);
          r2.sum += val;
          if (val < r2.min) {
            r2.min = val;
          }
          if (val > r2.max) {
            r2.max = val;
          }
          r2.count += 1;
        }
      });
      r2.domain = [r2.min, r2.max];
      r2.limits = function(mode, num2) {
        return limits(r2, mode, num2);
      };
      return r2;
    };
    var limits = function(data2, mode, num2) {
      if (mode === void 0)
        mode = "equal";
      if (num2 === void 0)
        num2 = 7;
      if (type3(data2) == "array") {
        data2 = analyze(data2);
      }
      var min4 = data2.min;
      var max4 = data2.max;
      var values3 = data2.values.sort(function(a2, b2) {
        return a2 - b2;
      });
      if (num2 === 1) {
        return [min4, max4];
      }
      var limits2 = [];
      if (mode.substr(0, 1) === "c") {
        limits2.push(min4);
        limits2.push(max4);
      }
      if (mode.substr(0, 1) === "e") {
        limits2.push(min4);
        for (var i2 = 1; i2 < num2; i2++) {
          limits2.push(min4 + i2 / num2 * (max4 - min4));
        }
        limits2.push(max4);
      } else if (mode.substr(0, 1) === "l") {
        if (min4 <= 0) {
          throw new Error("Logarithmic scales are only possible for values > 0");
        }
        var min_log = Math.LOG10E * log2(min4);
        var max_log = Math.LOG10E * log2(max4);
        limits2.push(min4);
        for (var i$12 = 1; i$12 < num2; i$12++) {
          limits2.push(pow$1(10, min_log + i$12 / num2 * (max_log - min_log)));
        }
        limits2.push(max4);
      } else if (mode.substr(0, 1) === "q") {
        limits2.push(min4);
        for (var i$2 = 1; i$2 < num2; i$2++) {
          var p2 = (values3.length - 1) * i$2 / num2;
          var pb2 = floor(p2);
          if (pb2 === p2) {
            limits2.push(values3[pb2]);
          } else {
            var pr = p2 - pb2;
            limits2.push(values3[pb2] * (1 - pr) + values3[pb2 + 1] * pr);
          }
        }
        limits2.push(max4);
      } else if (mode.substr(0, 1) === "k") {
        var cluster;
        var n2 = values3.length;
        var assignments = new Array(n2);
        var clusterSizes = new Array(num2);
        var repeat3 = true;
        var nb_iters = 0;
        var centroids = null;
        centroids = [];
        centroids.push(min4);
        for (var i$3 = 1; i$3 < num2; i$3++) {
          centroids.push(min4 + i$3 / num2 * (max4 - min4));
        }
        centroids.push(max4);
        while (repeat3) {
          for (var j2 = 0; j2 < num2; j2++) {
            clusterSizes[j2] = 0;
          }
          for (var i$4 = 0; i$4 < n2; i$4++) {
            var value = values3[i$4];
            var mindist = Number.MAX_VALUE;
            var best = void 0;
            for (var j$1 = 0; j$1 < num2; j$1++) {
              var dist2 = abs$12(centroids[j$1] - value);
              if (dist2 < mindist) {
                mindist = dist2;
                best = j$1;
              }
              clusterSizes[best]++;
              assignments[i$4] = best;
            }
          }
          var newCentroids = new Array(num2);
          for (var j$2 = 0; j$2 < num2; j$2++) {
            newCentroids[j$2] = null;
          }
          for (var i$5 = 0; i$5 < n2; i$5++) {
            cluster = assignments[i$5];
            if (newCentroids[cluster] === null) {
              newCentroids[cluster] = values3[i$5];
            } else {
              newCentroids[cluster] += values3[i$5];
            }
          }
          for (var j$3 = 0; j$3 < num2; j$3++) {
            newCentroids[j$3] *= 1 / clusterSizes[j$3];
          }
          repeat3 = false;
          for (var j$4 = 0; j$4 < num2; j$4++) {
            if (newCentroids[j$4] !== centroids[j$4]) {
              repeat3 = true;
              break;
            }
          }
          centroids = newCentroids;
          nb_iters++;
          if (nb_iters > 200) {
            repeat3 = false;
          }
        }
        var kClusters = {};
        for (var j$5 = 0; j$5 < num2; j$5++) {
          kClusters[j$5] = [];
        }
        for (var i$6 = 0; i$6 < n2; i$6++) {
          cluster = assignments[i$6];
          kClusters[cluster].push(values3[i$6]);
        }
        var tmpKMeansBreaks = [];
        for (var j$6 = 0; j$6 < num2; j$6++) {
          tmpKMeansBreaks.push(kClusters[j$6][0]);
          tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length - 1]);
        }
        tmpKMeansBreaks = tmpKMeansBreaks.sort(function(a2, b2) {
          return a2 - b2;
        });
        limits2.push(tmpKMeansBreaks[0]);
        for (var i$7 = 1; i$7 < tmpKMeansBreaks.length; i$7 += 2) {
          var v2 = tmpKMeansBreaks[i$7];
          if (!isNaN(v2) && limits2.indexOf(v2) === -1) {
            limits2.push(v2);
          }
        }
      }
      return limits2;
    };
    var analyze_1 = { analyze, limits };
    var Color$3 = Color_1;
    var contrast = function(a2, b2) {
      a2 = new Color$3(a2);
      b2 = new Color$3(b2);
      var l1 = a2.luminance();
      var l2 = b2.luminance();
      return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
    };
    var Color$2 = Color_1;
    var sqrt2 = Math.sqrt;
    var pow2 = Math.pow;
    var min3 = Math.min;
    var max3 = Math.max;
    var atan2 = Math.atan2;
    var abs2 = Math.abs;
    var cos2 = Math.cos;
    var sin2 = Math.sin;
    var exp2 = Math.exp;
    var PI = Math.PI;
    var deltaE = function(a2, b2, Kl, Kc2, Kh2) {
      if (Kl === void 0)
        Kl = 1;
      if (Kc2 === void 0)
        Kc2 = 1;
      if (Kh2 === void 0)
        Kh2 = 1;
      var rad2deg = function(rad) {
        return 360 * rad / (2 * PI);
      };
      var deg2rad = function(deg) {
        return 2 * PI * deg / 360;
      };
      a2 = new Color$2(a2);
      b2 = new Color$2(b2);
      var ref = Array.from(a2.lab());
      var L1 = ref[0];
      var a1 = ref[1];
      var b1 = ref[2];
      var ref$1 = Array.from(b2.lab());
      var L2 = ref$1[0];
      var a22 = ref$1[1];
      var b22 = ref$1[2];
      var avgL = (L1 + L2) / 2;
      var C1 = sqrt2(pow2(a1, 2) + pow2(b1, 2));
      var C2 = sqrt2(pow2(a22, 2) + pow2(b22, 2));
      var avgC = (C1 + C2) / 2;
      var G2 = 0.5 * (1 - sqrt2(pow2(avgC, 7) / (pow2(avgC, 7) + pow2(25, 7))));
      var a1p = a1 * (1 + G2);
      var a2p = a22 * (1 + G2);
      var C1p = sqrt2(pow2(a1p, 2) + pow2(b1, 2));
      var C2p = sqrt2(pow2(a2p, 2) + pow2(b22, 2));
      var avgCp = (C1p + C2p) / 2;
      var arctan1 = rad2deg(atan2(b1, a1p));
      var arctan2 = rad2deg(atan2(b22, a2p));
      var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
      var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
      var avgHp = abs2(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;
      var T2 = 1 - 0.17 * cos2(deg2rad(avgHp - 30)) + 0.24 * cos2(deg2rad(2 * avgHp)) + 0.32 * cos2(deg2rad(3 * avgHp + 6)) - 0.2 * cos2(deg2rad(4 * avgHp - 63));
      var deltaHp = h2p - h1p;
      deltaHp = abs2(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
      deltaHp = 2 * sqrt2(C1p * C2p) * sin2(deg2rad(deltaHp) / 2);
      var deltaL = L2 - L1;
      var deltaCp = C2p - C1p;
      var sl2 = 1 + 0.015 * pow2(avgL - 50, 2) / sqrt2(20 + pow2(avgL - 50, 2));
      var sc2 = 1 + 0.045 * avgCp;
      var sh2 = 1 + 0.015 * avgCp * T2;
      var deltaTheta = 30 * exp2(-pow2((avgHp - 275) / 25, 2));
      var Rc2 = 2 * sqrt2(pow2(avgCp, 7) / (pow2(avgCp, 7) + pow2(25, 7)));
      var Rt2 = -Rc2 * sin2(2 * deg2rad(deltaTheta));
      var result = sqrt2(pow2(deltaL / (Kl * sl2), 2) + pow2(deltaCp / (Kc2 * sc2), 2) + pow2(deltaHp / (Kh2 * sh2), 2) + Rt2 * (deltaCp / (Kc2 * sc2)) * (deltaHp / (Kh2 * sh2)));
      return max3(0, min3(100, result));
    };
    var Color$1 = Color_1;
    var distance = function(a2, b2, mode) {
      if (mode === void 0)
        mode = "lab";
      a2 = new Color$1(a2);
      b2 = new Color$1(b2);
      var l1 = a2.get(mode);
      var l2 = b2.get(mode);
      var sum_sq = 0;
      for (var i2 in l1) {
        var d2 = (l1[i2] || 0) - (l2[i2] || 0);
        sum_sq += d2 * d2;
      }
      return Math.sqrt(sum_sq);
    };
    var Color2 = Color_1;
    var valid = function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      try {
        new (Function.prototype.bind.apply(Color2, [null].concat(args)))();
        return true;
      } catch (e3) {
        return false;
      }
    };
    var chroma$12 = chroma_1;
    var scale = scale$2;
    var scales = {
      cool: function cool() {
        return scale([chroma$12.hsl(180, 1, 0.9), chroma$12.hsl(250, 0.7, 0.4)]);
      },
      hot: function hot() {
        return scale(["#000", "#f00", "#ff0", "#fff"]).mode("rgb");
      }
    };
    var colorbrewer = {
      // sequential
      OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
      PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
      BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
      Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
      BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
      YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
      YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
      Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
      RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
      Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
      YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
      Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
      GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
      Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
      YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
      PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
      Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
      PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
      Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
      // diverging
      Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
      RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
      RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
      PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
      PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
      RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
      BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
      RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
      PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
      // qualitative
      Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
      Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
      Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
      Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
      Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
      Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
      Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
      Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
    };
    for (var i = 0, list = Object.keys(colorbrewer); i < list.length; i += 1) {
      var key = list[i];
      colorbrewer[key.toLowerCase()] = colorbrewer[key];
    }
    var colorbrewer_1 = colorbrewer;
    var chroma2 = chroma_1;
    chroma2.average = average;
    chroma2.bezier = bezier_1;
    chroma2.blend = blend_1;
    chroma2.cubehelix = cubehelix;
    chroma2.mix = chroma2.interpolate = mix$1;
    chroma2.random = random_1;
    chroma2.scale = scale$2;
    chroma2.analyze = analyze_1.analyze;
    chroma2.contrast = contrast;
    chroma2.deltaE = deltaE;
    chroma2.distance = distance;
    chroma2.limits = analyze_1.limits;
    chroma2.valid = valid;
    chroma2.scales = scales;
    chroma2.colors = w3cx11_1;
    chroma2.brewer = colorbrewer_1;
    var chroma_js = chroma2;
    return chroma_js;
  });
})(chroma$1);
var chromaExports = chroma$1.exports;
const chroma = /* @__PURE__ */ getDefaultExportFromCjs(chromaExports);
var __extends$1 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __2() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__2.prototype = b2.prototype, new __2());
  };
}();
var __values = globalThis && globalThis.__values || function(o3) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o3[s2], i = 0;
  if (m2)
    return m2.call(o3);
  if (o3 && typeof o3.length === "number")
    return {
      next: function() {
        if (o3 && i >= o3.length)
          o3 = void 0;
        return { value: o3 && o3[i++], done: !o3 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = globalThis && globalThis.__read || function(o3, n2) {
  var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m2)
    return o3;
  var i = m2.call(o3), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar;
};
var __spreadArray = globalThis && globalThis.__spreadArray || function(to2, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to2.concat(ar || Array.prototype.slice.call(from2));
};
var EventSourceNotAvailableError = (
  /** @class */
  function(_super) {
    __extends$1(EventSourceNotAvailableError2, _super);
    function EventSourceNotAvailableError2() {
      return _super.call(this, "EventSource not available.\nConsider loading an EventSource polyfill and making it available globally as EventSource, or passing one in as eventSourceClass to the ReconnectingEventSource constructor.") || this;
    }
    return EventSourceNotAvailableError2;
  }(Error)
);
var ReconnectingEventSource = (
  /** @class */
  function() {
    function ReconnectingEventSource2(url, configuration) {
      var _this = this;
      this.CONNECTING = 0;
      this.OPEN = 1;
      this.CLOSED = 2;
      this._configuration = configuration != null ? Object.assign({}, configuration) : void 0;
      this.withCredentials = false;
      this._eventSource = null;
      this._lastEventId = null;
      this._timer = null;
      this._listeners = {};
      this.url = url.toString();
      this.readyState = this.CONNECTING;
      this.max_retry_time = 3e3;
      this.eventSourceClass = globalThis.EventSource;
      if (this._configuration != null) {
        if (this._configuration.lastEventId) {
          this._lastEventId = this._configuration.lastEventId;
          delete this._configuration["lastEventId"];
        }
        if (this._configuration.max_retry_time) {
          this.max_retry_time = this._configuration.max_retry_time;
          delete this._configuration["max_retry_time"];
        }
        if (this._configuration.eventSourceClass) {
          this.eventSourceClass = this._configuration.eventSourceClass;
          delete this._configuration["eventSourceClass"];
        }
      }
      if (this.eventSourceClass == null || typeof this.eventSourceClass !== "function") {
        throw new EventSourceNotAvailableError();
      }
      this._onevent_wrapped = function(event) {
        _this._onevent(event);
      };
      this._start();
    }
    ReconnectingEventSource2.prototype.dispatchEvent = function(event) {
      throw new Error("Method not implemented.");
    };
    ReconnectingEventSource2.prototype._start = function() {
      var e_1, _a2;
      var _this = this;
      var url = this.url;
      if (this._lastEventId) {
        if (url.indexOf("?") === -1) {
          url += "?";
        } else {
          url += "&";
        }
        url += "lastEventId=" + encodeURIComponent(this._lastEventId);
      }
      this._eventSource = new this.eventSourceClass(url, this._configuration);
      this._eventSource.onopen = function(event) {
        _this._onopen(event);
      };
      this._eventSource.onerror = function(event) {
        _this._onerror(event);
      };
      this._eventSource.onmessage = function(event) {
        _this.onmessage(event);
      };
      try {
        for (var _b = __values(Object.keys(this._listeners)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var type3 = _c.value;
          this._eventSource.addEventListener(type3, this._onevent_wrapped);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    ReconnectingEventSource2.prototype._onopen = function(event) {
      if (this.readyState === 0) {
        this.readyState = 1;
        this.onopen(event);
      }
    };
    ReconnectingEventSource2.prototype._onerror = function(event) {
      var _this = this;
      if (this.readyState === 1) {
        this.readyState = 0;
        this.onerror(event);
      }
      if (this._eventSource) {
        if (this._eventSource.readyState === 2) {
          this._eventSource.close();
          this._eventSource = null;
          var timeout = Math.round(this.max_retry_time * Math.random());
          this._timer = setTimeout(function() {
            return _this._start();
          }, timeout);
        }
      }
    };
    ReconnectingEventSource2.prototype._onevent = function(event) {
      var e_2, _a2;
      if (event instanceof MessageEvent) {
        this._lastEventId = event.lastEventId;
      }
      var listenersForType = this._listeners[event.type];
      if (listenersForType != null) {
        try {
          for (var _b = __values(__spreadArray([], __read(listenersForType), false)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var listener = _c.value;
            listener.call(this, event);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return))
              _a2.call(_b);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (event.type === "message") {
        this.onmessage(event);
      }
    };
    ReconnectingEventSource2.prototype.onopen = function(event) {
    };
    ReconnectingEventSource2.prototype.onerror = function(event) {
    };
    ReconnectingEventSource2.prototype.onmessage = function(event) {
    };
    ReconnectingEventSource2.prototype.close = function() {
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }
      if (this._eventSource) {
        this._eventSource.close();
        this._eventSource = null;
      }
      this.readyState = 2;
    };
    ReconnectingEventSource2.prototype.addEventListener = function(type3, listener, options) {
      if (!(type3 in this._listeners)) {
        this._listeners[type3] = [];
        if (this._eventSource != null) {
          this._eventSource.addEventListener(type3, this._onevent_wrapped);
        }
      }
      var listenersForType = this._listeners[type3];
      if (Array.isArray(listenersForType) && !listenersForType.includes(listener)) {
        listenersForType.push(listener);
      }
    };
    ReconnectingEventSource2.prototype.removeEventListener = function(type3, listener, options) {
      var listenersForType = this._listeners[type3];
      if (listenersForType != null) {
        while (true) {
          var index3 = listenersForType.indexOf(listener);
          if (index3 === -1) {
            break;
          }
          listenersForType.splice(index3, 1);
        }
        if (listenersForType.length <= 0) {
          delete this._listeners[type3];
          if (this._eventSource != null) {
            this._eventSource.removeEventListener(type3, this._onevent_wrapped);
          }
        }
      }
    };
    ReconnectingEventSource2.CONNECTING = 0;
    ReconnectingEventSource2.OPEN = 1;
    ReconnectingEventSource2.CLOSED = 2;
    return ReconnectingEventSource2;
  }()
);
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(redux);
var compose$1 = require$$0.compose;
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0)
    return void 0;
  if (typeof arguments[0] === "object")
    return compose$1;
  return compose$1.apply(null, arguments);
};
var axios$3 = { exports: {} };
var bind$2 = function bind2(fn2, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn2.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString$6 = Object.prototype.toString;
var kindOf = function(cache2) {
  return function(thing) {
    var str = toString$6.call(thing);
    return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
  };
}(/* @__PURE__ */ Object.create(null));
function kindOfTest(type3) {
  type3 = type3.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type3;
  };
}
function isArray$g(val) {
  return Array.isArray(val);
}
function isUndefined$1(val) {
  return typeof val === "undefined";
}
function isBuffer$3(val) {
  return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
function isString$2(val) {
  return typeof val === "string";
}
function isNumber$4(val) {
  return typeof val === "number";
}
function isObject$c(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject$1(val) {
  if (kindOf(val) !== "object") {
    return false;
  }
  var prototype2 = Object.getPrototypeOf(val);
  return prototype2 === null || prototype2 === Object.prototype;
}
var isDate$1 = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
function isFunction$5(val) {
  return toString$6.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$c(val) && isFunction$5(val.pipe);
}
function isFormData(thing) {
  var pattern3 = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString$6.call(thing) === pattern3 || isFunction$5(thing.toString) && thing.toString() === pattern3);
}
var isURLSearchParams = kindOfTest("URLSearchParams");
function trim3(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach2(obj, fn2) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$g(obj)) {
    for (var i = 0, l2 = obj.length; i < l2; i++) {
      fn2.call(null, obj[i], i, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn2.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge$1() {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject$1(result[key]) && isPlainObject$1(val)) {
      result[key] = merge$1(result[key], val);
    } else if (isPlainObject$1(val)) {
      result[key] = merge$1({}, val);
    } else if (isArray$g(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i = 0, l2 = arguments.length; i < l2; i++) {
    forEach2(arguments[i], assignValue);
  }
  return result;
}
function extend$5(a2, b2, thisArg) {
  forEach2(b2, function assignValue(val, key) {
    if (thisArg && typeof val === "function") {
      a2[key] = bind$1(val, thisArg);
    } else {
      a2[key] = val;
    }
  });
  return a2;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
function inherits(constructor, superConstructor, props3, descriptors2) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  props3 && Object.assign(constructor.prototype, props3);
}
function toFlatObject(sourceObj, destObj, filter2) {
  var props3;
  var i;
  var prop3;
  var merged = {};
  destObj = destObj || {};
  do {
    props3 = Object.getOwnPropertyNames(sourceObj);
    i = props3.length;
    while (i-- > 0) {
      prop3 = props3[i];
      if (!merged[prop3]) {
        destObj[prop3] = sourceObj[prop3];
        merged[prop3] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}
function toArray$2(thing) {
  if (!thing)
    return null;
  var i = thing.length;
  if (isUndefined$1(i))
    return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}
var isTypedArray$3 = function(TypedArray) {
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
}(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
var utils$b = {
  isArray: isArray$g,
  isArrayBuffer,
  isBuffer: isBuffer$3,
  isFormData,
  isArrayBufferView,
  isString: isString$2,
  isNumber: isNumber$4,
  isObject: isObject$c,
  isPlainObject: isPlainObject$1,
  isUndefined: isUndefined$1,
  isDate: isDate$1,
  isFile,
  isBlob,
  isFunction: isFunction$5,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach: forEach2,
  merge: merge$1,
  extend: extend$5,
  trim: trim3,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$2,
  isTypedArray: isTypedArray$3,
  isFileList
};
var utils$a = utils$b;
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function buildURL(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$a.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$a.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$a.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$a.forEach(val, function parseValue2(v2) {
        if (utils$a.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$a.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode(key) + "=" + encode(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$9 = utils$b;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach3(fn2) {
  utils$9.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn2(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$8 = utils$b;
var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$8.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};
var utils$7 = utils$b;
function AxiosError$2(message, code2, config2, request2, response) {
  Error.call(this);
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config2 && (this.config = config2);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils$7.inherits(AxiosError$2, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError$2.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED"
  // eslint-disable-next-line func-names
].forEach(function(code2) {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError$2, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError$2.from = function(error, code2, config2, request2, response, customProps) {
  var axiosError = Object.create(prototype);
  utils$7.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  });
  AxiosError$2.call(axiosError, error.message, code2, config2, request2, response);
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_1 = AxiosError$2;
var transitional = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var utils$6 = utils$b;
function toFormData$1(obj, formData) {
  formData = formData || new FormData();
  var stack = [];
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$6.isDate(value)) {
      return value.toISOString();
    }
    if (utils$6.isArrayBuffer(value) || utils$6.isTypedArray(value)) {
      return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function build(data2, parentKey) {
    if (utils$6.isPlainObject(data2) || utils$6.isArray(data2)) {
      if (stack.indexOf(data2) !== -1) {
        throw Error("Circular reference detected in " + parentKey);
      }
      stack.push(data2);
      utils$6.forEach(data2, function each(value, key) {
        if (utils$6.isUndefined(value))
          return;
        var fullKey = parentKey ? parentKey + "." + key : key;
        var arr;
        if (value && !parentKey && typeof value === "object") {
          if (utils$6.endsWith(key, "{}")) {
            value = JSON.stringify(value);
          } else if (utils$6.endsWith(key, "[]") && (arr = utils$6.toArray(value))) {
            arr.forEach(function(el2) {
              !utils$6.isUndefined(el2) && formData.append(fullKey, convertValue(el2));
            });
            return;
          }
        }
        build(value, fullKey);
      });
      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data2));
    }
  }
  build(obj);
  return formData;
}
var toFormData_1 = toFormData$1;
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var AxiosError2 = AxiosError_1;
  settle = function settle2(resolve, reject3, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject3(new AxiosError2(
        "Request failed with status code " + response.status,
        [AxiosError2.ERR_BAD_REQUEST, AxiosError2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  };
  return settle;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var utils2 = utils$b;
  cookies = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path3, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils2.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils2.isString(path3)) {
            cookie.push("path=" + path3);
          }
          if (utils2.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match5 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match5 ? decodeURIComponent(match5[3]) : null;
        },
        remove: function remove3(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove3() {
        }
      };
    }()
  );
  return cookies;
}
var isAbsoluteURL$1 = function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL2 = isAbsoluteURL$1;
var combineURLs2 = combineURLs$1;
var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL2(requestedURL)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
};
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = utils$b;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser2(line) {
      i = line.indexOf(":");
      key = utils2.trim(line.substr(0, i)).toLowerCase();
      val = utils2.trim(line.substr(i + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = utils$b;
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  return isURLSameOrigin;
}
var CanceledError_1;
var hasRequiredCanceledError;
function requireCanceledError() {
  if (hasRequiredCanceledError)
    return CanceledError_1;
  hasRequiredCanceledError = 1;
  var AxiosError2 = AxiosError_1;
  var utils2 = utils$b;
  function CanceledError2(message) {
    AxiosError2.call(this, message == null ? "canceled" : message, AxiosError2.ERR_CANCELED);
    this.name = "CanceledError";
  }
  utils2.inherits(CanceledError2, AxiosError2, {
    __CANCEL__: true
  });
  CanceledError_1 = CanceledError2;
  return CanceledError_1;
}
var parseProtocol;
var hasRequiredParseProtocol;
function requireParseProtocol() {
  if (hasRequiredParseProtocol)
    return parseProtocol;
  hasRequiredParseProtocol = 1;
  parseProtocol = function parseProtocol2(url) {
    var match5 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match5 && match5[1] || "";
  };
  return parseProtocol;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var utils2 = utils$b;
  var settle2 = requireSettle();
  var cookies2 = requireCookies();
  var buildURL3 = buildURL$1;
  var buildFullPath3 = buildFullPath$1;
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var transitionalDefaults2 = transitional;
  var AxiosError2 = AxiosError_1;
  var CanceledError2 = requireCanceledError();
  var parseProtocol2 = requireParseProtocol();
  xhr = function xhrAdapter(config2) {
    return new Promise(function dispatchXhrRequest(resolve, reject3) {
      var requestData = config2.data;
      var requestHeaders = config2.headers;
      var responseType = config2.responseType;
      var onCanceled;
      function done3() {
        if (config2.cancelToken) {
          config2.cancelToken.unsubscribe(onCanceled);
        }
        if (config2.signal) {
          config2.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils2.isFormData(requestData) && utils2.isStandardBrowserEnv()) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config2.auth) {
        var username = config2.auth.username || "";
        var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath3(config2.baseURL, config2.url);
      request2.open(config2.method.toUpperCase(), buildURL3(fullPath, config2.params, config2.paramsSerializer), true);
      request2.timeout = config2.timeout;
      function onloadend() {
        if (!request2) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
        var response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config: config2,
          request: request2
        };
        settle2(function _resolve(value) {
          resolve(value);
          done3();
        }, function _reject(err) {
          reject3(err);
          done3();
        }, response);
        request2 = null;
      }
      if ("onloadend" in request2) {
        request2.onloadend = onloadend;
      } else {
        request2.onreadystatechange = function handleLoad() {
          if (!request2 || request2.readyState !== 4) {
            return;
          }
          if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject3(new AxiosError2("Request aborted", AxiosError2.ECONNABORTED, config2, request2));
        request2 = null;
      };
      request2.onerror = function handleError() {
        reject3(new AxiosError2("Network Error", AxiosError2.ERR_NETWORK, config2, request2, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        var transitional3 = config2.transitional || transitionalDefaults2;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject3(new AxiosError2(
          timeoutErrorMessage,
          transitional3.clarifyTimeoutError ? AxiosError2.ETIMEDOUT : AxiosError2.ECONNABORTED,
          config2,
          request2
        ));
        request2 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config2.withCredentials || isURLSameOrigin2(fullPath)) && config2.xsrfCookieName ? cookies2.read(config2.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config2.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request2.setRequestHeader(key, val);
          }
        });
      }
      if (!utils2.isUndefined(config2.withCredentials)) {
        request2.withCredentials = !!config2.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request2.responseType = config2.responseType;
      }
      if (typeof config2.onDownloadProgress === "function") {
        request2.addEventListener("progress", config2.onDownloadProgress);
      }
      if (typeof config2.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config2.onUploadProgress);
      }
      if (config2.cancelToken || config2.signal) {
        onCanceled = function(cancel2) {
          if (!request2) {
            return;
          }
          reject3(!cancel2 || cancel2 && cancel2.type ? new CanceledError2() : cancel2);
          request2.abort();
          request2 = null;
        };
        config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
        if (config2.signal) {
          config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      var protocol = parseProtocol2(fullPath);
      if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
        reject3(new AxiosError2("Unsupported protocol " + protocol + ":", AxiosError2.ERR_BAD_REQUEST, config2));
        return;
      }
      request2.send(requestData);
    });
  };
  return xhr;
}
var _null;
var hasRequired_null;
function require_null() {
  if (hasRequired_null)
    return _null;
  hasRequired_null = 1;
  _null = null;
  return _null;
}
var utils$5 = utils$b;
var normalizeHeaderName2 = normalizeHeaderName$1;
var AxiosError$1 = AxiosError_1;
var transitionalDefaults = transitional;
var toFormData = toFormData_1;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = requireXhr();
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = requireXhr();
  }
  return adapter;
}
function stringifySafely(rawValue, parser2, encoder) {
  if (utils$5.isString(rawValue)) {
    try {
      (parser2 || JSON.parse)(rawValue);
      return utils$5.trim(rawValue);
    } catch (e3) {
      if (e3.name !== "SyntaxError") {
        throw e3;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$6 = {
  transitional: transitionalDefaults,
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName2(headers, "Accept");
    normalizeHeaderName2(headers, "Content-Type");
    if (utils$5.isFormData(data2) || utils$5.isArrayBuffer(data2) || utils$5.isBuffer(data2) || utils$5.isStream(data2) || utils$5.isFile(data2) || utils$5.isBlob(data2)) {
      return data2;
    }
    if (utils$5.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$5.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    var isObjectPayload = utils$5.isObject(data2);
    var contentType = headers && headers["Content-Type"];
    var isFileList2;
    if ((isFileList2 = utils$5.isFileList(data2)) || isObjectPayload && contentType === "multipart/form-data") {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList2 ? { "files[]": data2 } : data2, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional3 = this.transitional || defaults$6.transitional;
    var silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
    var forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e3) {
        if (strictJSONParsing) {
          if (e3.name === "SyntaxError") {
            throw AxiosError$1.from(e3, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e3;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: require_null()
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$6.headers[method] = {};
});
utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$6.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$6;
var utils$4 = utils$b;
var defaults$5 = defaults_1;
var transformData$1 = function transformData(data2, headers, fns) {
  var context2 = this || defaults$5;
  utils$4.forEach(fns, function transform(fn2) {
    data2 = fn2.call(context2, data2, headers);
  });
  return data2;
};
var isCancel$1;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel)
    return isCancel$1;
  hasRequiredIsCancel = 1;
  isCancel$1 = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel$1;
}
var utils$3 = utils$b;
var transformData2 = transformData$1;
var isCancel = requireIsCancel();
var defaults$4 = defaults_1;
var CanceledError = requireCanceledError();
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError();
  }
}
var dispatchRequest$1 = function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData2.call(
    config2,
    config2.data,
    config2.headers,
    config2.transformRequest
  );
  config2.headers = utils$3.merge(
    config2.headers.common || {},
    config2.headers[config2.method] || {},
    config2.headers
  );
  utils$3.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config2.headers[method];
    }
  );
  var adapter = config2.adapter || defaults$4.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData2.call(
      config2,
      response.data,
      response.headers,
      config2.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(
          config2,
          reason.response.data,
          reason.response.headers,
          config2.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$2 = utils$b;
var mergeConfig$2 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  function getMergedValue(target, source) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
      return utils$2.merge(target, source);
    } else if (utils$2.isPlainObject(source)) {
      return utils$2.merge({}, source);
    } else if (utils$2.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(prop3) {
    if (!utils$2.isUndefined(config2[prop3])) {
      return getMergedValue(config1[prop3], config2[prop3]);
    } else if (!utils$2.isUndefined(config1[prop3])) {
      return getMergedValue(void 0, config1[prop3]);
    }
  }
  function valueFromConfig2(prop3) {
    if (!utils$2.isUndefined(config2[prop3])) {
      return getMergedValue(void 0, config2[prop3]);
    }
  }
  function defaultToConfig2(prop3) {
    if (!utils$2.isUndefined(config2[prop3])) {
      return getMergedValue(void 0, config2[prop3]);
    } else if (!utils$2.isUndefined(config1[prop3])) {
      return getMergedValue(void 0, config1[prop3]);
    }
  }
  function mergeDirectKeys(prop3) {
    if (prop3 in config2) {
      return getMergedValue(config1[prop3], config2[prop3]);
    } else if (prop3 in config1) {
      return getMergedValue(void 0, config1[prop3]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "beforeRedirect": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$2.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop3) {
    var merge3 = mergeMap[prop3] || mergeDeepProperties;
    var configValue = merge3(prop3);
    utils$2.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop3] = configValue);
  });
  return config3;
};
var data;
var hasRequiredData;
function requireData() {
  if (hasRequiredData)
    return data;
  hasRequiredData = 1;
  data = {
    "version": "0.27.2"
  };
  return data;
}
var VERSION = requireData().version;
var AxiosError = AxiosError_1;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type3, i) {
  validators$1[type3] = function validator2(thing) {
    return typeof thing === type3 || "a" + (i < 1 ? "n " : " ") + type3;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional2(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys4 = Object.keys(options);
  var i = keys4.length;
  while (i-- > 0) {
    var opt = keys4[i];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
var validator$1 = {
  assertOptions,
  validators: validators$1
};
var utils$1 = utils$b;
var buildURL2 = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest2 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var buildFullPath2 = buildFullPath$1;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(configOrUrl, config2) {
  if (typeof configOrUrl === "string") {
    config2 = config2 || {};
    config2.url = configOrUrl;
  } else {
    config2 = configOrUrl || {};
  }
  config2 = mergeConfig$1(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var transitional3 = config2.transitional;
  if (transitional3 !== void 0) {
    validator.assertOptions(transitional3, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise3;
  if (!synchronousRequestInterceptors) {
    var chain3 = [dispatchRequest2, void 0];
    Array.prototype.unshift.apply(chain3, requestInterceptorChain);
    chain3 = chain3.concat(responseInterceptorChain);
    promise3 = Promise.resolve(config2);
    while (chain3.length) {
      promise3 = promise3.then(chain3.shift(), chain3.shift());
    }
    return promise3;
  }
  var newConfig = config2;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise3 = dispatchRequest2(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise3 = promise3.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise3;
};
Axios$1.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig$1(this.defaults, config2);
  var fullPath = buildFullPath2(config2.baseURL, config2.url);
  return buildURL2(fullPath, config2.params, config2.paramsSerializer);
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data2, config2) {
      return this.request(mergeConfig$1(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data2
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_1 = Axios$1;
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var CanceledError2 = requireCanceledError();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise2;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise2 = resolve;
    });
    var token2 = this;
    this.promise.then(function(cancel2) {
      if (!token2._listeners)
        return;
      var i;
      var l2 = token2._listeners.length;
      for (i = 0; i < l2; i++) {
        token2._listeners[i](cancel2);
      }
      token2._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise3 = new Promise(function(resolve) {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise3.cancel = function reject3() {
        token2.unsubscribe(_resolve);
      };
      return promise3;
    };
    executor(function cancel2(message) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError2(message);
      resolvePromise2(token2.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index3 = this._listeners.indexOf(listener);
    if (index3 !== -1) {
      this._listeners.splice(index3, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel2;
    var token2 = new CancelToken(function executor(c2) {
      cancel2 = c2;
    });
    return {
      token: token2,
      cancel: cancel2
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread)
    return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  var utils2 = utils$b;
  isAxiosError = function isAxiosError2(payload) {
    return utils2.isObject(payload) && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var utils = utils$b;
var bind3 = bind$2;
var Axios = Axios_1;
var mergeConfig2 = mergeConfig$2;
var defaults$3 = defaults_1;
function createInstance(defaultConfig) {
  var context2 = new Axios(defaultConfig);
  var instance = bind3(Axios.prototype.request, context2);
  utils.extend(instance, Axios.prototype, context2);
  utils.extend(instance, context2);
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig2(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios$2 = createInstance(defaults$3);
axios$2.Axios = Axios;
axios$2.CanceledError = requireCanceledError();
axios$2.CancelToken = requireCancelToken();
axios$2.isCancel = requireIsCancel();
axios$2.VERSION = requireData().version;
axios$2.toFormData = toFormData_1;
axios$2.AxiosError = AxiosError_1;
axios$2.Cancel = axios$2.CanceledError;
axios$2.all = function all3(promises) {
  return Promise.all(promises);
};
axios$2.spread = requireSpread();
axios$2.isAxiosError = requireIsAxiosError();
axios$3.exports = axios$2;
axios$3.exports.default = axios$2;
var axiosExports = axios$3.exports;
var axios = axiosExports;
const axios$1 = /* @__PURE__ */ getDefaultExportFromCjs(axios);
var build_umd = { exports: {} };
(function(module2, exports) {
  (function webpackUniversalModuleDefinition(root2, factory) {
    module2.exports = factory();
  })(commonjsGlobal$2, function() {
    return (
      /******/
      function() {
        var __webpack_modules__ = {
          /***/
          "./packages/@logrocket/console/src/index.js": (
            /*!**************************************************!*\
              !*** ./packages/@logrocket/console/src/index.js ***!
              \**************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = void 0;
              var _registerConsole = _interopRequireDefault2(__webpack_require__2(
                /*! ./registerConsole */
                "./packages/@logrocket/console/src/registerConsole.js"
              ));
              var _default2 = _registerConsole.default;
              exports2["default"] = _default2;
            }
          ),
          /***/
          "./packages/@logrocket/console/src/registerConsole.js": (
            /*!************************************************************!*\
              !*** ./packages/@logrocket/console/src/registerConsole.js ***!
              \************************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = registerConsole;
              var _typeof2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/typeof */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              ));
              var _enhanceFunc = _interopRequireDefault2(__webpack_require__2(
                /*! @logrocket/utils/src/enhanceFunc */
                "./packages/@logrocket/utils/src/enhanceFunc.js"
              ));
              var _exceptions = __webpack_require__2(
                /*! @logrocket/exceptions */
                "./packages/@logrocket/exceptions/src/index.js"
              );
              function registerConsole(logger) {
                var unsubFunctions = [];
                var methods = ["log", "warn", "info", "error", "debug"];
                methods.forEach(function(method) {
                  unsubFunctions.push((0, _enhanceFunc.default)(console, method, function() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }
                    logger.addEvent("lr.core.LogEvent", function() {
                      var consoleOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                      var isEnabled = consoleOptions.isEnabled;
                      if ((0, _typeof2.default)(isEnabled) === "object" && isEnabled[method] === false || isEnabled === false) {
                        return null;
                      }
                      if (method === "error" && consoleOptions.shouldAggregateConsoleErrors) {
                        _exceptions.Capture.captureMessage(logger, args[0], args, {}, true);
                      }
                      return {
                        logLevel: method.toUpperCase(),
                        args
                      };
                    });
                  }));
                });
                return function() {
                  unsubFunctions.forEach(function(unsubFunction) {
                    return unsubFunction();
                  });
                };
              }
            }
          ),
          /***/
          "./packages/@logrocket/exceptions/src/Capture.js": (
            /*!*******************************************************!*\
              !*** ./packages/@logrocket/exceptions/src/Capture.js ***!
              \*******************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.captureMessage = captureMessage;
              exports2.captureException = captureException;
              var _typeof2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/typeof */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              ));
              var _TraceKit = _interopRequireDefault2(__webpack_require__2(
                /*! @logrocket/utils/src/TraceKit */
                "./packages/@logrocket/utils/src/TraceKit.js"
              ));
              var _stackTraceFromError = _interopRequireDefault2(__webpack_require__2(
                /*! ./stackTraceFromError */
                "./packages/@logrocket/exceptions/src/stackTraceFromError.js"
              ));
              function isScalar(value) {
                return /boolean|number|string/.test((0, _typeof2.default)(value));
              }
              function scrub(data2, options) {
                if (options) {
                  var optionalScalars = [
                    // Valid values for 'level' are 'fatal', 'error', 'warning', 'info',
                    // and 'debug'. Defaults to 'error'.
                    "level",
                    "logger"
                  ];
                  for (var _i2 = 0, _optionalScalars = optionalScalars; _i2 < _optionalScalars.length; _i2++) {
                    var field = _optionalScalars[_i2];
                    var value = options[field];
                    if (isScalar(value)) {
                      data2[field] = value.toString();
                    }
                  }
                  var optionalMaps = ["tags", "extra"];
                  for (var _i22 = 0, _optionalMaps = optionalMaps; _i22 < _optionalMaps.length; _i22++) {
                    var _field = _optionalMaps[_i22];
                    var dirty = options[_field] || {};
                    var scrubbed = {};
                    for (var _i3 = 0, _Object$keys = Object.keys(dirty); _i3 < _Object$keys.length; _i3++) {
                      var key = _Object$keys[_i3];
                      var _value = dirty[key];
                      if (isScalar(_value)) {
                        scrubbed[key.toString()] = _value.toString();
                      }
                    }
                    data2[_field] = scrubbed;
                  }
                }
              }
              function captureMessage(logger, message, messageArgs) {
                var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                var isConsole = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                var data2 = {
                  exceptionType: isConsole ? "CONSOLE" : "MESSAGE",
                  message,
                  messageArgs,
                  browserHref: window.location ? window.location.href : ""
                };
                scrub(data2, options);
                logger.addEvent("lr.core.Exception", function() {
                  return data2;
                });
              }
              function captureException(logger, exception) {
                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                var preppedTrace = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                var trace = preppedTrace || _TraceKit.default.computeStackTrace(exception);
                var data2 = {
                  exceptionType: "WINDOW",
                  errorType: trace.name,
                  message: trace.message,
                  browserHref: window.location ? window.location.href : ""
                };
                scrub(data2, options);
                var addEventOptions = {
                  _stackTrace: (0, _stackTraceFromError.default)(trace)
                };
                logger.addEvent("lr.core.Exception", function() {
                  return data2;
                }, addEventOptions);
              }
            }
          ),
          /***/
          "./packages/@logrocket/exceptions/src/index.js": (
            /*!*****************************************************!*\
              !*** ./packages/@logrocket/exceptions/src/index.js ***!
              \*****************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              var _typeof2 = __webpack_require__2(
                /*! @babel/runtime/helpers/typeof */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              Object.defineProperty(exports2, "registerExceptions", {
                enumerable: true,
                get: function get3() {
                  return _registerExceptions.default;
                }
              });
              exports2.Capture = void 0;
              var _registerExceptions = _interopRequireDefault2(__webpack_require__2(
                /*! ./registerExceptions */
                "./packages/@logrocket/exceptions/src/registerExceptions.js"
              ));
              var Capture = _interopRequireWildcard2(__webpack_require__2(
                /*! ./Capture */
                "./packages/@logrocket/exceptions/src/Capture.js"
              ));
              exports2.Capture = Capture;
              function _getRequireWildcardCache(nodeInterop) {
                if (typeof WeakMap !== "function")
                  return null;
                var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
                var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
                return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
                  return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
                })(nodeInterop);
              }
              function _interopRequireWildcard2(obj, nodeInterop) {
                if (!nodeInterop && obj && obj.__esModule) {
                  return obj;
                }
                if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
                  return { default: obj };
                }
                var cache2 = _getRequireWildcardCache(nodeInterop);
                if (cache2 && cache2.has(obj)) {
                  return cache2.get(obj);
                }
                var newObj = {};
                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var key in obj) {
                  if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                    if (desc && (desc.get || desc.set)) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
                newObj.default = obj;
                if (cache2) {
                  cache2.set(obj, newObj);
                }
                return newObj;
              }
            }
          ),
          /***/
          "./packages/@logrocket/exceptions/src/raven/raven.js": (
            /*!***********************************************************!*\
              !*** ./packages/@logrocket/exceptions/src/raven/raven.js ***!
              \***********************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = void 0;
              var _classCallCheck2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/classCallCheck */
                "./node_modules/@babel/runtime/helpers/classCallCheck.js"
              ));
              var _createClass2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/createClass */
                "./node_modules/@babel/runtime/helpers/createClass.js"
              ));
              var _TraceKit = _interopRequireDefault2(__webpack_require__2(
                /*! @logrocket/utils/src/TraceKit */
                "./packages/@logrocket/utils/src/TraceKit.js"
              ));
              var objectPrototype2 = Object.prototype;
              function isUndefined2(what) {
                return what === void 0;
              }
              function isFunction2(what) {
                return typeof what === "function";
              }
              function hasKey(object2, key) {
                return objectPrototype2.hasOwnProperty.call(object2, key);
              }
              function fill(obj, name, replacement, track) {
                var orig = obj[name];
                obj[name] = replacement(orig);
                if (track) {
                  track.push([obj, name, orig]);
                }
              }
              var _window = typeof window !== "undefined" ? window : typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof self !== "undefined" ? self : {};
              _window.document;
              var Handler = /* @__PURE__ */ function() {
                function Handler2(_ref) {
                  var captureException = _ref.captureException;
                  (0, _classCallCheck2.default)(this, Handler2);
                  this._errorHandler = this._errorHandler.bind(this);
                  this._ignoreOnError = 0;
                  this._wrappedBuiltIns = [];
                  this.captureException = captureException;
                  _TraceKit.default.report.subscribe(this._errorHandler);
                  this._instrumentTryCatch();
                }
                (0, _createClass2.default)(Handler2, [{
                  key: "uninstall",
                  value: function uninstall() {
                    _TraceKit.default.report.unsubscribe(this._errorHandler);
                    var builtin;
                    while (this._wrappedBuiltIns.length) {
                      builtin = this._wrappedBuiltIns.shift();
                      var obj = builtin[0], name = builtin[1], orig = builtin[2];
                      obj[name] = orig;
                    }
                  }
                }, {
                  key: "_errorHandler",
                  value: function _errorHandler(report) {
                    if (!this._ignoreOnError) {
                      this.captureException(report);
                    }
                  }
                }, {
                  key: "_ignoreNextOnError",
                  value: function _ignoreNextOnError() {
                    var _this = this;
                    this._ignoreOnError += 1;
                    setTimeout(function() {
                      _this._ignoreOnError -= 1;
                    });
                  }
                  /*
                   * Wrap code within a context so Handler can capture errors
                   * reliably across domains that is executed immediately.
                   *
                   * @param {object} options A specific set of options for this context [optional]
                   * @param {function} func The callback to be immediately executed within the context
                   * @param {array} args An array of arguments to be called with the callback [optional]
                   */
                }, {
                  key: "context",
                  value: function context2(options, func3, args) {
                    if (isFunction2(options)) {
                      args = func3 || [];
                      func3 = options;
                      options = void 0;
                    }
                    return this.wrap(options, func3).apply(this, args);
                  }
                }, {
                  key: "wrap",
                  value: (
                    /*
                     * Wrap code within a context and returns back a new function to be executed
                     *
                     * @param {object} options A specific set of options for this context [optional]
                     * @param {function} func The function to be wrapped in a new context
                     * @param {function} func A function to call before the try/catch wrapper [optional, private]
                     * @return {function} The newly wrapped functions with a context
                     */
                    function wrap(options, func3, _before) {
                      var self2 = this;
                      if (isUndefined2(func3) && !isFunction2(options)) {
                        return options;
                      }
                      if (isFunction2(options)) {
                        func3 = options;
                        options = void 0;
                      }
                      if (!isFunction2(func3)) {
                        return func3;
                      }
                      try {
                        if (func3.__lr__) {
                          return func3;
                        }
                        if (func3.__lr_wrapper__) {
                          return func3.__lr_wrapper__;
                        }
                        if (!Object.isExtensible(func3)) {
                          return func3;
                        }
                      } catch (e3) {
                        return func3;
                      }
                      function wrapped() {
                        var args = [], i = arguments.length, deep = !options || options && options.deep !== false;
                        if (_before && isFunction2(_before)) {
                          _before.apply(this, arguments);
                        }
                        while (i--) {
                          args[i] = deep ? self2.wrap(options, arguments[i]) : arguments[i];
                        }
                        try {
                          return func3.apply(this, args);
                        } catch (e3) {
                          self2._ignoreNextOnError();
                          self2.captureException(_TraceKit.default.computeStackTrace(e3), options);
                          throw e3;
                        }
                      }
                      for (var property2 in func3) {
                        if (hasKey(func3, property2)) {
                          wrapped[property2] = func3[property2];
                        }
                      }
                      wrapped.prototype = func3.prototype;
                      func3.__lr_wrapper__ = wrapped;
                      wrapped.__lr__ = true;
                      wrapped.__inner__ = func3;
                      return wrapped;
                    }
                  )
                }, {
                  key: "_instrumentTryCatch",
                  value: (
                    /**
                     * Install any queued plugins
                     */
                    function _instrumentTryCatch() {
                      var self2 = this;
                      var wrappedBuiltIns = self2._wrappedBuiltIns;
                      function wrapTimeFn(orig) {
                        return function(fn2, t2) {
                          var args = new Array(arguments.length);
                          for (var i2 = 0; i2 < args.length; ++i2) {
                            args[i2] = arguments[i2];
                          }
                          var originalCallback = args[0];
                          if (isFunction2(originalCallback)) {
                            args[0] = self2.wrap(originalCallback);
                          }
                          if (orig.apply) {
                            return orig.apply(this, args);
                          } else {
                            return orig(args[0], args[1]);
                          }
                        };
                      }
                      function wrapEventTarget(global2) {
                        var proto2 = _window[global2] && _window[global2].prototype;
                        if (proto2 && proto2.hasOwnProperty && proto2.hasOwnProperty("addEventListener")) {
                          fill(proto2, "addEventListener", function(orig) {
                            return function(evtName, fn2, capture, secure) {
                              try {
                                if (fn2 && fn2.handleEvent) {
                                  fn2.handleEvent = self2.wrap(fn2.handleEvent);
                                }
                              } catch (err) {
                              }
                              var before;
                              return orig.call(this, evtName, self2.wrap(fn2, void 0, before), capture, secure);
                            };
                          }, wrappedBuiltIns);
                          fill(proto2, "removeEventListener", function(orig) {
                            return function(evt, fn2, capture, secure) {
                              try {
                                fn2 = fn2 && (fn2.__lr_wrapper__ ? fn2.__lr_wrapper__ : fn2);
                              } catch (e3) {
                              }
                              return orig.call(this, evt, fn2, capture, secure);
                            };
                          }, wrappedBuiltIns);
                        }
                      }
                      fill(_window, "setTimeout", wrapTimeFn, wrappedBuiltIns);
                      fill(_window, "setInterval", wrapTimeFn, wrappedBuiltIns);
                      if (_window.requestAnimationFrame) {
                        fill(_window, "requestAnimationFrame", function(orig) {
                          return function(cb2) {
                            return orig(self2.wrap(cb2));
                          };
                        }, wrappedBuiltIns);
                      }
                      var eventTargets = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
                      for (var i = 0; i < eventTargets.length; i++) {
                        wrapEventTarget(eventTargets[i]);
                      }
                      var $2 = _window.jQuery || _window.$;
                      if ($2 && $2.fn && $2.fn.ready) {
                        fill($2.fn, "ready", function(orig) {
                          return function(fn2) {
                            return orig.call(this, self2.wrap(fn2));
                          };
                        }, wrappedBuiltIns);
                      }
                    }
                  )
                }]);
                return Handler2;
              }();
              exports2["default"] = Handler;
            }
          ),
          /***/
          "./packages/@logrocket/exceptions/src/registerExceptions.js": (
            /*!******************************************************************!*\
              !*** ./packages/@logrocket/exceptions/src/registerExceptions.js ***!
              \******************************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              var _typeof2 = __webpack_require__2(
                /*! @babel/runtime/helpers/typeof */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = registerCore;
              var _raven = _interopRequireDefault2(__webpack_require__2(
                /*! ./raven/raven */
                "./packages/@logrocket/exceptions/src/raven/raven.js"
              ));
              var Capture = _interopRequireWildcard2(__webpack_require__2(
                /*! ./Capture */
                "./packages/@logrocket/exceptions/src/Capture.js"
              ));
              function _getRequireWildcardCache(nodeInterop) {
                if (typeof WeakMap !== "function")
                  return null;
                var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
                var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
                return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
                  return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
                })(nodeInterop);
              }
              function _interopRequireWildcard2(obj, nodeInterop) {
                if (!nodeInterop && obj && obj.__esModule) {
                  return obj;
                }
                if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
                  return { default: obj };
                }
                var cache2 = _getRequireWildcardCache(nodeInterop);
                if (cache2 && cache2.has(obj)) {
                  return cache2.get(obj);
                }
                var newObj = {};
                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var key in obj) {
                  if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                    if (desc && (desc.get || desc.set)) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
                newObj.default = obj;
                if (cache2) {
                  cache2.set(obj, newObj);
                }
                return newObj;
              }
              function registerCore(logger) {
                var raven = new _raven.default({
                  captureException: function captureException(errorReport) {
                    Capture.captureException(logger, null, null, errorReport);
                  }
                });
                var rejectionHandler = function rejectionHandler2(evt) {
                  logger.addEvent("lr.core.Exception", function() {
                    return {
                      exceptionType: "UNHANDLED_REJECTION",
                      message: evt.reason || "Unhandled Promise rejection"
                    };
                  });
                };
                window.addEventListener("unhandledrejection", rejectionHandler);
                return function() {
                  window.removeEventListener("unhandledrejection", rejectionHandler);
                  raven.uninstall();
                };
              }
            }
          ),
          /***/
          "./packages/@logrocket/exceptions/src/stackTraceFromError.js": (
            /*!*******************************************************************!*\
              !*** ./packages/@logrocket/exceptions/src/stackTraceFromError.js ***!
              \*******************************************************************/
            /***/
            function(__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = stackTraceFromError;
              function stackTraceFromError(errorReport) {
                function makeNotNull(val) {
                  return val === null ? void 0 : val;
                }
                return errorReport.stack ? errorReport.stack.map(function(frame) {
                  return {
                    lineNumber: makeNotNull(frame.line),
                    columnNumber: makeNotNull(frame.column),
                    fileName: makeNotNull(frame.url),
                    functionName: makeNotNull(frame.func)
                  };
                }) : void 0;
              }
            }
          ),
          /***/
          "./packages/@logrocket/network/src/fetchIntercept.js": (
            /*!***********************************************************!*\
              !*** ./packages/@logrocket/network/src/fetchIntercept.js ***!
              \***********************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = void 0;
              var _toConsumableArray2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/toConsumableArray */
                "./node_modules/@babel/runtime/helpers/toConsumableArray.js"
              ));
              var _registerXHR = __webpack_require__2(
                /*! ./registerXHR */
                "./packages/@logrocket/network/src/registerXHR.js"
              );
              var interceptors = [];
              function makeInterceptor(fetch2, fetchId) {
                var reversedInterceptors = interceptors.reduce(function(array3, interceptor) {
                  return [interceptor].concat(array3);
                }, []);
                for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                  args[_key - 2] = arguments[_key];
                }
                var promise3 = Promise.resolve(args);
                reversedInterceptors.forEach(function(_ref) {
                  var request2 = _ref.request, requestError = _ref.requestError;
                  if (request2 || requestError) {
                    promise3 = promise3.then(function(args2) {
                      return request2.apply(void 0, [fetchId].concat((0, _toConsumableArray2.default)(args2)));
                    }, function(args2) {
                      return requestError.apply(void 0, [fetchId].concat((0, _toConsumableArray2.default)(args2)));
                    });
                  }
                });
                promise3 = promise3.then(function(args2) {
                  (0, _registerXHR.setActive)(false);
                  var res;
                  var err;
                  try {
                    res = fetch2.apply(void 0, (0, _toConsumableArray2.default)(args2));
                  } catch (_err) {
                    err = _err;
                  }
                  (0, _registerXHR.setActive)(true);
                  if (err) {
                    throw err;
                  }
                  return res;
                });
                reversedInterceptors.forEach(function(_ref2) {
                  var response = _ref2.response, responseError = _ref2.responseError;
                  if (response || responseError) {
                    promise3 = promise3.then(function(res) {
                      return response(fetchId, res);
                    }, function(err) {
                      return responseError && responseError(fetchId, err);
                    });
                  }
                });
                return promise3;
              }
              function attach(env) {
                if (!env.fetch || !env.Promise) {
                  return;
                }
                var isPolyfill = env.fetch.polyfill;
                env.fetch = function(fetch2) {
                  var fetchId = 0;
                  return function() {
                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                      args[_key2] = arguments[_key2];
                    }
                    return makeInterceptor.apply(void 0, [fetch2, fetchId++].concat(args));
                  };
                }(env.fetch);
                if (isPolyfill) {
                  env.fetch.polyfill = isPolyfill;
                }
              }
              var didAttach = false;
              var _default2 = {
                register: function register(interceptor) {
                  if (!didAttach) {
                    didAttach = true;
                    attach(window);
                  }
                  interceptors.push(interceptor);
                  return function() {
                    var index3 = interceptors.indexOf(interceptor);
                    if (index3 >= 0) {
                      interceptors.splice(index3, 1);
                    }
                  };
                },
                clear: function clear3() {
                  interceptors = [];
                }
              };
              exports2["default"] = _default2;
            }
          ),
          /***/
          "./packages/@logrocket/network/src/index.js": (
            /*!**************************************************!*\
              !*** ./packages/@logrocket/network/src/index.js ***!
              \**************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = registerNetwork;
              var _defineProperty2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/defineProperty */
                "./node_modules/@babel/runtime/helpers/defineProperty.js"
              ));
              var _typeof2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/typeof */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              ));
              var _registerFetch = _interopRequireDefault2(__webpack_require__2(
                /*! ./registerFetch */
                "./packages/@logrocket/network/src/registerFetch.js"
              ));
              var _registerNetworkInformation = _interopRequireDefault2(__webpack_require__2(
                /*! ./registerNetworkInformation */
                "./packages/@logrocket/network/src/registerNetworkInformation.js"
              ));
              var _registerXHR = _interopRequireDefault2(__webpack_require__2(
                /*! ./registerXHR */
                "./packages/@logrocket/network/src/registerXHR.js"
              ));
              var _mapValues2 = _interopRequireDefault2(__webpack_require__2(
                /*! @logrocket/utils/src/mapValues */
                "./packages/@logrocket/utils/src/mapValues.js"
              ));
              function ownKeys2(object2, enumerableOnly) {
                var keys4 = Object.keys(object2);
                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object2);
                  enumerableOnly && (symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
                  })), keys4.push.apply(keys4, symbols);
                }
                return keys4;
              }
              function _objectSpread3(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = null != arguments[i] ? arguments[i] : {};
                  i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
                    (0, _defineProperty2.default)(target, key, source[key]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
                return target;
              }
              function registerNetwork(logger) {
                var config2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                  isReactNative: false
                };
                var isReactNative = config2.isReactNative, shouldAugmentNPS = config2.shouldAugmentNPS, shouldParseXHRBlob = config2.shouldParseXHRBlob;
                var ignoredNetwork = {};
                var truncate2 = function truncate3(data2) {
                  var limit = 1024 * 1e3 * 4;
                  var str = data2;
                  if ((0, _typeof2.default)(data2) === "object" && data2 != null) {
                    var proto2 = Object.getPrototypeOf(data2);
                    if (proto2 === Object.prototype || proto2 === null) {
                      str = JSON.stringify(data2);
                    }
                  }
                  if (str && str.length && str.length > limit && typeof str === "string") {
                    var beginning = str.substring(0, 1e3);
                    return "".concat(beginning, " ... LogRocket truncating to first 1000 characters.\n      Keep data under 4MB to prevent truncation. https://docs.logrocket.com/reference/network");
                  }
                  return data2;
                };
                var addRequest = function addRequest2(reqId, request2) {
                  var method = request2.method;
                  logger.addEvent("lr.network.RequestEvent", function() {
                    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$isEnabled = _ref.isEnabled, isEnabled = _ref$isEnabled === void 0 ? true : _ref$isEnabled, _ref$requestSanitizer = _ref.requestSanitizer, requestSanitizer = _ref$requestSanitizer === void 0 ? function(f2) {
                      return f2;
                    } : _ref$requestSanitizer;
                    if (!isEnabled) {
                      return null;
                    }
                    var sanitized = null;
                    try {
                      sanitized = requestSanitizer(_objectSpread3(_objectSpread3({}, request2), {}, {
                        reqId
                      }));
                    } catch (err) {
                      console.error(err);
                    }
                    if (sanitized) {
                      var url = sanitized.url;
                      if (typeof document !== "undefined" && typeof document.createElement === "function") {
                        var a2 = document.createElement("a");
                        a2.href = sanitized.url;
                        url = a2.href;
                      }
                      return {
                        reqId,
                        // default
                        url,
                        // sanitized
                        headers: (0, _mapValues2.default)(sanitized.headers, function(headerValue) {
                          return "".concat(headerValue);
                        }),
                        body: truncate2(sanitized.body),
                        // sanitized
                        method,
                        // default
                        referrer: sanitized.referrer || void 0,
                        // sanitized
                        mode: sanitized.mode || void 0,
                        // sanitized
                        credentials: sanitized.credentials || void 0
                        // sanitized
                      };
                    }
                    ignoredNetwork[reqId] = true;
                    return null;
                  });
                };
                var addResponse = function addResponse2(reqId, response) {
                  var method = response.method, status = response.status;
                  logger.addEvent("lr.network.ResponseEvent", function() {
                    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$isEnabled = _ref2.isEnabled, isEnabled = _ref2$isEnabled === void 0 ? true : _ref2$isEnabled, _ref2$responseSanitiz = _ref2.responseSanitizer, responseSanitizer = _ref2$responseSanitiz === void 0 ? function(f2) {
                      return f2;
                    } : _ref2$responseSanitiz;
                    if (!isEnabled) {
                      return null;
                    } else if (ignoredNetwork[reqId]) {
                      delete ignoredNetwork[reqId];
                      return null;
                    }
                    var sanitized = null;
                    try {
                      sanitized = responseSanitizer(_objectSpread3(_objectSpread3({}, response), {}, {
                        reqId
                      }));
                    } catch (err) {
                      console.error(err);
                    }
                    if (sanitized) {
                      return {
                        reqId,
                        // default
                        status: sanitized.status,
                        // sanitized
                        headers: (0, _mapValues2.default)(sanitized.headers, function(headerValue) {
                          return "".concat(headerValue);
                        }),
                        body: truncate2(sanitized.body),
                        // sanitized
                        method
                        // default
                      };
                    }
                    return {
                      reqId,
                      // default
                      status,
                      // default
                      headers: {},
                      // redacted
                      body: null,
                      // redacted
                      method
                      // default
                    };
                  });
                };
                var isIgnored = function isIgnored2(reqId) {
                  return logger.isDisabled || ignoredNetwork[reqId] === true;
                };
                var unsubFetch = (0, _registerFetch.default)({
                  addRequest,
                  addResponse,
                  isIgnored
                });
                var unsubXHR = (0, _registerXHR.default)({
                  addRequest,
                  addResponse,
                  isIgnored,
                  logger,
                  shouldAugmentNPS,
                  shouldParseXHRBlob
                });
                var unsubNetworkInformation = isReactNative ? function() {
                } : (0, _registerNetworkInformation.default)(logger);
                return function() {
                  unsubNetworkInformation();
                  unsubFetch();
                  unsubXHR();
                };
              }
            }
          ),
          /***/
          "./packages/@logrocket/network/src/registerFetch.js": (
            /*!**********************************************************!*\
              !*** ./packages/@logrocket/network/src/registerFetch.js ***!
              \**********************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = registerFetch;
              var _defineProperty2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/defineProperty */
                "./node_modules/@babel/runtime/helpers/defineProperty.js"
              ));
              var _mapValues2 = _interopRequireDefault2(__webpack_require__2(
                /*! @logrocket/utils/src/mapValues */
                "./packages/@logrocket/utils/src/mapValues.js"
              ));
              var _fetchIntercept = _interopRequireDefault2(__webpack_require__2(
                /*! ./fetchIntercept */
                "./packages/@logrocket/network/src/fetchIntercept.js"
              ));
              function ownKeys2(object2, enumerableOnly) {
                var keys4 = Object.keys(object2);
                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object2);
                  enumerableOnly && (symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
                  })), keys4.push.apply(keys4, symbols);
                }
                return keys4;
              }
              function _objectSpread3(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = null != arguments[i] ? arguments[i] : {};
                  i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
                    (0, _defineProperty2.default)(target, key, source[key]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
                return target;
              }
              function makeObjectFromHeaders(headers) {
                if (headers == null || typeof headers.forEach !== "function") {
                  return headers;
                }
                var result = {};
                headers.forEach(function(value, key) {
                  if (result[key]) {
                    result[key] = "".concat(result[key], ",").concat(value);
                  } else {
                    result[key] = "".concat(value);
                  }
                });
                return result;
              }
              var stringifyHeaders = function stringifyHeaders2(headers) {
                return (0, _mapValues2.default)(makeObjectFromHeaders(headers), function(value) {
                  return "".concat(value);
                });
              };
              function pluckFetchFields() {
                var arg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                return {
                  url: arg.url,
                  headers: stringifyHeaders(arg.headers),
                  method: arg.method && arg.method.toUpperCase(),
                  referrer: arg.referrer || void 0,
                  mode: arg.mode || void 0,
                  credentials: arg.credentials || void 0
                };
              }
              function registerFetch(_ref) {
                var addRequest = _ref.addRequest, addResponse = _ref.addResponse, isIgnored = _ref.isIgnored;
                var LOGROCKET_FETCH_LABEL = "fetch-";
                var fetchMethodMap = {};
                var unregister = _fetchIntercept.default.register({
                  request: function request2(fetchId) {
                    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                      args[_key - 1] = arguments[_key];
                    }
                    var p2;
                    if (typeof Request !== "undefined" && args[0] instanceof Request) {
                      var clonedText;
                      try {
                        clonedText = args[0].clone().text();
                      } catch (err) {
                        clonedText = Promise.resolve("LogRocket fetch error: ".concat(err.message));
                      }
                      p2 = clonedText.then(function(body) {
                        return _objectSpread3(_objectSpread3({}, pluckFetchFields(args[0])), {}, {
                          body
                        });
                      }, function(err) {
                        return _objectSpread3(_objectSpread3({}, pluckFetchFields(args[0])), {}, {
                          body: "LogRocket fetch error: ".concat(err.message)
                        });
                      });
                    } else {
                      p2 = Promise.resolve(_objectSpread3(_objectSpread3({}, pluckFetchFields(args[1])), {}, {
                        url: "".concat(args[0]),
                        body: (args[1] || {}).body
                      }));
                    }
                    return p2.then(function(req) {
                      fetchMethodMap[fetchId] = req.method;
                      addRequest("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), req);
                      return args;
                    });
                  },
                  requestError: function requestError(fetchId, error) {
                    return Promise.reject(error);
                  },
                  response: function response(fetchId, _response) {
                    var responseClone;
                    var responseTextPromise;
                    if (isIgnored("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId))) {
                      return _response;
                    }
                    try {
                      responseClone = _response.clone();
                    } catch (err) {
                      var responseHash = {
                        url: _response.url,
                        status: _response.status,
                        headers: stringifyHeaders(_response.headers),
                        body: "LogRocket fetch error: ".concat(err.message),
                        method: fetchMethodMap[fetchId]
                      };
                      delete fetchMethodMap[fetchId];
                      addResponse("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), responseHash);
                      return _response;
                    }
                    try {
                      if (window.TextDecoder && responseClone.body) {
                        var reader = responseClone.body.getReader();
                        var utf8Decoder = new window.TextDecoder("utf-8");
                        var bodyContents = "";
                        responseTextPromise = reader.read().then(function readResponseBody(_ref2) {
                          var done3 = _ref2.done, value = _ref2.value;
                          if (done3) {
                            return bodyContents;
                          }
                          var chunk = value ? utf8Decoder.decode(value, {
                            stream: true
                          }) : "";
                          bodyContents += chunk;
                          return reader.read().then(readResponseBody);
                        });
                      } else {
                        responseTextPromise = responseClone.text();
                      }
                    } catch (error) {
                      responseTextPromise = Promise.resolve("LogRocket error reading body: ".concat(error.message));
                    }
                    responseTextPromise.catch(function(error) {
                      if (error.name === "AbortError" && error instanceof DOMException) {
                        return;
                      }
                      return "LogRocket error reading body: ".concat(error.message);
                    }).then(function(data2) {
                      var responseHash2 = {
                        url: _response.url,
                        status: _response.status,
                        headers: stringifyHeaders(_response.headers),
                        body: data2,
                        method: fetchMethodMap[fetchId]
                      };
                      delete fetchMethodMap[fetchId];
                      addResponse("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), responseHash2);
                    });
                    return _response;
                  },
                  responseError: function responseError(fetchId, error) {
                    var response = {
                      url: void 0,
                      status: 0,
                      headers: {},
                      body: "".concat(error)
                    };
                    addResponse("".concat(LOGROCKET_FETCH_LABEL).concat(fetchId), response);
                    return Promise.reject(error);
                  }
                });
                return unregister;
              }
            }
          ),
          /***/
          "./packages/@logrocket/network/src/registerNetworkInformation.js": (
            /*!***********************************************************************!*\
              !*** ./packages/@logrocket/network/src/registerNetworkInformation.js ***!
              \***********************************************************************/
            /***/
            function(__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = registerNetworkInformation;
              var EFFECTIVE_TYPE_VALS = {
                "slow-2g": "SLOW2G",
                "2g": "TWOG",
                "3g": "THREEG",
                "4g": "FOURG"
              };
              function registerNetworkInformation(logger) {
                var lastStatus = void 0;
                function sendNetworkInformation() {
                  var newStatus = {
                    online: window.navigator.onLine,
                    effectiveType: "UNKOWN"
                  };
                  if (!window.navigator.onLine) {
                    newStatus.effectiveType = "NONE";
                  } else if (window.navigator.connection && window.navigator.connection.effectiveType) {
                    newStatus.effectiveType = EFFECTIVE_TYPE_VALS[window.navigator.connection.effectiveType] || "UNKNOWN";
                  }
                  if (lastStatus && newStatus.online === lastStatus.online && newStatus.effectiveType === lastStatus.effectiveType) {
                    return;
                  }
                  lastStatus = newStatus;
                  logger.addEvent("lr.network.NetworkStatusEvent", function() {
                    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$isEnabled = _ref.isEnabled, isEnabled = _ref$isEnabled === void 0 ? true : _ref$isEnabled;
                    if (!isEnabled) {
                      return null;
                    }
                    return newStatus;
                  });
                }
                setTimeout(sendNetworkInformation);
                if (window.navigator.connection && typeof window.navigator.connection.addEventListener === "function") {
                  window.navigator.connection.addEventListener("change", sendNetworkInformation);
                }
                window.addEventListener("online", sendNetworkInformation);
                window.addEventListener("offline", sendNetworkInformation);
                return function() {
                  window.removeEventListener("offline", sendNetworkInformation);
                  window.removeEventListener("online", sendNetworkInformation);
                  if (window.navigator.connection && typeof window.navigator.connection.removeEventListener === "function") {
                    window.navigator.connection.removeEventListener("change", sendNetworkInformation);
                  }
                };
              }
            }
          ),
          /***/
          "./packages/@logrocket/network/src/registerXHR.js": (
            /*!********************************************************!*\
              !*** ./packages/@logrocket/network/src/registerXHR.js ***!
              \********************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.setActive = setActive;
              exports2["default"] = registerXHR;
              var _mapValues2 = _interopRequireDefault2(__webpack_require__2(
                /*! @logrocket/utils/src/mapValues */
                "./packages/@logrocket/utils/src/mapValues.js"
              ));
              var _enhanceFunc = _interopRequireDefault2(__webpack_require__2(
                /*! @logrocket/utils/src/enhanceFunc */
                "./packages/@logrocket/utils/src/enhanceFunc.js"
              ));
              var _startsWith = _interopRequireDefault2(__webpack_require__2(
                /*! @logrocket/utils/src/startsWith */
                "./packages/@logrocket/utils/src/startsWith.js"
              ));
              var _nps = __webpack_require__2(
                /*! @logrocket/utils/src/constants/nps */
                "./packages/@logrocket/utils/src/constants/nps.js"
              );
              var isActive = true;
              function setActive(shouldBeActive) {
                isActive = shouldBeActive;
              }
              var currentXHRId = 0;
              function registerXHR(_ref) {
                var addRequest = _ref.addRequest, addResponse = _ref.addResponse, isIgnored = _ref.isIgnored, logger = _ref.logger, _ref$shouldAugmentNPS = _ref.shouldAugmentNPS, shouldAugmentNPS = _ref$shouldAugmentNPS === void 0 ? true : _ref$shouldAugmentNPS, _ref$shouldParseXHRBl = _ref.shouldParseXHRBlob, shouldParseXHRBlob = _ref$shouldParseXHRBl === void 0 ? false : _ref$shouldParseXHRBl;
                var _XHR = XMLHttpRequest;
                var xhrMap = /* @__PURE__ */ new WeakMap();
                var unsubscribedFromXhr = false;
                var LOGROCKET_XHR_LABEL = "xhr-";
                window._lrXMLHttpRequest = XMLHttpRequest;
                XMLHttpRequest = function XMLHttpRequest2(mozAnon, mozSystem) {
                  var xhrObject = new _XHR(mozAnon, mozSystem);
                  if (!isActive) {
                    return xhrObject;
                  }
                  xhrMap.set(xhrObject, {
                    xhrId: ++currentXHRId,
                    headers: {}
                  });
                  var openOriginal = xhrObject.open;
                  function openShim() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }
                    try {
                      var url = args[1];
                      if (window.URL && typeof window.URL === "function" && url.search(_nps.WOOTRIC_RESPONSES_REGEX) === 0) {
                        var logrocketSessionURL = new window.URL(logger.recordingURL);
                        logrocketSessionURL.searchParams.set("nps", "wootric");
                        var urlObj = new window.URL(url);
                        var responseText = urlObj.searchParams.get("response[text]");
                        var feedback = responseText ? "".concat(responseText, "\n\n") : "";
                        urlObj.searchParams.set("response[text]", "".concat(feedback, "<").concat(logrocketSessionURL.href, "|View LogRocket session>"));
                        args[1] = urlObj.href;
                      }
                    } catch (e3) {
                    }
                    return openOriginal.apply(this, args);
                  }
                  var sendOriginal = xhrObject.send;
                  function sendShim() {
                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                      args[_key2] = arguments[_key2];
                    }
                    try {
                      var currentXHR = xhrMap.get(xhrObject);
                      if (window.URL && typeof window.URL === "function" && currentXHR && currentXHR.url && currentXHR.url.search(_nps.DELIGHTED_RESPONSES_REGEX) === 0 && args.length && args[0].indexOf(_nps.DELIGHTED_FEEDBACK_PREFIX) !== -1) {
                        var recordingURL = new window.URL(logger.recordingURL);
                        recordingURL.searchParams.set("nps", "delighted");
                        var logrocketSessionURL = encodeURIComponent(recordingURL.href);
                        var data2 = args[0].split("&").map(function(dataString) {
                          if ((0, _startsWith.default)(dataString, _nps.DELIGHTED_FEEDBACK_PREFIX)) {
                            var isEmpty3 = dataString === _nps.DELIGHTED_FEEDBACK_PREFIX;
                            return "".concat(dataString).concat(isEmpty3 ? "" : "\n\n", "<").concat(logrocketSessionURL, "|View LogRocket session>");
                          }
                          return dataString;
                        }).join("&");
                        args[0] = data2;
                      }
                    } catch (e3) {
                    }
                    return sendOriginal.apply(this, args);
                  }
                  if (shouldAugmentNPS) {
                    xhrObject.open = openShim;
                    xhrObject.send = sendShim;
                  }
                  (0, _enhanceFunc.default)(xhrObject, "open", function(method, url) {
                    if (unsubscribedFromXhr) {
                      return;
                    }
                    var currentXHR = xhrMap.get(xhrObject);
                    currentXHR.method = method;
                    currentXHR.url = url;
                  });
                  (0, _enhanceFunc.default)(xhrObject, "send", function(data2) {
                    if (unsubscribedFromXhr) {
                      return;
                    }
                    var currentXHR = xhrMap.get(xhrObject);
                    if (!currentXHR) {
                      return;
                    }
                    var request2 = {
                      url: currentXHR.url,
                      method: currentXHR.method && currentXHR.method.toUpperCase(),
                      headers: (0, _mapValues2.default)(currentXHR.headers || {}, function(headerValues) {
                        return headerValues.join(", ");
                      }),
                      body: data2
                    };
                    addRequest("".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId), request2);
                  });
                  (0, _enhanceFunc.default)(xhrObject, "setRequestHeader", function(header, value) {
                    if (unsubscribedFromXhr) {
                      return;
                    }
                    var currentXHR = xhrMap.get(xhrObject);
                    if (!currentXHR) {
                      return;
                    }
                    currentXHR.headers = currentXHR.headers || {};
                    currentXHR.headers[header] = currentXHR.headers[header] || [];
                    currentXHR.headers[header].push(value);
                  });
                  var xhrListeners = {
                    readystatechange: function readystatechange() {
                      if (unsubscribedFromXhr) {
                        return;
                      }
                      if (xhrObject.readyState === 4) {
                        var currentXHR = xhrMap.get(xhrObject);
                        if (!currentXHR) {
                          return;
                        }
                        if (isIgnored("".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId))) {
                          return;
                        }
                        var headerString = xhrObject.getAllResponseHeaders() || "";
                        var headers = headerString.split(/[\r\n]+/).reduce(function(previous, current2) {
                          var next = previous;
                          var headerParts = current2.split(": ");
                          if (headerParts.length > 0) {
                            var key = headerParts.shift();
                            var value = headerParts.join(": ");
                            if (previous[key]) {
                              next[key] += ", ".concat(value);
                            } else {
                              next[key] = value;
                            }
                          }
                          return next;
                        }, {});
                        var body;
                        try {
                          switch (xhrObject.responseType) {
                            case "json":
                              body = logger._shouldCloneResponse ? JSON.parse(JSON.stringify(xhrObject.response)) : xhrObject.response;
                              break;
                            case "arraybuffer":
                            case "blob": {
                              body = xhrObject.response;
                              break;
                            }
                            case "document": {
                              body = xhrObject.responseXML;
                              break;
                            }
                            case "text":
                            case "": {
                              body = xhrObject.responseText;
                              break;
                            }
                            default: {
                              body = "";
                            }
                          }
                        } catch (err) {
                          body = "LogRocket: Error accessing response.";
                        }
                        var response = {
                          url: currentXHR.url,
                          status: xhrObject.status,
                          headers,
                          body,
                          method: (currentXHR.method || "").toUpperCase()
                        };
                        if (shouldParseXHRBlob && response.body instanceof Blob) {
                          var blobReader = new FileReader();
                          blobReader.readAsText(response.body);
                          blobReader.onload = function() {
                            try {
                              response.body = JSON.parse(blobReader.result);
                            } catch (_unused) {
                            }
                            addResponse("".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId), response);
                          };
                        } else {
                          addResponse("".concat(LOGROCKET_XHR_LABEL).concat(currentXHR.xhrId), response);
                        }
                      }
                    }
                    // // Unused Event Listeners
                    // loadstart: () => {},
                    // progress: () => {},
                    // abort: () => {},
                    // error: () => {},
                    // load: () => {},
                    // timeout: () => {},
                    // loadend: () => {},
                  };
                  Object.keys(xhrListeners).forEach(function(key) {
                    xhrObject.addEventListener(key, xhrListeners[key]);
                  });
                  return xhrObject;
                };
                XMLHttpRequest.prototype = _XHR.prototype;
                ["UNSENT", "OPENED", "HEADERS_RECEIVED", "LOADING", "DONE"].forEach(function(variable) {
                  XMLHttpRequest[variable] = _XHR[variable];
                });
                return function() {
                  unsubscribedFromXhr = true;
                  XMLHttpRequest = _XHR;
                };
              }
            }
          ),
          /***/
          "./packages/@logrocket/now/src/index.js": (
            /*!**********************************************!*\
              !*** ./packages/@logrocket/now/src/index.js ***!
              \**********************************************/
            /***/
            function(__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = void 0;
              var dateNow = Date.now.bind(Date);
              var loadTime = dateNow();
              var _default2 = typeof performance !== "undefined" && performance.now ? performance.now.bind(performance) : function() {
                return dateNow() - loadTime;
              };
              exports2["default"] = _default2;
            }
          ),
          /***/
          "./packages/@logrocket/redux/src/createEnhancer.js": (
            /*!*********************************************************!*\
              !*** ./packages/@logrocket/redux/src/createEnhancer.js ***!
              \*********************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = createEnhancer;
              var _defineProperty2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/defineProperty */
                "./node_modules/@babel/runtime/helpers/defineProperty.js"
              ));
              var _now = _interopRequireDefault2(__webpack_require__2(
                /*! @logrocket/now */
                "./packages/@logrocket/now/src/index.js"
              ));
              function ownKeys2(object2, enumerableOnly) {
                var keys4 = Object.keys(object2);
                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object2);
                  enumerableOnly && (symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
                  })), keys4.push.apply(keys4, symbols);
                }
                return keys4;
              }
              function _objectSpread3(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = null != arguments[i] ? arguments[i] : {};
                  i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
                    (0, _defineProperty2.default)(target, key, source[key]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
                return target;
              }
              var storeIdCounter = 0;
              function createEnhancer(logger) {
                var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$stateSanitizer = _ref.stateSanitizer, stateSanitizer = _ref$stateSanitizer === void 0 ? function(f2) {
                  return f2;
                } : _ref$stateSanitizer, _ref$actionSanitizer = _ref.actionSanitizer, actionSanitizer = _ref$actionSanitizer === void 0 ? function(f2) {
                  return f2;
                } : _ref$actionSanitizer;
                return function(createStore2) {
                  return function(reducer2, initialState, enhancer) {
                    var store = createStore2(reducer2, initialState, enhancer);
                    var originalDispatch = store.dispatch;
                    var storeId = storeIdCounter++;
                    logger.addEvent("lr.redux.InitialState", function() {
                      var sanitizedState;
                      try {
                        sanitizedState = stateSanitizer(store.getState());
                      } catch (err) {
                        console.error(err.toString());
                      }
                      return {
                        state: sanitizedState,
                        storeId
                      };
                    });
                    var dispatch = function dispatch2(action) {
                      var start = (0, _now.default)();
                      var err;
                      var res;
                      try {
                        res = originalDispatch(action);
                      } catch (_err) {
                        err = _err;
                      } finally {
                        var duration = (0, _now.default)() - start;
                        logger.addEvent("lr.redux.ReduxAction", function() {
                          var sanitizedState = null;
                          var sanitizedAction = null;
                          try {
                            sanitizedState = stateSanitizer(store.getState());
                            sanitizedAction = actionSanitizer(action);
                          } catch (err2) {
                            console.error(err2.toString());
                          }
                          if (sanitizedState && sanitizedAction) {
                            return {
                              storeId,
                              action: sanitizedAction,
                              duration,
                              stateDelta: sanitizedState
                            };
                          }
                          return null;
                        });
                      }
                      if (err) {
                        throw err;
                      }
                      return res;
                    };
                    return _objectSpread3(_objectSpread3({}, store), {}, {
                      dispatch
                    });
                  };
                };
              }
            }
          ),
          /***/
          "./packages/@logrocket/redux/src/createMiddleware.js": (
            /*!***********************************************************!*\
              !*** ./packages/@logrocket/redux/src/createMiddleware.js ***!
              \***********************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = createMiddleware;
              var _now = _interopRequireDefault2(__webpack_require__2(
                /*! @logrocket/now */
                "./packages/@logrocket/now/src/index.js"
              ));
              var storeIdCounter = 0;
              function createMiddleware(logger) {
                var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$stateSanitizer = _ref.stateSanitizer, stateSanitizer = _ref$stateSanitizer === void 0 ? function(f2) {
                  return f2;
                } : _ref$stateSanitizer, _ref$actionSanitizer = _ref.actionSanitizer, actionSanitizer = _ref$actionSanitizer === void 0 ? function(f2) {
                  return f2;
                } : _ref$actionSanitizer;
                return function(store) {
                  var storeId = storeIdCounter++;
                  logger.addEvent("lr.redux.InitialState", function() {
                    var sanitizedState;
                    try {
                      sanitizedState = stateSanitizer(store.getState());
                    } catch (err) {
                      console.error(err.toString());
                    }
                    return {
                      state: sanitizedState,
                      storeId
                    };
                  });
                  return function(next) {
                    return function(action) {
                      var start = (0, _now.default)();
                      var err;
                      var res;
                      try {
                        res = next(action);
                      } catch (_err) {
                        err = _err;
                      } finally {
                        var duration = (0, _now.default)() - start;
                        logger.addEvent("lr.redux.ReduxAction", function() {
                          var sanitizedState = null;
                          var sanitizedAction = null;
                          try {
                            sanitizedState = stateSanitizer(store.getState());
                            sanitizedAction = actionSanitizer(action);
                          } catch (err2) {
                            console.error(err2.toString());
                          }
                          if (sanitizedState && sanitizedAction) {
                            return {
                              storeId,
                              action: sanitizedAction,
                              duration,
                              stateDelta: sanitizedState
                            };
                          }
                          return null;
                        });
                      }
                      if (err) {
                        throw err;
                      }
                      return res;
                    };
                  };
                };
              }
            }
          ),
          /***/
          "./packages/@logrocket/redux/src/index.js": (
            /*!************************************************!*\
              !*** ./packages/@logrocket/redux/src/index.js ***!
              \************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              Object.defineProperty(exports2, "createEnhancer", {
                enumerable: true,
                get: function get3() {
                  return _createEnhancer.default;
                }
              });
              Object.defineProperty(exports2, "createMiddleware", {
                enumerable: true,
                get: function get3() {
                  return _createMiddleware.default;
                }
              });
              var _createEnhancer = _interopRequireDefault2(__webpack_require__2(
                /*! ./createEnhancer */
                "./packages/@logrocket/redux/src/createEnhancer.js"
              ));
              var _createMiddleware = _interopRequireDefault2(__webpack_require__2(
                /*! ./createMiddleware */
                "./packages/@logrocket/redux/src/createMiddleware.js"
              ));
            }
          ),
          /***/
          "./packages/@logrocket/utils/src/TraceKit.js": (
            /*!***************************************************!*\
              !*** ./packages/@logrocket/utils/src/TraceKit.js ***!
              \***************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = void 0;
              var TraceKit = {
                collectWindowErrors: true,
                debug: false
              };
              var _window = typeof window !== "undefined" ? window : typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof self !== "undefined" ? self : {};
              var _slice = [].slice;
              var UNKNOWN_FUNCTION = "?";
              var ERROR_TYPES_RE = /^(?:Uncaught (?:exception: )?)?((?:Eval|Internal|Range|Reference|Syntax|Type|URI)Error): ?(.*)$/;
              function getLocationHref() {
                if (typeof document === "undefined" || typeof document.location === "undefined")
                  return "";
                return document.location.href;
              }
              TraceKit.report = function reportModuleWrapper() {
                var handlers = [], lastArgs = null, lastException = null, lastExceptionStack = null;
                function subscribe(handler) {
                  installGlobalHandler();
                  handlers.push(handler);
                }
                function unsubscribe(handler) {
                  for (var i = handlers.length - 1; i >= 0; --i) {
                    if (handlers[i] === handler) {
                      handlers.splice(i, 1);
                    }
                  }
                }
                function unsubscribeAll() {
                  uninstallGlobalHandler();
                  handlers = [];
                }
                function notifyHandlers(stack, isWindowError) {
                  var exception = null;
                  if (isWindowError && !TraceKit.collectWindowErrors) {
                    return;
                  }
                  for (var i in handlers) {
                    if (handlers.hasOwnProperty(i)) {
                      try {
                        handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));
                      } catch (inner) {
                        exception = inner;
                      }
                    }
                  }
                  if (exception) {
                    throw exception;
                  }
                }
                var _oldOnerrorHandler, _onErrorHandlerInstalled;
                function traceKitWindowOnError(message, url, lineNo, colNo, ex) {
                  var stack = null;
                  if (lastExceptionStack) {
                    TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);
                    processLastException();
                  } else if (ex) {
                    stack = TraceKit.computeStackTrace(ex);
                    notifyHandlers(stack, true);
                  } else {
                    var location = {
                      "url": url,
                      "line": lineNo,
                      "column": colNo
                    };
                    var name = void 0;
                    var msg = message;
                    var groups;
                    if ({}.toString.call(message) === "[object String]") {
                      var groups = message.match(ERROR_TYPES_RE);
                      if (groups) {
                        name = groups[1];
                        msg = groups[2];
                      }
                    }
                    location.func = UNKNOWN_FUNCTION;
                    stack = {
                      "name": name,
                      "message": msg,
                      "url": getLocationHref(),
                      "stack": [location]
                    };
                    notifyHandlers(stack, true);
                  }
                  if (_oldOnerrorHandler) {
                    return _oldOnerrorHandler.apply(this, arguments);
                  }
                  return false;
                }
                function installGlobalHandler() {
                  if (_onErrorHandlerInstalled) {
                    return;
                  }
                  _oldOnerrorHandler = _window.onerror;
                  _window.onerror = traceKitWindowOnError;
                  _onErrorHandlerInstalled = true;
                }
                function uninstallGlobalHandler() {
                  if (!_onErrorHandlerInstalled) {
                    return;
                  }
                  _window.onerror = _oldOnerrorHandler;
                  _onErrorHandlerInstalled = false;
                  _oldOnerrorHandler = void 0;
                }
                function processLastException() {
                  var _lastExceptionStack = lastExceptionStack, _lastArgs = lastArgs;
                  lastArgs = null;
                  lastExceptionStack = null;
                  lastException = null;
                  notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));
                }
                function report(ex, rethrow) {
                  var args = _slice.call(arguments, 1);
                  if (lastExceptionStack) {
                    if (lastException === ex) {
                      return;
                    } else {
                      processLastException();
                    }
                  }
                  var stack = TraceKit.computeStackTrace(ex);
                  lastExceptionStack = stack;
                  lastException = ex;
                  lastArgs = args;
                  setTimeout(function() {
                    if (lastException === ex) {
                      processLastException();
                    }
                  }, stack.incomplete ? 2e3 : 0);
                  if (rethrow !== false) {
                    throw ex;
                  }
                }
                report.subscribe = subscribe;
                report.unsubscribe = unsubscribe;
                report.uninstall = unsubscribeAll;
                return report;
              }();
              TraceKit.computeStackTrace = function computeStackTraceWrapper() {
                function computeStackTraceFromStackProp(ex) {
                  if (typeof ex.stack === "undefined" || !ex.stack)
                    return;
                  var chrome = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|<anonymous>).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|resource|\[native).*?)(?::(\d+))?(?::(\d+))?\s*$/i, winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i, lines = ex.stack.split("\n"), stack = [], parts, element;
                  /^(.*) is undefined$/.exec(ex.message);
                  for (var i = 0, j2 = lines.length; i < j2; ++i) {
                    if (parts = chrome.exec(lines[i])) {
                      var isNative = parts[2] && parts[2].indexOf("native") !== -1;
                      element = {
                        "url": !isNative ? parts[2] : null,
                        "func": parts[1] || UNKNOWN_FUNCTION,
                        "args": isNative ? [parts[2]] : [],
                        "line": parts[3] ? +parts[3] : null,
                        "column": parts[4] ? +parts[4] : null
                      };
                    } else if (parts = winjs.exec(lines[i])) {
                      element = {
                        "url": parts[2],
                        "func": parts[1] || UNKNOWN_FUNCTION,
                        "args": [],
                        "line": +parts[3],
                        "column": parts[4] ? +parts[4] : null
                      };
                    } else if (parts = gecko.exec(lines[i])) {
                      element = {
                        "url": parts[3],
                        "func": parts[1] || UNKNOWN_FUNCTION,
                        "args": parts[2] ? parts[2].split(",") : [],
                        "line": parts[4] ? +parts[4] : null,
                        "column": parts[5] ? +parts[5] : null
                      };
                    } else {
                      continue;
                    }
                    if (!element.func && element.line) {
                      element.func = UNKNOWN_FUNCTION;
                    }
                    stack.push(element);
                  }
                  if (!stack.length) {
                    return null;
                  }
                  if (!stack[0].column && typeof ex.columnNumber !== "undefined") {
                    stack[0].column = ex.columnNumber + 1;
                  }
                  return {
                    "name": ex.name,
                    "message": ex.message,
                    "url": getLocationHref(),
                    "stack": stack
                  };
                }
                function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
                  var initial = {
                    "url": url,
                    "line": lineNo
                  };
                  if (initial.url && initial.line) {
                    stackInfo.incomplete = false;
                    if (!initial.func) {
                      initial.func = UNKNOWN_FUNCTION;
                    }
                    if (stackInfo.stack.length > 0) {
                      if (stackInfo.stack[0].url === initial.url) {
                        if (stackInfo.stack[0].line === initial.line) {
                          return false;
                        } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {
                          stackInfo.stack[0].line = initial.line;
                          return false;
                        }
                      }
                    }
                    stackInfo.stack.unshift(initial);
                    stackInfo.partial = true;
                    return true;
                  } else {
                    stackInfo.incomplete = true;
                  }
                  return false;
                }
                function computeStackTraceByWalkingCallerChain(ex, depth) {
                  var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i, stack = [], funcs = {}, recursion = false, parts, item;
                  for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {
                    if (curr === computeStackTrace || curr === TraceKit.report) {
                      continue;
                    }
                    item = {
                      "url": null,
                      "func": UNKNOWN_FUNCTION,
                      "line": null,
                      "column": null
                    };
                    if (curr.name) {
                      item.func = curr.name;
                    } else if (parts = functionName.exec(curr.toString())) {
                      item.func = parts[1];
                    }
                    if (typeof item.func === "undefined") {
                      try {
                        item.func = parts.input.substring(0, parts.input.indexOf("{"));
                      } catch (e3) {
                      }
                    }
                    if (funcs["" + curr]) {
                      recursion = true;
                    } else {
                      funcs["" + curr] = true;
                    }
                    stack.push(item);
                  }
                  if (depth) {
                    stack.splice(0, depth);
                  }
                  var result = {
                    "name": ex.name,
                    "message": ex.message,
                    "url": getLocationHref(),
                    "stack": stack
                  };
                  augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);
                  return result;
                }
                function computeStackTrace(ex, depth) {
                  var stack = null;
                  depth = depth == null ? 0 : +depth;
                  try {
                    stack = computeStackTraceFromStackProp(ex);
                    if (stack) {
                      return stack;
                    }
                  } catch (e3) {
                    if (TraceKit.debug) {
                      throw e3;
                    }
                  }
                  try {
                    stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
                    if (stack) {
                      return stack;
                    }
                  } catch (e3) {
                    if (TraceKit.debug) {
                      throw e3;
                    }
                  }
                  return {
                    "name": ex.name,
                    "message": ex.message,
                    "url": getLocationHref()
                  };
                }
                computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
                computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;
                return computeStackTrace;
              }();
              var _default2 = TraceKit;
              exports2["default"] = _default2;
            }
          ),
          /***/
          "./packages/@logrocket/utils/src/constants/nps.js": (
            /*!********************************************************!*\
              !*** ./packages/@logrocket/utils/src/constants/nps.js ***!
              \********************************************************/
            /***/
            function(__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.DELIGHTED_FEEDBACK_PREFIX = exports2.DELIGHTED_RESPONSES_REGEX = exports2.WOOTRIC_RESPONSES_REGEX = void 0;
              var WOOTRIC_RESPONSES_REGEX = /^https:\/\/production.wootric.com\/responses/;
              exports2.WOOTRIC_RESPONSES_REGEX = WOOTRIC_RESPONSES_REGEX;
              var DELIGHTED_RESPONSES_REGEX = /^https:\/\/web.delighted.com\/e\/[a-zA-Z-]*\/c/;
              exports2.DELIGHTED_RESPONSES_REGEX = DELIGHTED_RESPONSES_REGEX;
              var DELIGHTED_FEEDBACK_PREFIX = "comment=";
              exports2.DELIGHTED_FEEDBACK_PREFIX = DELIGHTED_FEEDBACK_PREFIX;
            }
          ),
          /***/
          "./packages/@logrocket/utils/src/enhanceFunc.js": (
            /*!******************************************************!*\
              !*** ./packages/@logrocket/utils/src/enhanceFunc.js ***!
              \******************************************************/
            /***/
            function(__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = enhanceFunc;
              function enhanceFunc(obj, method, handler) {
                var original = obj[method];
                function shim2() {
                  var res;
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  if (original) {
                    res = original.apply(this, args);
                  }
                  handler.apply(this, args);
                  return res;
                }
                obj[method] = shim2;
                return function() {
                  obj[method] = original;
                };
              }
            }
          ),
          /***/
          "./packages/@logrocket/utils/src/mapValues.js": (
            /*!****************************************************!*\
              !*** ./packages/@logrocket/utils/src/mapValues.js ***!
              \****************************************************/
            /***/
            function(__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = mapValues2;
              function mapValues2(obj, f2) {
                if (obj == null) {
                  return {};
                }
                var res = {};
                Object.keys(obj).forEach(function(key) {
                  res[key] = f2(obj[key]);
                });
                return res;
              }
            }
          ),
          /***/
          "./packages/@logrocket/utils/src/startsWith.js": (
            /*!*****************************************************!*\
              !*** ./packages/@logrocket/utils/src/startsWith.js ***!
              \*****************************************************/
            /***/
            function(__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = startsWith2;
              function startsWith2(value, search2) {
                var pos = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                return value && search2 && value.substring(pos, pos + search2.length) === search2;
              }
            }
          ),
          /***/
          "./packages/logrocket/src/LogRocket.js": (
            /*!*********************************************!*\
              !*** ./packages/logrocket/src/LogRocket.js ***!
              \*********************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = exports2.MAX_QUEUE_SIZE = void 0;
              var _classCallCheck2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/classCallCheck */
                "./node_modules/@babel/runtime/helpers/classCallCheck.js"
              ));
              var _createClass2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/createClass */
                "./node_modules/@babel/runtime/helpers/createClass.js"
              ));
              var _defineProperty2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/defineProperty */
                "./node_modules/@babel/runtime/helpers/defineProperty.js"
              ));
              var _objectWithoutProperties2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/objectWithoutProperties */
                "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js"
              ));
              var _network = _interopRequireDefault2(__webpack_require__2(
                /*! @logrocket/network */
                "./packages/@logrocket/network/src/index.js"
              ));
              var _exceptions = __webpack_require__2(
                /*! @logrocket/exceptions */
                "./packages/@logrocket/exceptions/src/index.js"
              );
              var _console = _interopRequireDefault2(__webpack_require__2(
                /*! @logrocket/console */
                "./packages/@logrocket/console/src/index.js"
              ));
              var _redux = __webpack_require__2(
                /*! @logrocket/redux */
                "./packages/@logrocket/redux/src/index.js"
              );
              function ownKeys2(object2, enumerableOnly) {
                var keys4 = Object.keys(object2);
                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object2);
                  enumerableOnly && (symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
                  })), keys4.push.apply(keys4, symbols);
                }
                return keys4;
              }
              function _objectSpread3(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = null != arguments[i] ? arguments[i] : {};
                  i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
                    (0, _defineProperty2.default)(target, key, source[key]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
                return target;
              }
              var MAX_QUEUE_SIZE = 1e3;
              exports2.MAX_QUEUE_SIZE = MAX_QUEUE_SIZE;
              var considerIngestServerOption = function considerIngestServerOption2() {
                var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ingestServer = _ref.ingestServer, options = (0, _objectWithoutProperties2.default)(_ref, ["ingestServer"]);
                if (ingestServer) {
                  return _objectSpread3({
                    serverURL: "".concat(ingestServer, "/i"),
                    statsURL: "".concat(ingestServer, "/s")
                  }, options);
                }
                return options;
              };
              var LogRocket2 = /* @__PURE__ */ function() {
                function LogRocket3() {
                  var _this = this;
                  (0, _classCallCheck2.default)(this, LogRocket3);
                  this._buffer = [];
                  ["log", "info", "warn", "error", "debug"].forEach(function(method) {
                    _this[method] = function() {
                      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                      }
                      _this.addEvent("lr.core.LogEvent", function() {
                        var consoleOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                        if (method === "error" && consoleOptions.shouldAggregateConsoleErrors) {
                          _exceptions.Capture.captureMessage(_this, args[0], args, {}, true);
                        }
                        return {
                          logLevel: method.toUpperCase(),
                          args
                        };
                      }, {
                        shouldCaptureStackTrace: true
                      });
                    };
                  });
                  this._isInitialized = false;
                  this._installed = [];
                  window._lr_surl_cb = this.getSessionURL.bind(this);
                }
                (0, _createClass2.default)(LogRocket3, [{
                  key: "addEvent",
                  value: function addEvent(type3, getMessage) {
                    var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                    var time2 = Date.now();
                    this._run(function(logger) {
                      logger.addEvent(type3, getMessage, _objectSpread3(_objectSpread3({}, opts), {}, {
                        timeOverride: time2
                      }));
                    });
                  }
                }, {
                  key: "onLogger",
                  value: function onLogger(logger) {
                    this._logger = logger;
                    while (this._buffer.length > 0) {
                      var f2 = this._buffer.shift();
                      f2(this._logger);
                    }
                  }
                }, {
                  key: "_run",
                  value: function _run(f2) {
                    if (this._isDisabled) {
                      return;
                    }
                    if (this._logger) {
                      f2(this._logger);
                    } else {
                      if (this._buffer.length >= MAX_QUEUE_SIZE) {
                        this._isDisabled = true;
                        console.warn("LogRocket: script did not load. Check that you have a valid network connection.");
                        this.uninstall();
                        return;
                      }
                      this._buffer.push(f2.bind(this));
                    }
                  }
                }, {
                  key: "init",
                  value: function init2(appID) {
                    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    if (!this._isInitialized) {
                      var _opts$shouldAugmentNP = opts.shouldAugmentNPS, shouldAugmentNPS = _opts$shouldAugmentNP === void 0 ? true : _opts$shouldAugmentNP, _opts$shouldParseXHRB = opts.shouldParseXHRBlob, shouldParseXHRBlob = _opts$shouldParseXHRB === void 0 ? false : _opts$shouldParseXHRB, _opts$shouldDetectExc = opts.shouldDetectExceptions, shouldDetectExceptions = _opts$shouldDetectExc === void 0 ? true : _opts$shouldDetectExc;
                      if (shouldDetectExceptions) {
                        this._installed.push((0, _exceptions.registerExceptions)(this));
                      }
                      this._installed.push((0, _network.default)(this, {
                        shouldAugmentNPS: !!shouldAugmentNPS,
                        shouldParseXHRBlob: !!shouldParseXHRBlob
                      }));
                      this._installed.push((0, _console.default)(this));
                      this._isInitialized = true;
                      this._run(function(logger) {
                        logger.init(appID, considerIngestServerOption(opts));
                      });
                    }
                  }
                }, {
                  key: "start",
                  value: function start() {
                    this._run(function(logger) {
                      logger.start();
                    });
                  }
                }, {
                  key: "uninstall",
                  value: function uninstall() {
                    this._installed.forEach(function(f2) {
                      return f2();
                    });
                    this._buffer = [];
                    this._run(function(logger) {
                      logger.uninstall();
                    });
                  }
                }, {
                  key: "identify",
                  value: function identify(id2, opts) {
                    this._run(function(logger) {
                      logger.identify(id2, opts);
                    });
                  }
                }, {
                  key: "startNewSession",
                  value: function startNewSession() {
                    this._run(function(logger) {
                      logger.startNewSession();
                    });
                  }
                }, {
                  key: "track",
                  value: function track(customEventName, eventProperties) {
                    this._run(function(logger) {
                      logger.track(customEventName, eventProperties);
                    });
                  }
                }, {
                  key: "getSessionURL",
                  value: function getSessionURL(cb2) {
                    if (typeof cb2 !== "function") {
                      throw new Error("LogRocket: must pass callback to getSessionURL()");
                    }
                    this._run(function(logger) {
                      if (logger.getSessionURL) {
                        logger.getSessionURL(cb2);
                      } else {
                        cb2(logger.recordingURL);
                      }
                    });
                  }
                }, {
                  key: "getVersion",
                  value: function getVersion(cb2) {
                    this._run(function(logger) {
                      cb2(logger.version);
                    });
                  }
                }, {
                  key: "captureMessage",
                  value: function captureMessage(message) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    _exceptions.Capture.captureMessage(this, message, [message], options);
                  }
                }, {
                  key: "captureException",
                  value: function captureException(exception) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    _exceptions.Capture.captureException(this, exception, options);
                  }
                }, {
                  key: "version",
                  get: function get3() {
                    return this._logger && this._logger.version;
                  }
                }, {
                  key: "sessionURL",
                  get: function get3() {
                    return this._logger && this._logger.recordingURL;
                  }
                }, {
                  key: "recordingURL",
                  get: function get3() {
                    return this._logger && this._logger.recordingURL;
                  }
                }, {
                  key: "recordingID",
                  get: function get3() {
                    return this._logger && this._logger.recordingID;
                  }
                }, {
                  key: "threadID",
                  get: function get3() {
                    return this._logger && this._logger.threadID;
                  }
                }, {
                  key: "tabID",
                  get: function get3() {
                    return this._logger && this._logger.tabID;
                  }
                }, {
                  key: "reduxEnhancer",
                  value: function reduxEnhancer() {
                    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    return (0, _redux.createEnhancer)(this, options);
                  }
                }, {
                  key: "reduxMiddleware",
                  value: function reduxMiddleware() {
                    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    return (0, _redux.createMiddleware)(this, options);
                  }
                }, {
                  key: "isDisabled",
                  get: function get3() {
                    return !!(this._isDisabled || this._logger && this._logger._isDisabled);
                  }
                }]);
                return LogRocket3;
              }();
              exports2["default"] = LogRocket2;
            }
          ),
          /***/
          "./packages/logrocket/src/makeLogRocket.js": (
            /*!*************************************************!*\
              !*** ./packages/logrocket/src/makeLogRocket.js ***!
              \*************************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = makeLogRocket;
              var _LogRocket = _interopRequireDefault2(__webpack_require__2(
                /*! ./LogRocket */
                "./packages/logrocket/src/LogRocket.js"
              ));
              var REACT_NATIVE_NOTICE = "LogRocket does not yet support React Native.";
              var makeNoopPolyfill = function makeNoopPolyfill2() {
                return {
                  init: function init2() {
                  },
                  uninstall: function uninstall() {
                  },
                  log: function log2() {
                  },
                  info: function info() {
                  },
                  warn: function warn3() {
                  },
                  error: function error() {
                  },
                  debug: function debug() {
                  },
                  addEvent: function addEvent() {
                  },
                  identify: function identify() {
                  },
                  start: function start() {
                  },
                  get threadID() {
                    return null;
                  },
                  get recordingID() {
                    return null;
                  },
                  get recordingURL() {
                    return null;
                  },
                  reduxEnhancer: function reduxEnhancer() {
                    return function(store) {
                      return function() {
                        return store.apply(void 0, arguments);
                      };
                    };
                  },
                  reduxMiddleware: function reduxMiddleware() {
                    return function() {
                      return function(next) {
                        return function(action) {
                          return next(action);
                        };
                      };
                    };
                  },
                  track: function track() {
                  },
                  getSessionURL: function getSessionURL() {
                  },
                  getVersion: function getVersion() {
                  },
                  startNewSession: function startNewSession() {
                  },
                  onLogger: function onLogger() {
                  },
                  setClock: function setClock() {
                  },
                  captureMessage: function captureMessage() {
                  },
                  captureException: function captureException() {
                  }
                };
              };
              function makeLogRocket() {
                var getLogger = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
                };
                if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
                  throw new Error(REACT_NATIVE_NOTICE);
                }
                if (typeof window !== "undefined") {
                  if (window._disableLogRocket) {
                    return makeNoopPolyfill();
                  }
                  if (window.MutationObserver && window.WeakMap) {
                    window._lrMutationObserver = window.MutationObserver;
                    var instance = new _LogRocket.default();
                    getLogger(instance);
                    return instance;
                  }
                }
                return makeNoopPolyfill();
              }
            }
          ),
          /***/
          "./packages/logrocket/src/setup.js": (
            /*!*****************************************!*\
              !*** ./packages/logrocket/src/setup.js ***!
              \*****************************************/
            /***/
            function(__unused_webpack_module, exports2, __webpack_require__2) {
              var _interopRequireDefault2 = __webpack_require__2(
                /*! @babel/runtime/helpers/interopRequireDefault */
                "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
              );
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2["default"] = setup;
              var _objectWithoutProperties2 = _interopRequireDefault2(__webpack_require__2(
                /*! @babel/runtime/helpers/objectWithoutProperties */
                "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js"
              ));
              var _makeLogRocket = _interopRequireDefault2(__webpack_require__2(
                /*! ./makeLogRocket */
                "./packages/logrocket/src/makeLogRocket.js"
              ));
              var CDN_SERVER_MAP = {
                "cdn.logrocket.io": "https://r.logrocket.io",
                "cdn.lr-ingest.io": "https://r.lr-ingest.io",
                "cdn.lr-in.com": "https://r.lr-in.com",
                "cdn.lr-in-prod.com": "https://r.lr-in-prod.com",
                "cdn.lr-ingest.com": "https://r.lr-ingest.com",
                "cdn-staging.logrocket.io": "https://staging-i.logrocket.io",
                "cdn-staging.lr-ingest.io": "https://staging-i.lr-ingest.io",
                "cdn-staging.lr-in.com": "https://staging-i.lr-in.com",
                "cdn-staging.lr-in-prod.com": "https://staging-i.lr-in-prod.com",
                "cdn-staging.lr-ingest.com": "https://staging-i.lr-ingest.com"
              };
              function setup() {
                var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, enterpriseServer = _ref.enterpriseServer, _ref$sdkVersion = _ref.sdkVersion, sdkVersion = _ref$sdkVersion === void 0 ? "4.0.1" : _ref$sdkVersion, opts = (0, _objectWithoutProperties2.default)(_ref, ["enterpriseServer", "sdkVersion"]);
                var scriptOrigin = "https://cdn.logrocket.io";
                var scriptIngest;
                if (sdkVersion === "script") {
                  try {
                    var scriptTag = document.currentScript;
                    var matches2 = scriptTag.src.match(/^(https?:\/\/([^\\]+))\/.+$/);
                    var scriptHostname = matches2 && matches2[2];
                    if (scriptHostname && CDN_SERVER_MAP[scriptHostname]) {
                      scriptOrigin = matches2 && matches2[1];
                      scriptIngest = CDN_SERVER_MAP[scriptHostname];
                    }
                  } catch (_2) {
                  }
                } else {
                  scriptOrigin = "https://cdn.lr-ingest.com";
                  scriptIngest = "https://r.lr-ingest.com";
                }
                var sdkServer = opts.sdkServer || enterpriseServer;
                var ingestServer = opts.ingestServer || enterpriseServer || scriptIngest;
                var instance = (0, _makeLogRocket.default)(function() {
                  var script = document.createElement("script");
                  if (ingestServer) {
                    if (typeof window.__SDKCONFIG__ === "undefined") {
                      window.__SDKCONFIG__ = {};
                    }
                    window.__SDKCONFIG__.serverURL = "".concat(ingestServer, "/i");
                    window.__SDKCONFIG__.statsURL = "".concat(ingestServer, "/s");
                  }
                  if (sdkServer) {
                    script.src = "".concat(sdkServer, "/logger.min.js");
                  } else if (window.__SDKCONFIG__ && window.__SDKCONFIG__.loggerURL) {
                    script.src = window.__SDKCONFIG__.loggerURL;
                  } else if (window._lrAsyncScript) {
                    script.src = window._lrAsyncScript;
                  } else {
                    script.src = "".concat(scriptOrigin, "/logger-1.min.js");
                  }
                  script.async = true;
                  document.head.appendChild(script);
                  script.onload = function() {
                    if (typeof window._LRLogger === "function") {
                      instance.onLogger(new window._LRLogger({
                        sdkVersion
                      }));
                    } else {
                      console.warn("LogRocket: script execution has been blocked by a product or service.");
                      instance.uninstall();
                    }
                  };
                  script.onerror = function() {
                    console.warn("LogRocket: script could not load. Check that you have a valid network connection.");
                    instance.uninstall();
                  };
                });
                return instance;
              }
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js": (
            /*!*****************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
              \*****************************************************************/
            /***/
            function(module3) {
              function _arrayLikeToArray2(arr, len) {
                if (len == null || len > arr.length)
                  len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++)
                  arr2[i] = arr[i];
                return arr2;
              }
              module3.exports = _arrayLikeToArray2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js": (
            /*!******************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
              \******************************************************************/
            /***/
            function(module3, __unused_webpack_exports, __webpack_require__2) {
              var arrayLikeToArray = __webpack_require__2(
                /*! ./arrayLikeToArray.js */
                "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js"
              );
              function _arrayWithoutHoles2(arr) {
                if (Array.isArray(arr))
                  return arrayLikeToArray(arr);
              }
              module3.exports = _arrayWithoutHoles2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/classCallCheck.js": (
            /*!***************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
              \***************************************************************/
            /***/
            function(module3) {
              function _classCallCheck2(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              module3.exports = _classCallCheck2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/createClass.js": (
            /*!************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
              \************************************************************/
            /***/
            function(module3, __unused_webpack_exports, __webpack_require__2) {
              var toPropertyKey = __webpack_require__2(
                /*! ./toPropertyKey.js */
                "./node_modules/@babel/runtime/helpers/toPropertyKey.js"
              );
              function _defineProperties2(target, props3) {
                for (var i = 0; i < props3.length; i++) {
                  var descriptor = props3[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
                }
              }
              function _createClass2(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties2(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties2(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", {
                  writable: false
                });
                return Constructor;
              }
              module3.exports = _createClass2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/defineProperty.js": (
            /*!***************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
              \***************************************************************/
            /***/
            function(module3, __unused_webpack_exports, __webpack_require__2) {
              var toPropertyKey = __webpack_require__2(
                /*! ./toPropertyKey.js */
                "./node_modules/@babel/runtime/helpers/toPropertyKey.js"
              );
              function _defineProperty2(obj, key, value) {
                key = toPropertyKey(key);
                if (key in obj) {
                  Object.defineProperty(obj, key, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              module3.exports = _defineProperty2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/interopRequireDefault.js": (
            /*!**********************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
              \**********************************************************************/
            /***/
            function(module3) {
              function _interopRequireDefault2(obj) {
                return obj && obj.__esModule ? obj : {
                  "default": obj
                };
              }
              module3.exports = _interopRequireDefault2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/iterableToArray.js": (
            /*!****************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
              \****************************************************************/
            /***/
            function(module3) {
              function _iterableToArray2(iter) {
                if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                  return Array.from(iter);
              }
              module3.exports = _iterableToArray2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/nonIterableSpread.js": (
            /*!******************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
              \******************************************************************/
            /***/
            function(module3) {
              function _nonIterableSpread2() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              module3.exports = _nonIterableSpread2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js": (
            /*!************************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/objectWithoutProperties.js ***!
              \************************************************************************/
            /***/
            function(module3, __unused_webpack_exports, __webpack_require__2) {
              var objectWithoutPropertiesLoose = __webpack_require__2(
                /*! ./objectWithoutPropertiesLoose.js */
                "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"
              );
              function _objectWithoutProperties2(source, excluded) {
                if (source == null)
                  return {};
                var target = objectWithoutPropertiesLoose(source, excluded);
                var key, i;
                if (Object.getOwnPropertySymbols) {
                  var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
                  for (i = 0; i < sourceSymbolKeys.length; i++) {
                    key = sourceSymbolKeys[i];
                    if (excluded.indexOf(key) >= 0)
                      continue;
                    if (!Object.prototype.propertyIsEnumerable.call(source, key))
                      continue;
                    target[key] = source[key];
                  }
                }
                return target;
              }
              module3.exports = _objectWithoutProperties2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js": (
            /*!*****************************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js ***!
              \*****************************************************************************/
            /***/
            function(module3) {
              function _objectWithoutPropertiesLoose2(source, excluded) {
                if (source == null)
                  return {};
                var target = {};
                var sourceKeys = Object.keys(source);
                var key, i;
                for (i = 0; i < sourceKeys.length; i++) {
                  key = sourceKeys[i];
                  if (excluded.indexOf(key) >= 0)
                    continue;
                  target[key] = source[key];
                }
                return target;
              }
              module3.exports = _objectWithoutPropertiesLoose2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/toConsumableArray.js": (
            /*!******************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
              \******************************************************************/
            /***/
            function(module3, __unused_webpack_exports, __webpack_require__2) {
              var arrayWithoutHoles = __webpack_require__2(
                /*! ./arrayWithoutHoles.js */
                "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"
              );
              var iterableToArray = __webpack_require__2(
                /*! ./iterableToArray.js */
                "./node_modules/@babel/runtime/helpers/iterableToArray.js"
              );
              var unsupportedIterableToArray = __webpack_require__2(
                /*! ./unsupportedIterableToArray.js */
                "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"
              );
              var nonIterableSpread = __webpack_require__2(
                /*! ./nonIterableSpread.js */
                "./node_modules/@babel/runtime/helpers/nonIterableSpread.js"
              );
              function _toConsumableArray2(arr) {
                return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
              }
              module3.exports = _toConsumableArray2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/toPrimitive.js": (
            /*!************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
              \************************************************************/
            /***/
            function(module3, __unused_webpack_exports, __webpack_require__2) {
              var _typeof2 = __webpack_require__2(
                /*! ./typeof.js */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              )["default"];
              function _toPrimitive2(input, hint) {
                if (_typeof2(input) !== "object" || input === null)
                  return input;
                var prim = input[Symbol.toPrimitive];
                if (prim !== void 0) {
                  var res = prim.call(input, hint || "default");
                  if (_typeof2(res) !== "object")
                    return res;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return (hint === "string" ? String : Number)(input);
              }
              module3.exports = _toPrimitive2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/toPropertyKey.js": (
            /*!**************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
              \**************************************************************/
            /***/
            function(module3, __unused_webpack_exports, __webpack_require__2) {
              var _typeof2 = __webpack_require__2(
                /*! ./typeof.js */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              )["default"];
              var toPrimitive = __webpack_require__2(
                /*! ./toPrimitive.js */
                "./node_modules/@babel/runtime/helpers/toPrimitive.js"
              );
              function _toPropertyKey2(arg) {
                var key = toPrimitive(arg, "string");
                return _typeof2(key) === "symbol" ? key : String(key);
              }
              module3.exports = _toPropertyKey2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/typeof.js": (
            /*!*******************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
              \*******************************************************/
            /***/
            function(module3) {
              function _typeof2(obj) {
                "@babel/helpers - typeof";
                return module3.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
                  return typeof obj2;
                } : function(obj2) {
                  return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                }, module3.exports.__esModule = true, module3.exports["default"] = module3.exports, _typeof2(obj);
              }
              module3.exports = _typeof2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js": (
            /*!***************************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
              \***************************************************************************/
            /***/
            function(module3, __unused_webpack_exports, __webpack_require__2) {
              var arrayLikeToArray = __webpack_require__2(
                /*! ./arrayLikeToArray.js */
                "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js"
              );
              function _unsupportedIterableToArray2(o3, minLen) {
                if (!o3)
                  return;
                if (typeof o3 === "string")
                  return arrayLikeToArray(o3, minLen);
                var n2 = Object.prototype.toString.call(o3).slice(8, -1);
                if (n2 === "Object" && o3.constructor)
                  n2 = o3.constructor.name;
                if (n2 === "Map" || n2 === "Set")
                  return Array.from(o3);
                if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
                  return arrayLikeToArray(o3, minLen);
              }
              module3.exports = _unsupportedIterableToArray2, module3.exports.__esModule = true, module3.exports["default"] = module3.exports;
            }
          )
          /******/
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module3 = __webpack_module_cache__[moduleId] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          __webpack_modules__[moduleId](module3, module3.exports, __webpack_require__);
          return module3.exports;
        }
        !function() {
          __webpack_require__.g = function() {
            if (typeof globalThis === "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (e3) {
              if (typeof window === "object")
                return window;
            }
          }();
        }();
        var __webpack_exports__ = {};
        !function() {
          var exports2 = __webpack_exports__;
          /*!**********************************************!*\
            !*** ./packages/logrocket/src/module-npm.js ***!
            \**********************************************/
          var _interopRequireDefault2 = __webpack_require__(
            /*! @babel/runtime/helpers/interopRequireDefault */
            "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
          );
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2["default"] = void 0;
          var _setup = _interopRequireDefault2(__webpack_require__(
            /*! ./setup */
            "./packages/logrocket/src/setup.js"
          ));
          var instance = (0, _setup.default)();
          var _default2 = instance;
          exports2["default"] = _default2;
        }();
        __webpack_exports__ = __webpack_exports__["default"];
        return __webpack_exports__;
      }()
    );
  });
})(build_umd);
var build_umdExports = build_umd.exports;
const LogRocket = /* @__PURE__ */ getDefaultExportFromCjs(build_umdExports);
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = reactExports, k$1 = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
function q(c2, a2, g2) {
  var b2, d2 = {}, e3 = null, h2 = null;
  void 0 !== g2 && (e3 = "" + g2);
  void 0 !== a2.key && (e3 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$1.call(a2, b2) && !p.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$1, type: c2, key: e3, ref: h2, props: d2, _owner: n.current };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
const appsOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><rect x='64' y='64' width='80' height='80' rx='40' ry='40' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><rect x='216' y='64' width='80' height='80' rx='40' ry='40' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><rect x='368' y='64' width='80' height='80' rx='40' ry='40' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><rect x='64' y='216' width='80' height='80' rx='40' ry='40' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><rect x='216' y='216' width='80' height='80' rx='40' ry='40' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><rect x='368' y='216' width='80' height='80' rx='40' ry='40' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><rect x='64' y='368' width='80' height='80' rx='40' ry='40' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><rect x='216' y='368' width='80' height='80' rx='40' ry='40' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><rect x='368' y='368' width='80' height='80' rx='40' ry='40' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const arrowForward = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M268 112l144 144-144 144M392 256H100' class='ionicon-fill-none'/></svg>";
const arrowUndo = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M448 440a16 16 0 01-12.61-6.15c-22.86-29.27-44.07-51.86-73.32-67C335 352.88 301 345.59 256 344.23V424a16 16 0 01-27 11.57l-176-168a16 16 0 010-23.14l176-168A16 16 0 01256 88v80.36c74.14 3.41 129.38 30.91 164.35 81.87C449.32 292.44 464 350.9 464 424a16 16 0 01-16 16z'/></svg>";
const arrowUp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M112 244l144-144 144 144M256 120v292' class='ionicon-fill-none'/></svg>";
const balloon = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M391 307.27c32.75-46.35 46.59-101.63 39-155.68A175.82 175.82 0 00231.38 2c-96 13.49-163.14 102.58-149.65 198.58 7.57 53.89 36.12 103.16 80.37 138.74 24.58 19.68 52.31 33.5 78.62 39.68a8 8 0 016 9.22l-4.87 26.38a16.29 16.29 0 001.48 10.57 16 16 0 0014.2 8.61 15.21 15.21 0 002.23-.16l17.81-2.5a2 2 0 012.09 1.14c16.72 36.31 45.46 63.85 82.15 78.36a16 16 0 0021-9.65c2.83-8.18-1.64-17.07-9.68-20.28a118.57 118.57 0 01-59.3-51.88 2 2 0 011.45-3l7.4-1a16.54 16.54 0 0010.08-5.23 16 16 0 002.39-17.8l-12.06-24.23a8 8 0 013.26-10.55c23.59-13.17 46.45-34 64.65-59.73zm-154.9 16.78a16 16 0 01-5.88-1.12c-41.26-16.32-76.3-52.7-91.45-94.94a16 16 0 1130.12-10.8c14.5 40.44 47.27 65.77 73.1 76a16 16 0 01-5.89 30.88z'/></svg>";
const brush = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M233.15 360.11a15.7 15.7 0 01-4.92-.77 16 16 0 01-10.92-13c-2.15-15-19.95-32.46-36.62-35.85a16 16 0 01-8.69-26.33l211.09-235.1c.19-.22.39-.43.59-.63a56.57 56.57 0 0179.89 0 56.51 56.51 0 01.11 79.78l-219 227a16 16 0 01-11.53 4.9zM119.89 480.11c-32.14 0-65.45-16.89-84.85-43a16 16 0 0112.85-25.54c5.34 0 20-4.87 20-20.57 0-39.07 31.4-70.86 70-70.86s70 31.79 70 70.86c0 49.12-39.48 89.11-88 89.11z'/></svg>";
const business = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M432 176H320V64a48 48 0 00-48-48H80a48 48 0 00-48 48v416a16 16 0 0016 16h104a8 8 0 008-8v-71.55c0-8.61 6.62-16 15.23-16.43A16 16 0 01192 416v72a8 8 0 008 8h264a16 16 0 0016-16V224a48 48 0 00-48-48zM98.08 431.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm0-80a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm0-80a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm0-80a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm0-80a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm80 240a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm0-80a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm0-80a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm0-80a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm80 320a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm0-80a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm0-80a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm0-80a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zm0-80a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM444 464H320V208h112a16 16 0 0116 16v236a4 4 0 01-4 4z'/><path d='M400 400a16 16 0 1016 16 16 16 0 00-16-16zM400 320a16 16 0 1016 16 16 16 0 00-16-16zM400 240a16 16 0 1016 16 16 16 0 00-16-16zM336 400a16 16 0 1016 16 16 16 0 00-16-16zM336 320a16 16 0 1016 16 16 16 0 00-16-16zM336 240a16 16 0 1016 16 16 16 0 00-16-16z'/></svg>";
const businessOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' d='M176 416v64M80 32h192a32 32 0 0132 32v412a4 4 0 01-4 4H48h0V64a32 32 0 0132-32zM320 192h112a32 32 0 0132 32v256h0-160 0V208a16 16 0 0116-16z' class='ionicon-fill-none ionicon-stroke-width'/><path d='M98.08 431.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM98.08 351.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM98.08 271.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM98.08 191.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM98.08 111.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM178.08 351.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM178.08 271.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM178.08 191.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM178.08 111.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM258.08 431.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM258.08 351.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM258.08 271.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79z'/><ellipse cx='256' cy='176' rx='15.95' ry='16.03' transform='rotate(-45 255.99 175.996)'/><path d='M258.08 111.87a16 16 0 1113.79-13.79 16 16 0 01-13.79 13.79zM400 400a16 16 0 1016 16 16 16 0 00-16-16zM400 320a16 16 0 1016 16 16 16 0 00-16-16zM400 240a16 16 0 1016 16 16 16 0 00-16-16zM336 400a16 16 0 1016 16 16 16 0 00-16-16zM336 320a16 16 0 1016 16 16 16 0 00-16-16zM336 240a16 16 0 1016 16 16 16 0 00-16-16z'/></svg>";
const calendarOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><rect stroke-linejoin='round' x='48' y='80' width='416' height='384' rx='48' class='ionicon-fill-none ionicon-stroke-width'/><circle cx='296' cy='232' r='24'/><circle cx='376' cy='232' r='24'/><circle cx='296' cy='312' r='24'/><circle cx='376' cy='312' r='24'/><circle cx='136' cy='312' r='24'/><circle cx='216' cy='312' r='24'/><circle cx='136' cy='392' r='24'/><circle cx='216' cy='392' r='24'/><circle cx='296' cy='392' r='24'/><path stroke-linejoin='round' stroke-linecap='round' d='M128 48v32M384 48v32' class='ionicon-fill-none ionicon-stroke-width'/><path stroke-linejoin='round' d='M464 160H48' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const chatbubblesOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M431 320.6c-1-3.6 1.2-8.6 3.3-12.2a33.68 33.68 0 012.1-3.1A162 162 0 00464 215c.3-92.2-77.5-167-173.7-167-83.9 0-153.9 57.1-170.3 132.9a160.7 160.7 0 00-3.7 34.2c0 92.3 74.8 169.1 171 169.1 15.3 0 35.9-4.6 47.2-7.7s22.5-7.2 25.4-8.3a26.44 26.44 0 019.3-1.7 26 26 0 0110.1 2l56.7 20.1a13.52 13.52 0 003.9 1 8 8 0 008-8 12.85 12.85 0 00-.5-2.7z' stroke-linecap='round' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><path d='M66.46 232a146.23 146.23 0 006.39 152.67c2.31 3.49 3.61 6.19 3.21 8s-11.93 61.87-11.93 61.87a8 8 0 002.71 7.68A8.17 8.17 0 0072 464a7.26 7.26 0 002.91-.6l56.21-22a15.7 15.7 0 0112 .2c18.94 7.38 39.88 12 60.83 12A159.21 159.21 0 00284 432.11' stroke-linecap='round' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const checkmark = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' d='M416 128L192 384l-96-96' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const checkmarkCircle = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm108.25 138.29l-134.4 160a16 16 0 01-12 5.71h-.27a16 16 0 01-11.89-5.3l-57.6-64a16 16 0 1123.78-21.4l45.29 50.32 122.59-145.91a16 16 0 0124.5 20.58z'/></svg>";
const chevronBackOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M328 112L184 256l144 144' class='ionicon-fill-none'/></svg>";
const close = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z'/></svg>";
const closeCircle = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm75.31 260.69a16 16 0 11-22.62 22.62L256 278.63l-52.69 52.68a16 16 0 01-22.62-22.62L233.37 256l-52.68-52.69a16 16 0 0122.62-22.62L256 233.37l52.69-52.68a16 16 0 0122.62 22.62L278.63 256z'/></svg>";
const closeCircleOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M448 256c0-106-86-192-192-192S64 150 64 256s86 192 192 192 192-86 192-192z' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><path stroke-linecap='round' stroke-linejoin='round' d='M320 320L192 192M192 320l128-128' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const contract = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' d='M304 416V304h112M314.2 314.23L432 432M208 96v112H96M197.8 197.77L80 80M416 208H304V96M314.23 197.8L432 80M96 304h112v112M197.77 314.2L80 432' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const ellipse = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 464c-114.69 0-208-93.31-208-208S141.31 48 256 48s208 93.31 208 208-93.31 208-208 208z'/></svg>";
const ellipseOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><circle cx='256' cy='256' r='192' stroke-linecap='round' stroke-linejoin='round' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const flash = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M194.82 496a18.36 18.36 0 01-18.1-21.53v-.11L204.83 320H96a16 16 0 01-12.44-26.06L302.73 23a18.45 18.45 0 0132.8 13.71c0 .3-.08.59-.13.89L307.19 192H416a16 16 0 0112.44 26.06L209.24 489a18.45 18.45 0 01-14.42 7z'/></svg>";
const flashOff = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M432 448a15.92 15.92 0 01-11.31-4.69l-352-352a16 16 0 0122.62-22.62l352 352A16 16 0 01432 448zM431.5 204a16 16 0 00-15.5-12H307.19L335.4 37.63c.05-.3.1-.59.13-.89A18.45 18.45 0 00302.73 23l-92.58 114.46a4 4 0 00.29 5.35l151 151a4 4 0 005.94-.31l60.8-75.16A16.37 16.37 0 00431.5 204zM301.57 369.19l-151-151a4 4 0 00-5.93.31L83.8 293.64A16.37 16.37 0 0080.5 308 16 16 0 0096 320h108.83l-28.09 154.36v.11a18.37 18.37 0 0032.5 14.53l92.61-114.46a4 4 0 00-.28-5.35z'/></svg>";
const flashlight = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M462 216c9.35-9.35 15.14-19.09 17.19-28.95 2.7-12.95-1.29-25.55-11.22-35.48L360.43 44.05C346.29 29.92 322 24.07 296 50l-2 2a8 8 0 000 11.32L448.64 218a8 8 0 0011.36 0zM250.14 153.08l-.16 2.34c-.53 7.18-6.88 19.15-13.88 26.14L47.27 370.36c-11.12 11.11-16.46 25.57-15.05 40.7C33.49 424.58 40.16 438 51 448.83L63.17 461c12.61 12.6 27.78 19 42.49 19a50.4 50.4 0 0036-15.24l188.84-188.8c7.07-7.07 18.84-13.3 26.17-13.87 17.48-1.32 43.57-3.28 67.79-15.65a4 4 0 001-6.37L271.69 86.31a4 4 0 00-6.39 1c-12.12 22.99-13.82 46.91-15.16 65.77zm-9.95 146.83a20 20 0 110-25.25 20 20 0 010 25.25z'/></svg>";
const help = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M160 164s1.44-33 33.54-59.46C212.6 88.83 235.49 84.28 256 84c18.73-.23 35.47 2.94 45.48 7.82C318.59 100.2 352 120.6 352 164c0 45.67-29.18 66.37-62.35 89.18S248 298.36 248 324' stroke-linecap='round' stroke-miterlimit='10' stroke-width='40' class='ionicon-fill-none'/><circle cx='248' cy='399.99' r='32'/></svg>";
const home = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M261.56 101.28a8 8 0 00-11.06 0L66.4 277.15a8 8 0 00-2.47 5.79L63.9 448a32 32 0 0032 32H192a16 16 0 0016-16V328a8 8 0 018-8h80a8 8 0 018 8v136a16 16 0 0016 16h96.06a32 32 0 0032-32V282.94a8 8 0 00-2.47-5.79z'/><path d='M490.91 244.15l-74.8-71.56V64a16 16 0 00-16-16h-48a16 16 0 00-16 16v32l-57.92-55.38C272.77 35.14 264.71 32 256 32c-8.68 0-16.72 3.14-22.14 8.63l-212.7 203.5c-6.22 6-7 15.87-1.34 22.37A16 16 0 0043 267.56L250.5 69.28a8 8 0 0111.06 0l207.52 198.28a16 16 0 0022.59-.44c6.14-6.36 5.63-16.86-.76-22.97z'/></svg>";
const informationCircle = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 56C145.72 56 56 145.72 56 256s89.72 200 200 200 200-89.72 200-200S366.28 56 256 56zm0 82a26 26 0 11-26 26 26 26 0 0126-26zm48 226h-88a16 16 0 010-32h28v-88h-16a16 16 0 010-32h32a16 16 0 0116 16v104h28a16 16 0 010 32z'/></svg>";
const informationCircleOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M248 64C146.39 64 64 146.39 64 248s82.39 184 184 184 184-82.39 184-184S349.61 64 248 64z' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><path stroke-linecap='round' stroke-linejoin='round' d='M220 220h32v116' class='ionicon-fill-none ionicon-stroke-width'/><path stroke-linecap='round' stroke-miterlimit='10' d='M208 340h88' class='ionicon-fill-none ionicon-stroke-width'/><path d='M248 130a26 26 0 1026 26 26 26 0 00-26-26z'/></svg>";
const link = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M200.66 352H144a96 96 0 010-192h55.41M312.59 160H368a96 96 0 010 192h-56.66M169.07 256h175.86' stroke-linecap='round' stroke-linejoin='round' stroke-width='48' class='ionicon-fill-none'/></svg>";
const listCircle = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm-88 302a24 24 0 1124-24 24 24 0 01-24 24zm0-71a24 24 0 1124-24 24 24 0 01-24 24zm0-73a24 24 0 1124-24 24 24 0 01-24 24zm184 135H224a16 16 0 010-32h128a16 16 0 010 32zm0-71H224a16 16 0 010-32h128a16 16 0 010 32zm0-72H224a16 16 0 010-32h128a16 16 0 010 32z'/></svg>";
const locateOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M256 96V56M256 456v-40' class='ionicon-fill-none'/><path d='M256 112a144 144 0 10144 144 144 144 0 00-144-144z' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M416 256h40M56 256h40' class='ionicon-fill-none'/></svg>";
const logOutOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M304 336v40a40 40 0 01-40 40H104a40 40 0 01-40-40V136a40 40 0 0140-40h152c22.09 0 48 17.91 48 40v40M368 336l80-80-80-80M176 256h256' stroke-linecap='round' stroke-linejoin='round' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const menu = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-miterlimit='10' stroke-width='48' d='M88 152h336M88 256h336M88 360h336' class='ionicon-fill-none'/></svg>";
const moon = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M264 480A232 232 0 0132 248c0-94 54-178.28 137.61-214.67a16 16 0 0121.06 21.06C181.07 76.43 176 104.66 176 136c0 110.28 89.72 200 200 200 31.34 0 59.57-5.07 81.61-14.67a16 16 0 0121.06 21.06C442.28 426 358 480 264 480z'/></svg>";
const navigate = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M272 464a16 16 0 01-16-16.42V264.13a8 8 0 00-8-8H64.41a16.31 16.31 0 01-15.49-10.65 16 16 0 018.41-19.87l384-176.15a16 16 0 0121.22 21.19l-176 384A16 16 0 01272 464z'/></svg>";
const pencil = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' stroke-width='44' d='M358.62 129.28L86.49 402.08 70 442l39.92-16.49 272.8-272.13-24.1-24.1zM413.07 74.84l-11.79 11.78 24.1 24.1 11.79-11.79a16.51 16.51 0 000-23.34l-.75-.75a16.51 16.51 0 00-23.35 0z' class='ionicon-fill-none'/></svg>";
const personCircle = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm-50.22 116.82C218.45 151.39 236.28 144 256 144s37.39 7.44 50.11 20.94c12.89 13.68 19.16 32.06 17.68 51.82C320.83 256 290.43 288 256 288s-64.89-32-67.79-71.25c-1.47-19.92 4.79-38.36 17.57-51.93zM256 432a175.49 175.49 0 01-126-53.22 122.91 122.91 0 0135.14-33.44C190.63 329 222.89 320 256 320s65.37 9 90.83 25.34A122.87 122.87 0 01382 378.78 175.45 175.45 0 01256 432z'/></svg>";
const pin = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M336 96a80 80 0 10-96 78.39v283.17a32.09 32.09 0 002.49 12.38l10.07 24a3.92 3.92 0 006.88 0l10.07-24a32.09 32.09 0 002.49-12.38V174.39A80.13 80.13 0 00336 96zm-56 0a24 24 0 1124-24 24 24 0 01-24 24z'/></svg>";
const pulseOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' d='M48 320h64l64-256 64 384 64-224 32 96h64' class='ionicon-fill-none ionicon-stroke-width'/><circle cx='432' cy='320' r='32' stroke-linecap='round' stroke-linejoin='round' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const radio = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><circle cx='256' cy='256' r='36'/><path d='M190.24 341.77a22 22 0 01-16.46-7.38 118 118 0 010-156.76 22 22 0 1132.87 29.24 74 74 0 000 98.29 22 22 0 01-16.43 36.61zM321.76 341.77a22 22 0 01-16.43-36.61 74 74 0 000-98.29 22 22 0 1132.87-29.24 118 118 0 010 156.76 22 22 0 01-16.44 7.38z'/><path d='M139.29 392.72a21.92 21.92 0 01-16.08-7 190 190 0 010-259.49 22 22 0 1132.13 30.06 146 146 0 000 199.38 22 22 0 01-16.06 37zM372.71 392.72a22 22 0 01-16.06-37 146 146 0 000-199.38 22 22 0 1132.13-30.06 190 190 0 010 259.49 21.92 21.92 0 01-16.07 6.95z'/><path d='M429 438a22 22 0 01-16.39-36.67 218.34 218.34 0 000-290.66 22 22 0 0132.78-29.34 262.34 262.34 0 010 349.34A22 22 0 01429 438zM83 438a21.94 21.94 0 01-16.41-7.33 262.34 262.34 0 010-349.34 22 22 0 0132.78 29.34 218.34 218.34 0 000 290.66A22 22 0 0183 438z'/></svg>";
const readerOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><rect x='96' y='48' width='320' height='416' rx='48' ry='48' stroke-linejoin='round' class='ionicon-fill-none ionicon-stroke-width'/><path stroke-linecap='round' stroke-linejoin='round' d='M176 128h160M176 208h160M176 288h80' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const reloadCircle = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm120 182.15a8.62 8.62 0 01-8.62 8.62h-59.54a8.61 8.61 0 01-6.09-14.71l22.17-22.17-5.6-6.51a87.38 87.38 0 10-62.94 148 87.55 87.55 0 0082.42-58.25A16 16 0 11368 295.8a119.4 119.4 0 11-112.62-159.18 118.34 118.34 0 0186.36 36.95l.56.62 4.31 5 14.68-14.68a8.44 8.44 0 016-2.54 8.61 8.61 0 018.68 8.63z'/></svg>";
const search = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M456.69 421.39L362.6 327.3a173.81 173.81 0 0034.84-104.58C397.44 126.38 319.06 48 222.72 48S48 126.38 48 222.72s78.38 174.72 174.72 174.72A173.81 173.81 0 00327.3 362.6l94.09 94.09a25 25 0 0035.3-35.3zM97.92 222.72a124.8 124.8 0 11124.8 124.8 124.95 124.95 0 01-124.8-124.8z'/></svg>";
const send = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M476.59 227.05l-.16-.07L49.35 49.84A23.56 23.56 0 0027.14 52 24.65 24.65 0 0016 72.59v113.29a24 24 0 0019.52 23.57l232.93 43.07a4 4 0 010 7.86L35.53 303.45A24 24 0 0016 327v113.31A23.57 23.57 0 0026.59 460a23.94 23.94 0 0013.22 4 24.55 24.55 0 009.52-1.93L476.4 285.94l.19-.09a32 32 0 000-58.8z'/></svg>";
const settings = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><circle cx='256' cy='256' r='48'/><path d='M470.39 300l-.47-.38-31.56-24.75a16.11 16.11 0 01-6.1-13.33v-11.56a16 16 0 016.11-13.22L469.92 212l.47-.38a26.68 26.68 0 005.9-34.06l-42.71-73.9a1.59 1.59 0 01-.13-.22A26.86 26.86 0 00401 92.14l-.35.13-37.1 14.93a15.94 15.94 0 01-14.47-1.29q-4.92-3.1-10-5.86a15.94 15.94 0 01-8.19-11.82l-5.59-39.59-.12-.72A27.22 27.22 0 00298.76 26h-85.52a26.92 26.92 0 00-26.45 22.39l-.09.56-5.57 39.67a16 16 0 01-8.13 11.82 175.21 175.21 0 00-10 5.82 15.92 15.92 0 01-14.43 1.27l-37.13-15-.35-.14a26.87 26.87 0 00-32.48 11.34l-.13.22-42.77 73.95a26.71 26.71 0 005.9 34.1l.47.38 31.56 24.75a16.11 16.11 0 016.1 13.33v11.56a16 16 0 01-6.11 13.22L42.08 300l-.47.38a26.68 26.68 0 00-5.9 34.06l42.71 73.9a1.59 1.59 0 01.13.22 26.86 26.86 0 0032.45 11.3l.35-.13 37.07-14.93a15.94 15.94 0 0114.47 1.29q4.92 3.11 10 5.86a15.94 15.94 0 018.19 11.82l5.56 39.59.12.72A27.22 27.22 0 00213.24 486h85.52a26.92 26.92 0 0026.45-22.39l.09-.56 5.57-39.67a16 16 0 018.18-11.82c3.42-1.84 6.76-3.79 10-5.82a15.92 15.92 0 0114.43-1.27l37.13 14.95.35.14a26.85 26.85 0 0032.48-11.34 2.53 2.53 0 01.13-.22l42.71-73.89a26.7 26.7 0 00-5.89-34.11zm-134.48-40.24a80 80 0 11-83.66-83.67 80.21 80.21 0 0183.66 83.67z'/></svg>";
const shuffle = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' d='M400 304l48 48-48 48M400 112l48 48-48 48M64 352h85.19a80 80 0 0066.56-35.62L256 256' class='ionicon-fill-none ionicon-stroke-width'/><path d='M64 160h85.19a80 80 0 0166.56 35.62l80.5 120.76A80 80 0 00362.81 352H416M416 160h-53.19a80 80 0 00-66.56 35.62L288 208' stroke-linecap='round' stroke-linejoin='round' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const skull = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M402 76.94C362.61 37.63 310.78 16 256 16h-.37A208 208 0 0048 224v100.67A79.62 79.62 0 0098.29 399l23.71 9.42a15.92 15.92 0 019.75 11.72l10 50.13A32.09 32.09 0 00173.12 496H184a8 8 0 008-8v-39.55c0-8.61 6.62-16 15.23-16.43A16 16 0 01224 448v40a8 8 0 008 8 8 8 0 008-8v-39.55c0-8.61 6.62-16 15.23-16.43A16 16 0 01272 448v40a8 8 0 008 8 8 8 0 008-8v-39.55c0-8.61 6.62-16 15.23-16.43A16 16 0 01320 448v40a8 8 0 008 8h10.88a32.09 32.09 0 0031.38-25.72l10-50.14a16 16 0 019.74-11.72l23.71-9.42A79.62 79.62 0 00464 324.67v-99c0-56-22-108.81-62-148.73zM171.66 335.88a56 56 0 1152.22-52.22 56 56 0 01-52.22 52.22zM281 397.25a16.37 16.37 0 01-9.3 2.75h-31.4a16.37 16.37 0 01-9.28-2.75 16 16 0 01-6.6-16.9l15.91-47.6C243 326 247.25 321 254 320.13c8.26-1 14 2.87 17.61 12.22l16 48a16 16 0 01-6.61 16.9zm66.68-61.37a56 56 0 1152.22-52.22 56 56 0 01-52.24 52.22z'/></svg>";
const star$1 = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M394 480a16 16 0 01-9.39-3L256 383.76 127.39 477a16 16 0 01-24.55-18.08L153 310.35 23 221.2a16 16 0 019-29.2h160.38l48.4-148.95a16 16 0 0130.44 0l48.4 149H480a16 16 0 019.05 29.2L359 310.35l50.13 148.53A16 16 0 01394 480z'/></svg>";
const timerOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M112.91 128A191.85 191.85 0 0064 254c-1.18 106.35 85.65 193.8 192 194 106.2.2 192-85.83 192-192 0-104.54-83.55-189.61-187.5-192a4.36 4.36 0 00-4.5 4.37V152' stroke-linecap='round' stroke-linejoin='round' class='ionicon-fill-none ionicon-stroke-width'/><path d='M233.38 278.63l-79-113a8.13 8.13 0 0111.32-11.32l113 79a32.5 32.5 0 01-37.25 53.26 33.21 33.21 0 01-8.07-7.94z'/></svg>";
const trash = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M296 64h-80a7.91 7.91 0 00-8 8v24h96V72a7.91 7.91 0 00-8-8z' class='ionicon-fill-none'/><path d='M432 96h-96V72a40 40 0 00-40-40h-80a40 40 0 00-40 40v24H80a16 16 0 000 32h17l19 304.92c1.42 26.85 22 47.08 48 47.08h184c26.13 0 46.3-19.78 48-47l19-305h17a16 16 0 000-32zM192.57 416H192a16 16 0 01-16-15.43l-8-224a16 16 0 1132-1.14l8 224A16 16 0 01192.57 416zM272 400a16 16 0 01-32 0V176a16 16 0 0132 0zm32-304h-96V72a7.91 7.91 0 018-8h80a7.91 7.91 0 018 8zm32 304.57A16 16 0 01320 416h-.58A16 16 0 01304 399.43l8-224a16 16 0 1132 1.14z'/></svg>";
const videocamOff = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M336 179.52A67.52 67.52 0 00268.48 112h-79.2a4 4 0 00-2.82 6.83l142.71 142.71a4 4 0 006.83-2.82zM16 180v152a68 68 0 0068 68h184a67.66 67.66 0 0042.84-15.24 4 4 0 00.33-6L54.41 122a4 4 0 00-4.87-.62A68 68 0 0016 180zM464 384.39a32 32 0 01-13-2.77 15.77 15.77 0 01-2.71-1.54l-82.71-58.22A32 32 0 01352 295.7v-79.4a32 32 0 0113.58-26.16l82.71-58.22a15.77 15.77 0 012.71-1.54 32 32 0 0145 29.24v192.76a32 32 0 01-32 32z'/><path stroke-linecap='round' stroke-miterlimit='10' d='M416 416L80 80' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
const walk$2 = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M312.55 479.9l-56.42-114-44.62-57a72.37 72.37 0 01-10.06-36.9V143.64H217a40 40 0 0140 40v182.21' stroke-linecap='round' stroke-linejoin='round' class='ionicon-stroke-width'/><path d='M127.38 291.78v-74.07s37-74.07 74.07-74.07' stroke-linecap='round' stroke-linejoin='round' class='ionicon-fill-none ionicon-stroke-width'/><path d='M368.09 291.78a18.49 18.49 0 01-10.26-3.11L297.7 250a21.18 21.18 0 01-9.7-17.79v-23.7a5.65 5.65 0 018.69-4.77l81.65 54.11a18.52 18.52 0 01-10.29 33.93zM171.91 493.47a18.5 18.5 0 01-14.83-7.41c-6.14-8.18-4-17.18 3.7-25.92l59.95-74.66a7.41 7.41 0 0110.76 2.06c1.56 2.54 3.38 5.65 5.19 9.09 5.24 9.95 6 16.11-1.68 25.7-8 10-52 67.44-52 67.44-2.62 2.98-7.23 3.7-11.09 3.7z'/><circle cx='257' cy='69.56' r='37.04' stroke-linecap='round' stroke-linejoin='round' stroke-width='16'/></svg>";
const warning = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M449.07 399.08L278.64 82.58c-12.08-22.44-44.26-22.44-56.35 0L51.87 399.08A32 32 0 0080 446.25h340.89a32 32 0 0028.18-47.17zm-198.6-1.83a20 20 0 1120-20 20 20 0 01-20 20zm21.72-201.15l-5.74 122a16 16 0 01-32 0l-5.74-121.95a21.73 21.73 0 0121.5-22.69h.21a21.74 21.74 0 0121.73 22.7z'/></svg>";
const wifi = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M346.65 304.3a136 136 0 00-180.71 0 21 21 0 1027.91 31.38 94 94 0 01124.89 0 21 21 0 0027.91-31.4z'/><path d='M256.28 183.7a221.47 221.47 0 00-151.8 59.92 21 21 0 1028.68 30.67 180.28 180.28 0 01246.24 0 21 21 0 1028.68-30.67 221.47 221.47 0 00-151.8-59.92z'/><path d='M462 175.86a309 309 0 00-411.44 0 21 21 0 1028 31.29 267 267 0 01355.43 0 21 21 0 0028-31.31z'/><circle cx='256.28' cy='393.41' r='32'/></svg>";
const wine = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path d='M414.56 94.92V80a16 16 0 00-16-16H113.44a16 16 0 00-16 16v14.92c-1.46 11.37-9.65 90.74 36.93 144.69 24.87 28.8 60.36 44.85 105.63 47.86V416h-80a16 16 0 000 32h192a16 16 0 000-32h-80V287.47c45.27-3 80.76-19.06 105.63-47.86 46.58-53.95 38.37-133.32 36.93-144.69zm-285.3 3.41a15.14 15.14 0 00.18-2.33h253.12a15.14 15.14 0 00.18 2.33 201.91 201.91 0 010 45.67H129.32a204.29 204.29 0 01-.06-45.67z'/></svg>";
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray$f(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject$b(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a2, b2) {
  return Object.prototype.hasOwnProperty.call(a2, b2);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k2;
    for (k2 in obj) {
      if (hasOwnProp(obj, k2)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input) {
  return input === void 0;
}
function isNumber$3(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map$4(arr, fn2) {
  var res = [], i, arrLen = arr.length;
  for (i = 0; i < arrLen; ++i) {
    res.push(fn2(arr[i], i));
  }
  return res;
}
function extend$4(a2, b2) {
  for (var i in b2) {
    if (hasOwnProp(b2, i)) {
      a2[i] = b2[i];
    }
  }
  if (hasOwnProp(b2, "toString")) {
    a2.toString = b2.toString;
  }
  if (hasOwnProp(b2, "valueOf")) {
    a2.valueOf = b2.valueOf;
  }
  return a2;
}
function createUTC(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m2) {
  if (m2._pf == null) {
    m2._pf = defaultParsingFlags();
  }
  return m2._pf;
}
var some$1;
if (Array.prototype.some) {
  some$1 = Array.prototype.some;
} else {
  some$1 = function(fun) {
    var t2 = Object(this), len = t2.length >>> 0, i;
    for (i = 0; i < len; i++) {
      if (i in t2 && fun.call(this, t2[i], i, t2)) {
        return true;
      }
    }
    return false;
  };
}
function isValid(m2) {
  if (m2._isValid == null) {
    var flags2 = getParsingFlags(m2), parsedParts = some$1.call(flags2.parsedDateParts, function(i) {
      return i != null;
    }), isNowValid = !isNaN(m2._d.getTime()) && flags2.overflow < 0 && !flags2.empty && !flags2.invalidEra && !flags2.invalidMonth && !flags2.invalidWeekday && !flags2.weekdayMismatch && !flags2.nullInput && !flags2.invalidFormat && !flags2.userInvalidated && (!flags2.meridiem || flags2.meridiem && parsedParts);
    if (m2._strict) {
      isNowValid = isNowValid && flags2.charsLeftOver === 0 && flags2.unusedTokens.length === 0 && flags2.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m2)) {
      m2._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m2._isValid;
}
function createInvalid(flags2) {
  var m2 = createUTC(NaN);
  if (flags2 != null) {
    extend$4(getParsingFlags(m2), flags2);
  } else {
    getParsingFlags(m2).userInvalidated = true;
  }
  return m2;
}
var momentProperties = hooks.momentProperties = [], updateInProgress = false;
function copyConfig(to2, from2) {
  var i, prop3, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i = 0; i < momentPropertiesLen; i++) {
      prop3 = momentProperties[i];
      val = from2[prop3];
      if (!isUndefined(val)) {
        to2[prop3] = val;
      }
    }
  }
  return to2;
}
function Moment(config2) {
  copyConfig(this, config2);
  this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn$1(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn2) {
  var firstTime = true;
  return extend$4(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i, key, argLen = arguments.length;
      for (i = 0; i < argLen; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += "\n[" + i + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn$1(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn2.apply(this, arguments);
  }, fn2);
}
var deprecations = {};
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn$1(msg);
    deprecations[name] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction$4(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set2(config2) {
  var prop3, i;
  for (i in config2) {
    if (hasOwnProp(config2, i)) {
      prop3 = config2[i];
      if (isFunction$4(prop3)) {
        this[i] = prop3;
      } else {
        this["_" + i] = prop3;
      }
    }
  }
  this._config = config2;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend$4({}, parentConfig), prop3;
  for (prop3 in childConfig) {
    if (hasOwnProp(childConfig, prop3)) {
      if (isObject$b(parentConfig[prop3]) && isObject$b(childConfig[prop3])) {
        res[prop3] = {};
        extend$4(res[prop3], parentConfig[prop3]);
        extend$4(res[prop3], childConfig[prop3]);
      } else if (childConfig[prop3] != null) {
        res[prop3] = childConfig[prop3];
      } else {
        delete res[prop3];
      }
    }
  }
  for (prop3 in parentConfig) {
    if (hasOwnProp(parentConfig, prop3) && !hasOwnProp(childConfig, prop3) && isObject$b(parentConfig[prop3])) {
      res[prop3] = extend$4({}, res[prop3]);
    }
  }
  return res;
}
function Locale2(config2) {
  if (config2 != null) {
    this.set(config2);
  }
}
var keys$5;
if (Object.keys) {
  keys$5 = Object.keys;
} else {
  keys$5 = function(obj) {
    var i, res = [];
    for (i in obj) {
      if (hasOwnProp(obj, i)) {
        res.push(i);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar$1(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction$4(output) ? output.call(mom, now2) : output;
}
function zeroFill(number2, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number2), zerosToFill = targetLength - absNumber.length, sign2 = number2 >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback) {
  var func3 = callback;
  if (typeof callback === "string") {
    func3 = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func3;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func3.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func3.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array3 = format2.match(formattingTokens), i, length3;
  for (i = 0, length3 = array3.length; i < length3; i++) {
    if (formatTokenFunctions[array3[i]]) {
      array3[i] = formatTokenFunctions[array3[i]];
    } else {
      array3[i] = removeFormattingTokens(array3[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0; i2 < length3; i2++) {
      output += isFunction$4(array3[i2]) ? array3[i2].call(mom, format2) : array3[i2];
    }
    return output;
  };
}
function formatMoment(m2, format2) {
  if (!m2.isValid()) {
    return m2.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m2.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m2);
}
function expandFormat(format2, locale2) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }
  return format2;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal$1(number2) {
  return this._ordinal.replace("%d", number2);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number2, withoutSuffix, string4, isFuture) {
  var output = this._relativeTime[string4];
  return isFunction$4(output) ? output(number2, withoutSuffix, string4, isFuture) : output.replace(/%d/i, number2);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction$4(format2) ? format2(output) : format2.replace(/%s/i, output);
}
var aliases = {};
function addUnitAlias(unit2, shorthand) {
  var lowerCase = unit2.toLowerCase();
  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit2;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop3;
  for (prop3 in inputObject) {
    if (hasOwnProp(inputObject, prop3)) {
      normalizedProp = normalizeUnits(prop3);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop3];
      }
    }
  }
  return normalizedInput;
}
var priorities = {};
function addUnitPriority(unit2, priority) {
  priorities[unit2] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u2;
  for (u2 in unitsObj) {
    if (hasOwnProp(unitsObj, u2)) {
      units.push({ unit: u2, priority: priorities[u2] });
    }
  }
  units.sort(function(a2, b2) {
    return a2.priority - b2.priority;
  });
  return units;
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function absFloor(number2) {
  if (number2 < 0) {
    return Math.ceil(number2) || 0;
  } else {
    return Math.floor(number2);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
function makeGetSet(unit2, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit2, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get$2(this, unit2);
    }
  };
}
function get$2(mom, unit2) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit2]() : NaN;
}
function set$1(mom, unit2, value) {
  if (mom.isValid() && !isNaN(value)) {
    if (unit2 === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      value = toInt(value);
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit2](
        value,
        mom.month(),
        daysInMonth(value, mom.month())
      );
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit2](value);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction$4(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
    for (i = 0; i < prioritizedLen; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction$4(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
var match1 = /\d/, match22 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
regexes = {};
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction$4(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config2) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config2._strict, config2._locale);
}
function unescapeFormat(s2) {
  return regexEscape(
    s2.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape(s2) {
  return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var tokens = {};
function addParseToken(token2, callback) {
  var i, func3 = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber$3(callback)) {
    func3 = function(input, array3) {
      array3[callback] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i = 0; i < tokenLen; i++) {
    tokens[token2[i]] = func3;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input, array3, config2, token3) {
    config2._w = config2._w || {};
    callback(input, config2._w, config2, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config2) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config2._a, config2, token2);
  }
}
var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
function mod(n2, x2) {
  return (n2 % x2 + x2) % x2;
}
var indexOf2;
if (Array.prototype.indexOf) {
  indexOf2 = Array.prototype.indexOf;
} else {
  indexOf2 = function(o3) {
    var i;
    for (i = 0; i < this.length; ++i) {
      if (this[i] === o3) {
        return i;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format2) {
  return this.localeData().monthsShort(this, format2);
});
addFormatToken("MMMM", 0, 0, function(format2) {
  return this.localeData().months(this, format2);
});
addUnitAlias("month", "M");
addUnitPriority("month", 8);
addRegexToken("M", match1to2);
addRegexToken("MM", match1to2, match22);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array3) {
  array3[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array3, config2, token2) {
  var month = config2._locale.monthsParse(input, token2, config2._strict);
  if (month != null) {
    array3[MONTH] = month;
  } else {
    getParsingFlags(config2).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
function localeMonths(m2, format2) {
  if (!m2) {
    return isArray$f(this._months) ? this._months : this._months["standalone"];
  }
  return isArray$f(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
}
function localeMonthsShort(m2, format2) {
  if (!m2) {
    return isArray$f(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray$f(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i, ii2, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0; i < 12; ++i) {
      mom = createUTC([2e3, i]);
      this._shortMonthsParse[i] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii2 = indexOf2.call(this._shortMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf2.call(this._longMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  } else {
    if (format2 === "MMM") {
      ii2 = indexOf2.call(this._shortMonthsParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf2.call(this._longMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf2.call(this._longMonthsParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf2.call(this._shortMonthsParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth(mom, value) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber$3(value)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get$2(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a2, b2) {
    return b2.length - a2.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i = 0; i < 12; i++) {
    shortPieces[i] = regexEscape(shortPieces[i]);
    longPieces[i] = regexEscape(longPieces[i]);
  }
  for (i = 0; i < 24; i++) {
    mixedPieces[i] = regexEscape(mixedPieces[i]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
addFormatToken("Y", 0, 0, function() {
  var y2 = this.year();
  return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addUnitAlias("year", "y");
addUnitPriority("year", 1);
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match22);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array3) {
  array3[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array3) {
  array3[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array3) {
  array3[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function createDate(y2, m2, d2, h2, M2, s2, ms2) {
  var date2;
  if (y2 < 100 && y2 >= 0) {
    date2 = new Date(y2 + 400, m2, d2, h2, M2, s2, ms2);
    if (isFinite(date2.getFullYear())) {
      date2.setFullYear(y2);
    }
  } else {
    date2 = new Date(y2, m2, d2, h2, M2, s2, ms2);
  }
  return date2;
}
function createUTCDate(y2) {
  var date2, args;
  if (y2 < 100 && y2 >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y2 + 400;
    date2 = new Date(Date.UTC.apply(null, args));
    if (isFinite(date2.getUTCFullYear())) {
      date2.setUTCFullYear(y2);
    }
  } else {
    date2 = new Date(Date.UTC.apply(null, arguments));
  }
  return date2;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addUnitAlias("week", "w");
addUnitAlias("isoWeek", "W");
addUnitPriority("week", 5);
addUnitPriority("isoWeek", 5);
addRegexToken("w", match1to2);
addRegexToken("ww", match1to2, match22);
addRegexToken("W", match1to2);
addRegexToken("WW", match1to2, match22);
addWeekParseToken(
  ["w", "ww", "W", "WW"],
  function(input, week, config2, token2) {
    week[token2.substr(0, 1)] = toInt(input);
  }
);
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format2) {
  return this.localeData().weekdaysMin(this, format2);
});
addFormatToken("ddd", 0, 0, function(format2) {
  return this.localeData().weekdaysShort(this, format2);
});
addFormatToken("dddd", 0, 0, function(format2) {
  return this.localeData().weekdays(this, format2);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addUnitAlias("day", "d");
addUnitAlias("weekday", "e");
addUnitAlias("isoWeekday", "E");
addUnitPriority("day", 11);
addUnitPriority("weekday", 11);
addUnitPriority("isoWeekday", 11);
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token2) {
  var weekday = config2._locale.weekdaysParse(input, token2, config2._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config2).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config2, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws2, n2) {
  return ws2.slice(n2, 7).concat(ws2.slice(0, n2));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m2, format2) {
  var weekdays2 = isArray$f(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m2 === true ? shiftWeekdays(weekdays2, this._week.dow) : m2 ? weekdays2[m2.day()] : weekdays2;
}
function localeWeekdaysShort(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i, ii2, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0; i < 7; ++i) {
      mom = createUTC([2e3, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii2 = indexOf2.call(this._weekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else if (format2 === "ddd") {
      ii2 = indexOf2.call(this._shortWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf2.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  } else {
    if (format2 === "dddd") {
      ii2 = indexOf2.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf2.call(this._shortWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf2.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else if (format2 === "ddd") {
      ii2 = indexOf2.call(this._shortWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf2.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf2.call(this._minWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    } else {
      ii2 = indexOf2.call(this._minWeekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf2.call(this._weekdaysParse, llc);
      if (ii2 !== -1) {
        return ii2;
      }
      ii2 = indexOf2.call(this._shortWeekdaysParse, llc);
      return ii2 !== -1 ? ii2 : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a2, b2) {
    return b2.length - a2.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
meridiem("a", true);
meridiem("A", false);
addUnitAlias("hour", "h");
addUnitPriority("hour", 13);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2);
addRegexToken("h", match1to2);
addRegexToken("k", match1to2);
addRegexToken("HH", match1to2, match22);
addRegexToken("hh", match1to2, match22);
addRegexToken("kk", match1to2, match22);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array3, config2) {
  var kInput = toInt(input);
  array3[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array3, config2) {
  config2._isPm = config2._locale.isPM(input);
  config2._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array3, config2) {
  array3[HOUR] = toInt(input);
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmm", function(input, array3, config2) {
  var pos = input.length - 2;
  array3[HOUR] = toInt(input.substr(0, pos));
  array3[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmmss", function(input, array3, config2) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array3[HOUR] = toInt(input.substr(0, pos1));
  array3[MINUTE] = toInt(input.substr(pos1, 2));
  array3[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("Hmm", function(input, array3, config2) {
  var pos = input.length - 2;
  array3[HOUR] = toInt(input.substr(0, pos));
  array3[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array3, config2) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array3[HOUR] = toInt(input.substr(0, pos1));
  array3[MINUTE] = toInt(input.substr(pos1, 2));
  array3[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {}, localeFamilies = {}, globalLocale;
function commonPrefix(arr1, arr2) {
  var i, minl = Math.min(arr1.length, arr2.length);
  for (i = 0; i < minl; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i = 0, j2, next, locale2, split2;
  while (i < names.length) {
    split2 = normalizeLocale(names[i]).split("-");
    j2 = split2.length;
    next = normalizeLocale(names[i + 1]);
    next = next ? next.split("-") : null;
    while (j2 > 0) {
      locale2 = loadLocale(split2.slice(0, j2).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j2 && commonPrefix(split2, next) >= j2 - 1) {
        break;
      }
      j2--;
    }
    i++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return name.match("^[^/\\\\]*$") != null;
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e3) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values3) {
  var data2;
  if (key) {
    if (isUndefined(values3)) {
      data2 = getLocale(key);
    } else {
      data2 = defineLocale(key, values3);
    }
    if (data2) {
      globalLocale = data2;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config2) {
  if (config2 !== null) {
    var locale2, parentConfig = baseConfig;
    config2.abbr = name;
    if (locales[name] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name]._config;
    } else if (config2.parentLocale != null) {
      if (locales[config2.parentLocale] != null) {
        parentConfig = locales[config2.parentLocale]._config;
      } else {
        locale2 = loadLocale(config2.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config2.parentLocale]) {
            localeFamilies[config2.parentLocale] = [];
          }
          localeFamilies[config2.parentLocale].push({
            name,
            config: config2
          });
          return null;
        }
      }
    }
    locales[name] = new Locale2(mergeConfigs(parentConfig, config2));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x2) {
        defineLocale(x2.name, x2.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config2) {
  if (config2 != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config2));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config2 = mergeConfigs(parentConfig, config2);
      if (tmpLocale == null) {
        config2.abbr = name;
      }
      locale2 = new Locale2(config2);
      locale2.parentLocale = locales[name];
      locales[name] = locale2;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray$f(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys$5(locales);
}
function checkOverflow$2(m2) {
  var overflow, a2 = m2._a;
  if (a2 && getParsingFlags(m2).overflow === -2) {
    overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m2).overflow = overflow;
  }
  return m2;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
], isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config2) {
  var i, l2, string4 = config2._i, match5 = extendedIsoRegex.exec(string4) || basicIsoRegex.exec(string4), allowTime, dateFormat, timeFormat2, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match5) {
    getParsingFlags(config2).iso = true;
    for (i = 0, l2 = isoDatesLen; i < l2; i++) {
      if (isoDates[i][1].exec(match5[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config2._isValid = false;
      return;
    }
    if (match5[3]) {
      for (i = 0, l2 = isoTimesLen; i < l2; i++) {
        if (isoTimes[i][1].exec(match5[3])) {
          timeFormat2 = (match5[2] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat2 == null) {
        config2._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat2 != null) {
      config2._isValid = false;
      return;
    }
    if (match5[4]) {
      if (tzRegex.exec(match5[4])) {
        tzFormat = "Z";
      } else {
        config2._isValid = false;
        return;
      }
    }
    config2._f = dateFormat + (timeFormat2 || "") + (tzFormat || "");
    configFromStringAndFormat(config2);
  } else {
    config2._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config2) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config2).weekdayMismatch = true;
      config2._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset$1(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m2 = hm % 100, h2 = (hm - m2) / 100;
    return h2 * 60 + m2;
  }
}
function configFromRFC2822(config2) {
  var match5 = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
  if (match5) {
    parsedArray = extractFromRFC2822Strings(
      match5[4],
      match5[3],
      match5[2],
      match5[5],
      match5[6],
      match5[7]
    );
    if (!checkWeekday(match5[1], parsedArray, config2)) {
      return;
    }
    config2._a = parsedArray;
    config2._tzm = calculateOffset$1(match5[8], match5[9], match5[10]);
    config2._d = createUTCDate.apply(null, config2._a);
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
    getParsingFlags(config2).rfc2822 = true;
  } else {
    config2._isValid = false;
  }
}
function configFromString(config2) {
  var matched = aspNetJsonRegex.exec(config2._i);
  if (matched !== null) {
    config2._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  configFromRFC2822(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  if (config2._strict) {
    config2._isValid = false;
  } else {
    hooks.createFromInputFallback(config2);
  }
}
hooks.createFromInputFallback = deprecate(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(config2) {
    config2._d = /* @__PURE__ */ new Date(config2._i + (config2._useUTC ? " UTC" : ""));
  }
);
function defaults$2(a2, b2, c2) {
  if (a2 != null) {
    return a2;
  }
  if (b2 != null) {
    return b2;
  }
  return c2;
}
function currentDateArray(config2) {
  var nowValue = new Date(hooks.now());
  if (config2._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config2) {
  var i, date2, input = [], currentDate, expectedWeekday, yearToUse;
  if (config2._d) {
    return;
  }
  currentDate = currentDateArray(config2);
  if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config2);
  }
  if (config2._dayOfYear != null) {
    yearToUse = defaults$2(config2._a[YEAR], currentDate[YEAR]);
    if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
      getParsingFlags(config2)._overflowDayOfYear = true;
    }
    date2 = createUTCDate(yearToUse, 0, config2._dayOfYear);
    config2._a[MONTH] = date2.getUTCMonth();
    config2._a[DATE] = date2.getUTCDate();
  }
  for (i = 0; i < 3 && config2._a[i] == null; ++i) {
    config2._a[i] = input[i] = currentDate[i];
  }
  for (; i < 7; i++) {
    config2._a[i] = input[i] = config2._a[i] == null ? i === 2 ? 1 : 0 : config2._a[i];
  }
  if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
    config2._nextDay = true;
    config2._a[HOUR] = 0;
  }
  config2._d = (config2._useUTC ? createUTCDate : createDate).apply(
    null,
    input
  );
  expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
  if (config2._tzm != null) {
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
  }
  if (config2._nextDay) {
    config2._a[HOUR] = 24;
  }
  if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
    getParsingFlags(config2).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config2) {
  var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w2 = config2._w;
  if (w2.GG != null || w2.W != null || w2.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults$2(
      w2.GG,
      config2._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults$2(w2.W, 1);
    weekday = defaults$2(w2.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config2._locale._week.dow;
    doy = config2._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults$2(w2.gg, config2._a[YEAR], curWeek.year);
    week = defaults$2(w2.w, curWeek.week);
    if (w2.d != null) {
      weekday = w2.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w2.e != null) {
      weekday = w2.e + dow;
      if (w2.e < 0 || w2.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config2)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config2)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config2._a[YEAR] = temp.year;
    config2._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config2) {
  if (config2._f === hooks.ISO_8601) {
    configFromISO(config2);
    return;
  }
  if (config2._f === hooks.RFC_2822) {
    configFromRFC2822(config2);
    return;
  }
  config2._a = [];
  getParsingFlags(config2).empty = true;
  var string4 = "" + config2._i, i, parsedInput, tokens2, token2, skipped, stringLength = string4.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i = 0; i < tokenLen; i++) {
    token2 = tokens2[i];
    parsedInput = (string4.match(getParseRegexForToken(token2, config2)) || [])[0];
    if (parsedInput) {
      skipped = string4.substr(0, string4.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config2).unusedInput.push(skipped);
      }
      string4 = string4.slice(
        string4.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config2).empty = false;
      } else {
        getParsingFlags(config2).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config2);
    } else if (config2._strict && !parsedInput) {
      getParsingFlags(config2).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
  if (string4.length > 0) {
    getParsingFlags(config2).unusedInput.push(string4);
  }
  if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
    getParsingFlags(config2).bigHour = void 0;
  }
  getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
  getParsingFlags(config2).meridiem = config2._meridiem;
  config2._a[HOUR] = meridiemFixWrap(
    config2._locale,
    config2._a[HOUR],
    config2._meridiem
  );
  era = getParsingFlags(config2).era;
  if (era !== null) {
    config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
  }
  configFromArray(config2);
  checkOverflow$2(config2);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config2) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
  if (configfLen === 0) {
    getParsingFlags(config2).invalidFormat = true;
    config2._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i = 0; i < configfLen; i++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config2);
    if (config2._useUTC != null) {
      tempConfig._useUTC = config2._useUTC;
    }
    tempConfig._f = config2._f[i];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend$4(config2, bestMoment || tempConfig);
}
function configFromObject(config2) {
  if (config2._d) {
    return;
  }
  var i = normalizeObjectUnits(config2._i), dayOrDate = i.day === void 0 ? i.date : i.day;
  config2._a = map$4(
    [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config2);
}
function createFromConfig(config2) {
  var res = new Moment(checkOverflow$2(prepareConfig(config2)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config2) {
  var input = config2._i, format2 = config2._f;
  config2._locale = config2._locale || getLocale(config2._l);
  if (input === null || format2 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config2._i = input = config2._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow$2(input));
  } else if (isDate(input)) {
    config2._d = input;
  } else if (isArray$f(format2)) {
    configFromStringAndArray(config2);
  } else if (format2) {
    configFromStringAndFormat(config2);
  } else {
    configFromInput(config2);
  }
  if (!isValid(config2)) {
    config2._d = null;
  }
  return config2;
}
function configFromInput(config2) {
  var input = config2._i;
  if (isUndefined(input)) {
    config2._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config2._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config2);
  } else if (isArray$f(input)) {
    config2._a = map$4(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config2);
  } else if (isObject$b(input)) {
    configFromObject(config2);
  } else if (isNumber$3(input)) {
    config2._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config2);
  }
}
function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
  var c2 = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject$b(input) && isObjectEmpty(input) || isArray$f(input) && input.length === 0) {
    input = void 0;
  }
  c2._isAMomentObject = true;
  c2._useUTC = c2._isUTC = isUTC;
  c2._l = locale2;
  c2._i = input;
  c2._f = format2;
  c2._strict = strict;
  return createFromConfig(c2);
}
function createLocal(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, false);
}
var prototypeMin = deprecate(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }
), prototypeMax = deprecate(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
function pickBy2(fn2, moments) {
  var res, i;
  if (moments.length === 1 && isArray$f(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1; i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn2](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min$2() {
  var args = [].slice.call(arguments, 0);
  return pickBy2("isBefore", args);
}
function max$2() {
  var args = [].slice.call(arguments, 0);
  return pickBy2("isAfter", args);
}
var now$3 = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m2) {
  var key, unitHasDecimal = false, i, orderLen = ordering.length;
  for (key in m2) {
    if (hasOwnProp(m2, key) && !(indexOf2.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
      return false;
    }
  }
  for (i = 0; i < orderLen; ++i) {
    if (m2[ordering[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m2[ordering[i]]) !== toInt(m2[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration2(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
  minutes2 * 6e4 + // 1000 * 60
  hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration2;
}
function absRound(number2) {
  if (number2 < 0) {
    return Math.round(-1 * number2) * -1;
  } else {
    return Math.round(number2);
  }
}
function compareArrays(array1, array22, dontConvert) {
  var len = Math.min(array1.length, array22.length), lengthDiff = Math.abs(array1.length - array22.length), diffs = 0, i;
  for (i = 0; i < len; i++) {
    if (dontConvert && array1[i] !== array22[i] || !dontConvert && toInt(array1[i]) !== toInt(array22[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array3, config2) {
  config2._useUTC = true;
  config2._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher2, string4) {
  var matches2 = (string4 || "").match(matcher2), chunk, parts, minutes2;
  if (matches2 === null) {
    return null;
  }
  chunk = matches2[matches2.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m2) {
  return -Math.round(m2._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input - offset2, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c2 = {}, other;
  copyConfig(c2, this);
  c2 = prepareConfig(c2);
  if (c2._a) {
    other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
    this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration = input, match5 = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber$3(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match5 = aspNetRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match5[DATE]) * sign2,
      h: toInt(match5[HOUR]) * sign2,
      m: toInt(match5[MINUTE]) * sign2,
      s: toInt(match5[SECOND]) * sign2,
      ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
      // the millisecond decimal point is included in the match
    };
  } else if (match5 = isoRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match5[2], sign2),
      M: parseIso(match5[3], sign2),
      w: parseIso(match5[4], sign2),
      d: parseIso(match5[5], sign2),
      h: parseIso(match5[6], sign2),
      m: parseIso(match5[7], sign2),
      s: parseIso(match5[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(
      createLocal(duration.from),
      createLocal(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration2(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration2.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name,
        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get$2(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1(mom, "Date", get$2(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add$1 = createAdder(1, "add"), subtract$1 = createAdder(-1, "subtract");
function isString$1(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate(input) || isString$1(input) || isNumber$3(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject$b(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i, property2, propertyLen = properties.length;
  for (i = 0; i < propertyLen; i += 1) {
    property2 = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property2);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray$f(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber$3(item) && isString$1(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject$b(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i, property2;
  for (i = 0; i < properties.length; i += 1) {
    property2 = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property2);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1$1(time2, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time2 = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time2 = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time2 = void 0;
    }
  }
  var now2 = time2 || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction$4(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
  return this.format(
    output || this.localeData().calendar(format2, this, createLocal(now2))
  );
}
function clone$1() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a2, b2) {
  if (a2.date() < b2.date()) {
    return -monthDiff(b2, a2);
  }
  var wholeMonthDiff = (b2.year() - a2.year()) * 12 + (b2.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust3;
  if (b2 - anchor < 0) {
    anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
    adjust3 = (b2 - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
    adjust3 = (b2 - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust3) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString$5() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
  if (m2.year() < 0 || m2.year() > 9999) {
    return formatMoment(
      m2,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction$4(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
    }
  }
  return formatMoment(
    m2,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func3 = "moment", zone = "", prefix2, year, datetime, suffix;
  if (!this.isLocal()) {
    func3 = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix2 = "[" + func3 + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix2 + year + datetime + suffix);
}
function format$1(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time2, withoutSuffix) {
  if (this.isValid() && (isMoment(time2) && time2.isValid() || createLocal(time2).isValid())) {
    return createDuration({ to: this, from: time2 }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time2, withoutSuffix) {
  if (this.isValid() && (isMoment(time2) && time2.isValid() || createLocal(time2).isValid())) {
    return createDuration({ from: this, to: time2 }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale$2(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  }
);
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y2, m2, d2) {
  if (y2 < 100 && y2 >= 0) {
    return new Date(y2 + 400, m2, d2) - MS_PER_400_YEARS;
  } else {
    return new Date(y2, m2, d2).valueOf();
  }
}
function utcStartOfDate(y2, m2, d2) {
  if (y2 < 100 && y2 >= 0) {
    return Date.UTC(y2 + 400, m2, d2) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y2, m2, d2);
  }
}
function startOf(units) {
  var time2, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time2 = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time2 = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time2 = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time2 = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time2 = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time2 = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time2 = this._d.valueOf();
      time2 -= mod$1(
        time2 + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time2 = this._d.valueOf();
      time2 -= mod$1(time2, MS_PER_MINUTE);
      break;
    case "second":
      time2 = this._d.valueOf();
      time2 -= mod$1(time2, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time2);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time2, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time2 = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time2 = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time2 = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time2 = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time2 = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time2 = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time2 = this._d.valueOf();
      time2 += MS_PER_HOUR - mod$1(
        time2 + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time2 = this._d.valueOf();
      time2 += MS_PER_MINUTE - mod$1(time2, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time2 = this._d.valueOf();
      time2 += MS_PER_SECOND - mod$1(time2, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time2);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray$1() {
  var m2 = this;
  return [
    m2.year(),
    m2.month(),
    m2.date(),
    m2.hour(),
    m2.minute(),
    m2.second(),
    m2.millisecond()
  ];
}
function toObject() {
  var m2 = this;
  return {
    years: m2.year(),
    months: m2.month(),
    date: m2.date(),
    hours: m2.hours(),
    minutes: m2.minutes(),
    seconds: m2.seconds(),
    milliseconds: m2.milliseconds()
  };
}
function toJSON2() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend$4({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(input, array3, config2, token2) {
    var era = config2._locale.erasParse(input, token2, config2._strict);
    if (era) {
      getParsingFlags(config2).era = era;
    } else {
      getParsingFlags(config2).invalidEra = input;
    }
  }
);
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array3, config2, token2) {
  var match5;
  if (config2._locale._eraYearOrdinalRegex) {
    match5 = input.match(config2._locale._eraYearOrdinalRegex);
  }
  if (config2._locale.eraYearOrdinalParse) {
    array3[YEAR] = config2._locale.eraYearOrdinalParse(input, match5);
  } else {
    array3[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m2, format2) {
  var i, l2, date2, eras2 = this._eras || getLocale("en")._eras;
  for (i = 0, l2 = eras2.length; i < l2; ++i) {
    switch (typeof eras2[i].since) {
      case "string":
        date2 = hooks(eras2[i].since).startOf("day");
        eras2[i].since = date2.valueOf();
        break;
    }
    switch (typeof eras2[i].until) {
      case "undefined":
        eras2[i].until = Infinity;
        break;
      case "string":
        date2 = hooks(eras2[i].until).startOf("day").valueOf();
        eras2[i].until = date2.valueOf();
        break;
    }
  }
  return eras2;
}
function localeErasParse(eraName, format2, strict) {
  var i, l2, eras2 = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i = 0, l2 = eras2.length; i < l2; ++i) {
    name = eras2[i].name.toUpperCase();
    abbr = eras2[i].abbr.toUpperCase();
    narrow = eras2[i].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras2[i];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras2[i];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras2[i];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras2[i];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i, l2, val, eras2 = this.localeData().eras();
  for (i = 0, l2 = eras2.length; i < l2; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras2[i].since <= val && val <= eras2[i].until) {
      return eras2[i].name;
    }
    if (eras2[i].until <= val && val <= eras2[i].since) {
      return eras2[i].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i, l2, val, eras2 = this.localeData().eras();
  for (i = 0, l2 = eras2.length; i < l2; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras2[i].since <= val && val <= eras2[i].until) {
      return eras2[i].narrow;
    }
    if (eras2[i].until <= val && val <= eras2[i].since) {
      return eras2[i].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i, l2, val, eras2 = this.localeData().eras();
  for (i = 0, l2 = eras2.length; i < l2; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras2[i].since <= val && val <= eras2[i].until) {
      return eras2[i].abbr;
    }
    if (eras2[i].until <= val && val <= eras2[i].since) {
      return eras2[i].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i, l2, dir, val, eras2 = this.localeData().eras();
  for (i = 0, l2 = eras2.length; i < l2; ++i) {
    dir = eras2[i].since <= eras2[i].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras2[i].since <= val && val <= eras2[i].until || eras2[i].until <= val && val <= eras2[i].since) {
      return (this.year() - hooks(eras2[i].since).year()) * dir + eras2[i].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l2, eras2 = this.eras();
  for (i = 0, l2 = eras2.length; i < l2; ++i) {
    namePieces.push(regexEscape(eras2[i].name));
    abbrPieces.push(regexEscape(eras2[i].abbr));
    narrowPieces.push(regexEscape(eras2[i].narrow));
    mixedPieces.push(regexEscape(eras2[i].name));
    mixedPieces.push(regexEscape(eras2[i].abbr));
    mixedPieces.push(regexEscape(eras2[i].narrow));
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addUnitAlias("weekYear", "gg");
addUnitAlias("isoWeekYear", "GG");
addUnitPriority("weekYear", 1);
addUnitPriority("isoWeekYear", 1);
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match22);
addRegexToken("gg", match1to2, match22);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(input, week, config2, token2) {
    week[token2.substr(0, 2)] = toInt(input);
  }
);
addWeekParseToken(["gg", "GG"], function(input, week, config2, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date2 = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date2.getUTCFullYear());
  this.month(date2.getUTCMonth());
  this.date(date2.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addUnitAlias("quarter", "Q");
addUnitPriority("quarter", 7);
addRegexToken("Q", match1);
addParseToken("Q", function(input, array3) {
  array3[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addUnitAlias("date", "D");
addUnitPriority("date", 9);
addRegexToken("D", match1to2);
addRegexToken("DD", match1to2, match22);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array3) {
  array3[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addUnitAlias("dayOfYear", "DDD");
addUnitPriority("dayOfYear", 4);
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array3, config2) {
  config2._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addUnitAlias("minute", "m");
addUnitPriority("minute", 14);
addRegexToken("m", match1to2);
addRegexToken("mm", match1to2, match22);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addUnitAlias("second", "s");
addUnitPriority("second", 15);
addRegexToken("s", match1to2);
addRegexToken("ss", match1to2, match22);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addUnitAlias("millisecond", "ms");
addUnitPriority("millisecond", 16);
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match22);
addRegexToken("SSS", match1to3, match3);
var token, getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array3) {
  array3[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add$1;
proto.calendar = calendar$1$1;
proto.clone = clone$1;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format$1;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale$2;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract$1;
proto.toArray = toArray$1;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON2;
proto.toString = toString$5;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate(
  "dates accessor is deprecated. Use date instead.",
  getSetDayOfMonth
);
proto.months = deprecate(
  "months accessor is deprecated. Use month instead",
  getSetMonth
);
proto.years = deprecate(
  "years accessor is deprecated. Use year instead",
  getSetYear
);
proto.zone = deprecate(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  getSetZone
);
proto.isDSTShifted = deprecate(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  isDaylightSavingTimeShifted
);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string4) {
  return string4;
}
var proto$1 = Locale2.prototype;
proto$1.calendar = calendar$1;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal$1;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set2;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1$1(format2, index3, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index3);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index3, field) {
  if (isNumber$3(format2)) {
    index3 = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index3 != null) {
    return get$1$1(format2, index3, field, "month");
  }
  var i, out = [];
  for (i = 0; i < 12; i++) {
    out[i] = get$1$1(format2, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index3, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber$3(format2)) {
      index3 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index3 = format2;
    localeSorted = false;
    if (isNumber$3(format2)) {
      index3 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
  if (index3 != null) {
    return get$1$1(format2, (index3 + shift) % 7, field, "day");
  }
  for (i = 0; i < 7; i++) {
    out[i] = get$1$1(format2, (i + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index3) {
  return listMonthsImpl(format2, index3, "months");
}
function listMonthsShort(format2, index3) {
  return listMonthsImpl(format2, index3, "monthsShort");
}
function listWeekdays(localeSorted, format2, index3) {
  return listWeekdaysImpl(localeSorted, format2, index3, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index3) {
  return listWeekdaysImpl(localeSorted, format2, index3, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index3) {
  return listWeekdaysImpl(localeSorted, format2, index3, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number2) {
    var b2 = number2 % 10, output = toInt(number2 % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
    return number2 + output;
  }
});
hooks.lang = deprecate(
  "moment.lang is deprecated. Use moment.locale instead.",
  getSetGlobalLocale
);
hooks.langData = deprecate(
  "moment.langData is deprecated. Use moment.localeData instead.",
  getLocale
);
var mathAbs = Math.abs;
function abs() {
  var data2 = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data2.milliseconds = mathAbs(data2.milliseconds);
  data2.seconds = mathAbs(data2.seconds);
  data2.minutes = mathAbs(data2.minutes);
  data2.hours = mathAbs(data2.hours);
  data2.months = mathAbs(data2.months);
  data2.years = mathAbs(data2.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number2) {
  if (number2 < 0) {
    return Math.floor(number2);
  } else {
    return Math.ceil(number2);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data2 = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data2.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data2.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data2.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data2.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data2.days = days2;
  data2.months = months2;
  data2.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
function clone$1$1() {
  return createDuration(this);
}
function get$2$1(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round$1 = Math.round, thresholds = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function substituteTimeAgo(string4, number2, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number2 || 1, !!withoutSuffix, string4, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round$1(duration.as("s")), minutes2 = round$1(duration.as("m")), hours2 = round$1(duration.as("h")), days2 = round$1(duration.as("d")), months2 = round$1(duration.as("M")), weeks2 = round$1(duration.as("w")), years2 = round$1(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a2[2] = withoutSuffix;
  a2[3] = +posNegDuration > 0;
  a2[4] = locale2;
  return substituteTimeAgo.apply(null, a2);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round$1;
  }
  if (typeof roundingFunction === "function") {
    round$1 = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold2, limit) {
  if (thresholds[threshold2] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold2];
  }
  thresholds[threshold2] = limit;
  if (threshold2 === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th2 = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th2 = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th2.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th2, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign$1(x2) {
  return (x2 > 0) - (x2 < 0) || +x2;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign$1(this._months) !== sign$1(total) ? "-" : "";
  daysSign = sign$1(this._days) !== sign$1(total) ? "-" : "";
  hmsSign = sign$1(this._milliseconds) !== sign$1(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
}
var proto$2 = Duration2.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1$1;
proto$2.subtract = subtract$1$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1$1;
proto$2.get = get$2$1;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale$2;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  toISOString$1
);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array3, config2) {
  config2._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array3, config2) {
  config2._d = new Date(toInt(input));
});
//! moment.js
hooks.version = "2.29.4";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min$2;
hooks.max = max$2;
hooks.now = now$3;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
function isObject$a(obj) {
  return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend$3(target = {}, src = {}) {
  Object.keys(src).forEach((key) => {
    if (typeof target[key] === "undefined")
      target[key] = src[key];
    else if (isObject$a(src[key]) && isObject$a(target[key]) && Object.keys(src[key]).length > 0) {
      extend$3(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      }
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  const doc2 = typeof document !== "undefined" ? document : {};
  extend$3(doc2, ssrDocument);
  return doc2;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    }
  },
  CustomEvent: function CustomEvent2() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === "undefined") {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id2) {
    if (typeof setTimeout === "undefined") {
      return;
    }
    clearTimeout(id2);
  }
};
function getWindow() {
  const win2 = typeof window !== "undefined" ? window : {};
  extend$3(win2, ssrWindow);
  return win2;
}
function deleteProps(obj) {
  const object2 = obj;
  Object.keys(object2).forEach((key) => {
    try {
      object2[key] = null;
    } catch (e3) {
    }
    try {
      delete object2[key];
    } catch (e3) {
    }
  });
}
function nextTick(callback, delay2 = 0) {
  return setTimeout(callback, delay2);
}
function now$2() {
  return Date.now();
}
function getComputedStyle$1(el2) {
  const window2 = getWindow();
  let style;
  if (window2.getComputedStyle) {
    style = window2.getComputedStyle(el2, null);
  }
  if (!style && el2.currentStyle) {
    style = el2.currentStyle;
  }
  if (!style) {
    style = el2.style;
  }
  return style;
}
function getTranslate(el2, axis = "x") {
  const window2 = getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle$1(el2);
  if (window2.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(",").length > 6) {
      curTransform = curTransform.split(", ").map((a2) => a2.replace(",", ".")).join(", ");
    }
    transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
    matrix = transformMatrix.toString().split(",");
  }
  if (axis === "x") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m41;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[12]);
    else
      curTransform = parseFloat(matrix[4]);
  }
  if (axis === "y") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m42;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[13]);
    else
      curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject$9(o3) {
  return typeof o3 === "object" && o3 !== null && o3.constructor && Object.prototype.toString.call(o3).slice(8, -1) === "Object";
}
function isNode(node) {
  if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend$2(...args) {
  const to2 = Object(args[0]);
  const noExtend = ["__proto__", "constructor", "prototype"];
  for (let i = 1; i < args.length; i += 1) {
    const nextSource = args[i];
    if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (isObject$9(to2[nextKey]) && isObject$9(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to2[nextKey] = nextSource[nextKey];
            } else {
              extend$2(to2[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject$9(to2[nextKey]) && isObject$9(nextSource[nextKey])) {
            to2[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to2[nextKey] = nextSource[nextKey];
            } else {
              extend$2(to2[nextKey], nextSource[nextKey]);
            }
          } else {
            to2[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to2;
}
function setCSSProperty(el2, varName, varValue) {
  el2.style.setProperty(varName, varValue);
}
function animateCSSModeScroll({
  swiper,
  targetPosition,
  side
}) {
  const window2 = getWindow();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time2;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = "none";
  window2.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? "next" : "prev";
  const isOutOfBound = (current2, target) => {
    return dir === "next" && current2 >= target || dir === "prev" && current2 <= target;
  };
  const animate = () => {
    time2 = (/* @__PURE__ */ new Date()).getTime();
    if (startTime === null) {
      startTime = time2;
    }
    const progress = Math.max(Math.min((time2 - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = "hidden";
      swiper.wrapperEl.style.scrollSnapType = "";
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = "";
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window2.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
  };
  animate();
}
function elementChildren(element, selector = "") {
  return [...element.children].filter((el2) => el2.matches(selector));
}
function createElement(tag, classes2 = []) {
  const el2 = document.createElement(tag);
  el2.classList.add(...Array.isArray(classes2) ? classes2 : [classes2]);
  return el2;
}
function elementPrevAll(el2, selector) {
  const prevEls = [];
  while (el2.previousElementSibling) {
    const prev = el2.previousElementSibling;
    if (selector) {
      if (prev.matches(selector))
        prevEls.push(prev);
    } else
      prevEls.push(prev);
    el2 = prev;
  }
  return prevEls;
}
function elementNextAll(el2, selector) {
  const nextEls = [];
  while (el2.nextElementSibling) {
    const next = el2.nextElementSibling;
    if (selector) {
      if (next.matches(selector))
        nextEls.push(next);
    } else
      nextEls.push(next);
    el2 = next;
  }
  return nextEls;
}
function elementStyle(el2, prop3) {
  const window2 = getWindow();
  return window2.getComputedStyle(el2, null).getPropertyValue(prop3);
}
function elementIndex(el2) {
  let child = el2;
  let i;
  if (child) {
    i = 0;
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1)
        i += 1;
    }
    return i;
  }
  return void 0;
}
function elementParents(el2, selector) {
  const parents = [];
  let parent = el2.parentElement;
  while (parent) {
    if (selector) {
      if (parent.matches(selector))
        parents.push(parent);
    } else {
      parents.push(parent);
    }
    parent = parent.parentElement;
  }
  return parents;
}
function elementOuterSize(el2, size, includeMargins) {
  const window2 = getWindow();
  if (includeMargins) {
    return el2[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el2, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el2, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
  }
  return el2.offsetWidth;
}
let support;
function calcSupport() {
  const window2 = getWindow();
  const document2 = getDocument();
  return {
    smoothScroll: document2.documentElement && document2.documentElement.style && "scrollBehavior" in document2.documentElement.style,
    touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}
let deviceCached;
function calcDevice({
  userAgent
} = {}) {
  const support2 = getSupport();
  const window2 = getWindow();
  const platform = window2.navigator.platform;
  const ua2 = userAgent || window2.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window2.screen.width;
  const screenHeight = window2.screen.height;
  const android = ua2.match(/(Android);?[\s\/]+([\d.]+)?/);
  let ipad = ua2.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua2.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua2.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === "Win32";
  let macos = platform === "MacIntel";
  const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua2.match(/(Version)\/([\d.]+)/);
    if (!ipad)
      ipad = [0, 1, "13_0_0"];
    macos = false;
  }
  if (android && !windows) {
    device.os = "android";
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = "ios";
    device.ios = true;
  }
  return device;
}
function getDevice(overrides = {}) {
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}
let browser;
function calcBrowser() {
  const window2 = getWindow();
  let needPerspectiveFix = false;
  function isSafari() {
    const ua2 = window2.navigator.userAgent.toLowerCase();
    return ua2.indexOf("safari") >= 0 && ua2.indexOf("chrome") < 0 && ua2.indexOf("android") < 0;
  }
  if (isSafari()) {
    const ua2 = String(window2.navigator.userAgent);
    if (ua2.includes("Version/")) {
      const [major, minor] = ua2.split("Version/")[1].split(" ")[0].split(".").map((num) => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  return {
    isSafari: needPerspectiveFix || isSafari(),
    needPerspectiveFix,
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}
function Resize({
  swiper,
  on: on3,
  emit: emit2
}) {
  const window2 = getWindow();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    emit2("beforeResize");
    emit2("resize");
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    observer = new ResizeObserver((entries) => {
      animationFrame = window2.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach(({
          contentBoxSize,
          contentRect,
          target
        }) => {
          if (target && target !== swiper.el)
            return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window2.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    emit2("orientationchange");
  };
  on3("init", () => {
    if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
      createObserver();
      return;
    }
    window2.addEventListener("resize", resizeHandler);
    window2.addEventListener("orientationchange", orientationChangeHandler);
  });
  on3("destroy", () => {
    removeObserver();
    window2.removeEventListener("resize", resizeHandler);
    window2.removeEventListener("orientationchange", orientationChangeHandler);
  });
}
function Observer({
  swiper,
  extendParams,
  on: on3,
  emit: emit2
}) {
  const observers = [];
  const window2 = getWindow();
  const attach = (target, options = {}) => {
    const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
    const observer = new ObserverFunc((mutations) => {
      if (swiper.__preventObserver__)
        return;
      if (mutations.length === 1) {
        emit2("observerUpdate", mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate2() {
        emit2("observerUpdate", mutations[0]);
      };
      if (window2.requestAnimationFrame) {
        window2.requestAnimationFrame(observerUpdate);
      } else {
        window2.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === "undefined" ? true : options.attributes,
      childList: typeof options.childList === "undefined" ? true : options.childList,
      characterData: typeof options.characterData === "undefined" ? true : options.characterData
    });
    observers.push(observer);
  };
  const init2 = () => {
    if (!swiper.params.observer)
      return;
    if (swiper.params.observeParents) {
      const containerParents = elementParents(swiper.el);
      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    }
    attach(swiper.el, {
      childList: swiper.params.observeSlideChildren
    });
    attach(swiper.wrapperEl, {
      attributes: false
    });
  };
  const destroy = () => {
    observers.forEach((observer) => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on3("init", init2);
  on3("destroy", destroy);
}
const eventsEmitter = {
  on(events2, handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (typeof handler !== "function")
      return self2;
    const method = priority ? "unshift" : "push";
    events2.split(" ").forEach((event) => {
      if (!self2.eventsListeners[event])
        self2.eventsListeners[event] = [];
      self2.eventsListeners[event][method](handler);
    });
    return self2;
  },
  once(events2, handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (typeof handler !== "function")
      return self2;
    function onceHandler(...args) {
      self2.off(events2, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      handler.apply(self2, args);
    }
    onceHandler.__emitterProxy = handler;
    return self2.on(events2, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (typeof handler !== "function")
      return self2;
    const method = priority ? "unshift" : "push";
    if (self2.eventsAnyListeners.indexOf(handler) < 0) {
      self2.eventsAnyListeners[method](handler);
    }
    return self2;
  },
  offAny(handler) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (!self2.eventsAnyListeners)
      return self2;
    const index3 = self2.eventsAnyListeners.indexOf(handler);
    if (index3 >= 0) {
      self2.eventsAnyListeners.splice(index3, 1);
    }
    return self2;
  },
  off(events2, handler) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (!self2.eventsListeners)
      return self2;
    events2.split(" ").forEach((event) => {
      if (typeof handler === "undefined") {
        self2.eventsListeners[event] = [];
      } else if (self2.eventsListeners[event]) {
        self2.eventsListeners[event].forEach((eventHandler, index3) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self2.eventsListeners[event].splice(index3, 1);
          }
        });
      }
    });
    return self2;
  },
  emit(...args) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (!self2.eventsListeners)
      return self2;
    let events2;
    let data2;
    let context2;
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      events2 = args[0];
      data2 = args.slice(1, args.length);
      context2 = self2;
    } else {
      events2 = args[0].events;
      data2 = args[0].data;
      context2 = args[0].context || self2;
    }
    data2.unshift(context2);
    const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
    eventsArray.forEach((event) => {
      if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
        self2.eventsAnyListeners.forEach((eventHandler) => {
          eventHandler.apply(context2, [event, ...data2]);
        });
      }
      if (self2.eventsListeners && self2.eventsListeners[event]) {
        self2.eventsListeners[event].forEach((eventHandler) => {
          eventHandler.apply(context2, data2);
        });
      }
    });
    return self2;
  }
};
function updateSize() {
  const swiper = this;
  let width;
  let height;
  const el2 = swiper.el;
  if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = el2.clientWidth;
  }
  if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = el2.clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }
  width = width - parseInt(elementStyle(el2, "padding-left") || 0, 10) - parseInt(elementStyle(el2, "padding-right") || 0, 10);
  height = height - parseInt(elementStyle(el2, "padding-top") || 0, 10) - parseInt(elementStyle(el2, "padding-bottom") || 0, 10);
  if (Number.isNaN(width))
    width = 0;
  if (Number.isNaN(height))
    height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}
function updateSlides() {
  const swiper = this;
  function getDirectionLabel(property2) {
    if (swiper.isHorizontal()) {
      return property2;
    }
    return {
      "width": "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      "marginRight": "marginBottom"
    }[property2];
  }
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    wrapperEl,
    slidesEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === "function") {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === "function") {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index3 = 0;
  if (typeof swiperSize === "undefined") {
    return;
  }
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
  } else if (typeof spaceBetween === "string") {
    spaceBetween = parseFloat(spaceBetween);
  }
  swiper.virtualSize = -spaceBetween;
  slides.forEach((slideEl) => {
    if (rtl) {
      slideEl.style.marginLeft = "";
    } else {
      slideEl.style.marginRight = "";
    }
    slideEl.style.marginBottom = "";
    slideEl.style.marginTop = "";
  });
  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
    setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slidesLength);
  }
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
    return typeof params.breakpoints[key].slidesPerView !== "undefined";
  }).length > 0;
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    let slide2;
    if (slides[i])
      slide2 = slides[i];
    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide2, slidesLength, getDirectionLabel);
    }
    if (slides[i] && elementStyle(slide2, "display") === "none")
      continue;
    if (params.slidesPerView === "auto") {
      if (shouldResetSlideSize) {
        slides[i].style[getDirectionLabel("width")] = ``;
      }
      const slideStyles = getComputedStyle(slide2);
      const currentTransform = slide2.style.transform;
      const currentWebKitTransform = slide2.style.webkitTransform;
      if (currentTransform) {
        slide2.style.transform = "none";
      }
      if (currentWebKitTransform) {
        slide2.style.webkitTransform = "none";
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, "width", true) : elementOuterSize(slide2, "height", true);
      } else {
        const width = getDirectionPropertyValue(slideStyles, "width");
        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
        const boxSizing = slideStyles.getPropertyValue("box-sizing");
        if (boxSizing && boxSizing === "border-box") {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide2;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide2.style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide2.style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[getDirectionLabel("width")] = `${slideSize}px`;
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1e3)
        slidePosition = 0;
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if (index3 % params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if ((index3 - Math.min(swiper.params.slidesPerGroupSkip, index3)) % swiper.params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index3 += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (params.setWrapperSize) {
    wrapperEl.style[getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
  }
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths)
        slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (isVirtual && params.loop) {
    const size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
      const groupSize = size * params.slidesPerGroup;
      for (let i = 0; i < groups; i += 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
      }
    }
    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
      if (params.slidesPerGroup === 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
      }
      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
      swiper.virtualSize += size;
    }
  }
  if (snapGrid.length === 0)
    snapGrid = [0];
  if (spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
    slides.filter((_2, slideIndex) => {
      if (!params.cssMode || params.loop)
        return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).forEach((slideEl) => {
      slideEl.style[key] = `${spaceBetween}px`;
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map((snap) => {
      if (snap < 0)
        return -offsetBefore;
      if (snap > maxSnap)
        return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
    setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map((v2) => v2 + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map((v2) => v2 + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit("slidesLengthChange");
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow)
      swiper.checkOverflow();
    swiper.emit("snapGridLengthChange");
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit("slidesGridLengthChange");
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded)
        swiper.el.classList.add(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.el.classList.remove(backFaceHiddenClass);
    }
  }
}
function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;
  if (typeof speed === "number") {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = (index3) => {
    if (isVirtual) {
      return swiper.slides[swiper.getSlideIndexByData(index3)];
    }
    return swiper.slides[index3];
  };
  if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      (swiper.visibleSlides || []).forEach((slide2) => {
        activeSlides.push(slide2);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index3 = swiper.activeIndex + i;
        if (index3 > swiper.slides.length && !isVirtual)
          break;
        activeSlides.push(getSlideByIndex(index3));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== "undefined") {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }
  if (newHeight || newHeight === 0)
    swiper.wrapperEl.style.height = `${newHeight}px`;
}
function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
  }
}
function updateSlidesProgress(translate2 = this && this.translate || 0) {
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0)
    return;
  if (typeof slides[0].swiperSlideOffset === "undefined")
    swiper.updateSlidesOffset();
  let offsetCenter = -translate2;
  if (rtl)
    offsetCenter = translate2;
  slides.forEach((slideEl) => {
    slideEl.classList.remove(params.slideVisibleClass);
  });
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  let spaceBetween = params.spaceBetween;
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size;
  } else if (typeof spaceBetween === "string") {
    spaceBetween = parseFloat(spaceBetween);
  }
  for (let i = 0; i < slides.length; i += 1) {
    const slide2 = slides[i];
    let slideOffset = slide2.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide2);
      swiper.visibleSlidesIndexes.push(i);
      slides[i].classList.add(params.slideVisibleClass);
    }
    slide2.progress = rtl ? -slideProgress : slideProgress;
    slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}
function updateProgress(translate2) {
  const swiper = this;
  if (typeof translate2 === "undefined") {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd: isEnd3,
    progressLoop
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd3;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd3 = true;
  } else {
    progress = (translate2 - swiper.minTranslate()) / translatesDiff;
    const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;
    const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress <= 0;
    isEnd3 = isEndRounded || progress >= 1;
    if (isBeginningRounded)
      progress = 0;
    if (isEndRounded)
      progress = 1;
  }
  if (params.loop) {
    const firstSlideIndex = swiper.getSlideIndexByData(0);
    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
    const translateAbs = Math.abs(translate2);
    if (translateAbs >= firstSlideTranslate) {
      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
    } else {
      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
    }
    if (progressLoop > 1)
      progressLoop -= 1;
  }
  Object.assign(swiper, {
    progress,
    progressLoop,
    isBeginning,
    isEnd: isEnd3
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
    swiper.updateSlidesProgress(translate2);
  if (isBeginning && !wasBeginning) {
    swiper.emit("reachBeginning toEdge");
  }
  if (isEnd3 && !wasEnd) {
    swiper.emit("reachEnd toEdge");
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd3) {
    swiper.emit("fromEdge");
  }
  swiper.emit("progress", progress);
}
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    slidesEl,
    activeIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const getFilteredSlide = (selector) => {
    return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
  };
  slides.forEach((slideEl) => {
    slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
  });
  let activeSlide;
  if (isVirtual) {
    if (params.loop) {
      let slideIndex = activeIndex - swiper.virtual.slidesBefore;
      if (slideIndex < 0)
        slideIndex = swiper.virtual.slides.length + slideIndex;
      if (slideIndex >= swiper.virtual.slides.length)
        slideIndex -= swiper.virtual.slides.length;
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else {
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
    }
  } else {
    activeSlide = slides[activeIndex];
  }
  if (activeSlide) {
    activeSlide.classList.add(params.slideActiveClass);
    let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
    if (params.loop && !nextSlide) {
      nextSlide = slides[0];
    }
    if (nextSlide) {
      nextSlide.classList.add(params.slideNextClass);
    }
    let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
    if (params.loop && !prevSlide === 0) {
      prevSlide = slides[slides.length - 1];
    }
    if (prevSlide) {
      prevSlide.classList.add(params.slidePrevClass);
    }
  }
  swiper.emitSlidesClasses();
}
const processLazyPreloader = (swiper, imageEl) => {
  if (!swiper || swiper.destroyed || !swiper.params)
    return;
  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
  const slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
    if (lazyEl)
      lazyEl.remove();
  }
};
const unlazy = (swiper, index3) => {
  if (!swiper.slides[index3])
    return;
  const imageEl = swiper.slides[index3].querySelector('[loading="lazy"]');
  if (imageEl)
    imageEl.removeAttribute("loading");
};
const preload2 = (swiper) => {
  if (!swiper || swiper.destroyed || !swiper.params)
    return;
  let amount = swiper.params.lazyPreloadPrevNext;
  const len = swiper.slides.length;
  if (!len || !amount || amount < 0)
    return;
  amount = Math.min(amount, len);
  const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
  const activeIndex = swiper.activeIndex;
  const slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper.params.rewind) {
    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
      const realIndex = (i % len + len) % len;
      if (realIndex !== activeIndex && realIndex > slideIndexLastInView)
        unlazy(swiper, realIndex);
    }
  } else {
    for (let i = Math.max(slideIndexLastInView - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
      if (i !== activeIndex && i > slideIndexLastInView)
        unlazy(swiper, i);
    }
  }
};
function getActiveIndexByTranslate(swiper) {
  const {
    slidesGrid,
    params
  } = swiper;
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  let activeIndex;
  for (let i = 0; i < slidesGrid.length; i += 1) {
    if (typeof slidesGrid[i + 1] !== "undefined") {
      if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
        activeIndex = i;
      } else if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1]) {
        activeIndex = i + 1;
      }
    } else if (translate2 >= slidesGrid[i]) {
      activeIndex = i;
    }
  }
  if (params.normalizeSlideIndex) {
    if (activeIndex < 0 || typeof activeIndex === "undefined")
      activeIndex = 0;
  }
  return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  const getVirtualRealIndex = (aIndex) => {
    let realIndex2 = aIndex - swiper.virtual.slidesBefore;
    if (realIndex2 < 0) {
      realIndex2 = swiper.virtual.slides.length + realIndex2;
    }
    if (realIndex2 >= swiper.virtual.slides.length) {
      realIndex2 -= swiper.virtual.slides.length;
    }
    return realIndex2;
  };
  if (typeof activeIndex === "undefined") {
    activeIndex = getActiveIndexByTranslate(swiper);
  }
  if (snapGrid.indexOf(translate2) >= 0) {
    snapIndex = snapGrid.indexOf(translate2);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit("snapIndexChange");
    }
    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.realIndex = getVirtualRealIndex(activeIndex);
    }
    return;
  }
  let realIndex;
  if (swiper.virtual && params.virtual.enabled && params.loop) {
    realIndex = getVirtualRealIndex(activeIndex);
  } else if (swiper.slides[activeIndex]) {
    realIndex = parseInt(swiper.slides[activeIndex].getAttribute("data-swiper-slide-index") || activeIndex, 10);
  } else {
    realIndex = activeIndex;
  }
  Object.assign(swiper, {
    previousSnapIndex,
    snapIndex,
    previousRealIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  if (swiper.initialized) {
    preload2(swiper);
  }
  swiper.emit("activeIndexChange");
  swiper.emit("snapIndexChange");
  if (previousRealIndex !== realIndex) {
    swiper.emit("realIndexChange");
  }
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit("slideChange");
  }
}
function updateClickedSlide(e3) {
  const swiper = this;
  const params = swiper.params;
  const slide2 = e3.closest(`.${params.slideClass}, swiper-slide`);
  let slideFound = false;
  let slideIndex;
  if (slide2) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide2) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide2 && slideFound) {
    swiper.clickedSlide = slide2;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(slide2.getAttribute("data-swiper-slide-index"), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = void 0;
    swiper.clickedIndex = void 0;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}
const update2 = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};
function getSwiperTranslate(axis = this.isHorizontal() ? "x" : "y") {
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate: translate2,
    wrapperEl
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate2 : translate2;
  }
  if (params.cssMode) {
    return translate2;
  }
  let currentTranslate = getTranslate(wrapperEl, axis);
  currentTranslate += swiper.cssOverflowAdjustment();
  if (rtl)
    currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}
function setTranslate(translate2, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress
  } = swiper;
  let x2 = 0;
  let y2 = 0;
  const z2 = 0;
  if (swiper.isHorizontal()) {
    x2 = rtl ? -translate2 : translate2;
  } else {
    y2 = translate2;
  }
  if (params.roundLengths) {
    x2 = Math.floor(x2);
    y2 = Math.floor(y2);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x2 : y2;
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x2 : -y2;
  } else if (!params.virtualTranslate) {
    if (swiper.isHorizontal()) {
      x2 -= swiper.cssOverflowAdjustment();
    } else {
      y2 -= swiper.cssOverflowAdjustment();
    }
    wrapperEl.style.transform = `translate3d(${x2}px, ${y2}px, ${z2}px)`;
  }
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate2);
  }
  swiper.emit("setTranslate", swiper.translate, byController);
}
function minTranslate() {
  return -this.snapGrid[0];
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(translate2 = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate2 = swiper.minTranslate();
  const maxTranslate2 = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate2 > minTranslate2)
    newTranslate = minTranslate2;
  else if (translateBounds && translate2 < maxTranslate2)
    newTranslate = maxTranslate2;
  else
    newTranslate = translate2;
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: -newTranslate,
        behavior: "smooth"
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionEnd");
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionStart");
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e3) {
          if (!swiper || swiper.destroyed)
            return;
          if (e3.target !== this)
            return;
          swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          if (runCallbacks) {
            swiper.emit("transitionEnd");
          }
        };
      }
      swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}
const translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};
function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
  }
  swiper.emit("setTransition", duration, byController);
}
function transitionEmit({
  swiper,
  runCallbacks,
  direction,
  step
}) {
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex)
      dir = "next";
    else if (activeIndex < previousIndex)
      dir = "prev";
    else
      dir = "reset";
  }
  swiper.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === "reset") {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }
    swiper.emit(`slideChangeTransition${step}`);
    if (dir === "next") {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}
function transitionStart(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode)
    return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "Start"
  });
}
function transitionEnd(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode)
    return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "End"
  });
}
const transition = {
  setTransition,
  transitionStart,
  transitionEnd
};
function slideTo(index3 = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
  if (typeof index3 === "string") {
    index3 = parseInt(index3, 10);
  }
  const swiper = this;
  let slideIndex = index3;
  if (slideIndex < 0)
    slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
    return false;
  }
  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  const translate2 = -snapGrid[snapIndex];
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate2 * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== "undefined") {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  }
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate2 < swiper.translate && translate2 < swiper.minTranslate()) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) {
        return false;
      }
    }
  }
  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper.emit("beforeSlideChangeStart");
  }
  swiper.updateProgress(translate2);
  let direction;
  if (slideIndex > activeIndex)
    direction = "next";
  else if (slideIndex < activeIndex)
    direction = "prev";
  else
    direction = "reset";
  if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {
    swiper.updateActiveIndex(slideIndex);
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== "slide") {
      swiper.setTranslate(translate2);
    }
    if (direction !== "reset") {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t2 = rtl ? translate2 : -translate2;
    if (speed === 0) {
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = "none";
        swiper._immediateVirtual = true;
      }
      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
        swiper._cssModeVirtualInitialSet = true;
        requestAnimationFrame(() => {
          wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t2;
        });
      } else {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t2;
      }
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = "";
          swiper._immediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: t2,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: t2,
        behavior: "smooth"
      });
    }
    return true;
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate2);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit("beforeTransitionStart", speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e3) {
        if (!swiper || swiper.destroyed)
          return;
        if (e3.target !== this)
          return;
        swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}
function slideToLoop(index3 = 0, speed = this.params.speed, runCallbacks = true, internal) {
  if (typeof index3 === "string") {
    const indexAsNumber = parseInt(index3, 10);
    index3 = indexAsNumber;
  }
  const swiper = this;
  let newIndex = index3;
  if (swiper.params.loop) {
    if (swiper.virtual && swiper.params.virtual.enabled) {
      newIndex = newIndex + swiper.virtual.slidesBefore;
    } else {
      newIndex = swiper.getSlideIndexByData(newIndex);
    }
  }
  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}
function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    enabled,
    params,
    animating
  } = swiper;
  if (!enabled)
    return swiper;
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding)
      return false;
    swiper.loopFix({
      direction: "next"
    });
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating
  } = swiper;
  if (!enabled)
    return swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding)
      return false;
    swiper.loopFix({
      direction: "prev"
    });
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize2(val) {
    if (val < 0)
      return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize2(translate2);
  const normalizedSnapGrid = snapGrid.map((val) => normalize2(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === "undefined" && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== "undefined") {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== "undefined") {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0)
      prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold2 = 0.5) {
  const swiper = this;
  let index3 = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index3);
  const snapIndex = skip + Math.floor((index3 - skip) / swiper.params.slidesPerGroup);
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate2 >= swiper.snapGrid[snapIndex]) {
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold2) {
      index3 += swiper.params.slidesPerGroup;
    }
  } else {
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold2) {
      index3 -= swiper.params.slidesPerGroup;
    }
  }
  index3 = Math.max(index3, 0);
  index3 = Math.min(index3, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index3, speed, runCallbacks, internal);
}
function slideToClickedSlide() {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
  if (params.loop) {
    if (swiper.animating)
      return;
    realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
      nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}
const slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};
function loopCreate(slideRealIndex) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)
    return;
  const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  slides.forEach((el2, index3) => {
    el2.setAttribute("data-swiper-slide-index", index3);
  });
  swiper.loopFix({
    slideRealIndex,
    direction: params.centeredSlides ? void 0 : "next"
  });
}
function loopFix({
  slideRealIndex,
  slideTo: slideTo2 = true,
  direction,
  setTranslate: setTranslate2,
  activeSlideIndex,
  byController,
  byMousewheel
} = {}) {
  const swiper = this;
  if (!swiper.params.loop)
    return;
  swiper.emit("beforeLoopFix");
  const {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params
  } = swiper;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  if (swiper.virtual && params.virtual.enabled) {
    if (slideTo2) {
      if (!params.centeredSlides && swiper.snapIndex === 0) {
        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit("loopFix");
    return;
  }
  const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));
  let loopedSlides = params.loopedSlides || slidesPerView;
  if (loopedSlides % params.slidesPerGroup !== 0) {
    loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;
  }
  swiper.loopedSlides = loopedSlides;
  const prependSlidesIndexes = [];
  const appendSlidesIndexes = [];
  let activeIndex = swiper.activeIndex;
  if (typeof activeSlideIndex === "undefined") {
    activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter((el2) => el2.classList.contains(params.slideActiveClass))[0]);
  } else {
    activeIndex = activeSlideIndex;
  }
  const isNext = direction === "next" || !direction;
  const isPrev = direction === "prev" || !direction;
  let slidesPrepended = 0;
  let slidesAppended = 0;
  if (activeSlideIndex < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);
    for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {
      const index3 = i - Math.floor(i / slides.length) * slides.length;
      prependSlidesIndexes.push(slides.length - index3 - 1);
    }
  } else if (activeSlideIndex > swiper.slides.length - loopedSlides * 2) {
    slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);
    for (let i = 0; i < slidesAppended; i += 1) {
      const index3 = i - Math.floor(i / slides.length) * slides.length;
      appendSlidesIndexes.push(index3);
    }
  }
  if (isPrev) {
    prependSlidesIndexes.forEach((index3) => {
      swiper.slides[index3].swiperLoopMoveDOM = true;
      slidesEl.prepend(swiper.slides[index3]);
      swiper.slides[index3].swiperLoopMoveDOM = false;
    });
  }
  if (isNext) {
    appendSlidesIndexes.forEach((index3) => {
      swiper.slides[index3].swiperLoopMoveDOM = true;
      slidesEl.append(swiper.slides[index3]);
      swiper.slides[index3].swiperLoopMoveDOM = false;
    });
  }
  swiper.recalcSlides();
  if (params.slidesPerView === "auto") {
    swiper.updateSlides();
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (slideTo2) {
    if (prependSlidesIndexes.length > 0 && isPrev) {
      if (typeof slideRealIndex === "undefined") {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
        const diff2 = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff2);
        } else {
          swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);
          if (setTranslate2) {
            swiper.touches[swiper.isHorizontal() ? "startX" : "startY"] += diff2;
          }
        }
      } else {
        if (setTranslate2) {
          swiper.slideToLoop(slideRealIndex, 0, false, true);
        }
      }
    } else if (appendSlidesIndexes.length > 0 && isNext) {
      if (typeof slideRealIndex === "undefined") {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
        const diff2 = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff2);
        } else {
          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
          if (setTranslate2) {
            swiper.touches[swiper.isHorizontal() ? "startX" : "startY"] += diff2;
          }
        }
      } else {
        swiper.slideToLoop(slideRealIndex, 0, false, true);
      }
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.controller && swiper.controller.control && !byController) {
    const loopParams = {
      slideRealIndex,
      slideTo: false,
      direction,
      setTranslate: setTranslate2,
      activeSlideIndex,
      byController: true
    };
    if (Array.isArray(swiper.controller.control)) {
      swiper.controller.control.forEach((c2) => {
        if (!c2.destroyed && c2.params.loop)
          c2.loopFix(loopParams);
      });
    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
      swiper.controller.control.loopFix(loopParams);
    }
  }
  swiper.emit("loopFix");
}
function loopDestroy() {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)
    return;
  swiper.recalcSlides();
  const newSlidesOrder = [];
  swiper.slides.forEach((slideEl) => {
    const index3 = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index3] = slideEl;
  });
  swiper.slides.forEach((slideEl) => {
    slideEl.removeAttribute("data-swiper-slide-index");
  });
  newSlidesOrder.forEach((slideEl) => {
    slidesEl.append(slideEl);
  });
  swiper.recalcSlides();
  swiper.slideTo(swiper.realIndex, 0);
}
const loop = {
  loopCreate,
  loopFix,
  loopDestroy
};
function setGrabCursor(moving) {
  const swiper = this;
  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)
    return;
  const el2 = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  el2.style.cursor = "move";
  el2.style.cursor = moving ? "grabbing" : "grab";
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}
function unsetGrabCursor() {
  const swiper = this;
  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}
const grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};
function closestElement(selector, base = this) {
  function __closestFrom(el2) {
    if (!el2 || el2 === getDocument() || el2 === getWindow())
      return null;
    if (el2.assignedSlot)
      el2 = el2.assignedSlot;
    const found = el2.closest(selector);
    if (!found && !el2.getRootNode) {
      return null;
    }
    return found || __closestFrom(el2.getRootNode().host);
  }
  return __closestFrom(base);
}
function onTouchStart(event) {
  const swiper = this;
  const document2 = getDocument();
  const window2 = getWindow();
  const data2 = swiper.touchEventsData;
  data2.evCache.push(event);
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled)
    return;
  if (!params.simulateTouch && event.pointerType === "mouse")
    return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let e3 = event;
  if (e3.originalEvent)
    e3 = e3.originalEvent;
  let targetEl = e3.target;
  if (params.touchEventsTarget === "wrapper") {
    if (!swiper.wrapperEl.contains(targetEl))
      return;
  }
  if ("which" in e3 && e3.which === 3)
    return;
  if ("button" in e3 && e3.button > 0)
    return;
  if (data2.isTouched && data2.isMoved)
    return;
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
  const eventPath = event.composedPath ? event.composedPath() : event.path;
  if (swipingClassHasValue && e3.target && e3.target.shadowRoot && eventPath) {
    targetEl = eventPath[0];
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e3.target && e3.target.shadowRoot);
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!targetEl.closest(params.swipeHandler))
      return;
  }
  touches.currentX = e3.pageX;
  touches.currentY = e3.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;
  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === "prevent") {
      event.preventDefault();
    } else {
      return;
    }
  }
  Object.assign(data2, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: void 0,
    startMoving: void 0
  });
  touches.startX = startX;
  touches.startY = startY;
  data2.touchStartTime = now$2();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = void 0;
  if (params.threshold > 0)
    data2.allowThresholdMove = false;
  let preventDefault = true;
  if (targetEl.matches(data2.focusableElements)) {
    preventDefault = false;
    if (targetEl.nodeName === "SELECT") {
      data2.isTouched = false;
    }
  }
  if (document2.activeElement && document2.activeElement.matches(data2.focusableElements) && document2.activeElement !== targetEl) {
    document2.activeElement.blur();
  }
  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
    e3.preventDefault();
  }
  if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }
  swiper.emit("touchStart", e3);
}
function onTouchMove(event) {
  const document2 = getDocument();
  const swiper = this;
  const data2 = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled)
    return;
  if (!params.simulateTouch && event.pointerType === "mouse")
    return;
  let e3 = event;
  if (e3.originalEvent)
    e3 = e3.originalEvent;
  if (!data2.isTouched) {
    if (data2.startMoving && data2.isScrolling) {
      swiper.emit("touchMoveOpposite", e3);
    }
    return;
  }
  const pointerIndex = data2.evCache.findIndex((cachedEv) => cachedEv.pointerId === e3.pointerId);
  if (pointerIndex >= 0)
    data2.evCache[pointerIndex] = e3;
  const targetTouch = data2.evCache.length > 1 ? data2.evCache[0] : e3;
  const pageX = targetTouch.pageX;
  const pageY = targetTouch.pageY;
  if (e3.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    if (!e3.target.matches(data2.focusableElements)) {
      swiper.allowClick = false;
    }
    if (data2.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        prevX: swiper.touches.currentX,
        prevY: swiper.touches.currentY,
        currentX: pageX,
        currentY: pageY
      });
      data2.touchStartTime = now$2();
    }
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data2.isTouched = false;
        data2.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (document2.activeElement) {
    if (e3.target === document2.activeElement && e3.target.matches(data2.focusableElements)) {
      data2.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data2.allowTouchCallbacks) {
    swiper.emit("touchMove", e3);
  }
  if (e3.targetTouches && e3.targetTouches.length > 1)
    return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)
    return;
  if (typeof data2.isScrolling === "undefined") {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data2.isScrolling = false;
    } else {
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data2.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data2.isScrolling) {
    swiper.emit("touchMoveOpposite", e3);
  }
  if (typeof data2.startMoving === "undefined") {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data2.startMoving = true;
    }
  }
  if (data2.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data2.evCache.length > 1) {
    data2.isTouched = false;
    return;
  }
  if (!data2.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e3.cancelable) {
    e3.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e3.stopPropagation();
  }
  let diff2 = swiper.isHorizontal() ? diffX : diffY;
  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  if (params.oneWayMovement) {
    diff2 = Math.abs(diff2) * (rtl ? 1 : -1);
    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
  }
  touches.diff = diff2;
  diff2 *= params.touchRatio;
  if (rtl) {
    diff2 = -diff2;
    touchesDiff = -touchesDiff;
  }
  const prevTouchesDirection = swiper.touchesDirection;
  swiper.swipeDirection = diff2 > 0 ? "prev" : "next";
  swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
  const isLoop = swiper.params.loop && !params.cssMode;
  if (!data2.isMoved) {
    if (isLoop) {
      swiper.loopFix({
        direction: swiper.swipeDirection
      });
    }
    data2.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      const evt = new window.CustomEvent("transitionend", {
        bubbles: true,
        cancelable: true
      });
      swiper.wrapperEl.dispatchEvent(evt);
    }
    data2.allowMomentumBounce = false;
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit("sliderFirstMove", e3);
  }
  let loopFixed;
  if (data2.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff2) >= 1) {
    swiper.loopFix({
      direction: swiper.swipeDirection,
      setTranslate: true
    });
    loopFixed = true;
  }
  swiper.emit("sliderMove", e3);
  data2.isMoved = true;
  data2.currentTranslate = diff2 + data2.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff2 > 0) {
    if (isLoop && !loopFixed && data2.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {
      swiper.loopFix({
        direction: "prev",
        setTranslate: true,
        activeSlideIndex: 0
      });
    }
    if (data2.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data2.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data2.startTranslate + diff2) ** resistanceRatio;
      }
    }
  } else if (diff2 < 0) {
    if (isLoop && !loopFixed && data2.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {
      swiper.loopFix({
        direction: "next",
        setTranslate: true,
        activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
      });
    }
    if (data2.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data2.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data2.startTranslate - diff2) ** resistanceRatio;
      }
    }
  }
  if (disableParentSwiper) {
    e3.preventedByNestedSwiper = true;
  }
  if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data2.currentTranslate < data2.startTranslate) {
    data2.currentTranslate = data2.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data2.currentTranslate > data2.startTranslate) {
    data2.currentTranslate = data2.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data2.currentTranslate = data2.startTranslate;
  }
  if (params.threshold > 0) {
    if (Math.abs(diff2) > params.threshold || data2.allowThresholdMove) {
      if (!data2.allowThresholdMove) {
        data2.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data2.currentTranslate = data2.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data2.currentTranslate = data2.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode)
    return;
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  swiper.updateProgress(data2.currentTranslate);
  swiper.setTranslate(data2.currentTranslate);
}
function onTouchEnd(event) {
  const swiper = this;
  const data2 = swiper.touchEventsData;
  const pointerIndex = data2.evCache.findIndex((cachedEv) => cachedEv.pointerId === event.pointerId);
  if (pointerIndex >= 0) {
    data2.evCache.splice(pointerIndex, 1);
  }
  if (["pointercancel", "pointerout", "pointerleave"].includes(event.type)) {
    const proceed = event.type === "pointercancel" && (swiper.browser.isSafari || swiper.browser.isWebView);
    if (!proceed) {
      return;
    }
  }
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled)
    return;
  if (!params.simulateTouch && event.pointerType === "mouse")
    return;
  let e3 = event;
  if (e3.originalEvent)
    e3 = e3.originalEvent;
  if (data2.allowTouchCallbacks) {
    swiper.emit("touchEnd", e3);
  }
  data2.allowTouchCallbacks = false;
  if (!data2.isTouched) {
    if (data2.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data2.isMoved = false;
    data2.startMoving = false;
    return;
  }
  if (params.grabCursor && data2.isMoved && data2.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }
  const touchEndTime = now$2();
  const timeDiff = touchEndTime - data2.touchStartTime;
  if (swiper.allowClick) {
    const pathTree = e3.path || e3.composedPath && e3.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e3.target);
    swiper.emit("tap click", e3);
    if (timeDiff < 300 && touchEndTime - data2.lastClickTime < 300) {
      swiper.emit("doubleTap doubleClick", e3);
    }
  }
  data2.lastClickTime = now$2();
  nextTick(() => {
    if (!swiper.destroyed)
      swiper.allowClick = true;
  });
  if (!data2.isTouched || !data2.isMoved || !swiper.swipeDirection || touches.diff === 0 || data2.currentTranslate === data2.startTranslate) {
    data2.isTouched = false;
    data2.isMoved = false;
    data2.startMoving = false;
    return;
  }
  data2.isTouched = false;
  data2.isMoved = false;
  data2.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data2.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (swiper.params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + increment2] !== "undefined") {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment2] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === "next") {
      if (ratio >= params.longSwipesRatio)
        swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
      else
        swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === "prev") {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e3.target === swiper.navigation.nextEl || e3.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === "next") {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper.swipeDirection === "prev") {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e3.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}
function onResize() {
  const swiper = this;
  const {
    params,
    el: el2
  } = swiper;
  if (el2 && el2.offsetWidth === 0)
    return;
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper;
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  const isVirtualLoop = isVirtual && params.loop;
  if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    if (swiper.params.loop && !isVirtual) {
      swiper.slideToLoop(swiper.realIndex, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    clearTimeout(swiper.autoplay.resizeTimeout);
    swiper.autoplay.resizeTimeout = setTimeout(() => {
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.resume();
      }
    }, 500);
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}
function onClick(e3) {
  const swiper = this;
  if (!swiper.enabled)
    return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks)
      e3.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e3.stopPropagation();
      e3.stopImmediatePropagation();
    }
  }
}
function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled)
    return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  if (swiper.translate === 0)
    swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit("setTranslate", swiper.translate, false);
}
function onLoad(e3) {
  const swiper = this;
  processLazyPreloader(swiper, e3.target);
  if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) {
    return;
  }
  swiper.update();
}
let dummyEventAttached = false;
function dummyEventListener() {
}
const events = (swiper, method) => {
  const document2 = getDocument();
  const {
    params,
    el: el2,
    wrapperEl,
    device
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
  const swiperMethod = method;
  el2[domMethod]("pointerdown", swiper.onTouchStart, {
    passive: false
  });
  document2[domMethod]("pointermove", swiper.onTouchMove, {
    passive: false,
    capture
  });
  document2[domMethod]("pointerup", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointercancel", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerout", swiper.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerleave", swiper.onTouchEnd, {
    passive: true
  });
  if (params.preventClicks || params.preventClicksPropagation) {
    el2[domMethod]("click", swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]("scroll", swiper.onScroll);
  }
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
  } else {
    swiper[swiperMethod]("observerUpdate", onResize, true);
  }
  el2[domMethod]("load", swiper.onLoad, {
    capture: true
  });
};
function attachEvents() {
  const swiper = this;
  const document2 = getDocument();
  const {
    params
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  swiper.onLoad = onLoad.bind(swiper);
  if (!dummyEventAttached) {
    document2.addEventListener("touchstart", dummyEventListener);
    dummyEventAttached = true;
  }
  events(swiper, "on");
}
function detachEvents() {
  const swiper = this;
  events(swiper, "off");
}
const events$1 = {
  attachEvents,
  detachEvents
};
const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    realIndex,
    initialized,
    params,
    el: el2
  } = swiper;
  const breakpoints2 = params.breakpoints;
  if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)
    return;
  const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint)
    return;
  const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    el2.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    el2.classList.add(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
      el2.classList.add(`${params.containerModifierClass}grid-column`);
    }
    swiper.emitContainerClasses();
  }
  ["navigation", "pagination", "scrollbar"].forEach((prop3) => {
    const wasModuleEnabled = params[prop3] && params[prop3].enabled;
    const isModuleEnabled = breakpointParams[prop3] && breakpointParams[prop3].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper[prop3].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper[prop3].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  extend$2(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit("_beforeBreakpoint", breakpointParams);
  if (needsReLoop && initialized) {
    swiper.loopDestroy();
    swiper.loopCreate(realIndex);
    swiper.updateSlides();
  }
  swiper.emit("breakpoint", breakpointParams);
}
function getBreakpoint(breakpoints2, base = "window", containerEl) {
  if (!breakpoints2 || base === "container" && !containerEl)
    return void 0;
  let breakpoint = false;
  const window2 = getWindow();
  const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints2).map((point2) => {
    if (typeof point2 === "string" && point2.indexOf("@") === 0) {
      const minRatio = parseFloat(point2.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point: point2
      };
    }
    return {
      value: point2,
      point: point2
    };
  });
  points.sort((a2, b2) => parseInt(a2.value, 10) - parseInt(b2.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const {
      point: point2,
      value
    } = points[i];
    if (base === "window") {
      if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point2;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point2;
    }
  }
  return breakpoint || "max";
}
const breakpoints = {
  setBreakpoint,
  getBreakpoint
};
function prepareClasses(entries, prefix2) {
  const resultClasses = [];
  entries.forEach((item) => {
    if (typeof item === "object") {
      Object.keys(item).forEach((classNames2) => {
        if (item[classNames2]) {
          resultClasses.push(prefix2 + classNames2);
        }
      });
    } else if (typeof item === "string") {
      resultClasses.push(prefix2 + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames: classNames2,
    params,
    rtl,
    el: el2,
    device
  } = swiper;
  const suffixes = prepareClasses(["initialized", params.direction, {
    "free-mode": swiper.params.freeMode && params.freeMode.enabled
  }, {
    "autoheight": params.autoHeight
  }, {
    "rtl": rtl
  }, {
    "grid": params.grid && params.grid.rows > 1
  }, {
    "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
  }, {
    "android": device.android
  }, {
    "ios": device.ios
  }, {
    "css-mode": params.cssMode
  }, {
    "centered": params.cssMode && params.centeredSlides
  }, {
    "watch-progress": params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames2.push(...suffixes);
  el2.classList.add(...classNames2);
  swiper.emitContainerClasses();
}
function removeClasses() {
  const swiper = this;
  const {
    el: el2,
    classNames: classNames2
  } = swiper;
  el2.classList.remove(...classNames2);
  swiper.emitContainerClasses();
}
const classes = {
  addClasses,
  removeClasses
};
function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? "lock" : "unlock");
  }
}
const checkOverflow$1 = {
  checkOverflow
};
const defaults$1 = {
  init: true,
  direction: "horizontal",
  oneWayMovement: false,
  touchEventsTarget: "wrapper",
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  enabled: true,
  focusableElements: "input, select, option, textarea, button, video, label",
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: "slide",
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: void 0,
  breakpointsBase: "window",
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 5,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // loop
  loop: false,
  loopedSlides: null,
  loopPreventsSliding: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: "swiper-",
  // NEW
  slideClass: "swiper-slide",
  slideActiveClass: "swiper-slide-active",
  slideVisibleClass: "swiper-slide-visible",
  slideNextClass: "swiper-slide-next",
  slidePrevClass: "swiper-slide-prev",
  wrapperClass: "swiper-wrapper",
  lazyPreloaderClass: "swiper-lazy-preloader",
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};
function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj = {}) {
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== "object" || moduleParams === null) {
      extend$2(allModulesParams, obj);
      return;
    }
    if (["navigation", "pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
      params[moduleParamName] = {
        auto: true
      };
    }
    if (!(moduleParamName in params && "enabled" in moduleParams)) {
      extend$2(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName])
      params[moduleParamName] = {
        enabled: false
      };
    extend$2(allModulesParams, obj);
  };
}
const prototypes = {
  eventsEmitter,
  update: update2,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes
};
const extendedDefaults = {};
let Swiper$1 = class Swiper {
  constructor(...args) {
    let el2;
    let params;
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
      params = args[0];
    } else {
      [el2, params] = args;
    }
    if (!params)
      params = {};
    params = extend$2({}, params);
    if (el2 && !params.el)
      params.el = el2;
    const document2 = getDocument();
    if (params.el && typeof params.el === "string" && document2.querySelectorAll(params.el).length > 1) {
      const swipers = [];
      document2.querySelectorAll(params.el).forEach((containerEl) => {
        const newParams = extend$2({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach((mod2) => {
      mod2({
        params,
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });
    const swiperParams = extend$2({}, defaults$1, allModulesParams);
    swiper.params = extend$2({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend$2({}, swiper.params);
    swiper.passedParams = extend$2({}, params);
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach((eventName) => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el: el2,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return swiper.params.direction === "horizontal";
      },
      isVertical() {
        return swiper.params.direction === "vertical";
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      cssOverflowAdjustment() {
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: void 0,
        // Velocities
        velocities: [],
        allowMomentumBounce: void 0,
        startMoving: void 0,
        evCache: []
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit("_swiper");
    if (swiper.params.init) {
      swiper.init();
    }
    return swiper;
  }
  getSlideIndex(slideEl) {
    const {
      slidesEl,
      params
    } = this;
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    const firstSlideIndex = elementIndex(slides[0]);
    return elementIndex(slideEl) - firstSlideIndex;
  }
  getSlideIndexByData(index3) {
    return this.getSlideIndex(this.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === index3)[0]);
  }
  recalcSlides() {
    const swiper = this;
    const {
      slidesEl,
      params
    } = swiper;
    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  }
  enable() {
    const swiper = this;
    if (swiper.enabled)
      return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit("enable");
  }
  disable() {
    const swiper = this;
    if (!swiper.enabled)
      return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit("disable");
  }
  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min3 = swiper.minTranslate();
    const max3 = swiper.maxTranslate();
    const current2 = (max3 - min3) * progress + min3;
    swiper.translateTo(current2, typeof speed === "undefined" ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    const cls = swiper.el.className.split(" ").filter((className) => {
      return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit("_containerClasses", cls.join(" "));
  }
  getSlideClasses(slideEl) {
    const swiper = this;
    if (swiper.destroyed)
      return "";
    return slideEl.className.split(" ").filter((className) => {
      return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(" ");
  }
  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    const updates = [];
    swiper.slides.forEach((slideEl) => {
      const classNames2 = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames: classNames2
      });
      swiper.emit("_slideClass", slideEl, classNames2);
    });
    swiper.emit("_slideClasses", updates);
  }
  slidesPerViewDynamic(view3 = "current", exact = false) {
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
    } else {
      if (view3 === "current") {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed)
      return;
    const {
      snapGrid,
      params
    } = swiper;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      }
    });
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate2() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
      setTranslate2();
      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        const slides = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
        translated = swiper.slideTo(slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate2();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit("update");
  }
  changeDirection(newDirection, needUpdate = true) {
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
    }
    if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
      return swiper;
    }
    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.forEach((slideEl) => {
      if (newDirection === "vertical") {
        slideEl.style.width = "";
      } else {
        slideEl.style.height = "";
      }
    });
    swiper.emit("changeDirection");
    if (needUpdate)
      swiper.update();
    return swiper;
  }
  changeLanguageDirection(direction) {
    const swiper = this;
    if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr")
      return;
    swiper.rtl = direction === "rtl";
    swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
    if (swiper.rtl) {
      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = "rtl";
    } else {
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = "ltr";
    }
    swiper.update();
  }
  mount(element) {
    const swiper = this;
    if (swiper.mounted)
      return true;
    let el2 = element || swiper.params.el;
    if (typeof el2 === "string") {
      el2 = document.querySelector(el2);
    }
    if (!el2) {
      return false;
    }
    el2.swiper = swiper;
    if (el2.shadowEl) {
      swiper.isElement = true;
    }
    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
    };
    const getWrapper = () => {
      if (el2 && el2.shadowRoot && el2.shadowRoot.querySelector) {
        const res = el2.shadowRoot.querySelector(getWrapperSelector());
        return res;
      }
      return elementChildren(el2, getWrapperSelector())[0];
    };
    let wrapperEl = getWrapper();
    if (!wrapperEl && swiper.params.createElements) {
      wrapperEl = createElement("div", swiper.params.wrapperClass);
      el2.append(wrapperEl);
      elementChildren(el2, `.${swiper.params.slideClass}`).forEach((slideEl) => {
        wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      el: el2,
      wrapperEl,
      slidesEl: swiper.isElement ? el2 : wrapperEl,
      mounted: true,
      // RTL
      rtl: el2.dir.toLowerCase() === "rtl" || elementStyle(el2, "direction") === "rtl",
      rtlTranslate: swiper.params.direction === "horizontal" && (el2.dir.toLowerCase() === "rtl" || elementStyle(el2, "direction") === "rtl"),
      wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
    });
    return true;
  }
  init(el2) {
    const swiper = this;
    if (swiper.initialized)
      return swiper;
    const mounted = swiper.mount(el2);
    if (mounted === false)
      return swiper;
    swiper.emit("beforeInit");
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.addClasses();
    swiper.updateSize();
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }
    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }
    if (swiper.params.loop) {
      swiper.loopCreate();
    }
    swiper.attachEvents();
    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      } else {
        imageEl.addEventListener("load", (e3) => {
          processLazyPreloader(swiper, e3.target);
        });
      }
    });
    preload2(swiper);
    swiper.initialized = true;
    preload2(swiper);
    swiper.emit("init");
    swiper.emit("afterInit");
    return swiper;
  }
  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params,
      el: el2,
      wrapperEl,
      slides
    } = swiper;
    if (typeof swiper.params === "undefined" || swiper.destroyed) {
      return null;
    }
    swiper.emit("beforeDestroy");
    swiper.initialized = false;
    swiper.detachEvents();
    if (params.loop) {
      swiper.loopDestroy();
    }
    if (cleanStyles) {
      swiper.removeClasses();
      el2.removeAttribute("style");
      wrapperEl.removeAttribute("style");
      if (slides && slides.length) {
        slides.forEach((slideEl) => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
          slideEl.removeAttribute("style");
          slideEl.removeAttribute("data-swiper-slide-index");
        });
      }
    }
    swiper.emit("destroy");
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      swiper.el.swiper = null;
      deleteProps(swiper);
    }
    swiper.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    extend$2(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults$1;
  }
  static installModule(mod2) {
    if (!Swiper.prototype.__modules__)
      Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;
    if (typeof mod2 === "function" && modules.indexOf(mod2) < 0) {
      modules.push(mod2);
    }
  }
  static use(module2) {
    if (Array.isArray(module2)) {
      module2.forEach((m2) => Swiper.installModule(m2));
      return Swiper;
    }
    Swiper.installModule(module2);
    return Swiper;
  }
};
Object.keys(prototypes).forEach((prototypeGroup) => {
  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
    Swiper$1.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper$1.use([Resize, Observer]);
function isObject$8(o3) {
  return typeof o3 === "object" && o3 !== null && o3.constructor && Object.prototype.toString.call(o3).slice(8, -1) === "Object";
}
function extend$1(target, src) {
  const noExtend = ["__proto__", "constructor", "prototype"];
  Object.keys(src).filter((key) => noExtend.indexOf(key) < 0).forEach((key) => {
    if (typeof target[key] === "undefined")
      target[key] = src[key];
    else if (isObject$8(src[key]) && isObject$8(target[key]) && Object.keys(src[key]).length > 0) {
      if (src[key].__swiper__)
        target[key] = src[key];
      else
        extend$1(target[key], src[key]);
    } else {
      target[key] = src[key];
    }
  });
}
function needsNavigation(params = {}) {
  return params.navigation && typeof params.navigation.nextEl === "undefined" && typeof params.navigation.prevEl === "undefined";
}
function needsPagination(params = {}) {
  return params.pagination && typeof params.pagination.el === "undefined";
}
function needsScrollbar(params = {}) {
  return params.scrollbar && typeof params.scrollbar.el === "undefined";
}
function uniqueClasses(classNames2 = "") {
  const classes2 = classNames2.split(" ").map((c2) => c2.trim()).filter((c2) => !!c2);
  const unique = [];
  classes2.forEach((c2) => {
    if (unique.indexOf(c2) < 0)
      unique.push(c2);
  });
  return unique.join(" ");
}
function wrapperClass(className = "") {
  if (!className)
    return "swiper-wrapper";
  if (!className.includes("swiper-wrapper"))
    return `swiper-wrapper ${className}`;
  return className;
}
const paramsList = [
  "eventsPrefix",
  "injectStyles",
  "injectStylesUrls",
  "modules",
  "init",
  "_direction",
  "oneWayMovement",
  "touchEventsTarget",
  "initialSlide",
  "_speed",
  "cssMode",
  "updateOnWindowResize",
  "resizeObserver",
  "nested",
  "focusableElements",
  "_enabled",
  "_width",
  "_height",
  "preventInteractionOnTransition",
  "userAgent",
  "url",
  "_edgeSwipeDetection",
  "_edgeSwipeThreshold",
  "_freeMode",
  "_autoHeight",
  "setWrapperSize",
  "virtualTranslate",
  "_effect",
  "breakpoints",
  "_spaceBetween",
  "_slidesPerView",
  "maxBackfaceHiddenSlides",
  "_grid",
  "_slidesPerGroup",
  "_slidesPerGroupSkip",
  "_slidesPerGroupAuto",
  "_centeredSlides",
  "_centeredSlidesBounds",
  "_slidesOffsetBefore",
  "_slidesOffsetAfter",
  "normalizeSlideIndex",
  "_centerInsufficientSlides",
  "_watchOverflow",
  "roundLengths",
  "touchRatio",
  "touchAngle",
  "simulateTouch",
  "_shortSwipes",
  "_longSwipes",
  "longSwipesRatio",
  "longSwipesMs",
  "_followFinger",
  "allowTouchMove",
  "_threshold",
  "touchMoveStopPropagation",
  "touchStartPreventDefault",
  "touchStartForcePreventDefault",
  "touchReleaseOnEdges",
  "uniqueNavElements",
  "_resistance",
  "_resistanceRatio",
  "_watchSlidesProgress",
  "_grabCursor",
  "preventClicks",
  "preventClicksPropagation",
  "_slideToClickedSlide",
  "_loop",
  "loopedSlides",
  "loopPreventsSliding",
  "_rewind",
  "_allowSlidePrev",
  "_allowSlideNext",
  "_swipeHandler",
  "_noSwiping",
  "noSwipingClass",
  "noSwipingSelector",
  "passiveListeners",
  "containerModifierClass",
  "slideClass",
  "slideActiveClass",
  "slideVisibleClass",
  "slideNextClass",
  "slidePrevClass",
  "wrapperClass",
  "lazyPreloaderClass",
  "lazyPreloadPrevNext",
  "runCallbacksOnInit",
  "observer",
  "observeParents",
  "observeSlideChildren",
  // modules
  "a11y",
  "_autoplay",
  "_controller",
  "coverflowEffect",
  "cubeEffect",
  "fadeEffect",
  "flipEffect",
  "creativeEffect",
  "cardsEffect",
  "hashNavigation",
  "history",
  "keyboard",
  "mousewheel",
  "_navigation",
  "_pagination",
  "parallax",
  "_scrollbar",
  "_thumbs",
  "virtual",
  "zoom",
  "control"
];
function getParams(obj = {}, splitEvents = true) {
  const params = {
    on: {}
  };
  const events2 = {};
  const passedParams = {};
  extend$1(params, Swiper$1.defaults);
  extend$1(params, Swiper$1.extendedDefaults);
  params._emitClasses = true;
  params.init = false;
  const rest = {};
  const allowedParams = paramsList.map((key) => key.replace(/_/, ""));
  const plainObj = Object.assign({}, obj);
  Object.keys(plainObj).forEach((key) => {
    if (typeof obj[key] === "undefined")
      return;
    if (allowedParams.indexOf(key) >= 0) {
      if (isObject$8(obj[key])) {
        params[key] = {};
        passedParams[key] = {};
        extend$1(params[key], obj[key]);
        extend$1(passedParams[key], obj[key]);
      } else {
        params[key] = obj[key];
        passedParams[key] = obj[key];
      }
    } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === "function") {
      if (splitEvents) {
        events2[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      } else {
        params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      }
    } else {
      rest[key] = obj[key];
    }
  });
  ["navigation", "pagination", "scrollbar"].forEach((key) => {
    if (params[key] === true)
      params[key] = {};
    if (params[key] === false)
      delete params[key];
  });
  return {
    params,
    passedParams,
    rest,
    events: events2
  };
}
function mountSwiper({
  el: el2,
  nextEl,
  prevEl,
  paginationEl,
  scrollbarEl,
  swiper
}, swiperParams) {
  if (needsNavigation(swiperParams) && nextEl && prevEl) {
    swiper.params.navigation.nextEl = nextEl;
    swiper.originalParams.navigation.nextEl = nextEl;
    swiper.params.navigation.prevEl = prevEl;
    swiper.originalParams.navigation.prevEl = prevEl;
  }
  if (needsPagination(swiperParams) && paginationEl) {
    swiper.params.pagination.el = paginationEl;
    swiper.originalParams.pagination.el = paginationEl;
  }
  if (needsScrollbar(swiperParams) && scrollbarEl) {
    swiper.params.scrollbar.el = scrollbarEl;
    swiper.originalParams.scrollbar.el = scrollbarEl;
  }
  swiper.init(el2);
}
function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
  const keys4 = [];
  if (!oldParams)
    return keys4;
  const addKey = (key) => {
    if (keys4.indexOf(key) < 0)
      keys4.push(key);
  };
  if (children && oldChildren) {
    const oldChildrenKeys = oldChildren.map(getKey);
    const childrenKeys = children.map(getKey);
    if (oldChildrenKeys.join("") !== childrenKeys.join(""))
      addKey("children");
    if (oldChildren.length !== children.length)
      addKey("children");
  }
  const watchParams = paramsList.filter((key) => key[0] === "_").map((key) => key.replace(/_/, ""));
  watchParams.forEach((key) => {
    if (key in swiperParams && key in oldParams) {
      if (isObject$8(swiperParams[key]) && isObject$8(oldParams[key])) {
        const newKeys = Object.keys(swiperParams[key]);
        const oldKeys = Object.keys(oldParams[key]);
        if (newKeys.length !== oldKeys.length) {
          addKey(key);
        } else {
          newKeys.forEach((newKey) => {
            if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
              addKey(key);
            }
          });
          oldKeys.forEach((oldKey) => {
            if (swiperParams[key][oldKey] !== oldParams[key][oldKey])
              addKey(key);
          });
        }
      } else if (swiperParams[key] !== oldParams[key]) {
        addKey(key);
      }
    }
  });
  return keys4;
}
function isChildSwiperSlide(child) {
  return child.type && child.type.displayName && child.type.displayName.includes("SwiperSlide");
}
function processChildren(c2) {
  const slides = [];
  React.Children.toArray(c2).forEach((child) => {
    if (isChildSwiperSlide(child)) {
      slides.push(child);
    } else if (child.props && child.props.children) {
      processChildren(child.props.children).forEach((slide2) => slides.push(slide2));
    }
  });
  return slides;
}
function getChildren(c2) {
  const slides = [];
  const slots = {
    "container-start": [],
    "container-end": [],
    "wrapper-start": [],
    "wrapper-end": []
  };
  React.Children.toArray(c2).forEach((child) => {
    if (isChildSwiperSlide(child)) {
      slides.push(child);
    } else if (child.props && child.props.slot && slots[child.props.slot]) {
      slots[child.props.slot].push(child);
    } else if (child.props && child.props.children) {
      const foundSlides = processChildren(child.props.children);
      if (foundSlides.length > 0) {
        foundSlides.forEach((slide2) => slides.push(slide2));
      } else {
        slots["container-end"].push(child);
      }
    } else {
      slots["container-end"].push(child);
    }
  });
  return {
    slides,
    slots
  };
}
function updateSwiper({
  swiper,
  slides,
  passedParams,
  changedParams,
  nextEl,
  prevEl,
  scrollbarEl,
  paginationEl
}) {
  const updateParams = changedParams.filter((key) => key !== "children" && key !== "direction" && key !== "wrapperClass");
  const {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper;
  let needThumbsInit;
  let needControllerInit;
  let needPaginationInit;
  let needScrollbarInit;
  let needNavigationInit;
  let loopNeedDestroy;
  let loopNeedEnable;
  let loopNeedReloop;
  if (changedParams.includes("thumbs") && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
    needThumbsInit = true;
  }
  if (changedParams.includes("controller") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
    needControllerInit = true;
  }
  if (changedParams.includes("pagination") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
    needPaginationInit = true;
  }
  if (changedParams.includes("scrollbar") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
    needScrollbarInit = true;
  }
  if (changedParams.includes("navigation") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
    needNavigationInit = true;
  }
  const destroyModule = (mod2) => {
    if (!swiper[mod2])
      return;
    swiper[mod2].destroy();
    if (mod2 === "navigation") {
      if (swiper.isElement) {
        swiper[mod2].prevEl.remove();
        swiper[mod2].nextEl.remove();
      }
      currentParams[mod2].prevEl = void 0;
      currentParams[mod2].nextEl = void 0;
      swiper[mod2].prevEl = void 0;
      swiper[mod2].nextEl = void 0;
    } else {
      if (swiper.isElement) {
        swiper[mod2].el.remove();
      }
      currentParams[mod2].el = void 0;
      swiper[mod2].el = void 0;
    }
  };
  if (changedParams.includes("loop") && swiper.isElement) {
    if (currentParams.loop && !passedParams.loop) {
      loopNeedDestroy = true;
    } else if (!currentParams.loop && passedParams.loop) {
      loopNeedEnable = true;
    } else {
      loopNeedReloop = true;
    }
  }
  updateParams.forEach((key) => {
    if (isObject$8(currentParams[key]) && isObject$8(passedParams[key])) {
      extend$1(currentParams[key], passedParams[key]);
      if ((key === "navigation" || key === "pagination" || key === "scrollbar") && "enabled" in passedParams[key] && !passedParams[key].enabled) {
        destroyModule(key);
      }
    } else {
      const newValue = passedParams[key];
      if ((newValue === true || newValue === false) && (key === "navigation" || key === "pagination" || key === "scrollbar")) {
        if (newValue === false) {
          destroyModule(key);
        }
      } else {
        currentParams[key] = passedParams[key];
      }
    }
  });
  if (updateParams.includes("controller") && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (changedParams.includes("children") && slides && virtual && currentParams.virtual.enabled) {
    virtual.slides = slides;
    virtual.update(true);
  }
  if (changedParams.includes("children") && slides && currentParams.loop) {
    loopNeedReloop = true;
  }
  if (needThumbsInit) {
    const initialized = thumbs.init();
    if (initialized)
      thumbs.update(true);
  }
  if (needControllerInit) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (needPaginationInit) {
    if (swiper.isElement && (!paginationEl || typeof paginationEl === "string")) {
      paginationEl = document.createElement("div");
      paginationEl.classList.add("swiper-pagination");
      swiper.el.shadowEl.appendChild(paginationEl);
    }
    if (paginationEl)
      currentParams.pagination.el = paginationEl;
    pagination.init();
    pagination.render();
    pagination.update();
  }
  if (needScrollbarInit) {
    if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === "string")) {
      scrollbarEl = document.createElement("div");
      scrollbarEl.classList.add("swiper-scrollbar");
      swiper.el.shadowEl.appendChild(scrollbarEl);
    }
    if (scrollbarEl)
      currentParams.scrollbar.el = scrollbarEl;
    scrollbar.init();
    scrollbar.updateSize();
    scrollbar.setTranslate();
  }
  if (needNavigationInit) {
    if (swiper.isElement) {
      if (!nextEl || typeof nextEl === "string") {
        nextEl = document.createElement("div");
        nextEl.classList.add("swiper-button-next");
        swiper.el.shadowEl.appendChild(nextEl);
      }
      if (!prevEl || typeof prevEl === "string") {
        prevEl = document.createElement("div");
        prevEl.classList.add("swiper-button-prev");
        swiper.el.shadowEl.appendChild(prevEl);
      }
    }
    if (nextEl)
      currentParams.navigation.nextEl = nextEl;
    if (prevEl)
      currentParams.navigation.prevEl = prevEl;
    navigation.init();
    navigation.update();
  }
  if (changedParams.includes("allowSlideNext")) {
    swiper.allowSlideNext = passedParams.allowSlideNext;
  }
  if (changedParams.includes("allowSlidePrev")) {
    swiper.allowSlidePrev = passedParams.allowSlidePrev;
  }
  if (changedParams.includes("direction")) {
    swiper.changeDirection(passedParams.direction, false);
  }
  if (loopNeedDestroy || loopNeedReloop) {
    swiper.loopDestroy();
  }
  if (loopNeedEnable || loopNeedReloop) {
    swiper.loopCreate();
  }
  swiper.update();
}
function renderVirtual(swiper, slides, virtualData) {
  if (!virtualData)
    return null;
  const getSlideIndex = (index3) => {
    let slideIndex = index3;
    if (index3 < 0) {
      slideIndex = slides.length + index3;
    } else if (slideIndex >= slides.length) {
      slideIndex = slideIndex - slides.length;
    }
    return slideIndex;
  };
  const style = swiper.isHorizontal() ? {
    [swiper.rtlTranslate ? "right" : "left"]: `${virtualData.offset}px`
  } : {
    top: `${virtualData.offset}px`
  };
  const {
    from: from2,
    to: to2
  } = virtualData;
  const loopFrom = swiper.params.loop ? -slides.length : 0;
  const loopTo = swiper.params.loop ? slides.length * 2 : slides.length;
  const slidesToRender = [];
  for (let i = loopFrom; i < loopTo; i += 1) {
    if (i >= from2 && i <= to2) {
      slidesToRender.push(slides[getSlideIndex(i)]);
    }
  }
  return slidesToRender.map((child, index3) => {
    return /* @__PURE__ */ React.cloneElement(child, {
      swiper,
      style,
      key: `slide-${index3}`
    });
  });
}
const updateOnVirtualData = (swiper) => {
  if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled)
    return;
  swiper.updateSlides();
  swiper.updateProgress();
  swiper.updateSlidesClasses();
  if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {
    swiper.parallax.setTranslate();
  }
};
function useIsomorphicLayoutEffect(callback, deps) {
  if (typeof window === "undefined")
    return reactExports.useEffect(callback, deps);
  return reactExports.useLayoutEffect(callback, deps);
}
const SwiperSlideContext = /* @__PURE__ */ reactExports.createContext(null);
const SwiperContext = /* @__PURE__ */ reactExports.createContext(null);
function _extends$o() {
  _extends$o = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$o.apply(this, arguments);
}
const Swiper2 = /* @__PURE__ */ reactExports.forwardRef(function(_temp, externalElRef) {
  let {
    className,
    tag: Tag = "div",
    wrapperTag: WrapperTag = "div",
    children,
    onSwiper,
    ...rest
  } = _temp === void 0 ? {} : _temp;
  let eventsAssigned = false;
  const [containerClasses, setContainerClasses] = reactExports.useState("swiper");
  const [virtualData, setVirtualData] = reactExports.useState(null);
  const [breakpointChanged, setBreakpointChanged] = reactExports.useState(false);
  const initializedRef = reactExports.useRef(false);
  const swiperElRef = reactExports.useRef(null);
  const swiperRef = reactExports.useRef(null);
  const oldPassedParamsRef = reactExports.useRef(null);
  const oldSlides = reactExports.useRef(null);
  const nextElRef = reactExports.useRef(null);
  const prevElRef = reactExports.useRef(null);
  const paginationElRef = reactExports.useRef(null);
  const scrollbarElRef = reactExports.useRef(null);
  const {
    params: swiperParams,
    passedParams,
    rest: restProps,
    events: events2
  } = getParams(rest);
  const {
    slides,
    slots
  } = getChildren(children);
  const onBeforeBreakpoint = () => {
    setBreakpointChanged(!breakpointChanged);
  };
  Object.assign(swiperParams.on, {
    _containerClasses(swiper, classes2) {
      setContainerClasses(classes2);
    }
  });
  const initSwiper = () => {
    Object.assign(swiperParams.on, events2);
    eventsAssigned = true;
    const passParams = {
      ...swiperParams
    };
    delete passParams.wrapperClass;
    swiperRef.current = new Swiper$1(passParams);
    if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {
      swiperRef.current.virtual.slides = slides;
      const extendWith = {
        cache: false,
        slides,
        renderExternal: setVirtualData,
        renderExternalUpdate: false
      };
      extend$1(swiperRef.current.params.virtual, extendWith);
      extend$1(swiperRef.current.originalParams.virtual, extendWith);
    }
  };
  if (!swiperElRef.current) {
    initSwiper();
  }
  if (swiperRef.current) {
    swiperRef.current.on("_beforeBreakpoint", onBeforeBreakpoint);
  }
  const attachEvents2 = () => {
    if (eventsAssigned || !events2 || !swiperRef.current)
      return;
    Object.keys(events2).forEach((eventName) => {
      swiperRef.current.on(eventName, events2[eventName]);
    });
  };
  const detachEvents2 = () => {
    if (!events2 || !swiperRef.current)
      return;
    Object.keys(events2).forEach((eventName) => {
      swiperRef.current.off(eventName, events2[eventName]);
    });
  };
  reactExports.useEffect(() => {
    return () => {
      if (swiperRef.current)
        swiperRef.current.off("_beforeBreakpoint", onBeforeBreakpoint);
    };
  });
  reactExports.useEffect(() => {
    if (!initializedRef.current && swiperRef.current) {
      swiperRef.current.emitSlidesClasses();
      initializedRef.current = true;
    }
  });
  useIsomorphicLayoutEffect(() => {
    if (externalElRef) {
      externalElRef.current = swiperElRef.current;
    }
    if (!swiperElRef.current)
      return;
    if (swiperRef.current.destroyed) {
      initSwiper();
    }
    mountSwiper({
      el: swiperElRef.current,
      nextEl: nextElRef.current,
      prevEl: prevElRef.current,
      paginationEl: paginationElRef.current,
      scrollbarEl: scrollbarElRef.current,
      swiper: swiperRef.current
    }, swiperParams);
    if (onSwiper)
      onSwiper(swiperRef.current);
    return () => {
      if (swiperRef.current && !swiperRef.current.destroyed) {
        swiperRef.current.destroy(true, false);
      }
    };
  }, []);
  useIsomorphicLayoutEffect(() => {
    attachEvents2();
    const changedParams = getChangedParams(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, (c2) => c2.key);
    oldPassedParamsRef.current = passedParams;
    oldSlides.current = slides;
    if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {
      updateSwiper({
        swiper: swiperRef.current,
        slides,
        passedParams,
        changedParams,
        nextEl: nextElRef.current,
        prevEl: prevElRef.current,
        scrollbarEl: scrollbarElRef.current,
        paginationEl: paginationElRef.current
      });
    }
    return () => {
      detachEvents2();
    };
  });
  useIsomorphicLayoutEffect(() => {
    updateOnVirtualData(swiperRef.current);
  }, [virtualData]);
  function renderSlides() {
    if (swiperParams.virtual) {
      return renderVirtual(swiperRef.current, slides, virtualData);
    }
    return slides.map((child, index3) => {
      return /* @__PURE__ */ React.cloneElement(child, {
        swiper: swiperRef.current,
        swiperSlideIndex: index3
      });
    });
  }
  return /* @__PURE__ */ React.createElement(Tag, _extends$o({
    ref: swiperElRef,
    className: uniqueClasses(`${containerClasses}${className ? ` ${className}` : ""}`)
  }, restProps), /* @__PURE__ */ React.createElement(SwiperContext.Provider, {
    value: swiperRef.current
  }, slots["container-start"], /* @__PURE__ */ React.createElement(WrapperTag, {
    className: wrapperClass(swiperParams.wrapperClass)
  }, slots["wrapper-start"], renderSlides(), slots["wrapper-end"]), needsNavigation(swiperParams) && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    ref: prevElRef,
    className: "swiper-button-prev"
  }), /* @__PURE__ */ React.createElement("div", {
    ref: nextElRef,
    className: "swiper-button-next"
  })), needsScrollbar(swiperParams) && /* @__PURE__ */ React.createElement("div", {
    ref: scrollbarElRef,
    className: "swiper-scrollbar"
  }), needsPagination(swiperParams) && /* @__PURE__ */ React.createElement("div", {
    ref: paginationElRef,
    className: "swiper-pagination"
  }), slots["container-end"]));
});
Swiper2.displayName = "Swiper";
function _extends$n() {
  _extends$n = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$n.apply(this, arguments);
}
const SwiperSlide = /* @__PURE__ */ reactExports.forwardRef(function(_temp, externalRef) {
  let {
    tag: Tag = "div",
    children,
    className = "",
    swiper,
    zoom,
    lazy,
    virtualIndex,
    swiperSlideIndex,
    ...rest
  } = _temp === void 0 ? {} : _temp;
  const slideElRef = reactExports.useRef(null);
  const [slideClasses, setSlideClasses] = reactExports.useState("swiper-slide");
  const [lazyLoaded, setLazyLoaded] = reactExports.useState(false);
  function updateClasses(_s2, el2, classNames2) {
    if (el2 === slideElRef.current) {
      setSlideClasses(classNames2);
    }
  }
  useIsomorphicLayoutEffect(() => {
    if (typeof swiperSlideIndex !== "undefined") {
      slideElRef.current.swiperSlideIndex = swiperSlideIndex;
    }
    if (externalRef) {
      externalRef.current = slideElRef.current;
    }
    if (!slideElRef.current || !swiper) {
      return;
    }
    if (swiper.destroyed) {
      if (slideClasses !== "swiper-slide") {
        setSlideClasses("swiper-slide");
      }
      return;
    }
    swiper.on("_slideClass", updateClasses);
    return () => {
      if (!swiper)
        return;
      swiper.off("_slideClass", updateClasses);
    };
  });
  useIsomorphicLayoutEffect(() => {
    if (swiper && slideElRef.current && !swiper.destroyed) {
      setSlideClasses(swiper.getSlideClasses(slideElRef.current));
    }
  }, [swiper]);
  const slideData = {
    isActive: slideClasses.indexOf("swiper-slide-active") >= 0,
    isVisible: slideClasses.indexOf("swiper-slide-visible") >= 0,
    isPrev: slideClasses.indexOf("swiper-slide-prev") >= 0,
    isNext: slideClasses.indexOf("swiper-slide-next") >= 0
  };
  const renderChildren = () => {
    return typeof children === "function" ? children(slideData) : children;
  };
  const onLoad2 = () => {
    setLazyLoaded(true);
  };
  return /* @__PURE__ */ React.createElement(Tag, _extends$n({
    ref: slideElRef,
    className: uniqueClasses(`${slideClasses}${className ? ` ${className}` : ""}`),
    "data-swiper-slide-index": virtualIndex,
    onLoad: onLoad2
  }, rest), zoom && /* @__PURE__ */ React.createElement(SwiperSlideContext.Provider, {
    value: slideData
  }, /* @__PURE__ */ React.createElement("div", {
    className: "swiper-zoom-container",
    "data-swiper-zoom": typeof zoom === "number" ? zoom : void 0
  }, renderChildren(), lazy && !lazyLoaded && /* @__PURE__ */ React.createElement("div", {
    className: "swiper-lazy-preloader"
  }))), !zoom && /* @__PURE__ */ React.createElement(SwiperSlideContext.Provider, {
    value: slideData
  }, renderChildren(), lazy && !lazyLoaded && /* @__PURE__ */ React.createElement("div", {
    className: "swiper-lazy-preloader"
  })));
});
SwiperSlide.displayName = "SwiperSlide";
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module2) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames2() {
      var classes2 = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes2.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes2.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            classes2.push(arg.toString());
            continue;
          }
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes2.push(key);
            }
          }
        }
      }
      return classes2.join(" ");
    }
    if (module2.exports) {
      classNames2.default = classNames2;
      module2.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classnamesExports = classnames.exports;
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
function isObject$7(value) {
  var type3 = typeof value;
  return value != null && (type3 == "object" || type3 == "function");
}
var isObject_1 = isObject$7;
const _isObject = /* @__PURE__ */ getDefaultExportFromCjs(isObject_1);
var freeGlobal$1 = typeof commonjsGlobal$2 == "object" && commonjsGlobal$2 && commonjsGlobal$2.Object === Object && commonjsGlobal$2;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var Symbol$7 = root$8.Symbol;
var _Symbol = Symbol$7;
var Symbol$6 = _Symbol;
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
var nativeObjectToString$1 = objectProto$b.toString;
var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$a = Object.prototype;
var nativeObjectToString = objectProto$a.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$5 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$8(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$8;
var baseGetTag$7 = _baseGetTag, isObject$6 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$6(value)) {
    return false;
  }
  var tag = baseGetTag$7(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
const _isFunction = /* @__PURE__ */ getDefaultExportFromCjs(isFunction_1);
var isArray$e = Array.isArray;
var isArray_1 = isArray$e;
const _isArray2 = /* @__PURE__ */ getDefaultExportFromCjs(isArray_1);
function isObjectLike$8(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$8;
var baseGetTag$6 = _baseGetTag, isArray$d = isArray_1, isObjectLike$7 = isObjectLike_1;
var stringTag$2 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray$d(value) && isObjectLike$7(value) && baseGetTag$6(value) == stringTag$2;
}
var isString_1 = isString;
const _isString = /* @__PURE__ */ getDefaultExportFromCjs(isString_1);
var baseGetTag$5 = _baseGetTag, isObjectLike$6 = isObjectLike_1;
var symbolTag$1 = "[object Symbol]";
function isSymbol$6(value) {
  return typeof value == "symbol" || isObjectLike$6(value) && baseGetTag$5(value) == symbolTag$1;
}
var isSymbol_1 = isSymbol$6;
var isArray$c = isArray_1, isSymbol$5 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$3(value, object2) {
  if (isArray$c(value)) {
    return false;
  }
  var type3 = typeof value;
  if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value == null || isSymbol$5(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
}
var _isKey = isKey$3;
var root$7 = _root;
var coreJsData$1 = root$7["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func3) {
  return !!maskSrcKey && maskSrcKey in func3;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func3) {
  if (func3 != null) {
    try {
      return funcToString$1.call(func3);
    } catch (e3) {
    }
    try {
      return func3 + "";
    } catch (e3) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1, isMasked = _isMasked, isObject$5 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$9 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$5(value) || isMasked(value)) {
    return false;
  }
  var pattern3 = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern3.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object2, key) {
  var value = getValue(object2, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var nativeCreate$4 = getNative$6(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function hashGet$1(key) {
  var data2 = this.__data__;
  if (nativeCreate$2) {
    var result = data2[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$7.call(data2, key) ? data2[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function hashHas$1(key) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$6.call(data2, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index3 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index3 < length3) {
    var entry = entries[index3];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$3(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$3;
var eq$2 = eq_1;
function assocIndexOf$4(array3, key) {
  var length3 = array3.length;
  while (length3--) {
    if (eq$2(array3[length3][0], key)) {
      return length3;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data2 = this.__data__, index3 = assocIndexOf$3(data2, key);
  if (index3 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index3 == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index3, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data2 = this.__data__, index3 = assocIndexOf$2(data2, key);
  return index3 < 0 ? void 0 : data2[index3][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data2 = this.__data__, index3 = assocIndexOf(data2, key);
  if (index3 < 0) {
    ++this.size;
    data2.push([key, value]);
  } else {
    data2[index3][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index3 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index3 < length3) {
    var entry = entries[index3];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var getNative$5 = _getNative, root$6 = _root;
var Map$4 = getNative$5(root$6, "Map");
var _Map = Map$4;
var Hash = _Hash, ListCache$3 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$3)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type3 = typeof value;
  return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map3, key) {
  var data2 = map3.__data__;
  return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data2 = getMapData(this, key), size = data2.size;
  data2.set(key, value);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index3 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index3 < length3) {
    var entry = entries[index3];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var MapCache$2 = _MapCache;
var FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize$2(func3, resolver) {
  if (typeof func3 != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func3.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize$2.Cache || MapCache$2)();
  return memoized;
}
memoize$2.Cache = MapCache$2;
var memoize_1 = memoize$2;
var memoize$1 = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func3) {
  var result = memoize$1(func3, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string4) {
  var result = [];
  if (string4.charCodeAt(0) === 46) {
    result.push("");
  }
  string4.replace(rePropName, function(match5, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match5);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$3(array3, iteratee) {
  var index3 = -1, length3 = array3 == null ? 0 : array3.length, result = Array(length3);
  while (++index3 < length3) {
    result[index3] = iteratee(array3[index3], index3, array3);
  }
  return result;
}
var _arrayMap = arrayMap$3;
var Symbol$4 = _Symbol, arrayMap$2 = _arrayMap, isArray$b = isArray_1, isSymbol$4 = isSymbol_1;
var INFINITY$3 = 1 / 0;
var symbolProto$1 = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$b(value)) {
    return arrayMap$2(value, baseToString$1) + "";
  }
  if (isSymbol$4(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$4(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$4;
var isArray$a = isArray_1, isKey$2 = _isKey, stringToPath = _stringToPath, toString$3 = toString_1;
function castPath$2(value, object2) {
  if (isArray$a(value)) {
    return value;
  }
  return isKey$2(value, object2) ? [value] : stringToPath(toString$3(value));
}
var _castPath = castPath$2;
var isSymbol$3 = isSymbol_1;
var INFINITY$2 = 1 / 0;
function toKey$4(value) {
  if (typeof value == "string" || isSymbol$3(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
var _toKey = toKey$4;
var castPath$1 = _castPath, toKey$3 = _toKey;
function baseGet$3(object2, path3) {
  path3 = castPath$1(path3, object2);
  var index3 = 0, length3 = path3.length;
  while (object2 != null && index3 < length3) {
    object2 = object2[toKey$3(path3[index3++])];
  }
  return index3 && index3 == length3 ? object2 : void 0;
}
var _baseGet = baseGet$3;
var baseGet$2 = _baseGet;
function get$1(object2, path3, defaultValue) {
  var result = object2 == null ? void 0 : baseGet$2(object2, path3);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$1;
const _get = /* @__PURE__ */ getDefaultExportFromCjs(get_1);
function isNil2(value) {
  return value == null;
}
var isNil_1 = isNil2;
const _isNil = /* @__PURE__ */ getDefaultExportFromCjs(isNil_1);
var baseGetTag$4 = _baseGetTag, isObjectLike$5 = isObjectLike_1;
var numberTag$2 = "[object Number]";
function isNumber$2(value) {
  return typeof value == "number" || isObjectLike$5(value) && baseGetTag$4(value) == numberTag$2;
}
var isNumber_1 = isNumber$2;
const _isNumber = /* @__PURE__ */ getDefaultExportFromCjs(isNumber_1);
var isNumber$1 = isNumber_1;
function isNaN$1(value) {
  return isNumber$1(value) && value != +value;
}
var _isNaN = isNaN$1;
const _isNaN$1 = /* @__PURE__ */ getDefaultExportFromCjs(_isNaN);
var mathSign = function mathSign2(value) {
  if (value === 0) {
    return 0;
  }
  if (value > 0) {
    return 1;
  }
  return -1;
};
var isPercent = function isPercent2(value) {
  return _isString(value) && value.indexOf("%") === value.length - 1;
};
var isNumber = function isNumber2(value) {
  return _isNumber(value) && !_isNaN$1(value);
};
var isNumOrStr = function isNumOrStr2(value) {
  return isNumber(value) || _isString(value);
};
var idCounter = 0;
var uniqueId = function uniqueId2(prefix2) {
  var id2 = ++idCounter;
  return "".concat(prefix2 || "").concat(id2);
};
var getPercentValue = function getPercentValue2(percent, totalValue) {
  var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var validate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (!isNumber(percent) && !_isString(percent)) {
    return defaultValue;
  }
  var value;
  if (isPercent(percent)) {
    var index3 = percent.indexOf("%");
    value = totalValue * parseFloat(percent.slice(0, index3)) / 100;
  } else {
    value = +percent;
  }
  if (_isNaN$1(value)) {
    value = defaultValue;
  }
  if (validate && value > totalValue) {
    value = totalValue;
  }
  return value;
};
var getAnyElementOfObject = function getAnyElementOfObject2(obj) {
  if (!obj) {
    return null;
  }
  var keys4 = Object.keys(obj);
  if (keys4 && keys4.length) {
    return obj[keys4[0]];
  }
  return null;
};
var hasDuplicate = function hasDuplicate2(ary) {
  if (!_isArray2(ary)) {
    return false;
  }
  var len = ary.length;
  var cache2 = {};
  for (var i = 0; i < len; i++) {
    if (!cache2[ary[i]]) {
      cache2[ary[i]] = true;
    } else {
      return true;
    }
  }
  return false;
};
var interpolateNumber$2 = function interpolateNumber(numberA, numberB) {
  if (isNumber(numberA) && isNumber(numberB)) {
    return function(t2) {
      return numberA + t2 * (numberB - numberA);
    };
  }
  return function() {
    return numberB;
  };
};
function findEntryInArray(ary, specifiedKey, specifiedValue) {
  if (!ary || !ary.length) {
    return null;
  }
  return ary.find(function(entry) {
    return entry && (typeof specifiedKey === "function" ? specifiedKey(entry) : _get(entry, specifiedKey)) === specifiedValue;
  });
}
function shallowEqual(a2, b2) {
  for (var key in a2) {
    if ({}.hasOwnProperty.call(a2, key) && (!{}.hasOwnProperty.call(b2, key) || a2[key] !== b2[key])) {
      return false;
    }
  }
  for (var _key in b2) {
    if ({}.hasOwnProperty.call(b2, _key) && !{}.hasOwnProperty.call(a2, _key)) {
      return false;
    }
  }
  return true;
}
function _typeof$v(obj) {
  "@babel/helpers - typeof";
  return _typeof$v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$v(obj);
}
var SVGContainerPropKeys = ["viewBox", "children"];
var SVGElementPropKeys = [
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "className",
  "color",
  "height",
  "id",
  "lang",
  "max",
  "media",
  "method",
  "min",
  "name",
  "style",
  /*
   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
   * that can use it and it conflicts with the recharts prop 'type'
   * https://github.com/recharts/recharts/pull/3327
   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
   */
  // 'type',
  "target",
  "width",
  "role",
  "tabIndex",
  "accentHeight",
  "accumulate",
  "additive",
  "alignmentBaseline",
  "allowReorder",
  "alphabetic",
  "amplitude",
  "arabicForm",
  "ascent",
  "attributeName",
  "attributeType",
  "autoReverse",
  "azimuth",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "bbox",
  "begin",
  "bias",
  "by",
  "calcMode",
  "capHeight",
  "clip",
  "clipPath",
  "clipPathUnits",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "diffuseConstant",
  "direction",
  "display",
  "divisor",
  "dominantBaseline",
  "dur",
  "dx",
  "dy",
  "edgeMode",
  "elevation",
  "enableBackground",
  "end",
  "exponent",
  "externalResourcesRequired",
  "fill",
  "fillOpacity",
  "fillRule",
  "filter",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "focusable",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "format",
  "from",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "hanging",
  "horizAdvX",
  "horizOriginX",
  "href",
  "ideographic",
  "imageRendering",
  "in2",
  "in",
  "intercept",
  "k1",
  "k2",
  "k3",
  "k4",
  "k",
  "kernelMatrix",
  "kernelUnitLength",
  "kerning",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "local",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "mask",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "mode",
  "numOctaves",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "overlinePosition",
  "overlineThickness",
  "paintOrder",
  "panose1",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "renderingIntent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "seed",
  "shapeRendering",
  "slope",
  "spacing",
  "specularConstant",
  "specularExponent",
  "speed",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stemh",
  "stemv",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "string",
  "stroke",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textLength",
  "textRendering",
  "to",
  "transform",
  "u1",
  "u2",
  "underlinePosition",
  "underlineThickness",
  "unicode",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "values",
  "vectorEffect",
  "version",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "vHanging",
  "vIdeographic",
  "viewTarget",
  "visibility",
  "vMathematical",
  "widths",
  "wordSpacing",
  "writingMode",
  "x1",
  "x2",
  "x",
  "xChannelSelector",
  "xHeight",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlns",
  "xmlnsXlink",
  "xmlSpace",
  "y1",
  "y2",
  "y",
  "yChannelSelector",
  "z",
  "zoomAndPan",
  "ref",
  "key",
  "angle"
];
var PolyElementKeys = ["points", "pathLength"];
var FilteredElementKeyMap = {
  svg: SVGContainerPropKeys,
  polygon: PolyElementKeys,
  polyline: PolyElementKeys
};
var EventKeys = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"];
var adaptEventHandlers = function adaptEventHandlers2(props3, newHandler) {
  if (!props3 || typeof props3 === "function" || typeof props3 === "boolean") {
    return null;
  }
  var inputProps = props3;
  if (/* @__PURE__ */ reactExports.isValidElement(props3)) {
    inputProps = props3.props;
  }
  if (!_isObject(inputProps)) {
    return null;
  }
  var out = {};
  Object.keys(inputProps).forEach(function(key) {
    if (EventKeys.includes(key)) {
      out[key] = newHandler || function(e3) {
        return inputProps[key](inputProps, e3);
      };
    }
  });
  return out;
};
var getEventHandlerOfChild = function getEventHandlerOfChild2(originalHandler, data2, index3) {
  return function(e3) {
    originalHandler(data2, index3, e3);
    return null;
  };
};
var adaptEventsOfChild = function adaptEventsOfChild2(props3, data2, index3) {
  if (!_isObject(props3) || _typeof$v(props3) !== "object") {
    return null;
  }
  var out = null;
  Object.keys(props3).forEach(function(key) {
    var item = props3[key];
    if (EventKeys.includes(key) && typeof item === "function") {
      if (!out)
        out = {};
      out[key] = getEventHandlerOfChild(item, data2, index3);
    }
  });
  return out;
};
var _excluded$c = ["children"], _excluded2$2 = ["children"];
function _objectWithoutProperties$c(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$d(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$d(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var REACT_BROWSER_EVENT_MAP = {
  click: "onClick",
  mousedown: "onMouseDown",
  mouseup: "onMouseUp",
  mouseover: "onMouseOver",
  mousemove: "onMouseMove",
  mouseout: "onMouseOut",
  mouseenter: "onMouseEnter",
  mouseleave: "onMouseLeave",
  touchcancel: "onTouchCancel",
  touchend: "onTouchEnd",
  touchmove: "onTouchMove",
  touchstart: "onTouchStart"
};
var getDisplayName = function getDisplayName2(Comp) {
  if (typeof Comp === "string") {
    return Comp;
  }
  if (!Comp) {
    return "";
  }
  return Comp.displayName || Comp.name || "Component";
};
var lastChildren = null;
var lastResult = null;
var toArray = function toArray2(children) {
  if (children === lastChildren && _isArray2(lastResult)) {
    return lastResult;
  }
  var result = [];
  reactExports.Children.forEach(children, function(child) {
    if (_isNil(child))
      return;
    if (reactIsExports$1.isFragment(child)) {
      result = result.concat(toArray2(child.props.children));
    } else {
      result.push(child);
    }
  });
  lastResult = result;
  lastChildren = children;
  return result;
};
function findAllByType(children, type3) {
  var result = [];
  var types = [];
  if (_isArray2(type3)) {
    types = type3.map(function(t2) {
      return getDisplayName(t2);
    });
  } else {
    types = [getDisplayName(type3)];
  }
  toArray(children).forEach(function(child) {
    var childType = _get(child, "type.displayName") || _get(child, "type.name");
    if (types.indexOf(childType) !== -1) {
      result.push(child);
    }
  });
  return result;
}
function findChildByType(children, type3) {
  var result = findAllByType(children, type3);
  return result && result[0];
}
var validateWidthHeight = function validateWidthHeight2(el2) {
  if (!el2 || !el2.props) {
    return false;
  }
  var _el$props = el2.props, width = _el$props.width, height = _el$props.height;
  if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0) {
    return false;
  }
  return true;
};
var SVG_TAGS = ["a", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColormatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-url", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "lineGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "script", "set", "stop", "style", "svg", "switch", "symbol", "text", "textPath", "title", "tref", "tspan", "use", "view", "vkern"];
var isSvgElement = function isSvgElement2(child) {
  return child && child.type && _isString(child.type) && SVG_TAGS.indexOf(child.type) >= 0;
};
var isValidSpreadableProp = function isValidSpreadableProp2(property2, key, includeEvents, svgElementType) {
  var _FilteredElementKeyMa;
  var matchingElementTypeKeys = (_FilteredElementKeyMa = FilteredElementKeyMap === null || FilteredElementKeyMap === void 0 ? void 0 : FilteredElementKeyMap[svgElementType]) !== null && _FilteredElementKeyMa !== void 0 ? _FilteredElementKeyMa : [];
  return !_isFunction(property2) && (svgElementType && matchingElementTypeKeys.includes(key) || SVGElementPropKeys.includes(key)) || includeEvents && EventKeys.includes(key);
};
var filterProps = function filterProps2(props3, includeEvents, svgElementType) {
  if (!props3 || typeof props3 === "function" || typeof props3 === "boolean") {
    return null;
  }
  var inputProps = props3;
  if (/* @__PURE__ */ reactExports.isValidElement(props3)) {
    inputProps = props3.props;
  }
  if (!_isObject(inputProps)) {
    return null;
  }
  var out = {};
  Object.keys(inputProps).forEach(function(key) {
    var _inputProps;
    if (isValidSpreadableProp((_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps[key], key, includeEvents, svgElementType)) {
      out[key] = inputProps[key];
    }
  });
  return out;
};
var isChildrenEqual = function isChildrenEqual2(nextChildren, prevChildren) {
  if (nextChildren === prevChildren) {
    return true;
  }
  var count2 = reactExports.Children.count(nextChildren);
  if (count2 !== reactExports.Children.count(prevChildren)) {
    return false;
  }
  if (count2 === 0) {
    return true;
  }
  if (count2 === 1) {
    return isSingleChildEqual(_isArray2(nextChildren) ? nextChildren[0] : nextChildren, _isArray2(prevChildren) ? prevChildren[0] : prevChildren);
  }
  for (var i = 0; i < count2; i++) {
    var nextChild = nextChildren[i];
    var prevChild = prevChildren[i];
    if (_isArray2(nextChild) || _isArray2(prevChild)) {
      if (!isChildrenEqual2(nextChild, prevChild)) {
        return false;
      }
    } else if (!isSingleChildEqual(nextChild, prevChild)) {
      return false;
    }
  }
  return true;
};
var isSingleChildEqual = function isSingleChildEqual2(nextChild, prevChild) {
  if (_isNil(nextChild) && _isNil(prevChild)) {
    return true;
  }
  if (!_isNil(nextChild) && !_isNil(prevChild)) {
    var _ref = nextChild.props || {}, nextChildren = _ref.children, nextProps = _objectWithoutProperties$c(_ref, _excluded$c);
    var _ref2 = prevChild.props || {}, prevChildren = _ref2.children, prevProps = _objectWithoutProperties$c(_ref2, _excluded2$2);
    if (nextChildren && prevChildren) {
      return shallowEqual(nextProps, prevProps) && isChildrenEqual(nextChildren, prevChildren);
    }
    if (!nextChildren && !prevChildren) {
      return shallowEqual(nextProps, prevProps);
    }
    return false;
  }
  return false;
};
var renderByOrder = function renderByOrder2(children, renderMap) {
  var elements = [];
  var record = {};
  toArray(children).forEach(function(child, index3) {
    if (isSvgElement(child)) {
      elements.push(child);
    } else if (child) {
      var displayName = getDisplayName(child.type);
      var _ref3 = renderMap[displayName] || {}, handler = _ref3.handler, once4 = _ref3.once;
      if (handler && (!once4 || !record[displayName])) {
        var results = handler(child, displayName, index3);
        elements.push(results);
        record[displayName] = true;
      }
    }
  });
  return elements;
};
var getReactEventByType = function getReactEventByType2(e3) {
  var type3 = e3 && e3.type;
  if (type3 && REACT_BROWSER_EVENT_MAP[type3]) {
    return REACT_BROWSER_EVENT_MAP[type3];
  }
  return null;
};
var parseChildIndex = function parseChildIndex2(child, children) {
  return toArray(children).indexOf(child);
};
var _excluded$b = ["children", "width", "height", "viewBox", "className", "style"];
function _extends$m() {
  _extends$m = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$m.apply(this, arguments);
}
function _objectWithoutProperties$b(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$c(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$c(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function Surface(props3) {
  var children = props3.children, width = props3.width, height = props3.height, viewBox = props3.viewBox, className = props3.className, style = props3.style, others = _objectWithoutProperties$b(props3, _excluded$b);
  var svgView = viewBox || {
    width,
    height,
    x: 0,
    y: 0
  };
  var layerClass = classNames("recharts-surface", className);
  return /* @__PURE__ */ React.createElement("svg", _extends$m({}, filterProps(others, true, "svg"), {
    className: layerClass,
    width,
    height,
    style,
    viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height)
  }), /* @__PURE__ */ React.createElement("title", null, props3.title), /* @__PURE__ */ React.createElement("desc", null, props3.desc), children);
}
var _excluded$a = ["children", "className"];
function _extends$l() {
  _extends$l = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$l.apply(this, arguments);
}
function _objectWithoutProperties$a(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$b(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$b(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var Layer = /* @__PURE__ */ React.forwardRef(function(props3, ref) {
  var children = props3.children, className = props3.className, others = _objectWithoutProperties$a(props3, _excluded$a);
  var layerClass = classNames("recharts-layer", className);
  return /* @__PURE__ */ React.createElement("g", _extends$l({
    className: layerClass
  }, filterProps(others, true), {
    ref
  }), children);
});
var ListCache$2 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$2();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data2 = this.__data__, result = data2["delete"](key);
  this.size = data2.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$1(key, value) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache$1) {
    var pairs = data2.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache$1(pairs);
  }
  data2.set(key, value);
  this.size = data2.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(entries) {
  var data2 = this.__data__ = new ListCache(entries);
  this.size = data2.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$2(values3) {
  var index3 = -1, length3 = values3 == null ? 0 : values3.length;
  this.__data__ = new MapCache();
  while (++index3 < length3) {
    this.add(values3[index3]);
  }
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
SetCache$2.prototype.has = setCacheHas;
var _SetCache = SetCache$2;
function arraySome$2(array3, predicate3) {
  var index3 = -1, length3 = array3 == null ? 0 : array3.length;
  while (++index3 < length3) {
    if (predicate3(array3[index3], index3, array3)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$2;
function cacheHas$2(cache2, key) {
  return cache2.has(key);
}
var _cacheHas = cacheHas$2;
var SetCache$1 = _SetCache, arraySome$1 = _arraySome, cacheHas$1 = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array3, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array3.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array3);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array3;
  }
  var index3 = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache$1() : void 0;
  stack.set(array3, other);
  stack.set(other, array3);
  while (++index3 < arrLength) {
    var arrValue = array3[index3], othValue = other[index3];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index3, other, array3, stack) : customizer(arrValue, othValue, index3, array3, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen2) {
      if (!arraySome$1(other, function(othValue2, othIndex) {
        if (!cacheHas$1(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen2.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array3);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root$5 = _root;
var Uint8Array$2 = root$5.Uint8Array;
var _Uint8Array = Uint8Array$2;
function mapToArray$1(map3) {
  var index3 = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index3] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$3(set4) {
  var index3 = -1, result = Array(set4.size);
  set4.forEach(function(value) {
    result[++index3] = value;
  });
  return result;
}
var _setToArray = setToArray$3;
var Symbol$3 = _Symbol, Uint8Array$1 = _Uint8Array, eq$1 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray$2 = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$2 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
var symbolProto = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag$1(object2, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
        return false;
      }
      object2 = object2.buffer;
      other = other.buffer;
    case arrayBufferTag$1:
      if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object2), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag$2:
    case dateTag$1:
    case numberTag$1:
      return eq$1(+object2, +other);
    case errorTag$1:
      return object2.name == other.name && object2.message == other.message;
    case regexpTag$1:
    case stringTag$1:
      return object2 == other + "";
    case mapTag$2:
      var convert2 = mapToArray;
    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert2 || (convert2 = setToArray$2);
      if (object2.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object2);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object2, other);
      var result = equalArrays$1(convert2(object2), convert2(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object2);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object2) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$2(array3, values3) {
  var index3 = -1, length3 = values3.length, offset2 = array3.length;
  while (++index3 < length3) {
    array3[offset2 + index3] = values3[index3];
  }
  return array3;
}
var _arrayPush = arrayPush$2;
var arrayPush$1 = _arrayPush, isArray$9 = isArray_1;
function baseGetAllKeys$1(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray$9(object2) ? result : arrayPush$1(result, symbolsFunc(object2));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$1(array3, predicate3) {
  var index3 = -1, length3 = array3 == null ? 0 : array3.length, resIndex = 0, result = [];
  while (++index3 < length3) {
    var value = array3[index3];
    if (predicate3(value, index3, array3)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$1() {
  return [];
}
var stubArray_1 = stubArray$1;
var arrayFilter = _arrayFilter, stubArray = stubArray_1;
var objectProto$6 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return arrayFilter(nativeGetSymbols(object2), function(symbol4) {
    return propertyIsEnumerable$1.call(object2, symbol4);
  });
};
var _getSymbols = getSymbols$1;
function baseTimes$1(n2, iteratee) {
  var index3 = -1, result = Array(n2);
  while (++index3 < n2) {
    result[index3] = iteratee(index3);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var baseGetTag$3 = _baseGetTag, isObjectLike$4 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$4(value) && baseGetTag$3(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$3 = isObjectLike_1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
var isArguments$3 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$3(value) && hasOwnProperty$5.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments$3;
var isBuffer$2 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$2.exports;
(function(module2, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module2.exports = isBuffer2;
})(isBuffer$2, isBuffer$2.exports);
var isBufferExports = isBuffer$2.exports;
var MAX_SAFE_INTEGER$2 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$3(value, length3) {
  var type3 = typeof value;
  length3 = length3 == null ? MAX_SAFE_INTEGER$2 : length3;
  return !!length3 && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
}
var _isIndex = isIndex$3;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$3;
var baseGetTag$2 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$2 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$2 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$2(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$2(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$2(func3) {
  return function(value) {
    return func3(value);
  };
}
var _baseUnary = baseUnary$2;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module2, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  module2.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray, baseUnary$1 = _baseUnary, nodeUtil = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$1(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes, isArguments$2 = isArguments_1, isArray$8 = isArray_1, isBuffer$1 = isBufferExports, isIndex$2 = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$8(value), isArg = !isArr && isArguments$2(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length3 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$2(key, length3)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$3 = Object.prototype;
function isPrototype$1(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$3;
  return value === proto2;
}
var _isPrototype = isPrototype$1;
function overArg$1(func3, transform) {
  return function(arg) {
    return func3(transform(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$2 = Object.prototype;
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
function baseKeys$1(object2) {
  if (!isPrototype(object2)) {
    return nativeKeys(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty$3.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction$1 = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$5(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$5;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$4 = isArrayLike_1;
function keys$4(object2) {
  return isArrayLike$4(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
}
var keys_1 = keys$4;
var baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys$3 = keys_1;
function getAllKeys$1(object2) {
  return baseGetAllKeys(object2, keys$3, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function equalObjects$1(object2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index3 = objLength;
  while (index3--) {
    var key = objProps[index3];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object2);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object2;
  }
  var result = true;
  stack.set(object2, other);
  stack.set(other, object2);
  var skipCtor = isPartial;
  while (++index3 < objLength) {
    key = objProps[index3];
    var objValue = object2[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object2.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object2);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$4 = _getNative, root$4 = _root;
var DataView$2 = getNative$4(root$4, "DataView");
var _DataView = DataView$2;
var getNative$3 = _getNative, root$3 = _root;
var Promise$2 = getNative$3(root$3, "Promise");
var _Promise = Promise$2;
var getNative$2 = _getNative, root$2 = _root;
var Set$3 = getNative$2(root$2, "Set");
var _Set = Set$3;
var getNative$1 = _getNative, root$1 = _root;
var WeakMap$2 = getNative$1(root$1, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView$1 = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$2 = _Set, WeakMap$1 = _WeakMap, baseGetTag$1 = _baseGetTag, toSource = _toSource;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
var getTag$1 = baseGetTag$1;
if (DataView$1 && getTag$1(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$2 && getTag$1(new Set$2()) != setTag || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag) {
  getTag$1 = function(value) {
    var result = baseGetTag$1(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var _getTag = getTag$1;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray$7 = isArray_1, isBuffer = isBufferExports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function baseIsEqualDeep$1(object2, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$7(object2), othIsArr = isArray$7(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object2)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$1 = isObjectLike_1;
function baseIsEqual$3(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$1(value) && !isObjectLike$1(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);
}
var _baseIsEqual = baseIsEqual$3;
var Stack = _Stack, baseIsEqual$2 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object2, source, matchData, customizer) {
  var index3 = matchData.length, length3 = index3, noCustomizer = !customizer;
  if (object2 == null) {
    return !length3;
  }
  object2 = Object(object2);
  while (index3--) {
    var data2 = matchData[index3];
    if (noCustomizer && data2[2] ? data2[1] !== object2[data2[0]] : !(data2[0] in object2)) {
      return false;
    }
  }
  while (++index3 < length3) {
    data2 = matchData[index3];
    var key = data2[0], objValue = object2[key], srcValue = data2[1];
    if (noCustomizer && data2[2]) {
      if (objValue === void 0 && !(key in object2)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object2, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$4 = isObject_1;
function isStrictComparable$2(value) {
  return value === value && !isObject$4(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable, keys$2 = keys_1;
function getMatchData$1(object2) {
  var result = keys$2(object2), length3 = result.length;
  while (length3--) {
    var key = result[length3], value = object2[key];
    result[length3] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object2) {
    if (object2 == null) {
      return false;
    }
    return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object2) {
    return object2 === source || baseIsMatch(object2, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
function baseHasIn$1(object2, key) {
  return object2 != null && key in Object(object2);
}
var _baseHasIn = baseHasIn$1;
var castPath = _castPath, isArguments$1 = isArguments_1, isArray$6 = isArray_1, isIndex$1 = _isIndex, isLength = isLength_1, toKey$2 = _toKey;
function hasPath$1(object2, path3, hasFunc) {
  path3 = castPath(path3, object2);
  var index3 = -1, length3 = path3.length, result = false;
  while (++index3 < length3) {
    var key = toKey$2(path3[index3]);
    if (!(result = object2 != null && hasFunc(object2, key))) {
      break;
    }
    object2 = object2[key];
  }
  if (result || ++index3 != length3) {
    return result;
  }
  length3 = object2 == null ? 0 : object2.length;
  return !!length3 && isLength(length3) && isIndex$1(key, length3) && (isArray$6(object2) || isArguments$1(object2));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn, hasPath2 = _hasPath;
function hasIn$1(object2, path3) {
  return object2 != null && hasPath2(object2, path3, baseHasIn);
}
var hasIn_1 = hasIn$1;
var baseIsEqual$1 = _baseIsEqual, get = get_1, hasIn2 = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$1 = _toKey;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path3, srcValue) {
  if (isKey$1(path3) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$1(path3), srcValue);
  }
  return function(object2) {
    var objValue = get(object2, path3);
    return objValue === void 0 && objValue === srcValue ? hasIn2(object2, path3) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function identity$b(value) {
  return value;
}
var identity_1 = identity$b;
function baseProperty$1(key) {
  return function(object2) {
    return object2 == null ? void 0 : object2[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet$1 = _baseGet;
function basePropertyDeep$1(path3) {
  return function(object2) {
    return baseGet$1(object2, path3);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey = _toKey;
function property$1(path3) {
  return isKey(path3) ? baseProperty(toKey(path3)) : basePropertyDeep(path3);
}
var property_1 = property$1;
var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity$a = identity_1, isArray$5 = isArray_1, property = property_1;
function baseIteratee$8(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$a;
  }
  if (typeof value == "object") {
    return isArray$5(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$8;
function baseFindIndex$2(array3, predicate3, fromIndex, fromRight) {
  var length3 = array3.length, index3 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index3-- : ++index3 < length3) {
    if (predicate3(array3[index3], index3, array3)) {
      return index3;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$2;
function baseIsNaN$1(value) {
  return value !== value;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(array3, value, fromIndex) {
  var index3 = fromIndex - 1, length3 = array3.length;
  while (++index3 < length3) {
    if (array3[index3] === value) {
      return index3;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf$1;
var baseFindIndex$1 = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
function baseIndexOf$1(array3, value, fromIndex) {
  return value === value ? strictIndexOf(array3, value, fromIndex) : baseFindIndex$1(array3, baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf$1;
var baseIndexOf = _baseIndexOf;
function arrayIncludes$1(array3, value) {
  var length3 = array3 == null ? 0 : array3.length;
  return !!length3 && baseIndexOf(array3, value, 0) > -1;
}
var _arrayIncludes = arrayIncludes$1;
function arrayIncludesWith$1(array3, value, comparator3) {
  var index3 = -1, length3 = array3 == null ? 0 : array3.length;
  while (++index3 < length3) {
    if (comparator3(value, array3[index3])) {
      return true;
    }
  }
  return false;
}
var _arrayIncludesWith = arrayIncludesWith$1;
function noop$4() {
}
var noop_1 = noop$4;
var Set$1 = _Set, noop$3 = noop_1, setToArray$1 = _setToArray;
var INFINITY$1 = 1 / 0;
var createSet$1 = !(Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == INFINITY$1) ? noop$3 : function(values3) {
  return new Set$1(values3);
};
var _createSet = createSet$1;
var SetCache = _SetCache, arrayIncludes = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, cacheHas = _cacheHas, createSet = _createSet, setToArray = _setToArray;
var LARGE_ARRAY_SIZE = 200;
function baseUniq$1(array3, iteratee, comparator3) {
  var index3 = -1, includes2 = arrayIncludes, length3 = array3.length, isCommon = true, result = [], seen2 = result;
  if (comparator3) {
    isCommon = false;
    includes2 = arrayIncludesWith;
  } else if (length3 >= LARGE_ARRAY_SIZE) {
    var set4 = iteratee ? null : createSet(array3);
    if (set4) {
      return setToArray(set4);
    }
    isCommon = false;
    includes2 = cacheHas;
    seen2 = new SetCache();
  } else {
    seen2 = iteratee ? [] : result;
  }
  outer:
    while (++index3 < length3) {
      var value = array3[index3], computed = iteratee ? iteratee(value) : value;
      value = comparator3 || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen2.length;
        while (seenIndex--) {
          if (seen2[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen2.push(computed);
        }
        result.push(value);
      } else if (!includes2(seen2, computed, comparator3)) {
        if (seen2 !== result) {
          seen2.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var _baseUniq = baseUniq$1;
var baseIteratee$7 = _baseIteratee, baseUniq = _baseUniq;
function uniqBy(array3, iteratee) {
  return array3 && array3.length ? baseUniq(array3, baseIteratee$7(iteratee)) : [];
}
var uniqBy_1 = uniqBy;
const _uniqBy = /* @__PURE__ */ getDefaultExportFromCjs(uniqBy_1);
function baseSlice$1(array3, start, end) {
  var index3 = -1, length3 = array3.length;
  if (start < 0) {
    start = -start > length3 ? 0 : length3 + start;
  }
  end = end > length3 ? length3 : end;
  if (end < 0) {
    end += length3;
  }
  length3 = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length3);
  while (++index3 < length3) {
    result[index3] = array3[index3 + start];
  }
  return result;
}
var _baseSlice = baseSlice$1;
var baseSlice = _baseSlice;
function castSlice$1(array3, start, end) {
  var length3 = array3.length;
  end = end === void 0 ? length3 : end;
  return !start && end >= length3 ? array3 : baseSlice(array3, start, end);
}
var _castSlice = castSlice$1;
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$2(string4) {
  return reHasUnicode.test(string4);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string4) {
  return string4.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string4) {
  return string4.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray, hasUnicode$1 = _hasUnicode, unicodeToArray = _unicodeToArray;
function stringToArray$1(string4) {
  return hasUnicode$1(string4) ? unicodeToArray(string4) : asciiToArray(string4);
}
var _stringToArray = stringToArray$1;
var castSlice = _castSlice, hasUnicode = _hasUnicode, stringToArray = _stringToArray, toString$2 = toString_1;
function createCaseFirst$1(methodName) {
  return function(string4) {
    string4 = toString$2(string4);
    var strSymbols = hasUnicode(string4) ? stringToArray(string4) : void 0;
    var chr = strSymbols ? strSymbols[0] : string4.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string4.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$1;
var createCaseFirst = _createCaseFirst;
var upperFirst = createCaseFirst("toUpperCase");
var upperFirst_1 = upperFirst;
const _upperFirst = /* @__PURE__ */ getDefaultExportFromCjs(upperFirst_1);
function constant$3(x2) {
  return function constant2() {
    return x2;
  };
}
const cos = Math.cos;
const sin = Math.sin;
const sqrt$1 = Math.sqrt;
const pi$1 = Math.PI;
const tau$1 = 2 * pi$1;
const pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function append2(strings) {
  this._ += strings[0];
  for (let i = 1, n2 = strings.length; i < n2; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d2 = Math.floor(digits);
  if (!(d2 >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d2 > 15)
    return append2;
  const k2 = 10 ** d2;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n2 = strings.length; i < n2; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append2 : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r2) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2;
    if (r2 < 0)
      throw new Error(`negative radius: ${r2}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r2, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw;
    if (r2 < 0)
      throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }
    if (!r2)
      return;
    if (da2 < 0)
      da2 = da2 % tau + tau;
    if (da2 > tauEpsilon) {
      this._append`A${r2},${r2},0,1,${cw},${x2 - dx},${y2 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da2 > epsilon) {
      this._append`A${r2},${r2},0,${+(da2 >= pi)},${cw},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`;
    }
  }
  rect(x2, y2, w2, h2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w2 = +w2}v${+h2}h${-w2}Z`;
  }
  toString() {
    return this._;
  }
}
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_2) {
    if (!arguments.length)
      return digits;
    if (_2 == null) {
      digits = null;
    } else {
      const d2 = Math.floor(_2);
      if (!(d2 >= 0))
        throw new RangeError(`invalid digits: ${_2}`);
      digits = d2;
    }
    return shape;
  };
  return () => new Path(digits);
}
function array2(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear(context2) {
  this._context = context2;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context2) {
  return new Linear(context2);
}
function x(p2) {
  return p2[0];
}
function y(p2) {
  return p2[1];
}
function shapeLine(x$12, y$12) {
  var defined3 = constant$3(true), context2 = null, curve = curveLinear, output = null, path3 = withPath(line);
  x$12 = typeof x$12 === "function" ? x$12 : x$12 === void 0 ? x : constant$3(x$12);
  y$12 = typeof y$12 === "function" ? y$12 : y$12 === void 0 ? y : constant$3(y$12);
  function line(data2) {
    var i, n2 = (data2 = array2(data2)).length, d2, defined0 = false, buffer2;
    if (context2 == null)
      output = curve(buffer2 = path3());
    for (i = 0; i <= n2; ++i) {
      if (!(i < n2 && defined3(d2 = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x$12(d2, i, data2), +y$12(d2, i, data2));
    }
    if (buffer2)
      return output = null, buffer2 + "" || null;
  }
  line.x = function(_2) {
    return arguments.length ? (x$12 = typeof _2 === "function" ? _2 : constant$3(+_2), line) : x$12;
  };
  line.y = function(_2) {
    return arguments.length ? (y$12 = typeof _2 === "function" ? _2 : constant$3(+_2), line) : y$12;
  };
  line.defined = function(_2) {
    return arguments.length ? (defined3 = typeof _2 === "function" ? _2 : constant$3(!!_2), line) : defined3;
  };
  line.curve = function(_2) {
    return arguments.length ? (curve = _2, context2 != null && (output = curve(context2)), line) : curve;
  };
  line.context = function(_2) {
    return arguments.length ? (_2 == null ? context2 = output = null : output = curve(context2 = _2), line) : context2;
  };
  return line;
}
function shapeArea(x0, y0, y1) {
  var x1 = null, defined3 = constant$3(true), context2 = null, curve = curveLinear, output = null, path3 = withPath(area);
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant$3(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant$3(0) : constant$3(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant$3(+y1);
  function area(data2) {
    var i, j2, k2, n2 = (data2 = array2(data2)).length, d2, defined0 = false, buffer2, x0z = new Array(n2), y0z = new Array(n2);
    if (context2 == null)
      output = curve(buffer2 = path3());
    for (i = 0; i <= n2; ++i) {
      if (!(i < n2 && defined3(d2 = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0) {
          j2 = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j2; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d2, i, data2), y0z[i] = +y0(d2, i, data2);
        output.point(x1 ? +x1(d2, i, data2) : x0z[i], y1 ? +y1(d2, i, data2) : y0z[i]);
      }
    }
    if (buffer2)
      return output = null, buffer2 + "" || null;
  }
  function arealine() {
    return shapeLine().defined(defined3).curve(curve).context(context2);
  }
  area.x = function(_2) {
    return arguments.length ? (x0 = typeof _2 === "function" ? _2 : constant$3(+_2), x1 = null, area) : x0;
  };
  area.x0 = function(_2) {
    return arguments.length ? (x0 = typeof _2 === "function" ? _2 : constant$3(+_2), area) : x0;
  };
  area.x1 = function(_2) {
    return arguments.length ? (x1 = _2 == null ? null : typeof _2 === "function" ? _2 : constant$3(+_2), area) : x1;
  };
  area.y = function(_2) {
    return arguments.length ? (y0 = typeof _2 === "function" ? _2 : constant$3(+_2), y1 = null, area) : y0;
  };
  area.y0 = function(_2) {
    return arguments.length ? (y0 = typeof _2 === "function" ? _2 : constant$3(+_2), area) : y0;
  };
  area.y1 = function(_2) {
    return arguments.length ? (y1 = _2 == null ? null : typeof _2 === "function" ? _2 : constant$3(+_2), area) : y1;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area.defined = function(_2) {
    return arguments.length ? (defined3 = typeof _2 === "function" ? _2 : constant$3(!!_2), area) : defined3;
  };
  area.curve = function(_2) {
    return arguments.length ? (curve = _2, context2 != null && (output = curve(context2)), area) : curve;
  };
  area.context = function(_2) {
    return arguments.length ? (_2 == null ? context2 = output = null : output = curve(context2 = _2), area) : context2;
  };
  return area;
}
const symbolCircle = {
  draw(context2, size) {
    const r2 = sqrt$1(size / pi$1);
    context2.moveTo(r2, 0);
    context2.arc(0, 0, r2, 0, tau$1);
  }
};
const symbolCross = {
  draw(context2, size) {
    const r2 = sqrt$1(size / 5) / 2;
    context2.moveTo(-3 * r2, -r2);
    context2.lineTo(-r2, -r2);
    context2.lineTo(-r2, -3 * r2);
    context2.lineTo(r2, -3 * r2);
    context2.lineTo(r2, -r2);
    context2.lineTo(3 * r2, -r2);
    context2.lineTo(3 * r2, r2);
    context2.lineTo(r2, r2);
    context2.lineTo(r2, 3 * r2);
    context2.lineTo(-r2, 3 * r2);
    context2.lineTo(-r2, r2);
    context2.lineTo(-3 * r2, r2);
    context2.closePath();
  }
};
const tan30 = sqrt$1(1 / 3);
const tan30_2 = tan30 * 2;
const symbolDiamond = {
  draw(context2, size) {
    const y2 = sqrt$1(size / tan30_2);
    const x2 = y2 * tan30;
    context2.moveTo(0, -y2);
    context2.lineTo(x2, 0);
    context2.lineTo(0, y2);
    context2.lineTo(-x2, 0);
    context2.closePath();
  }
};
const symbolSquare = {
  draw(context2, size) {
    const w2 = sqrt$1(size);
    const x2 = -w2 / 2;
    context2.rect(x2, x2, w2, w2);
  }
};
const ka = 0.8908130915292852;
const kr = sin(pi$1 / 10) / sin(7 * pi$1 / 10);
const kx = sin(tau$1 / 10) * kr;
const ky = -cos(tau$1 / 10) * kr;
const symbolStar = {
  draw(context2, size) {
    const r2 = sqrt$1(size * ka);
    const x2 = kx * r2;
    const y2 = ky * r2;
    context2.moveTo(0, -r2);
    context2.lineTo(x2, y2);
    for (let i = 1; i < 5; ++i) {
      const a2 = tau$1 * i / 5;
      const c2 = cos(a2);
      const s2 = sin(a2);
      context2.lineTo(s2 * r2, -c2 * r2);
      context2.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
    }
    context2.closePath();
  }
};
const sqrt3 = sqrt$1(3);
const symbolTriangle = {
  draw(context2, size) {
    const y2 = -sqrt$1(size / (sqrt3 * 3));
    context2.moveTo(0, y2 * 2);
    context2.lineTo(-sqrt3 * y2, -y2);
    context2.lineTo(sqrt3 * y2, -y2);
    context2.closePath();
  }
};
const c = -0.5;
const s = sqrt$1(3) / 2;
const k = 1 / sqrt$1(12);
const a = (k / 2 + 1) * 3;
const symbolWye = {
  draw(context2, size) {
    const r2 = sqrt$1(size / a);
    const x0 = r2 / 2, y0 = r2 * k;
    const x1 = x0, y1 = r2 * k + r2;
    const x2 = -x1, y2 = y1;
    context2.moveTo(x0, y0);
    context2.lineTo(x1, y1);
    context2.lineTo(x2, y2);
    context2.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context2.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context2.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context2.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context2.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context2.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context2.closePath();
  }
};
function Symbol$2(type3, size) {
  let context2 = null, path3 = withPath(symbol4);
  type3 = typeof type3 === "function" ? type3 : constant$3(type3 || symbolCircle);
  size = typeof size === "function" ? size : constant$3(size === void 0 ? 64 : +size);
  function symbol4() {
    let buffer2;
    if (!context2)
      context2 = buffer2 = path3();
    type3.apply(this, arguments).draw(context2, +size.apply(this, arguments));
    if (buffer2)
      return context2 = null, buffer2 + "" || null;
  }
  symbol4.type = function(_2) {
    return arguments.length ? (type3 = typeof _2 === "function" ? _2 : constant$3(_2), symbol4) : type3;
  };
  symbol4.size = function(_2) {
    return arguments.length ? (size = typeof _2 === "function" ? _2 : constant$3(+_2), symbol4) : size;
  };
  symbol4.context = function(_2) {
    return arguments.length ? (context2 = _2 == null ? null : _2, symbol4) : context2;
  };
  return symbol4;
}
function noop$2() {
}
function point$2(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context2) {
  this._context = context2;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point$2(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasis(context2) {
  return new Basis(context2);
}
function BasisClosed(context2) {
  this._context = context2;
}
BasisClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisClosed(context2) {
  return new BasisClosed(context2);
}
function BasisOpen(context2) {
  this._context = context2;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisOpen(context2) {
  return new BasisOpen(context2);
}
function LinearClosed(context2) {
  this._context = context2;
}
LinearClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point)
      this._context.lineTo(x2, y2);
    else
      this._point = 1, this._context.moveTo(x2, y2);
  }
};
function curveLinearClosed(context2) {
  return new LinearClosed(context2);
}
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
}
function slope2(that, t2) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t2) / 2 : t2;
}
function point$1(that, t02, t12) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t02, x1 - dx, y1 - dx * t12, x1, y1);
}
function MonotoneX(context2) {
  this._context = context2;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point$1(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t12 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point$1(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
        break;
      default:
        point$1(this, this._t0, t12 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t12;
  }
};
function MonotoneY(context2) {
  this._context = new ReflectContext(context2);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context2) {
  this._context = context2;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
  }
};
function monotoneX(context2) {
  return new MonotoneX(context2);
}
function monotoneY(context2) {
  return new MonotoneY(context2);
}
function Natural(context2) {
  this._context = context2;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n2 = x2.length;
    if (n2) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n2 === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n2; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n2 === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n2 = x2.length - 1, m2, a2 = new Array(n2), b2 = new Array(n2), r2 = new Array(n2);
  a2[0] = 0, b2[0] = 2, r2[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n2 - 1; ++i)
    a2[i] = 1, b2[i] = 4, r2[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n2 - 1] = 2, b2[n2 - 1] = 7, r2[n2 - 1] = 8 * x2[n2 - 1] + x2[n2];
  for (i = 1; i < n2; ++i)
    m2 = a2[i] / b2[i - 1], b2[i] -= m2, r2[i] -= m2 * r2[i - 1];
  a2[n2 - 1] = r2[n2 - 1] / b2[n2 - 1];
  for (i = n2 - 2; i >= 0; --i)
    a2[i] = (r2[i] - a2[i + 1]) / b2[i];
  b2[n2 - 1] = (x2[n2] + a2[n2 - 1]) / 2;
  for (i = 0; i < n2 - 1; ++i)
    b2[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b2];
}
function curveNatural(context2) {
  return new Natural(context2);
}
function Step(context2, t2) {
  this._context = context2;
  this._t = t2;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x1 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function curveStep(context2) {
  return new Step(context2, 0.5);
}
function stepBefore(context2) {
  return new Step(context2, 0);
}
function stepAfter(context2) {
  return new Step(context2, 1);
}
function stackOffsetNone(series, order) {
  if (!((n2 = series.length) > 1))
    return;
  for (var i = 1, j2, s0, s1 = series[order[0]], n2, m2 = s1.length; i < n2; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j2 = 0; j2 < m2; ++j2) {
      s1[j2][1] += s1[j2][0] = isNaN(s0[j2][1]) ? s0[j2][0] : s0[j2][1];
    }
  }
}
function stackOrderNone(series) {
  var n2 = series.length, o3 = new Array(n2);
  while (--n2 >= 0)
    o3[n2] = n2;
  return o3;
}
function stackValue(d2, key) {
  return d2[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function shapeStack() {
  var keys4 = constant$3([]), order = stackOrderNone, offset2 = stackOffsetNone, value = stackValue;
  function stack(data2) {
    var sz = Array.from(keys4.apply(this, arguments), stackSeries), i, n2 = sz.length, j2 = -1, oz;
    for (const d2 of data2) {
      for (i = 0, ++j2; i < n2; ++i) {
        (sz[i][j2] = [0, +value(d2, sz[i].key, j2, data2)]).data = d2;
      }
    }
    for (i = 0, oz = array2(order(sz)); i < n2; ++i) {
      sz[oz[i]].index = i;
    }
    offset2(sz, oz);
    return sz;
  }
  stack.keys = function(_2) {
    return arguments.length ? (keys4 = typeof _2 === "function" ? _2 : constant$3(Array.from(_2)), stack) : keys4;
  };
  stack.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$3(+_2), stack) : value;
  };
  stack.order = function(_2) {
    return arguments.length ? (order = _2 == null ? stackOrderNone : typeof _2 === "function" ? _2 : constant$3(Array.from(_2)), stack) : order;
  };
  stack.offset = function(_2) {
    return arguments.length ? (offset2 = _2 == null ? stackOffsetNone : _2, stack) : offset2;
  };
  return stack;
}
function stackOffsetExpand(series, order) {
  if (!((n2 = series.length) > 0))
    return;
  for (var i, n2, j2 = 0, m2 = series[0].length, y2; j2 < m2; ++j2) {
    for (y2 = i = 0; i < n2; ++i)
      y2 += series[i][j2][1] || 0;
    if (y2)
      for (i = 0; i < n2; ++i)
        series[i][j2][1] /= y2;
  }
  stackOffsetNone(series, order);
}
function stackOffsetSilhouette(series, order) {
  if (!((n2 = series.length) > 0))
    return;
  for (var j2 = 0, s0 = series[order[0]], n2, m2 = s0.length; j2 < m2; ++j2) {
    for (var i = 0, y2 = 0; i < n2; ++i)
      y2 += series[i][j2][1] || 0;
    s0[j2][1] += s0[j2][0] = -y2 / 2;
  }
  stackOffsetNone(series, order);
}
function stackOffsetWiggle(series, order) {
  if (!((n2 = series.length) > 0) || !((m2 = (s0 = series[order[0]]).length) > 0))
    return;
  for (var y2 = 0, j2 = 1, s0, m2, n2; j2 < m2; ++j2) {
    for (var i = 0, s1 = 0, s2 = 0; i < n2; ++i) {
      var si2 = series[order[i]], sij0 = si2[j2][1] || 0, sij1 = si2[j2 - 1][1] || 0, s3 = (sij0 - sij1) / 2;
      for (var k2 = 0; k2 < i; ++k2) {
        var sk2 = series[order[k2]], skj0 = sk2[j2][1] || 0, skj1 = sk2[j2 - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j2 - 1][1] += s0[j2 - 1][0] = y2;
    if (s1)
      y2 -= s2 / s1;
  }
  s0[j2 - 1][1] += s0[j2 - 1][0] = y2;
  stackOffsetNone(series, order);
}
function _typeof$u(obj) {
  "@babel/helpers - typeof";
  return _typeof$u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$u(obj);
}
function _extends$k() {
  _extends$k = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$k.apply(this, arguments);
}
function _classCallCheck$f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$f(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$t(descriptor.key), descriptor);
  }
}
function _createClass$f(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$f(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$f(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$d(subClass, superClass);
}
function _setPrototypeOf$d(o3, p2) {
  _setPrototypeOf$d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$d(o3, p2);
}
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$d(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$d(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$d(this, result);
  };
}
function _possibleConstructorReturn$d(self2, call3) {
  if (call3 && (_typeof$u(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$d(self2);
}
function _assertThisInitialized$d(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$d(o3) {
  _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$d(o3);
}
function _defineProperty$t(obj, key, value) {
  key = _toPropertyKey$t(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$t(arg) {
  var key = _toPrimitive$t(arg, "string");
  return _typeof$u(key) === "symbol" ? key : String(key);
}
function _toPrimitive$t(input, hint) {
  if (_typeof$u(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$u(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var symbolFactories = {
  symbolCircle,
  symbolCross,
  symbolDiamond,
  symbolSquare,
  symbolStar,
  symbolTriangle,
  symbolWye
};
var RADIAN$1 = Math.PI / 180;
var getSymbolFactory = function getSymbolFactory2(type3) {
  var name = "symbol".concat(_upperFirst(type3));
  return symbolFactories[name] || symbolCircle;
};
var calculateAreaSize = function calculateAreaSize2(size, sizeType, type3) {
  if (sizeType === "area") {
    return size;
  }
  switch (type3) {
    case "cross":
      return 5 * size * size / 9;
    case "diamond":
      return 0.5 * size * size / Math.sqrt(3);
    case "square":
      return size * size;
    case "star": {
      var angle = 18 * RADIAN$1;
      return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.pow(Math.tan(angle), 2));
    }
    case "triangle":
      return Math.sqrt(3) * size * size / 4;
    case "wye":
      return (21 - 10 * Math.sqrt(3)) * size * size / 8;
    default:
      return Math.PI * size * size / 4;
  }
};
var Symbols = /* @__PURE__ */ function(_PureComponent) {
  _inherits$d(Symbols2, _PureComponent);
  var _super = _createSuper$d(Symbols2);
  function Symbols2() {
    _classCallCheck$f(this, Symbols2);
    return _super.apply(this, arguments);
  }
  _createClass$f(Symbols2, [{
    key: "getPath",
    value: (
      /**
       * Calculate the path of curve
       * @return {String} path
       */
      function getPath4() {
        var _this$props = this.props, size = _this$props.size, sizeType = _this$props.sizeType, type3 = _this$props.type;
        var symbolFactory = getSymbolFactory(type3);
        var symbol4 = Symbol$2().type(symbolFactory).size(calculateAreaSize(size, sizeType, type3));
        return symbol4();
      }
    )
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props, className = _this$props2.className, cx = _this$props2.cx, cy = _this$props2.cy, size = _this$props2.size;
      var filteredProps = filterProps(this.props, true);
      if (cx === +cx && cy === +cy && size === +size) {
        return /* @__PURE__ */ React.createElement("path", _extends$k({}, filteredProps, {
          className: classNames("recharts-symbols", className),
          transform: "translate(".concat(cx, ", ").concat(cy, ")"),
          d: this.getPath()
        }));
      }
      return null;
    }
  }]);
  return Symbols2;
}(reactExports.PureComponent);
_defineProperty$t(Symbols, "defaultProps", {
  type: "circle",
  size: 64,
  sizeType: "area"
});
_defineProperty$t(Symbols, "registerSymbol", function(key, factory) {
  symbolFactories["symbol".concat(_upperFirst(key))] = factory;
});
function _typeof$t(obj) {
  "@babel/helpers - typeof";
  return _typeof$t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$t(obj);
}
function _extends$j() {
  _extends$j = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$j.apply(this, arguments);
}
function ownKeys$o(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$o(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$o(Object(source), true).forEach(function(key) {
      _defineProperty$s(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$o(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$e(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$s(descriptor.key), descriptor);
  }
}
function _createClass$e(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$e(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$e(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$c(subClass, superClass);
}
function _setPrototypeOf$c(o3, p2) {
  _setPrototypeOf$c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$c(o3, p2);
}
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$c(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$c(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$c(this, result);
  };
}
function _possibleConstructorReturn$c(self2, call3) {
  if (call3 && (_typeof$t(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$c(self2);
}
function _assertThisInitialized$c(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$c(o3) {
  _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$c(o3);
}
function _defineProperty$s(obj, key, value) {
  key = _toPropertyKey$s(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$s(arg) {
  var key = _toPrimitive$s(arg, "string");
  return _typeof$t(key) === "symbol" ? key : String(key);
}
function _toPrimitive$s(input, hint) {
  if (_typeof$t(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$t(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var SIZE = 32;
var DefaultLegendContent = /* @__PURE__ */ function(_PureComponent) {
  _inherits$c(DefaultLegendContent2, _PureComponent);
  var _super = _createSuper$c(DefaultLegendContent2);
  function DefaultLegendContent2() {
    _classCallCheck$e(this, DefaultLegendContent2);
    return _super.apply(this, arguments);
  }
  _createClass$e(DefaultLegendContent2, [{
    key: "renderIcon",
    value: (
      /**
       * Render the path of icon
       * @param {Object} data Data of each legend item
       * @return {String} Path element
       */
      function renderIcon(data2) {
        var inactiveColor = this.props.inactiveColor;
        var halfSize = SIZE / 2;
        var sixthSize = SIZE / 6;
        var thirdSize = SIZE / 3;
        var color2 = data2.inactive ? inactiveColor : data2.color;
        if (data2.type === "plainline") {
          return /* @__PURE__ */ React.createElement("line", {
            strokeWidth: 4,
            fill: "none",
            stroke: color2,
            strokeDasharray: data2.payload.strokeDasharray,
            x1: 0,
            y1: halfSize,
            x2: SIZE,
            y2: halfSize,
            className: "recharts-legend-icon"
          });
        }
        if (data2.type === "line") {
          return /* @__PURE__ */ React.createElement("path", {
            strokeWidth: 4,
            fill: "none",
            stroke: color2,
            d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
            className: "recharts-legend-icon"
          });
        }
        if (data2.type === "rect") {
          return /* @__PURE__ */ React.createElement("path", {
            stroke: "none",
            fill: color2,
            d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
            className: "recharts-legend-icon"
          });
        }
        if (/* @__PURE__ */ React.isValidElement(data2.legendIcon)) {
          var iconProps = _objectSpread$o({}, data2);
          delete iconProps.legendIcon;
          return /* @__PURE__ */ React.cloneElement(data2.legendIcon, iconProps);
        }
        return /* @__PURE__ */ React.createElement(Symbols, {
          fill: color2,
          cx: halfSize,
          cy: halfSize,
          size: SIZE,
          sizeType: "diameter",
          type: data2.type
        });
      }
    )
    /**
     * Draw items of legend
     * @return {ReactElement} Items
     */
  }, {
    key: "renderItems",
    value: function renderItems() {
      var _this = this;
      var _this$props = this.props, payload = _this$props.payload, iconSize = _this$props.iconSize, layout = _this$props.layout, formatter = _this$props.formatter, inactiveColor = _this$props.inactiveColor;
      var viewBox = {
        x: 0,
        y: 0,
        width: SIZE,
        height: SIZE
      };
      var itemStyle = {
        display: layout === "horizontal" ? "inline-block" : "block",
        marginRight: 10
      };
      var svgStyle = {
        display: "inline-block",
        verticalAlign: "middle",
        marginRight: 4
      };
      return payload.map(function(entry, i) {
        var _classNames;
        var finalFormatter = entry.formatter || formatter;
        var className = classNames((_classNames = {
          "recharts-legend-item": true
        }, _defineProperty$s(_classNames, "legend-item-".concat(i), true), _defineProperty$s(_classNames, "inactive", entry.inactive), _classNames));
        if (entry.type === "none") {
          return null;
        }
        var color2 = entry.inactive ? inactiveColor : entry.color;
        return /* @__PURE__ */ React.createElement("li", _extends$j({
          className,
          style: itemStyle,
          key: "legend-item-".concat(i)
          // eslint-disable-line react/no-array-index-key
        }, adaptEventsOfChild(_this.props, entry, i)), /* @__PURE__ */ React.createElement(Surface, {
          width: iconSize,
          height: iconSize,
          viewBox,
          style: svgStyle
        }, _this.renderIcon(entry)), /* @__PURE__ */ React.createElement("span", {
          className: "recharts-legend-item-text",
          style: {
            color: color2
          }
        }, finalFormatter ? finalFormatter(entry.value, entry, i) : entry.value));
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props, payload = _this$props2.payload, layout = _this$props2.layout, align = _this$props2.align;
      if (!payload || !payload.length) {
        return null;
      }
      var finalStyle = {
        padding: 0,
        margin: 0,
        textAlign: layout === "horizontal" ? align : "left"
      };
      return /* @__PURE__ */ React.createElement("ul", {
        className: "recharts-default-legend",
        style: finalStyle
      }, this.renderItems());
    }
  }]);
  return DefaultLegendContent2;
}(reactExports.PureComponent);
_defineProperty$s(DefaultLegendContent, "displayName", "Legend");
_defineProperty$s(DefaultLegendContent, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "middle",
  inactiveColor: "#ccc"
});
function _typeof$s(obj) {
  "@babel/helpers - typeof";
  return _typeof$s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$s(obj);
}
var _excluded$9 = ["ref"];
function ownKeys$n(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$n(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$n(Object(source), true).forEach(function(key) {
      _defineProperty$r(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$n(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$d(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$r(descriptor.key), descriptor);
  }
}
function _createClass$d(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$d(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$d(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$b(subClass, superClass);
}
function _setPrototypeOf$b(o3, p2) {
  _setPrototypeOf$b = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$b(o3, p2);
}
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$b(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$b(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _possibleConstructorReturn$b(self2, call3) {
  if (call3 && (_typeof$s(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$b(self2);
}
function _assertThisInitialized$b(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$b(o3) {
  _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$b(o3);
}
function _defineProperty$r(obj, key, value) {
  key = _toPropertyKey$r(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$r(arg) {
  var key = _toPrimitive$r(arg, "string");
  return _typeof$s(key) === "symbol" ? key : String(key);
}
function _toPrimitive$r(input, hint) {
  if (_typeof$s(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$s(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _objectWithoutProperties$9(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$a(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$a(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function defaultUniqBy$1(entry) {
  return entry.value;
}
function getUniqPayload$1(option, payload) {
  if (option === true) {
    return _uniqBy(payload, defaultUniqBy$1);
  }
  if (_isFunction(option)) {
    return _uniqBy(payload, option);
  }
  return payload;
}
function renderContent$1(content, props3) {
  if (/* @__PURE__ */ React.isValidElement(content)) {
    return /* @__PURE__ */ React.cloneElement(content, props3);
  }
  if (_isFunction(content)) {
    return /* @__PURE__ */ React.createElement(content, props3);
  }
  props3.ref;
  var otherProps = _objectWithoutProperties$9(props3, _excluded$9);
  return /* @__PURE__ */ React.createElement(DefaultLegendContent, otherProps);
}
var EPS$2 = 1;
var Legend = /* @__PURE__ */ function(_PureComponent) {
  _inherits$b(Legend2, _PureComponent);
  var _super = _createSuper$b(Legend2);
  function Legend2() {
    var _this;
    _classCallCheck$d(this, Legend2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$r(_assertThisInitialized$b(_this), "state", {
      boxWidth: -1,
      boxHeight: -1
    });
    return _this;
  }
  _createClass$d(Legend2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateBBox();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.updateBBox();
    }
  }, {
    key: "getBBox",
    value: function getBBox() {
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        return this.wrapperNode.getBoundingClientRect();
      }
      return null;
    }
  }, {
    key: "getBBoxSnapshot",
    value: function getBBoxSnapshot() {
      var _this$state = this.state, boxWidth = _this$state.boxWidth, boxHeight = _this$state.boxHeight;
      if (boxWidth >= 0 && boxHeight >= 0) {
        return {
          width: boxWidth,
          height: boxHeight
        };
      }
      return null;
    }
  }, {
    key: "getDefaultPosition",
    value: function getDefaultPosition(style) {
      var _this$props = this.props, layout = _this$props.layout, align = _this$props.align, verticalAlign = _this$props.verticalAlign, margin = _this$props.margin, chartWidth = _this$props.chartWidth, chartHeight = _this$props.chartHeight;
      var hPos, vPos;
      if (!style || (style.left === void 0 || style.left === null) && (style.right === void 0 || style.right === null)) {
        if (align === "center" && layout === "vertical") {
          var _box = this.getBBoxSnapshot() || {
            width: 0
          };
          hPos = {
            left: ((chartWidth || 0) - _box.width) / 2
          };
        } else {
          hPos = align === "right" ? {
            right: margin && margin.right || 0
          } : {
            left: margin && margin.left || 0
          };
        }
      }
      if (!style || (style.top === void 0 || style.top === null) && (style.bottom === void 0 || style.bottom === null)) {
        if (verticalAlign === "middle") {
          var _box2 = this.getBBoxSnapshot() || {
            height: 0
          };
          vPos = {
            top: ((chartHeight || 0) - _box2.height) / 2
          };
        } else {
          vPos = verticalAlign === "bottom" ? {
            bottom: margin && margin.bottom || 0
          } : {
            top: margin && margin.top || 0
          };
        }
      }
      return _objectSpread$n(_objectSpread$n({}, hPos), vPos);
    }
  }, {
    key: "updateBBox",
    value: function updateBBox() {
      var _this$state2 = this.state, boxWidth = _this$state2.boxWidth, boxHeight = _this$state2.boxHeight;
      var onBBoxUpdate = this.props.onBBoxUpdate;
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var _box3 = this.wrapperNode.getBoundingClientRect();
        if (Math.abs(_box3.width - boxWidth) > EPS$2 || Math.abs(_box3.height - boxHeight) > EPS$2) {
          this.setState({
            boxWidth: _box3.width,
            boxHeight: _box3.height
          }, function() {
            if (onBBoxUpdate) {
              onBBoxUpdate(_box3);
            }
          });
        }
      } else if (boxWidth !== -1 || boxHeight !== -1) {
        this.setState({
          boxWidth: -1,
          boxHeight: -1
        }, function() {
          if (onBBoxUpdate) {
            onBBoxUpdate(null);
          }
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props2 = this.props, content = _this$props2.content, width = _this$props2.width, height = _this$props2.height, wrapperStyle = _this$props2.wrapperStyle, payloadUniqBy = _this$props2.payloadUniqBy, payload = _this$props2.payload;
      var outerStyle = _objectSpread$n(_objectSpread$n({
        position: "absolute",
        width: width || "auto",
        height: height || "auto"
      }, this.getDefaultPosition(wrapperStyle)), wrapperStyle);
      return /* @__PURE__ */ React.createElement("div", {
        className: "recharts-legend-wrapper",
        style: outerStyle,
        ref: function ref(node) {
          _this2.wrapperNode = node;
        }
      }, renderContent$1(content, _objectSpread$n(_objectSpread$n({}, this.props), {}, {
        payload: getUniqPayload$1(payloadUniqBy, payload)
      })));
    }
  }], [{
    key: "getWithHeight",
    value: function getWithHeight(item, chartWidth) {
      var layout = item.props.layout;
      if (layout === "vertical" && isNumber(item.props.height)) {
        return {
          height: item.props.height
        };
      }
      if (layout === "horizontal") {
        return {
          width: item.props.width || chartWidth
        };
      }
      return null;
    }
  }]);
  return Legend2;
}(reactExports.PureComponent);
_defineProperty$r(Legend, "displayName", "Legend");
_defineProperty$r(Legend, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "bottom"
});
function createDefaultIsNestedEqual(comparator3) {
  return function isEqual2(a2, b2, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, meta) {
    return comparator3(a2, b2, meta);
  };
}
function createIsCircular(areItemsEqual) {
  return function isCircular(a2, b2, isEqual2, cache2) {
    if (!a2 || !b2 || typeof a2 !== "object" || typeof b2 !== "object") {
      return areItemsEqual(a2, b2, isEqual2, cache2);
    }
    var cachedA = cache2.get(a2);
    var cachedB = cache2.get(b2);
    if (cachedA && cachedB) {
      return cachedA === b2 && cachedB === a2;
    }
    cache2.set(a2, b2);
    cache2.set(b2, a2);
    var result = areItemsEqual(a2, b2, isEqual2, cache2);
    cache2.delete(a2);
    cache2.delete(b2);
    return result;
  };
}
function merge2(a2, b2) {
  var merged = {};
  for (var key in a2) {
    merged[key] = a2[key];
  }
  for (var key in b2) {
    merged[key] = b2[key];
  }
  return merged;
}
function isPlainObject(value) {
  return value.constructor === Object || value.constructor == null;
}
function isPromiseLike(value) {
  return typeof value.then === "function";
}
function sameValueZeroEqual(a2, b2) {
  return a2 === b2 || a2 !== a2 && b2 !== b2;
}
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATE_TAG = "[object Date]";
var REG_EXP_TAG = "[object RegExp]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var toString$1 = Object.prototype.toString;
function createComparator(_a2) {
  var areArraysEqual2 = _a2.areArraysEqual, areDatesEqual2 = _a2.areDatesEqual, areMapsEqual2 = _a2.areMapsEqual, areObjectsEqual2 = _a2.areObjectsEqual, areRegExpsEqual2 = _a2.areRegExpsEqual, areSetsEqual2 = _a2.areSetsEqual, createIsNestedEqual = _a2.createIsNestedEqual;
  var isEqual2 = createIsNestedEqual(comparator3);
  function comparator3(a2, b2, meta) {
    if (a2 === b2) {
      return true;
    }
    if (!a2 || !b2 || typeof a2 !== "object" || typeof b2 !== "object") {
      return a2 !== a2 && b2 !== b2;
    }
    if (isPlainObject(a2) && isPlainObject(b2)) {
      return areObjectsEqual2(a2, b2, isEqual2, meta);
    }
    var aArray = Array.isArray(a2);
    var bArray = Array.isArray(b2);
    if (aArray || bArray) {
      return aArray === bArray && areArraysEqual2(a2, b2, isEqual2, meta);
    }
    var aTag = toString$1.call(a2);
    if (aTag !== toString$1.call(b2)) {
      return false;
    }
    if (aTag === DATE_TAG) {
      return areDatesEqual2(a2, b2, isEqual2, meta);
    }
    if (aTag === REG_EXP_TAG) {
      return areRegExpsEqual2(a2, b2, isEqual2, meta);
    }
    if (aTag === MAP_TAG) {
      return areMapsEqual2(a2, b2, isEqual2, meta);
    }
    if (aTag === SET_TAG) {
      return areSetsEqual2(a2, b2, isEqual2, meta);
    }
    if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {
      return isPromiseLike(a2) || isPromiseLike(b2) ? false : areObjectsEqual2(a2, b2, isEqual2, meta);
    }
    if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {
      return sameValueZeroEqual(a2.valueOf(), b2.valueOf());
    }
    return false;
  }
  return comparator3;
}
function areArraysEqual(a2, b2, isEqual2, meta) {
  var index3 = a2.length;
  if (b2.length !== index3) {
    return false;
  }
  while (index3-- > 0) {
    if (!isEqual2(a2[index3], b2[index3], index3, index3, a2, b2, meta)) {
      return false;
    }
  }
  return true;
}
var areArraysEqualCircular = createIsCircular(areArraysEqual);
function areDatesEqual(a2, b2) {
  return sameValueZeroEqual(a2.valueOf(), b2.valueOf());
}
function areMapsEqual(a2, b2, isEqual2, meta) {
  var isValueEqual = a2.size === b2.size;
  if (!isValueEqual) {
    return false;
  }
  if (!a2.size) {
    return true;
  }
  var matchedIndices = {};
  var indexA = 0;
  a2.forEach(function(aValue, aKey) {
    if (!isValueEqual) {
      return;
    }
    var hasMatch = false;
    var matchIndexB = 0;
    b2.forEach(function(bValue, bKey) {
      if (!hasMatch && !matchedIndices[matchIndexB] && (hasMatch = isEqual2(aKey, bKey, indexA, matchIndexB, a2, b2, meta) && isEqual2(aValue, bValue, aKey, bKey, a2, b2, meta))) {
        matchedIndices[matchIndexB] = true;
      }
      matchIndexB++;
    });
    indexA++;
    isValueEqual = hasMatch;
  });
  return isValueEqual;
}
var areMapsEqualCircular = createIsCircular(areMapsEqual);
var OWNER = "_owner";
var hasOwnProperty = Object.prototype.hasOwnProperty;
function areObjectsEqual(a2, b2, isEqual2, meta) {
  var keysA = Object.keys(a2);
  var index3 = keysA.length;
  if (Object.keys(b2).length !== index3) {
    return false;
  }
  var key;
  while (index3-- > 0) {
    key = keysA[index3];
    if (key === OWNER) {
      var reactElementA = !!a2.$$typeof;
      var reactElementB = !!b2.$$typeof;
      if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {
        return false;
      }
    }
    if (!hasOwnProperty.call(b2, key) || !isEqual2(a2[key], b2[key], key, key, a2, b2, meta)) {
      return false;
    }
  }
  return true;
}
var areObjectsEqualCircular = createIsCircular(areObjectsEqual);
function areRegExpsEqual(a2, b2) {
  return a2.source === b2.source && a2.flags === b2.flags;
}
function areSetsEqual(a2, b2, isEqual2, meta) {
  var isValueEqual = a2.size === b2.size;
  if (!isValueEqual) {
    return false;
  }
  if (!a2.size) {
    return true;
  }
  var matchedIndices = {};
  a2.forEach(function(aValue, aKey) {
    if (!isValueEqual) {
      return;
    }
    var hasMatch = false;
    var matchIndex = 0;
    b2.forEach(function(bValue, bKey) {
      if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = isEqual2(aValue, bValue, aKey, bKey, a2, b2, meta))) {
        matchedIndices[matchIndex] = true;
      }
      matchIndex++;
    });
    isValueEqual = hasMatch;
  });
  return isValueEqual;
}
var areSetsEqualCircular = createIsCircular(areSetsEqual);
var DEFAULT_CONFIG = Object.freeze({
  areArraysEqual,
  areDatesEqual,
  areMapsEqual,
  areObjectsEqual,
  areRegExpsEqual,
  areSetsEqual,
  createIsNestedEqual: createDefaultIsNestedEqual
});
var DEFAULT_CIRCULAR_CONFIG = Object.freeze({
  areArraysEqual: areArraysEqualCircular,
  areDatesEqual,
  areMapsEqual: areMapsEqualCircular,
  areObjectsEqual: areObjectsEqualCircular,
  areRegExpsEqual,
  areSetsEqual: areSetsEqualCircular,
  createIsNestedEqual: createDefaultIsNestedEqual
});
var isDeepEqual = createComparator(DEFAULT_CONFIG);
function deepEqual(a2, b2) {
  return isDeepEqual(a2, b2, void 0);
}
createComparator(merge2(DEFAULT_CONFIG, { createIsNestedEqual: function() {
  return sameValueZeroEqual;
} }));
createComparator(DEFAULT_CIRCULAR_CONFIG);
createComparator(merge2(DEFAULT_CIRCULAR_CONFIG, {
  createIsNestedEqual: function() {
    return sameValueZeroEqual;
  }
}));
function setRafTimeout(callback) {
  var timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var currTime = -1;
  var shouldUpdate = function shouldUpdate2(now2) {
    if (currTime < 0) {
      currTime = now2;
    }
    if (now2 - currTime > timeout) {
      callback(now2);
      currTime = -1;
    } else {
      requestAnimationFrame(shouldUpdate2);
    }
  };
  requestAnimationFrame(shouldUpdate);
}
function _typeof$r(obj) {
  "@babel/helpers - typeof";
  return _typeof$r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$r(obj);
}
function _toArray(arr) {
  return _arrayWithHoles$a(arr) || _iterableToArray$b(arr) || _unsupportedIterableToArray$h(arr) || _nonIterableRest$a();
}
function _nonIterableRest$a() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$h(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$h(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$h(o3, minLen);
}
function _arrayLikeToArray$h(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArray$b(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithHoles$a(arr) {
  if (Array.isArray(arr))
    return arr;
}
function createAnimateManager() {
  var currStyle = {};
  var handleChange = function handleChange2() {
    return null;
  };
  var shouldStop = false;
  var setStyle = function setStyle2(_style) {
    if (shouldStop) {
      return;
    }
    if (Array.isArray(_style)) {
      if (!_style.length) {
        return;
      }
      var styles2 = _style;
      var _styles = _toArray(styles2), curr = _styles[0], restStyles = _styles.slice(1);
      if (typeof curr === "number") {
        setRafTimeout(setStyle2.bind(null, restStyles), curr);
        return;
      }
      setStyle2(curr);
      setRafTimeout(setStyle2.bind(null, restStyles));
      return;
    }
    if (_typeof$r(_style) === "object") {
      currStyle = _style;
      handleChange(currStyle);
    }
    if (typeof _style === "function") {
      _style();
    }
  };
  return {
    stop: function stop() {
      shouldStop = true;
    },
    start: function start(style) {
      shouldStop = false;
      setStyle(style);
    },
    subscribe: function subscribe(_handleChange) {
      handleChange = _handleChange;
      return function() {
        handleChange = function handleChange2() {
          return null;
        };
      };
    }
  };
}
function _typeof$q(obj) {
  "@babel/helpers - typeof";
  return _typeof$q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$q(obj);
}
function ownKeys$m(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$m(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$m(Object(source), true).forEach(function(key) {
      _defineProperty$q(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$m(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$q(obj, key, value) {
  key = _toPropertyKey$q(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$q(arg) {
  var key = _toPrimitive$q(arg, "string");
  return _typeof$q(key) === "symbol" ? key : String(key);
}
function _toPrimitive$q(input, hint) {
  if (_typeof$q(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$q(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var PREFIX_LIST$1 = ["Webkit", "Moz", "O", "ms"];
var IN_LINE_PREFIX_LIST = ["-webkit-", "-moz-", "-o-", "-ms-"];
var IN_COMPATIBLE_PROPERTY = ["transform", "transformOrigin", "transition"];
var getIntersectionKeys = function getIntersectionKeys2(preObj, nextObj) {
  return [Object.keys(preObj), Object.keys(nextObj)].reduce(function(a2, b2) {
    return a2.filter(function(c2) {
      return b2.includes(c2);
    });
  });
};
var identity$9 = function identity2(param) {
  return param;
};
var getDashCase = function getDashCase2(name) {
  return name.replace(/([A-Z])/g, function(v2) {
    return "-".concat(v2.toLowerCase());
  });
};
var generatePrefixStyle$1 = function generatePrefixStyle(name, value) {
  if (IN_COMPATIBLE_PROPERTY.indexOf(name) === -1) {
    return _defineProperty$q({}, name, value);
  }
  var isTransition = name === "transition";
  var camelName = name.replace(/(\w)/, function(v2) {
    return v2.toUpperCase();
  });
  var styleVal = value;
  return PREFIX_LIST$1.reduce(function(result, property2, i) {
    if (isTransition) {
      styleVal = value.replace(/(transform|transform-origin)/gim, "".concat(IN_LINE_PREFIX_LIST[i], "$1"));
    }
    return _objectSpread$m(_objectSpread$m({}, result), {}, _defineProperty$q({}, property2 + camelName, styleVal));
  }, {});
};
var mapObject = function mapObject2(fn2, obj) {
  return Object.keys(obj).reduce(function(res, key) {
    return _objectSpread$m(_objectSpread$m({}, res), {}, _defineProperty$q({}, key, fn2(key, obj[key])));
  }, {});
};
var translateStyle = function translateStyle2(style) {
  return Object.keys(style).reduce(function(res, key) {
    return _objectSpread$m(_objectSpread$m({}, res), generatePrefixStyle$1(key, res[key]));
  }, style);
};
var getTransitionVal = function getTransitionVal2(props3, duration, easing) {
  return props3.map(function(prop3) {
    return "".concat(getDashCase(prop3), " ").concat(duration, "ms ").concat(easing);
  }).join(",");
};
function _slicedToArray$9(arr, i) {
  return _arrayWithHoles$9(arr) || _iterableToArrayLimit$9(arr, i) || _unsupportedIterableToArray$g(arr, i) || _nonIterableRest$9();
}
function _nonIterableRest$9() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$9(arr, i) {
  var _i2 = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i2) {
    var _s2, _e2, _x, _r, _arr = [], _n2 = true, _d = false;
    try {
      if (_x = (_i2 = _i2.call(arr)).next, 0 === i) {
        if (Object(_i2) !== _i2)
          return;
        _n2 = false;
      } else
        for (; !(_n2 = (_s2 = _x.call(_i2)).done) && (_arr.push(_s2.value), _arr.length !== i); _n2 = true)
          ;
    } catch (err) {
      _d = true, _e2 = err;
    } finally {
      try {
        if (!_n2 && null != _i2.return && (_r = _i2.return(), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$9(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray$a(arr) {
  return _arrayWithoutHoles$a(arr) || _iterableToArray$a(arr) || _unsupportedIterableToArray$g(arr) || _nonIterableSpread$a();
}
function _nonIterableSpread$a() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$g(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$g(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$g(o3, minLen);
}
function _iterableToArray$a(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$a(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$g(arr);
}
function _arrayLikeToArray$g(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var ACCURACY = 1e-4;
var cubicBezierFactor = function cubicBezierFactor2(c1, c2) {
  return [0, 3 * c1, 3 * c2 - 6 * c1, 3 * c1 - 3 * c2 + 1];
};
var multyTime = function multyTime2(params, t2) {
  return params.map(function(param, i) {
    return param * Math.pow(t2, i);
  }).reduce(function(pre, curr) {
    return pre + curr;
  });
};
var cubicBezier = function cubicBezier2(c1, c2) {
  return function(t2) {
    var params = cubicBezierFactor(c1, c2);
    return multyTime(params, t2);
  };
};
var derivativeCubicBezier = function derivativeCubicBezier2(c1, c2) {
  return function(t2) {
    var params = cubicBezierFactor(c1, c2);
    var newParams = [].concat(_toConsumableArray$a(params.map(function(param, i) {
      return param * i;
    }).slice(1)), [0]);
    return multyTime(newParams, t2);
  };
};
var configBezier = function configBezier2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var x1 = args[0], y1 = args[1], x2 = args[2], y2 = args[3];
  if (args.length === 1) {
    switch (args[0]) {
      case "linear":
        x1 = 0;
        y1 = 0;
        x2 = 1;
        y2 = 1;
        break;
      case "ease":
        x1 = 0.25;
        y1 = 0.1;
        x2 = 0.25;
        y2 = 1;
        break;
      case "ease-in":
        x1 = 0.42;
        y1 = 0;
        x2 = 1;
        y2 = 1;
        break;
      case "ease-out":
        x1 = 0.42;
        y1 = 0;
        x2 = 0.58;
        y2 = 1;
        break;
      case "ease-in-out":
        x1 = 0;
        y1 = 0;
        x2 = 0.58;
        y2 = 1;
        break;
      default: {
        var easing = args[0].split("(");
        if (easing[0] === "cubic-bezier" && easing[1].split(")")[0].split(",").length === 4) {
          var _easing$1$split$0$spl = easing[1].split(")")[0].split(",").map(function(x3) {
            return parseFloat(x3);
          });
          var _easing$1$split$0$spl2 = _slicedToArray$9(_easing$1$split$0$spl, 4);
          x1 = _easing$1$split$0$spl2[0];
          y1 = _easing$1$split$0$spl2[1];
          x2 = _easing$1$split$0$spl2[2];
          y2 = _easing$1$split$0$spl2[3];
        }
      }
    }
  }
  var curveX = cubicBezier(x1, x2);
  var curveY = cubicBezier(y1, y2);
  var derCurveX = derivativeCubicBezier(x1, x2);
  var rangeValue = function rangeValue2(value) {
    if (value > 1) {
      return 1;
    } else if (value < 0) {
      return 0;
    }
    return value;
  };
  var bezier = function bezier2(_t2) {
    var t2 = _t2 > 1 ? 1 : _t2;
    var x3 = t2;
    for (var i = 0; i < 8; ++i) {
      var evalT = curveX(x3) - t2;
      var derVal = derCurveX(x3);
      if (Math.abs(evalT - t2) < ACCURACY || derVal < ACCURACY) {
        return curveY(x3);
      }
      x3 = rangeValue(x3 - evalT / derVal);
    }
    return curveY(x3);
  };
  bezier.isStepper = false;
  return bezier;
};
var configSpring = function configSpring2() {
  var config2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _config$stiff = config2.stiff, stiff = _config$stiff === void 0 ? 100 : _config$stiff, _config$damping = config2.damping, damping = _config$damping === void 0 ? 8 : _config$damping, _config$dt = config2.dt, dt2 = _config$dt === void 0 ? 17 : _config$dt;
  var stepper = function stepper2(currX, destX, currV) {
    var FSpring = -(currX - destX) * stiff;
    var FDamping = currV * damping;
    var newV = currV + (FSpring - FDamping) * dt2 / 1e3;
    var newX = currV * dt2 / 1e3 + currX;
    if (Math.abs(newX - destX) < ACCURACY && Math.abs(newV) < ACCURACY) {
      return [destX, 0];
    }
    return [newX, newV];
  };
  stepper.isStepper = true;
  stepper.dt = dt2;
  return stepper;
};
var configEasing = function configEasing2() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var easing = args[0];
  if (typeof easing === "string") {
    switch (easing) {
      case "ease":
      case "ease-in-out":
      case "ease-out":
      case "ease-in":
      case "linear":
        return configBezier(easing);
      case "spring":
        return configSpring();
      default:
        if (easing.split("(")[0] === "cubic-bezier") {
          return configBezier(easing);
        }
    }
  }
  if (typeof easing === "function") {
    return easing;
  }
  return null;
};
function _typeof$p(obj) {
  "@babel/helpers - typeof";
  return _typeof$p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$p(obj);
}
function _toConsumableArray$9(arr) {
  return _arrayWithoutHoles$9(arr) || _iterableToArray$9(arr) || _unsupportedIterableToArray$f(arr) || _nonIterableSpread$9();
}
function _nonIterableSpread$9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$9(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$9(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$f(arr);
}
function ownKeys$l(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$l(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$l(Object(source), true).forEach(function(key) {
      _defineProperty$p(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$l(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$p(obj, key, value) {
  key = _toPropertyKey$p(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$p(arg) {
  var key = _toPrimitive$p(arg, "string");
  return _typeof$p(key) === "symbol" ? key : String(key);
}
function _toPrimitive$p(input, hint) {
  if (_typeof$p(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$p(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _slicedToArray$8(arr, i) {
  return _arrayWithHoles$8(arr) || _iterableToArrayLimit$8(arr, i) || _unsupportedIterableToArray$f(arr, i) || _nonIterableRest$8();
}
function _nonIterableRest$8() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$f(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$f(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$f(o3, minLen);
}
function _arrayLikeToArray$f(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$8(arr, i) {
  var _i2 = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i2) {
    var _s2, _e2, _x, _r, _arr = [], _n2 = true, _d = false;
    try {
      if (_x = (_i2 = _i2.call(arr)).next, 0 === i) {
        if (Object(_i2) !== _i2)
          return;
        _n2 = false;
      } else
        for (; !(_n2 = (_s2 = _x.call(_i2)).done) && (_arr.push(_s2.value), _arr.length !== i); _n2 = true)
          ;
    } catch (err) {
      _d = true, _e2 = err;
    } finally {
      try {
        if (!_n2 && null != _i2.return && (_r = _i2.return(), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$8(arr) {
  if (Array.isArray(arr))
    return arr;
}
var alpha = function alpha2(begin, end, k2) {
  return begin + (end - begin) * k2;
};
var needContinue = function needContinue2(_ref) {
  var from2 = _ref.from, to2 = _ref.to;
  return from2 !== to2;
};
var calStepperVals = function calStepperVals2(easing, preVals, steps) {
  var nextStepVals = mapObject(function(key, val) {
    if (needContinue(val)) {
      var _easing = easing(val.from, val.to, val.velocity), _easing2 = _slicedToArray$8(_easing, 2), newX = _easing2[0], newV = _easing2[1];
      return _objectSpread$l(_objectSpread$l({}, val), {}, {
        from: newX,
        velocity: newV
      });
    }
    return val;
  }, preVals);
  if (steps < 1) {
    return mapObject(function(key, val) {
      if (needContinue(val)) {
        return _objectSpread$l(_objectSpread$l({}, val), {}, {
          velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
          from: alpha(val.from, nextStepVals[key].from, steps)
        });
      }
      return val;
    }, preVals);
  }
  return calStepperVals2(easing, nextStepVals, steps - 1);
};
const configUpdate = function(from2, to2, easing, duration, render) {
  var interKeys = getIntersectionKeys(from2, to2);
  var timingStyle = interKeys.reduce(function(res, key) {
    return _objectSpread$l(_objectSpread$l({}, res), {}, _defineProperty$p({}, key, [from2[key], to2[key]]));
  }, {});
  var stepperStyle = interKeys.reduce(function(res, key) {
    return _objectSpread$l(_objectSpread$l({}, res), {}, _defineProperty$p({}, key, {
      from: from2[key],
      velocity: 0,
      to: to2[key]
    }));
  }, {});
  var cafId = -1;
  var preTime;
  var beginTime;
  var update3 = function update4() {
    return null;
  };
  var getCurrStyle = function getCurrStyle2() {
    return mapObject(function(key, val) {
      return val.from;
    }, stepperStyle);
  };
  var shouldStopAnimation = function shouldStopAnimation2() {
    return !Object.values(stepperStyle).filter(needContinue).length;
  };
  var stepperUpdate = function stepperUpdate2(now2) {
    if (!preTime) {
      preTime = now2;
    }
    var deltaTime = now2 - preTime;
    var steps = deltaTime / easing.dt;
    stepperStyle = calStepperVals(easing, stepperStyle, steps);
    render(_objectSpread$l(_objectSpread$l(_objectSpread$l({}, from2), to2), getCurrStyle()));
    preTime = now2;
    if (!shouldStopAnimation()) {
      cafId = requestAnimationFrame(update3);
    }
  };
  var timingUpdate = function timingUpdate2(now2) {
    if (!beginTime) {
      beginTime = now2;
    }
    var t2 = (now2 - beginTime) / duration;
    var currStyle = mapObject(function(key, val) {
      return alpha.apply(void 0, _toConsumableArray$9(val).concat([easing(t2)]));
    }, timingStyle);
    render(_objectSpread$l(_objectSpread$l(_objectSpread$l({}, from2), to2), currStyle));
    if (t2 < 1) {
      cafId = requestAnimationFrame(update3);
    } else {
      var finalStyle = mapObject(function(key, val) {
        return alpha.apply(void 0, _toConsumableArray$9(val).concat([easing(1)]));
      }, timingStyle);
      render(_objectSpread$l(_objectSpread$l(_objectSpread$l({}, from2), to2), finalStyle));
    }
  };
  update3 = easing.isStepper ? stepperUpdate : timingUpdate;
  return function() {
    requestAnimationFrame(update3);
    return function() {
      cancelAnimationFrame(cafId);
    };
  };
};
var _excluded$8 = ["children", "begin", "duration", "attributeName", "easing", "isActive", "steps", "from", "to", "canBegin", "onAnimationEnd", "shouldReAnimate", "onAnimationReStart"];
function _typeof$o(obj) {
  "@babel/helpers - typeof";
  return _typeof$o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$o(obj);
}
function _objectWithoutProperties$8(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$9(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$9(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _toConsumableArray$8(arr) {
  return _arrayWithoutHoles$8(arr) || _iterableToArray$8(arr) || _unsupportedIterableToArray$e(arr) || _nonIterableSpread$8();
}
function _nonIterableSpread$8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$e(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$e(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$e(o3, minLen);
}
function _iterableToArray$8(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$8(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$e(arr);
}
function _arrayLikeToArray$e(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function ownKeys$k(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$k(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$k(Object(source), true).forEach(function(key) {
      _defineProperty$o(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$k(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$c(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$o(descriptor.key), descriptor);
  }
}
function _createClass$c(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$c(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$c(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$a(subClass, superClass);
}
function _setPrototypeOf$a(o3, p2) {
  _setPrototypeOf$a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$a(o3, p2);
}
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$a(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$a(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$a(this, result);
  };
}
function _possibleConstructorReturn$a(self2, call3) {
  if (call3 && (_typeof$o(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$a(self2);
}
function _assertThisInitialized$a(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$a(o3) {
  _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$a(o3);
}
function _defineProperty$o(obj, key, value) {
  key = _toPropertyKey$o(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$o(arg) {
  var key = _toPrimitive$o(arg, "string");
  return _typeof$o(key) === "symbol" ? key : String(key);
}
function _toPrimitive$o(input, hint) {
  if (_typeof$o(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$o(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Animate = /* @__PURE__ */ function(_PureComponent) {
  _inherits$a(Animate2, _PureComponent);
  var _super = _createSuper$a(Animate2);
  function Animate2(props3, context2) {
    var _this;
    _classCallCheck$c(this, Animate2);
    _this = _super.call(this, props3, context2);
    var _this$props = _this.props, isActive = _this$props.isActive, attributeName = _this$props.attributeName, from2 = _this$props.from, to2 = _this$props.to, steps = _this$props.steps, children = _this$props.children;
    _this.handleStyleChange = _this.handleStyleChange.bind(_assertThisInitialized$a(_this));
    _this.changeStyle = _this.changeStyle.bind(_assertThisInitialized$a(_this));
    if (!isActive) {
      _this.state = {
        style: {}
      };
      if (typeof children === "function") {
        _this.state = {
          style: to2
        };
      }
      return _possibleConstructorReturn$a(_this);
    }
    if (steps && steps.length) {
      _this.state = {
        style: steps[0].style
      };
    } else if (from2) {
      if (typeof children === "function") {
        _this.state = {
          style: from2
        };
        return _possibleConstructorReturn$a(_this);
      }
      _this.state = {
        style: attributeName ? _defineProperty$o({}, attributeName, from2) : from2
      };
    } else {
      _this.state = {
        style: {}
      };
    }
    return _this;
  }
  _createClass$c(Animate2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props2 = this.props, isActive = _this$props2.isActive, canBegin = _this$props2.canBegin;
      this.mounted = true;
      if (!isActive || !canBegin) {
        return;
      }
      this.runAnimation(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props3 = this.props, isActive = _this$props3.isActive, canBegin = _this$props3.canBegin, attributeName = _this$props3.attributeName, shouldReAnimate = _this$props3.shouldReAnimate;
      if (!canBegin) {
        return;
      }
      if (!isActive) {
        var newState = {
          style: attributeName ? _defineProperty$o({}, attributeName, this.props.to) : this.props.to
        };
        if (this.state && this.state.style) {
          if (attributeName && this.state.style[attributeName] !== this.props.to || !attributeName && this.state.style !== this.props.to) {
            this.setState(newState);
          }
        }
        return;
      }
      if (deepEqual(prevProps.to, this.props.to) && prevProps.canBegin && prevProps.isActive) {
        return;
      }
      var isTriggered = !prevProps.canBegin || !prevProps.isActive;
      if (this.manager) {
        this.manager.stop();
      }
      if (this.stopJSAnimation) {
        this.stopJSAnimation();
      }
      var from2 = isTriggered || shouldReAnimate ? this.props.from : prevProps.to;
      if (this.state && this.state.style) {
        var _newState = {
          style: attributeName ? _defineProperty$o({}, attributeName, from2) : from2
        };
        if (attributeName && this.state.style[attributeName] !== from2 || !attributeName && this.state.style !== from2) {
          this.setState(_newState);
        }
      }
      this.runAnimation(_objectSpread$k(_objectSpread$k({}, this.props), {}, {
        from: from2,
        begin: 0
      }));
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.mounted = false;
      if (this.unSubscribe) {
        this.unSubscribe();
      }
      if (this.manager) {
        this.manager.stop();
        this.manager = null;
      }
      if (this.stopJSAnimation) {
        this.stopJSAnimation();
      }
    }
  }, {
    key: "runJSAnimation",
    value: function runJSAnimation(props3) {
      var _this2 = this;
      var from2 = props3.from, to2 = props3.to, duration = props3.duration, easing = props3.easing, begin = props3.begin, onAnimationEnd2 = props3.onAnimationEnd, onAnimationStart2 = props3.onAnimationStart;
      var startAnimation = configUpdate(from2, to2, configEasing(easing), duration, this.changeStyle);
      var finalStartAnimation = function finalStartAnimation2() {
        _this2.stopJSAnimation = startAnimation();
      };
      this.manager.start([onAnimationStart2, begin, finalStartAnimation, duration, onAnimationEnd2]);
    }
  }, {
    key: "runStepAnimation",
    value: function runStepAnimation(props3) {
      var _this3 = this;
      var steps = props3.steps, begin = props3.begin, onAnimationStart2 = props3.onAnimationStart;
      var _steps$ = steps[0], initialStyle = _steps$.style, _steps$$duration = _steps$.duration, initialTime = _steps$$duration === void 0 ? 0 : _steps$$duration;
      var addStyle2 = function addStyle3(sequence3, nextItem, index3) {
        if (index3 === 0) {
          return sequence3;
        }
        var duration = nextItem.duration, _nextItem$easing = nextItem.easing, easing = _nextItem$easing === void 0 ? "ease" : _nextItem$easing, style = nextItem.style, nextProperties = nextItem.properties, onAnimationEnd2 = nextItem.onAnimationEnd;
        var preItem = index3 > 0 ? steps[index3 - 1] : nextItem;
        var properties = nextProperties || Object.keys(style);
        if (typeof easing === "function" || easing === "spring") {
          return [].concat(_toConsumableArray$8(sequence3), [_this3.runJSAnimation.bind(_this3, {
            from: preItem.style,
            to: style,
            duration,
            easing
          }), duration]);
        }
        var transition2 = getTransitionVal(properties, duration, easing);
        var newStyle = _objectSpread$k(_objectSpread$k(_objectSpread$k({}, preItem.style), style), {}, {
          transition: transition2
        });
        return [].concat(_toConsumableArray$8(sequence3), [newStyle, duration, onAnimationEnd2]).filter(identity$9);
      };
      return this.manager.start([onAnimationStart2].concat(_toConsumableArray$8(steps.reduce(addStyle2, [initialStyle, Math.max(initialTime, begin)])), [props3.onAnimationEnd]));
    }
  }, {
    key: "runAnimation",
    value: function runAnimation(props3) {
      if (!this.manager) {
        this.manager = createAnimateManager();
      }
      var begin = props3.begin, duration = props3.duration, attributeName = props3.attributeName, propsTo = props3.to, easing = props3.easing, onAnimationStart2 = props3.onAnimationStart, onAnimationEnd2 = props3.onAnimationEnd, steps = props3.steps, children = props3.children;
      var manager = this.manager;
      this.unSubscribe = manager.subscribe(this.handleStyleChange);
      if (typeof easing === "function" || typeof children === "function" || easing === "spring") {
        this.runJSAnimation(props3);
        return;
      }
      if (steps.length > 1) {
        this.runStepAnimation(props3);
        return;
      }
      var to2 = attributeName ? _defineProperty$o({}, attributeName, propsTo) : propsTo;
      var transition2 = getTransitionVal(Object.keys(to2), duration, easing);
      manager.start([onAnimationStart2, begin, _objectSpread$k(_objectSpread$k({}, to2), {}, {
        transition: transition2
      }), duration, onAnimationEnd2]);
    }
  }, {
    key: "handleStyleChange",
    value: function handleStyleChange(style) {
      this.changeStyle(style);
    }
  }, {
    key: "changeStyle",
    value: function changeStyle(style) {
      if (this.mounted) {
        this.setState({
          style
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props4 = this.props, children = _this$props4.children;
      _this$props4.begin;
      _this$props4.duration;
      _this$props4.attributeName;
      _this$props4.easing;
      var isActive = _this$props4.isActive;
      _this$props4.steps;
      _this$props4.from;
      _this$props4.to;
      _this$props4.canBegin;
      _this$props4.onAnimationEnd;
      _this$props4.shouldReAnimate;
      _this$props4.onAnimationReStart;
      var others = _objectWithoutProperties$8(_this$props4, _excluded$8);
      var count2 = reactExports.Children.count(children);
      var stateStyle = translateStyle(this.state.style);
      if (typeof children === "function") {
        return children(stateStyle);
      }
      if (!isActive || count2 === 0) {
        return children;
      }
      var cloneContainer = function cloneContainer2(container) {
        var _container$props = container.props, _container$props$styl = _container$props.style, style = _container$props$styl === void 0 ? {} : _container$props$styl, className = _container$props.className;
        var res = /* @__PURE__ */ reactExports.cloneElement(container, _objectSpread$k(_objectSpread$k({}, others), {}, {
          style: _objectSpread$k(_objectSpread$k({}, style), stateStyle),
          className
        }));
        return res;
      };
      if (count2 === 1) {
        return cloneContainer(reactExports.Children.only(children));
      }
      return /* @__PURE__ */ React.createElement("div", null, reactExports.Children.map(children, function(child) {
        return cloneContainer(child);
      }));
    }
  }]);
  return Animate2;
}(reactExports.PureComponent);
_defineProperty$o(Animate, "displayName", "Animate");
_defineProperty$o(Animate, "propTypes", {
  from: PropTypes$1.oneOfType([PropTypes$1.object, PropTypes$1.string]),
  to: PropTypes$1.oneOfType([PropTypes$1.object, PropTypes$1.string]),
  attributeName: PropTypes$1.string,
  // animation duration
  duration: PropTypes$1.number,
  begin: PropTypes$1.number,
  easing: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.func]),
  steps: PropTypes$1.arrayOf(PropTypes$1.shape({
    duration: PropTypes$1.number.isRequired,
    style: PropTypes$1.object.isRequired,
    easing: PropTypes$1.oneOfType([PropTypes$1.oneOf(["ease", "ease-in", "ease-out", "ease-in-out", "linear"]), PropTypes$1.func]),
    // transition css properties(dash case), optional
    properties: PropTypes$1.arrayOf("string"),
    onAnimationEnd: PropTypes$1.func
  })),
  children: PropTypes$1.oneOfType([PropTypes$1.node, PropTypes$1.func]),
  isActive: PropTypes$1.bool,
  canBegin: PropTypes$1.bool,
  onAnimationEnd: PropTypes$1.func,
  // decide if it should reanimate with initial from style when props change
  shouldReAnimate: PropTypes$1.bool,
  onAnimationStart: PropTypes$1.func,
  onAnimationReStart: PropTypes$1.func
});
_defineProperty$o(Animate, "defaultProps", {
  begin: 0,
  duration: 1e3,
  from: "",
  to: "",
  attributeName: "",
  easing: "ease",
  isActive: true,
  canBegin: true,
  steps: [],
  onAnimationEnd: function onAnimationEnd() {
  },
  onAnimationStart: function onAnimationStart() {
  }
});
var CSSTransition = { exports: {} };
var addClass = { exports: {} };
var interopRequireDefault = { exports: {} };
(function(module2) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module2.exports = _interopRequireDefault2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports;
var hasClass = { exports: {} };
var hasRequiredHasClass;
function requireHasClass() {
  if (hasRequiredHasClass)
    return hasClass.exports;
  hasRequiredHasClass = 1;
  (function(module2, exports) {
    exports.__esModule = true;
    exports.default = hasClass2;
    function hasClass2(element, className) {
      if (element.classList)
        return !!className && element.classList.contains(className);
      else
        return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
    }
    module2.exports = exports["default"];
  })(hasClass, hasClass.exports);
  return hasClass.exports;
}
(function(module2, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports.default = addClass2;
  var _hasClass = _interopRequireDefault2(requireHasClass());
  function addClass2(element, className) {
    if (element.classList)
      element.classList.add(className);
    else if (!(0, _hasClass.default)(element, className))
      if (typeof element.className === "string")
        element.className = element.className + " " + className;
      else
        element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
  }
  module2.exports = exports["default"];
})(addClass, addClass.exports);
var addClassExports = addClass.exports;
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
var removeClass = function removeClass2(element, className) {
  if (element.classList)
    element.classList.remove(className);
  else if (typeof element.className === "string")
    element.className = replaceClassName(element.className, className);
  else
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
};
var Transition$1 = {};
function componentWillMount() {
  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
  if (state !== null && state !== void 0) {
    this.setState(state);
  }
}
function componentWillReceiveProps(nextProps) {
  function updater(prevState) {
    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
    return state !== null && state !== void 0 ? state : null;
  }
  this.setState(updater.bind(this));
}
function componentWillUpdate(nextProps, nextState) {
  try {
    var prevProps = this.props;
    var prevState = this.state;
    this.props = nextProps;
    this.state = nextState;
    this.__reactInternalSnapshotFlag = true;
    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
      prevProps,
      prevState
    );
  } finally {
    this.props = prevProps;
    this.state = prevState;
  }
}
componentWillMount.__suppressDeprecationWarning = true;
componentWillReceiveProps.__suppressDeprecationWarning = true;
componentWillUpdate.__suppressDeprecationWarning = true;
function polyfill(Component) {
  var prototype2 = Component.prototype;
  if (!prototype2 || !prototype2.isReactComponent) {
    throw new Error("Can only polyfill class components");
  }
  if (typeof Component.getDerivedStateFromProps !== "function" && typeof prototype2.getSnapshotBeforeUpdate !== "function") {
    return Component;
  }
  var foundWillMountName = null;
  var foundWillReceivePropsName = null;
  var foundWillUpdateName = null;
  if (typeof prototype2.componentWillMount === "function") {
    foundWillMountName = "componentWillMount";
  } else if (typeof prototype2.UNSAFE_componentWillMount === "function") {
    foundWillMountName = "UNSAFE_componentWillMount";
  }
  if (typeof prototype2.componentWillReceiveProps === "function") {
    foundWillReceivePropsName = "componentWillReceiveProps";
  } else if (typeof prototype2.UNSAFE_componentWillReceiveProps === "function") {
    foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
  }
  if (typeof prototype2.componentWillUpdate === "function") {
    foundWillUpdateName = "componentWillUpdate";
  } else if (typeof prototype2.UNSAFE_componentWillUpdate === "function") {
    foundWillUpdateName = "UNSAFE_componentWillUpdate";
  }
  if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
    var componentName = Component.displayName || Component.name;
    var newApiName = typeof Component.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
    throw Error(
      "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + componentName + " uses " + newApiName + " but also contains the following legacy lifecycles:" + (foundWillMountName !== null ? "\n  " + foundWillMountName : "") + (foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "") + (foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-async-component-lifecycle-hooks"
    );
  }
  if (typeof Component.getDerivedStateFromProps === "function") {
    prototype2.componentWillMount = componentWillMount;
    prototype2.componentWillReceiveProps = componentWillReceiveProps;
  }
  if (typeof prototype2.getSnapshotBeforeUpdate === "function") {
    if (typeof prototype2.componentDidUpdate !== "function") {
      throw new Error(
        "Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype"
      );
    }
    prototype2.componentWillUpdate = componentWillUpdate;
    var componentDidUpdate = prototype2.componentDidUpdate;
    prototype2.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {
      var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;
      componentDidUpdate.call(this, prevProps, prevState, snapshot);
    };
  }
  return Component;
}
const reactLifecyclesCompat_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  polyfill
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(reactLifecyclesCompat_es);
Transition$1.__esModule = true;
Transition$1.default = Transition$1.EXITING = Transition$1.ENTERED = Transition$1.ENTERING = Transition$1.EXITED = Transition$1.UNMOUNTED = void 0;
var PropTypes = _interopRequireWildcard(propTypesExports);
var _react$1 = _interopRequireDefault$2(reactExports);
var _reactDom = _interopRequireDefault$2(reactDomExports);
var _reactLifecyclesCompat = require$$2;
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function _objectWithoutPropertiesLoose$8(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var UNMOUNTED = "unmounted";
Transition$1.UNMOUNTED = UNMOUNTED;
var EXITED = "exited";
Transition$1.EXITED = EXITED;
var ENTERING = "entering";
Transition$1.ENTERING = ENTERING;
var ENTERED = "entered";
Transition$1.ENTERED = ENTERED;
var EXITING = "exiting";
Transition$1.EXITING = EXITING;
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props3, context2) {
    var _this;
    _this = _React$Component.call(this, props3, context2) || this;
    var parentGroup = context2.transitionGroup;
    var appear = parentGroup && !parentGroup.isMounting ? props3.enter : props3.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props3.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props3.unmountOnExit || props3.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  var _proto = Transition2.prototype;
  _proto.getChildContext = function getChildContext() {
    return {
      transitionGroup: null
      // allows for nested Transitions
    };
  };
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;
    if (timeout != null && typeof timeout !== "number") {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear !== void 0 ? timeout.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      var node = _reactDom.default.findDOMNode(this);
      if (nextStatus === ENTERING) {
        this.performEnter(node, mounting);
      } else {
        this.performExit(node);
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(node, mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(node);
      });
      return;
    }
    this.props.onEnter(node, appearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(node, appearing);
      _this2.onTransitionEnd(node, enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(node, appearing);
        });
      });
    });
  };
  _proto.performExit = function performExit(node) {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    if (!exit) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(node);
      });
      return;
    }
    this.props.onExit(node);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(node);
      _this3.onTransitionEnd(node, timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(node);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {
    this.setNextCallback(handler);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      this.props.addEndListener(node, this.nextCallback);
    }
    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children, childProps = _objectWithoutPropertiesLoose$8(_this$props, ["children"]);
    delete childProps.in;
    delete childProps.mountOnEnter;
    delete childProps.unmountOnExit;
    delete childProps.appear;
    delete childProps.enter;
    delete childProps.exit;
    delete childProps.timeout;
    delete childProps.addEndListener;
    delete childProps.onEnter;
    delete childProps.onEntering;
    delete childProps.onEntered;
    delete childProps.onExit;
    delete childProps.onExiting;
    delete childProps.onExited;
    if (typeof children === "function") {
      return children(status, childProps);
    }
    var child = _react$1.default.Children.only(children);
    return _react$1.default.cloneElement(child, childProps);
  };
  return Transition2;
}(_react$1.default.Component);
Transition.contextTypes = {
  transitionGroup: PropTypes.object
};
Transition.childContextTypes = {
  transitionGroup: function transitionGroup() {
  }
};
Transition.propTypes = {};
function noop$1() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$1,
  onEntering: noop$1,
  onEntered: noop$1,
  onExit: noop$1,
  onExiting: noop$1,
  onExited: noop$1
};
Transition.UNMOUNTED = 0;
Transition.EXITED = 1;
Transition.ENTERING = 2;
Transition.ENTERED = 3;
Transition.EXITING = 4;
var _default = (0, _reactLifecyclesCompat.polyfill)(Transition);
Transition$1.default = _default;
(function(module2, exports) {
  exports.__esModule = true;
  exports.default = void 0;
  _interopRequireWildcard2(propTypesExports);
  var _addClass = _interopRequireDefault2(addClassExports);
  var _removeClass = _interopRequireDefault2(removeClass);
  var _react2 = _interopRequireDefault2(reactExports);
  var _Transition2 = _interopRequireDefault2(Transition$1);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _interopRequireWildcard2(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
            if (desc.get || desc.set) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _extends2() {
    _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var addClass2 = function addClass3(node, classes2) {
    return node && classes2 && classes2.split(" ").forEach(function(c2) {
      return (0, _addClass.default)(node, c2);
    });
  };
  var removeClass$1 = function removeClass3(node, classes2) {
    return node && classes2 && classes2.split(" ").forEach(function(c2) {
      return (0, _removeClass.default)(node, c2);
    });
  };
  var CSSTransition2 = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose2(CSSTransition3, _React$Component);
    function CSSTransition3() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.onEnter = function(node, appearing) {
        var _this$getClassNames = _this.getClassNames(appearing ? "appear" : "enter"), className = _this$getClassNames.className;
        _this.removeClasses(node, "exit");
        addClass2(node, className);
        if (_this.props.onEnter) {
          _this.props.onEnter(node, appearing);
        }
      };
      _this.onEntering = function(node, appearing) {
        var _this$getClassNames2 = _this.getClassNames(appearing ? "appear" : "enter"), activeClassName = _this$getClassNames2.activeClassName;
        _this.reflowAndAddClass(node, activeClassName);
        if (_this.props.onEntering) {
          _this.props.onEntering(node, appearing);
        }
      };
      _this.onEntered = function(node, appearing) {
        var appearClassName = _this.getClassNames("appear").doneClassName;
        var enterClassName = _this.getClassNames("enter").doneClassName;
        var doneClassName = appearing ? appearClassName + " " + enterClassName : enterClassName;
        _this.removeClasses(node, appearing ? "appear" : "enter");
        addClass2(node, doneClassName);
        if (_this.props.onEntered) {
          _this.props.onEntered(node, appearing);
        }
      };
      _this.onExit = function(node) {
        var _this$getClassNames3 = _this.getClassNames("exit"), className = _this$getClassNames3.className;
        _this.removeClasses(node, "appear");
        _this.removeClasses(node, "enter");
        addClass2(node, className);
        if (_this.props.onExit) {
          _this.props.onExit(node);
        }
      };
      _this.onExiting = function(node) {
        var _this$getClassNames4 = _this.getClassNames("exit"), activeClassName = _this$getClassNames4.activeClassName;
        _this.reflowAndAddClass(node, activeClassName);
        if (_this.props.onExiting) {
          _this.props.onExiting(node);
        }
      };
      _this.onExited = function(node) {
        var _this$getClassNames5 = _this.getClassNames("exit"), doneClassName = _this$getClassNames5.doneClassName;
        _this.removeClasses(node, "exit");
        addClass2(node, doneClassName);
        if (_this.props.onExited) {
          _this.props.onExited(node);
        }
      };
      _this.getClassNames = function(type3) {
        var classNames2 = _this.props.classNames;
        var isStringClassNames = typeof classNames2 === "string";
        var prefix2 = isStringClassNames && classNames2 ? classNames2 + "-" : "";
        var className = isStringClassNames ? prefix2 + type3 : classNames2[type3];
        var activeClassName = isStringClassNames ? className + "-active" : classNames2[type3 + "Active"];
        var doneClassName = isStringClassNames ? className + "-done" : classNames2[type3 + "Done"];
        return {
          className,
          activeClassName,
          doneClassName
        };
      };
      return _this;
    }
    var _proto = CSSTransition3.prototype;
    _proto.removeClasses = function removeClasses2(node, type3) {
      var _this$getClassNames6 = this.getClassNames(type3), className = _this$getClassNames6.className, activeClassName = _this$getClassNames6.activeClassName, doneClassName = _this$getClassNames6.doneClassName;
      className && removeClass$1(node, className);
      activeClassName && removeClass$1(node, activeClassName);
      doneClassName && removeClass$1(node, doneClassName);
    };
    _proto.reflowAndAddClass = function reflowAndAddClass(node, className) {
      if (className) {
        node && node.scrollTop;
        addClass2(node, className);
      }
    };
    _proto.render = function render() {
      var props3 = _extends2({}, this.props);
      delete props3.classNames;
      return _react2.default.createElement(_Transition2.default, _extends2({}, props3, {
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }));
    };
    return CSSTransition3;
  }(_react2.default.Component);
  CSSTransition2.defaultProps = {
    classNames: ""
  };
  CSSTransition2.propTypes = {};
  var _default2 = CSSTransition2;
  exports.default = _default2;
  module2.exports = exports["default"];
})(CSSTransition, CSSTransition.exports);
var CSSTransitionExports = CSSTransition.exports;
var ReplaceTransition = { exports: {} };
var TransitionGroup = { exports: {} };
var ChildMapping = {};
ChildMapping.__esModule = true;
ChildMapping.getChildMapping = getChildMapping;
ChildMapping.mergeChildMappings = mergeChildMappings;
ChildMapping.getInitialChildMapping = getInitialChildMapping;
ChildMapping.getNextChildMapping = getNextChildMapping;
var _react = reactExports;
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children)
    _react.Children.map(children, function(c2) {
      return c2;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};
  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
function getProp(child, prop3, props3) {
  return props3[prop3] != null ? props3[prop3] : child.props[prop3];
}
function getInitialChildMapping(props3, onExited) {
  return getChildMapping(props3.children, function(child) {
    return (0, _react.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props3),
      enter: getProp(child, "enter", props3),
      exit: getProp(child, "exit", props3)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!(0, _react.isValidElement)(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = (0, _react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = (0, _react.cloneElement)(child, {
        in: false
      });
    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {
      children[key] = (0, _react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
(function(module2, exports) {
  exports.__esModule = true;
  exports.default = void 0;
  var _propTypes = _interopRequireDefault2(propTypesExports);
  var _react2 = _interopRequireDefault2(reactExports);
  var _reactLifecyclesCompat2 = require$$2;
  var _ChildMapping = ChildMapping;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _objectWithoutPropertiesLoose2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _extends2() {
    _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  function _assertThisInitialized2(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  var values3 = Object.values || function(obj) {
    return Object.keys(obj).map(function(k2) {
      return obj[k2];
    });
  };
  var defaultProps2 = {
    component: "div",
    childFactory: function childFactory(child) {
      return child;
    }
    /**
     * The `<TransitionGroup>` component manages a set of transition components
     * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
     * components, `<TransitionGroup>` is a state machine for managing the mounting
     * and unmounting of components over time.
     *
     * Consider the example below. As items are removed or added to the TodoList the
     * `in` prop is toggled automatically by the `<TransitionGroup>`.
     *
     * Note that `<TransitionGroup>`  does not define any animation behavior!
     * Exactly _how_ a list item animates is up to the individual transition
     * component. This means you can mix and match animations across different list
     * items.
     */
  };
  var TransitionGroup2 = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose2(TransitionGroup3, _React$Component);
    function TransitionGroup3(props3, context2) {
      var _this;
      _this = _React$Component.call(this, props3, context2) || this;
      var handleExited = _this.handleExited.bind(_assertThisInitialized2(_assertThisInitialized2(_this)));
      _this.state = {
        handleExited,
        firstRender: true
      };
      return _this;
    }
    var _proto = TransitionGroup3.prototype;
    _proto.getChildContext = function getChildContext() {
      return {
        transitionGroup: {
          isMounting: !this.appeared
        }
      };
    };
    _proto.componentDidMount = function componentDidMount() {
      this.appeared = true;
      this.mounted = true;
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };
    TransitionGroup3.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
      return {
        children: firstRender ? (0, _ChildMapping.getInitialChildMapping)(nextProps, handleExited) : (0, _ChildMapping.getNextChildMapping)(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    };
    _proto.handleExited = function handleExited(child, node) {
      var currentChildMapping = (0, _ChildMapping.getChildMapping)(this.props.children);
      if (child.key in currentChildMapping)
        return;
      if (child.props.onExited) {
        child.props.onExited(node);
      }
      if (this.mounted) {
        this.setState(function(state) {
          var children = _extends2({}, state.children);
          delete children[child.key];
          return {
            children
          };
        });
      }
    };
    _proto.render = function render() {
      var _this$props = this.props, Component = _this$props.component, childFactory = _this$props.childFactory, props3 = _objectWithoutPropertiesLoose2(_this$props, ["component", "childFactory"]);
      var children = values3(this.state.children).map(childFactory);
      delete props3.appear;
      delete props3.enter;
      delete props3.exit;
      if (Component === null) {
        return children;
      }
      return _react2.default.createElement(Component, props3, children);
    };
    return TransitionGroup3;
  }(_react2.default.Component);
  TransitionGroup2.childContextTypes = {
    transitionGroup: _propTypes.default.object.isRequired
  };
  TransitionGroup2.propTypes = {};
  TransitionGroup2.defaultProps = defaultProps2;
  var _default2 = (0, _reactLifecyclesCompat2.polyfill)(TransitionGroup2);
  exports.default = _default2;
  module2.exports = exports["default"];
})(TransitionGroup, TransitionGroup.exports);
var TransitionGroupExports = TransitionGroup.exports;
(function(module2, exports) {
  exports.__esModule = true;
  exports.default = void 0;
  _interopRequireDefault2(propTypesExports);
  var _react2 = _interopRequireDefault2(reactExports);
  var _reactDom2 = reactDomExports;
  var _TransitionGroup2 = _interopRequireDefault2(TransitionGroupExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _objectWithoutPropertiesLoose2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var ReplaceTransition2 = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose2(ReplaceTransition3, _React$Component);
    function ReplaceTransition3() {
      var _this;
      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
        _args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
      _this.handleEnter = function() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return _this.handleLifecycle("onEnter", 0, args);
      };
      _this.handleEntering = function() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return _this.handleLifecycle("onEntering", 0, args);
      };
      _this.handleEntered = function() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return _this.handleLifecycle("onEntered", 0, args);
      };
      _this.handleExit = function() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        return _this.handleLifecycle("onExit", 1, args);
      };
      _this.handleExiting = function() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        return _this.handleLifecycle("onExiting", 1, args);
      };
      _this.handleExited = function() {
        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }
        return _this.handleLifecycle("onExited", 1, args);
      };
      return _this;
    }
    var _proto = ReplaceTransition3.prototype;
    _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
      var _child$props;
      var children = this.props.children;
      var child = _react2.default.Children.toArray(children)[idx];
      if (child.props[handler])
        (_child$props = child.props)[handler].apply(_child$props, originalArgs);
      if (this.props[handler])
        this.props[handler]((0, _reactDom2.findDOMNode)(this));
    };
    _proto.render = function render() {
      var _this$props = this.props, children = _this$props.children, inProp = _this$props.in, props3 = _objectWithoutPropertiesLoose2(_this$props, ["children", "in"]);
      var _React$Children$toArr = _react2.default.Children.toArray(children), first = _React$Children$toArr[0], second2 = _React$Children$toArr[1];
      delete props3.onEnter;
      delete props3.onEntering;
      delete props3.onEntered;
      delete props3.onExit;
      delete props3.onExiting;
      delete props3.onExited;
      return _react2.default.createElement(_TransitionGroup2.default, props3, inProp ? _react2.default.cloneElement(first, {
        key: "first",
        onEnter: this.handleEnter,
        onEntering: this.handleEntering,
        onEntered: this.handleEntered
      }) : _react2.default.cloneElement(second2, {
        key: "second",
        onEnter: this.handleExit,
        onEntering: this.handleExiting,
        onEntered: this.handleExited
      }));
    };
    return ReplaceTransition3;
  }(_react2.default.Component);
  ReplaceTransition2.propTypes = {};
  var _default2 = ReplaceTransition2;
  exports.default = _default2;
  module2.exports = exports["default"];
})(ReplaceTransition, ReplaceTransition.exports);
var ReplaceTransitionExports = ReplaceTransition.exports;
var _CSSTransition = _interopRequireDefault$1(CSSTransitionExports);
var _ReplaceTransition = _interopRequireDefault$1(ReplaceTransitionExports);
var _TransitionGroup = _interopRequireDefault$1(TransitionGroupExports);
var _Transition = _interopRequireDefault$1(Transition$1);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var reactTransitionGroup = {
  Transition: _Transition.default,
  TransitionGroup: _TransitionGroup.default,
  ReplaceTransition: _ReplaceTransition.default,
  CSSTransition: _CSSTransition.default
};
var _excluded$7 = ["children", "appearOptions", "enterOptions", "leaveOptions"];
function _typeof$n(obj) {
  "@babel/helpers - typeof";
  return _typeof$n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$n(obj);
}
function _extends$i() {
  _extends$i = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$i.apply(this, arguments);
}
function _objectWithoutProperties$7(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$7(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$7(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function ownKeys$j(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$j(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$j(Object(source), true).forEach(function(key) {
      _defineProperty$n(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$j(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$b(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$n(descriptor.key), descriptor);
  }
}
function _createClass$b(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$b(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$b(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o3, p2) {
  _setPrototypeOf$9 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$9(o3, p2);
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$9(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$9(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$9(this, result);
  };
}
function _possibleConstructorReturn$9(self2, call3) {
  if (call3 && (_typeof$n(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$9(self2);
}
function _assertThisInitialized$9(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$9(o3) {
  _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$9(o3);
}
function _defineProperty$n(obj, key, value) {
  key = _toPropertyKey$n(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$n(arg) {
  var key = _toPrimitive$n(arg, "string");
  return _typeof$n(key) === "symbol" ? key : String(key);
}
function _toPrimitive$n(input, hint) {
  if (_typeof$n(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$n(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
if (Number.isFinite === void 0) {
  Number.isFinite = function(value) {
    return typeof value === "number" && isFinite(value);
  };
}
var parseDurationOfSingleTransition = function parseDurationOfSingleTransition2() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var steps = options.steps, duration = options.duration;
  if (steps && steps.length) {
    return steps.reduce(function(result, entry) {
      return result + (Number.isFinite(entry.duration) && entry.duration > 0 ? entry.duration : 0);
    }, 0);
  }
  if (Number.isFinite(duration)) {
    return duration;
  }
  return 0;
};
var AnimateGroupChild = /* @__PURE__ */ function(_Component) {
  _inherits$9(AnimateGroupChild2, _Component);
  var _super = _createSuper$9(AnimateGroupChild2);
  function AnimateGroupChild2() {
    var _this;
    _classCallCheck$b(this, AnimateGroupChild2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$n(_assertThisInitialized$9(_this), "state", {
      isActive: false
    });
    _defineProperty$n(_assertThisInitialized$9(_this), "handleEnter", function(node, isAppearing) {
      var _this$props = _this.props, appearOptions = _this$props.appearOptions, enterOptions = _this$props.enterOptions;
      _this.handleStyleActive(isAppearing ? appearOptions : enterOptions);
    });
    _defineProperty$n(_assertThisInitialized$9(_this), "handleExit", function() {
      _this.handleStyleActive(_this.props.leaveOptions);
    });
    return _this;
  }
  _createClass$b(AnimateGroupChild2, [{
    key: "handleStyleActive",
    value: function handleStyleActive(style) {
      if (style) {
        var onAnimationEnd2 = style.onAnimationEnd ? function() {
          style.onAnimationEnd();
        } : null;
        this.setState(_objectSpread$j(_objectSpread$j({}, style), {}, {
          onAnimationEnd: onAnimationEnd2,
          isActive: true
        }));
      }
    }
  }, {
    key: "parseTimeout",
    value: function parseTimeout() {
      var _this$props2 = this.props, appearOptions = _this$props2.appearOptions, enterOptions = _this$props2.enterOptions, leaveOptions = _this$props2.leaveOptions;
      return parseDurationOfSingleTransition(appearOptions) + parseDurationOfSingleTransition(enterOptions) + parseDurationOfSingleTransition(leaveOptions);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props3 = this.props, children = _this$props3.children;
      _this$props3.appearOptions;
      _this$props3.enterOptions;
      _this$props3.leaveOptions;
      var props3 = _objectWithoutProperties$7(_this$props3, _excluded$7);
      return /* @__PURE__ */ React.createElement(reactTransitionGroup.Transition, _extends$i({}, props3, {
        onEnter: this.handleEnter,
        onExit: this.handleExit,
        timeout: this.parseTimeout()
      }), function() {
        return /* @__PURE__ */ React.createElement(Animate, _this2.state, reactExports.Children.only(children));
      });
    }
  }]);
  return AnimateGroupChild2;
}(reactExports.Component);
_defineProperty$n(AnimateGroupChild, "propTypes", {
  appearOptions: PropTypes$1.object,
  enterOptions: PropTypes$1.object,
  leaveOptions: PropTypes$1.object,
  children: PropTypes$1.element
});
({
  appear: PropTypes$1.object,
  enter: PropTypes$1.object,
  leave: PropTypes$1.object,
  children: PropTypes$1.oneOfType([PropTypes$1.array, PropTypes$1.element]),
  component: PropTypes$1.any
});
var Symbol$1 = _Symbol, isArguments = isArguments_1, isArray$4 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$4(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$2(array3, depth, predicate3, isStrict, result) {
  var index3 = -1, length3 = array3.length;
  predicate3 || (predicate3 = isFlattenable);
  result || (result = []);
  while (++index3 < length3) {
    var value = array3[index3];
    if (depth > 0 && predicate3(value)) {
      if (depth > 1) {
        baseFlatten$2(value, depth - 1, predicate3, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$2;
function createBaseFor$1(fromRight) {
  return function(object2, iteratee, keysFunc) {
    var index3 = -1, iterable = Object(object2), props3 = keysFunc(object2), length3 = props3.length;
    while (length3--) {
      var key = props3[fromRight ? length3 : ++index3];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var baseFor = _baseFor, keys$1 = keys_1;
function baseForOwn$2(object2, iteratee) {
  return object2 && baseFor(object2, iteratee, keys$1);
}
var _baseForOwn = baseForOwn$2;
var isArrayLike$3 = isArrayLike_1;
function createBaseEach$1(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$3(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length3 = collection.length, index3 = fromRight ? length3 : -1, iterable = Object(collection);
    while (fromRight ? index3-- : ++index3 < length3) {
      if (iteratee(iterable[index3], index3, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$1;
var baseForOwn$1 = _baseForOwn, createBaseEach = _createBaseEach;
var baseEach$3 = createBaseEach(baseForOwn$1);
var _baseEach = baseEach$3;
var baseEach$2 = _baseEach, isArrayLike$2 = isArrayLike_1;
function baseMap$2(collection, iteratee) {
  var index3 = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];
  baseEach$2(collection, function(value, key, collection2) {
    result[++index3] = iteratee(value, key, collection2);
  });
  return result;
}
var _baseMap = baseMap$2;
function baseSortBy$1(array3, comparer) {
  var length3 = array3.length;
  array3.sort(comparer);
  while (length3--) {
    array3[length3] = array3[length3].value;
  }
  return array3;
}
var _baseSortBy = baseSortBy$1;
var isSymbol$2 = isSymbol_1;
function compareAscending$1(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol$2(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol$2(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var _compareAscending = compareAscending$1;
var compareAscending = _compareAscending;
function compareMultiple$1(object2, other, orders) {
  var index3 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length3 = objCriteria.length, ordersLength = orders.length;
  while (++index3 < length3) {
    var result = compareAscending(objCriteria[index3], othCriteria[index3]);
    if (result) {
      if (index3 >= ordersLength) {
        return result;
      }
      var order = orders[index3];
      return result * (order == "desc" ? -1 : 1);
    }
  }
  return object2.index - other.index;
}
var _compareMultiple = compareMultiple$1;
var arrayMap$1 = _arrayMap, baseGet = _baseGet, baseIteratee$6 = _baseIteratee, baseMap$1 = _baseMap, baseSortBy = _baseSortBy, baseUnary = _baseUnary, compareMultiple = _compareMultiple, identity$8 = identity_1, isArray$3 = isArray_1;
function baseOrderBy$1(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap$1(iteratees, function(iteratee) {
      if (isArray$3(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity$8];
  }
  var index3 = -1;
  iteratees = arrayMap$1(iteratees, baseUnary(baseIteratee$6));
  var result = baseMap$1(collection, function(value, key, collection2) {
    var criteria = arrayMap$1(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { "criteria": criteria, "index": ++index3, "value": value };
  });
  return baseSortBy(result, function(object2, other) {
    return compareMultiple(object2, other, orders);
  });
}
var _baseOrderBy = baseOrderBy$1;
function apply$1(func3, thisArg, args) {
  switch (args.length) {
    case 0:
      return func3.call(thisArg);
    case 1:
      return func3.call(thisArg, args[0]);
    case 2:
      return func3.call(thisArg, args[0], args[1]);
    case 3:
      return func3.call(thisArg, args[0], args[1], args[2]);
  }
  return func3.apply(thisArg, args);
}
var _apply = apply$1;
var apply2 = _apply;
var nativeMax$3 = Math.max;
function overRest$1(func3, start, transform) {
  start = nativeMax$3(start === void 0 ? func3.length - 1 : start, 0);
  return function() {
    var args = arguments, index3 = -1, length3 = nativeMax$3(args.length - start, 0), array3 = Array(length3);
    while (++index3 < length3) {
      array3[index3] = args[start + index3];
    }
    index3 = -1;
    var otherArgs = Array(start + 1);
    while (++index3 < start) {
      otherArgs[index3] = args[index3];
    }
    otherArgs[start] = transform(array3);
    return apply2(func3, this, otherArgs);
  };
}
var _overRest = overRest$1;
function constant$2(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$2;
var getNative = _getNative;
var defineProperty$2 = function() {
  try {
    var func3 = getNative(Object, "defineProperty");
    func3({}, "", {});
    return func3;
  } catch (e3) {
  }
}();
var _defineProperty$m = defineProperty$2;
var constant$1 = constant_1, defineProperty$1 = _defineProperty$m, identity$7 = identity_1;
var baseSetToString$1 = !defineProperty$1 ? identity$7 : function(func3, string4) {
  return defineProperty$1(func3, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant$1(string4),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func3) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func3.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;
var identity$6 = identity_1, overRest = _overRest, setToString = _setToString;
function baseRest$1(func3, start) {
  return setToString(overRest(func3, start, identity$6), func3 + "");
}
var _baseRest = baseRest$1;
var eq = eq_1, isArrayLike$1 = isArrayLike_1, isIndex = _isIndex, isObject$3 = isObject_1;
function isIterateeCall$4(value, index3, object2) {
  if (!isObject$3(object2)) {
    return false;
  }
  var type3 = typeof index3;
  if (type3 == "number" ? isArrayLike$1(object2) && isIndex(index3, object2.length) : type3 == "string" && index3 in object2) {
    return eq(object2[index3], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$4;
var baseFlatten$1 = _baseFlatten, baseOrderBy = _baseOrderBy, baseRest = _baseRest, isIterateeCall$3 = _isIterateeCall;
var sortBy2 = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length3 = iteratees.length;
  if (length3 > 1 && isIterateeCall$3(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length3 > 2 && isIterateeCall$3(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten$1(iteratees, 1), []);
});
var sortBy_1 = sortBy2;
const _sortBy = /* @__PURE__ */ getDefaultExportFromCjs(sortBy_1);
function _typeof$m(obj) {
  "@babel/helpers - typeof";
  return _typeof$m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$m(obj);
}
function _slicedToArray$7(arr, i) {
  return _arrayWithHoles$7(arr) || _iterableToArrayLimit$7(arr, i) || _unsupportedIterableToArray$d(arr, i) || _nonIterableRest$7();
}
function _nonIterableRest$7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$d(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$d(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$d(o3, minLen);
}
function _arrayLikeToArray$d(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$7(arr, i) {
  var _i2 = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i2) {
    var _s2, _e2, _x, _r, _arr = [], _n2 = true, _d = false;
    try {
      if (_x = (_i2 = _i2.call(arr)).next, 0 === i) {
        if (Object(_i2) !== _i2)
          return;
        _n2 = false;
      } else
        for (; !(_n2 = (_s2 = _x.call(_i2)).done) && (_arr.push(_s2.value), _arr.length !== i); _n2 = true)
          ;
    } catch (err) {
      _d = true, _e2 = err;
    } finally {
      try {
        if (!_n2 && null != _i2["return"] && (_r = _i2["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$7(arr) {
  if (Array.isArray(arr))
    return arr;
}
function ownKeys$i(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$i(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$i(Object(source), true).forEach(function(key) {
      _defineProperty$l(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$i(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$a(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$m(descriptor.key), descriptor);
  }
}
function _createClass$a(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$a(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$a(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o3, p2) {
  _setPrototypeOf$8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$8(o3, p2);
}
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$8(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$8(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$8(this, result);
  };
}
function _possibleConstructorReturn$8(self2, call3) {
  if (call3 && (_typeof$m(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$8(self2);
}
function _assertThisInitialized$8(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$8(o3) {
  _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$8(o3);
}
function _defineProperty$l(obj, key, value) {
  key = _toPropertyKey$m(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$m(arg) {
  var key = _toPrimitive$m(arg, "string");
  return _typeof$m(key) === "symbol" ? key : String(key);
}
function _toPrimitive$m(input, hint) {
  if (_typeof$m(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$m(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function defaultFormatter(value) {
  return _isArray2(value) && isNumOrStr(value[0]) && isNumOrStr(value[1]) ? value.join(" ~ ") : value;
}
var DefaultTooltipContent = /* @__PURE__ */ function(_PureComponent) {
  _inherits$8(DefaultTooltipContent2, _PureComponent);
  var _super = _createSuper$8(DefaultTooltipContent2);
  function DefaultTooltipContent2() {
    _classCallCheck$a(this, DefaultTooltipContent2);
    return _super.apply(this, arguments);
  }
  _createClass$a(DefaultTooltipContent2, [{
    key: "renderContent",
    value: function renderContent2() {
      var _this$props = this.props, payload = _this$props.payload, separator = _this$props.separator, formatter = _this$props.formatter, itemStyle = _this$props.itemStyle, itemSorter = _this$props.itemSorter;
      if (payload && payload.length) {
        var listStyle = {
          padding: 0,
          margin: 0
        };
        var items = (itemSorter ? _sortBy(payload, itemSorter) : payload).map(function(entry, i) {
          if (entry.type === "none") {
            return null;
          }
          var finalItemStyle = _objectSpread$i({
            display: "block",
            paddingTop: 4,
            paddingBottom: 4,
            color: entry.color || "#000"
          }, itemStyle);
          var finalFormatter = entry.formatter || formatter || defaultFormatter;
          var value = entry.value, name = entry.name;
          if (finalFormatter && value != null && name != null) {
            var formatted = finalFormatter(value, name, entry, i, payload);
            if (Array.isArray(formatted)) {
              var _ref = formatted;
              var _ref2 = _slicedToArray$7(_ref, 2);
              value = _ref2[0];
              name = _ref2[1];
            } else {
              value = formatted;
            }
          }
          return (
            // eslint-disable-next-line react/no-array-index-key
            /* @__PURE__ */ React.createElement("li", {
              className: "recharts-tooltip-item",
              key: "tooltip-item-".concat(i),
              style: finalItemStyle
            }, isNumOrStr(name) ? /* @__PURE__ */ React.createElement("span", {
              className: "recharts-tooltip-item-name"
            }, name) : null, isNumOrStr(name) ? /* @__PURE__ */ React.createElement("span", {
              className: "recharts-tooltip-item-separator"
            }, separator) : null, /* @__PURE__ */ React.createElement("span", {
              className: "recharts-tooltip-item-value"
            }, value), /* @__PURE__ */ React.createElement("span", {
              className: "recharts-tooltip-item-unit"
            }, entry.unit || ""))
          );
        });
        return /* @__PURE__ */ React.createElement("ul", {
          className: "recharts-tooltip-item-list",
          style: listStyle
        }, items);
      }
      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props, wrapperClassName = _this$props2.wrapperClassName, contentStyle = _this$props2.contentStyle, labelClassName = _this$props2.labelClassName, labelStyle = _this$props2.labelStyle, label = _this$props2.label, labelFormatter = _this$props2.labelFormatter, payload = _this$props2.payload;
      var finalStyle = _objectSpread$i({
        margin: 0,
        padding: 10,
        backgroundColor: "#fff",
        border: "1px solid #ccc",
        whiteSpace: "nowrap"
      }, contentStyle);
      var finalLabelStyle = _objectSpread$i({
        margin: 0
      }, labelStyle);
      var hasLabel = !_isNil(label);
      var finalLabel = hasLabel ? label : "";
      var wrapperCN = classNames("recharts-default-tooltip", wrapperClassName);
      var labelCN = classNames("recharts-tooltip-label", labelClassName);
      if (hasLabel && labelFormatter && payload !== void 0 && payload !== null) {
        finalLabel = labelFormatter(label, payload);
      }
      return /* @__PURE__ */ React.createElement("div", {
        className: wrapperCN,
        style: finalStyle
      }, /* @__PURE__ */ React.createElement("p", {
        className: labelCN,
        style: finalLabelStyle
      }, /* @__PURE__ */ React.isValidElement(finalLabel) ? finalLabel : "".concat(finalLabel)), this.renderContent());
    }
  }]);
  return DefaultTooltipContent2;
}(reactExports.PureComponent);
_defineProperty$l(DefaultTooltipContent, "displayName", "DefaultTooltipContent");
_defineProperty$l(DefaultTooltipContent, "defaultProps", {
  separator: " : ",
  contentStyle: {},
  itemStyle: {},
  labelStyle: {}
});
var parseIsSsrByDefault = function parseIsSsrByDefault2() {
  return !(typeof window !== "undefined" && window.document && window.document.createElement && window.setTimeout);
};
var Global = {
  isSsr: parseIsSsrByDefault(),
  get: function get2(key) {
    return Global[key];
  },
  set: function set3(key, value) {
    if (typeof key === "string") {
      Global[key] = value;
    } else {
      var keys4 = Object.keys(key);
      if (keys4 && keys4.length) {
        keys4.forEach(function(k2) {
          Global[k2] = key[k2];
        });
      }
    }
  }
};
function _typeof$l(obj) {
  "@babel/helpers - typeof";
  return _typeof$l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$l(obj);
}
function ownKeys$h(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$h(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$h(Object(source), true).forEach(function(key) {
      _defineProperty$k(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$h(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$k(obj, key, value) {
  key = _toPropertyKey$l(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$l(arg) {
  var key = _toPrimitive$l(arg, "string");
  return _typeof$l(key) === "symbol" ? key : String(key);
}
function _toPrimitive$l(input, hint) {
  if (_typeof$l(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$l(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _slicedToArray$6(arr, i) {
  return _arrayWithHoles$6(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$c(arr, i) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$c(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$c(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$c(o3, minLen);
}
function _arrayLikeToArray$c(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$6(arr, i) {
  var _i2 = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i2) {
    var _s2, _e2, _x, _r, _arr = [], _n2 = true, _d = false;
    try {
      if (_x = (_i2 = _i2.call(arr)).next, 0 === i) {
        if (Object(_i2) !== _i2)
          return;
        _n2 = false;
      } else
        for (; !(_n2 = (_s2 = _x.call(_i2)).done) && (_arr.push(_s2.value), _arr.length !== i); _n2 = true)
          ;
    } catch (err) {
      _d = true, _e2 = err;
    } finally {
      try {
        if (!_n2 && null != _i2["return"] && (_r = _i2["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$6(arr) {
  if (Array.isArray(arr))
    return arr;
}
var CLS_PREFIX = "recharts-tooltip-wrapper";
var EPS$1 = 1;
function defaultUniqBy(entry) {
  return entry.dataKey;
}
function getUniqPayload(option, payload) {
  if (option === true) {
    return _uniqBy(payload, defaultUniqBy);
  }
  if (_isFunction(option)) {
    return _uniqBy(payload, option);
  }
  return payload;
}
function renderContent(content, props3) {
  if (/* @__PURE__ */ React.isValidElement(content)) {
    return /* @__PURE__ */ React.cloneElement(content, props3);
  }
  if (_isFunction(content)) {
    return /* @__PURE__ */ React.createElement(content, props3);
  }
  return /* @__PURE__ */ React.createElement(DefaultTooltipContent, props3);
}
var tooltipDefaultProps = {
  active: false,
  allowEscapeViewBox: {
    x: false,
    y: false
  },
  reverseDirection: {
    x: false,
    y: false
  },
  offset: 10,
  viewBox: {
    x: 0,
    y: 0,
    height: 0,
    width: 0
  },
  coordinate: {
    x: 0,
    y: 0
  },
  // this doesn't exist on TooltipProps
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  cursorStyle: {},
  separator: " : ",
  wrapperStyle: {},
  contentStyle: {},
  itemStyle: {},
  labelStyle: {},
  cursor: true,
  trigger: "hover",
  isAnimationActive: !Global.isSsr,
  animationEasing: "ease",
  animationDuration: 400,
  filterNull: true,
  useTranslate3d: false
};
var Tooltip = function Tooltip2(props3) {
  var _classNames;
  var _useState = reactExports.useState(-1), _useState2 = _slicedToArray$6(_useState, 2), boxWidth = _useState2[0], setBoxWidth = _useState2[1];
  var _useState3 = reactExports.useState(-1), _useState4 = _slicedToArray$6(_useState3, 2), boxHeight = _useState4[0], setBoxHeight = _useState4[1];
  var _useState5 = reactExports.useState(false), _useState6 = _slicedToArray$6(_useState5, 2), dismissed = _useState6[0], setDismissed = _useState6[1];
  var _useState7 = reactExports.useState({
    x: 0,
    y: 0
  }), _useState8 = _slicedToArray$6(_useState7, 2), dismissedAtCoordinate = _useState8[0], setDismissedAtCoordinate = _useState8[1];
  var wrapperNode = reactExports.useRef();
  var allowEscapeViewBox = props3.allowEscapeViewBox, reverseDirection = props3.reverseDirection, coordinate = props3.coordinate, offset2 = props3.offset, position = props3.position, viewBox = props3.viewBox;
  var handleKeyDown = reactExports.useCallback(function(event) {
    if (event.key === "Escape") {
      setDismissed(true);
      setDismissedAtCoordinate(function(prev) {
        return _objectSpread$h(_objectSpread$h({}, prev), {}, {
          x: coordinate === null || coordinate === void 0 ? void 0 : coordinate.x,
          y: coordinate === null || coordinate === void 0 ? void 0 : coordinate.y
        });
      });
    }
  }, [coordinate === null || coordinate === void 0 ? void 0 : coordinate.x, coordinate === null || coordinate === void 0 ? void 0 : coordinate.y]);
  reactExports.useEffect(function() {
    var updateBBox = function updateBBox2() {
      if (dismissed) {
        document.removeEventListener("keydown", handleKeyDown);
        if ((coordinate === null || coordinate === void 0 ? void 0 : coordinate.x) !== dismissedAtCoordinate.x || (coordinate === null || coordinate === void 0 ? void 0 : coordinate.y) !== dismissedAtCoordinate.y) {
          setDismissed(false);
        }
      } else {
        document.addEventListener("keydown", handleKeyDown);
      }
      if (wrapperNode.current && wrapperNode.current.getBoundingClientRect) {
        var box = wrapperNode.current.getBoundingClientRect();
        if (Math.abs(box.width - boxWidth) > EPS$1 || Math.abs(box.height - boxHeight) > EPS$1) {
          setBoxWidth(box.width);
          setBoxHeight(box.height);
        }
      } else if (boxWidth !== -1 || boxHeight !== -1) {
        setBoxWidth(-1);
        setBoxHeight(-1);
      }
    };
    updateBBox();
    return function() {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [boxHeight, boxWidth, coordinate, dismissed, dismissedAtCoordinate.x, dismissedAtCoordinate.y, handleKeyDown]);
  var getTranslate2 = function getTranslate3(_ref) {
    var key = _ref.key, tooltipDimension = _ref.tooltipDimension, viewBoxDimension = _ref.viewBoxDimension;
    if (position && isNumber(position[key])) {
      return position[key];
    }
    var negative = coordinate[key] - tooltipDimension - offset2;
    var positive = coordinate[key] + offset2;
    if (allowEscapeViewBox !== null && allowEscapeViewBox !== void 0 && allowEscapeViewBox[key]) {
      return reverseDirection[key] ? negative : positive;
    }
    if (reverseDirection !== null && reverseDirection !== void 0 && reverseDirection[key]) {
      var _tooltipBoundary = negative;
      var _viewBoxBoundary = viewBox[key];
      if (_tooltipBoundary < _viewBoxBoundary) {
        return Math.max(positive, viewBox[key]);
      }
      return Math.max(negative, viewBox[key]);
    }
    var tooltipBoundary = positive + tooltipDimension;
    var viewBoxBoundary = viewBox[key] + viewBoxDimension;
    if (tooltipBoundary > viewBoxBoundary) {
      return Math.max(negative, viewBox[key]);
    }
    return Math.max(positive, viewBox[key]);
  };
  var payload = props3.payload, payloadUniqBy = props3.payloadUniqBy, filterNull = props3.filterNull, active = props3.active, wrapperStyle = props3.wrapperStyle, useTranslate3d = props3.useTranslate3d, isAnimationActive = props3.isAnimationActive, animationDuration = props3.animationDuration, animationEasing = props3.animationEasing;
  var finalPayload = getUniqPayload(payloadUniqBy, filterNull && payload && payload.length ? payload.filter(function(entry) {
    return !_isNil(entry.value);
  }) : payload);
  var hasPayload = finalPayload && finalPayload.length;
  var content = props3.content;
  var outerStyle = _objectSpread$h({
    pointerEvents: "none",
    visibility: !dismissed && active && hasPayload ? "visible" : "hidden",
    position: "absolute",
    top: 0,
    left: 0
  }, wrapperStyle);
  var translateX, translateY;
  if (position && isNumber(position.x) && isNumber(position.y)) {
    translateX = position.x;
    translateY = position.y;
  } else if (boxWidth > 0 && boxHeight > 0 && coordinate) {
    translateX = getTranslate2({
      key: "x",
      tooltipDimension: boxWidth,
      viewBoxDimension: viewBox.width
    });
    translateY = getTranslate2({
      key: "y",
      tooltipDimension: boxHeight,
      viewBoxDimension: viewBox.height
    });
  } else {
    outerStyle.visibility = "hidden";
  }
  outerStyle = _objectSpread$h(_objectSpread$h({}, translateStyle({
    transform: useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)")
  })), outerStyle);
  if (isAnimationActive && active) {
    outerStyle = _objectSpread$h(_objectSpread$h({}, translateStyle({
      transition: "transform ".concat(animationDuration, "ms ").concat(animationEasing)
    })), outerStyle);
  }
  var cls = classNames(CLS_PREFIX, (_classNames = {}, _defineProperty$k(_classNames, "".concat(CLS_PREFIX, "-right"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX >= coordinate.x), _defineProperty$k(_classNames, "".concat(CLS_PREFIX, "-left"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX < coordinate.x), _defineProperty$k(_classNames, "".concat(CLS_PREFIX, "-bottom"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY >= coordinate.y), _defineProperty$k(_classNames, "".concat(CLS_PREFIX, "-top"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY < coordinate.y), _classNames));
  return (
    // ESLint is disabled to allow listening to the `Escape` key. Refer to
    // https://github.com/recharts/recharts/pull/2925
    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
    /* @__PURE__ */ React.createElement("div", {
      tabIndex: -1,
      role: "dialog",
      className: cls,
      style: outerStyle,
      ref: wrapperNode
    }, renderContent(content, _objectSpread$h(_objectSpread$h({}, props3), {}, {
      payload: finalPayload
    })))
  );
};
Tooltip.displayName = "Tooltip";
Tooltip.defaultProps = tooltipDefaultProps;
var root = _root;
var now$1 = function() {
  return root.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string4) {
  var index3 = string4.length;
  while (index3-- && reWhitespace.test(string4.charAt(index3))) {
  }
  return index3;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string4) {
  return string4 ? string4.slice(0, trimmedEndIndex(string4) + 1).replace(reTrimStart, "") : string4;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim, isObject$2 = isObject_1, isSymbol$1 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$2(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$2(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$2;
var isObject$1 = isObject_1, now = now_1, toNumber$1 = toNumber_1;
var FUNC_ERROR_TEXT$1 = "Expected a function";
var nativeMax$2 = Math.max, nativeMin = Math.min;
function debounce$1(func3, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func3 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$2(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result = func3.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result;
  }
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time2 = now();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel2() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush2() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time2 = now(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel2;
  debounced.flush = flush2;
  return debounced;
}
var debounce_1 = debounce$1;
const debounce$2 = /* @__PURE__ */ getDefaultExportFromCjs(debounce_1);
var debounce = debounce_1, isObject = isObject_1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func3, wait, options) {
  var leading = true, trailing = true;
  if (typeof func3 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func3, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle;
const _throttle = /* @__PURE__ */ getDefaultExportFromCjs(throttle_1);
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __2() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__2.prototype = b2.prototype, new __2());
}
function __rest(s2, e3) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
var patchResizeHandler = function(resizeCallback, refreshMode, refreshRate, refreshOptions) {
  switch (refreshMode) {
    case "debounce":
      return debounce$2(resizeCallback, refreshRate, refreshOptions);
    case "throttle":
      return _throttle(resizeCallback, refreshRate, refreshOptions);
    default:
      return resizeCallback;
  }
};
var isFunction = function(fn2) {
  return typeof fn2 === "function";
};
var isSSR = function() {
  return typeof window === "undefined";
};
var isDOMElement = function(element) {
  return element instanceof Element || element instanceof HTMLDocument;
};
var createNotifier = function(setSize, handleWidth, handleHeight) {
  return function(_a2) {
    var width = _a2.width, height = _a2.height;
    setSize(function(prev) {
      if (prev.width === width && prev.height === height) {
        return prev;
      }
      if (prev.width === width && !handleHeight || prev.height === height && !handleWidth) {
        return prev;
      }
      return { width, height };
    });
  };
};
var ResizeDetector = (
  /** @class */
  function(_super) {
    __extends(ResizeDetector2, _super);
    function ResizeDetector2(props3) {
      var _this = _super.call(this, props3) || this;
      _this.cancelHandler = function() {
        if (_this.resizeHandler && _this.resizeHandler.cancel) {
          _this.resizeHandler.cancel();
          _this.resizeHandler = null;
        }
      };
      _this.attachObserver = function() {
        var _a3 = _this.props, targetRef = _a3.targetRef, observerOptions = _a3.observerOptions;
        if (isSSR()) {
          return;
        }
        if (targetRef && targetRef.current) {
          _this.targetRef.current = targetRef.current;
        }
        var element = _this.getElement();
        if (!element) {
          return;
        }
        if (_this.observableElement && _this.observableElement === element) {
          return;
        }
        _this.observableElement = element;
        _this.resizeObserver.observe(element, observerOptions);
      };
      _this.getElement = function() {
        var _a3 = _this.props, querySelector = _a3.querySelector, targetDomEl = _a3.targetDomEl;
        if (isSSR())
          return null;
        if (querySelector)
          return document.querySelector(querySelector);
        if (targetDomEl && isDOMElement(targetDomEl))
          return targetDomEl;
        if (_this.targetRef && isDOMElement(_this.targetRef.current))
          return _this.targetRef.current;
        var currentElement = reactDomExports.findDOMNode(_this);
        if (!currentElement)
          return null;
        var renderType = _this.getRenderType();
        switch (renderType) {
          case "renderProp":
            return currentElement;
          case "childFunction":
            return currentElement;
          case "child":
            return currentElement;
          case "childArray":
            return currentElement;
          default:
            return currentElement.parentElement;
        }
      };
      _this.createResizeHandler = function(entries) {
        var _a3 = _this.props, _b = _a3.handleWidth, handleWidth = _b === void 0 ? true : _b, _c = _a3.handleHeight, handleHeight = _c === void 0 ? true : _c, onResize2 = _a3.onResize;
        if (!handleWidth && !handleHeight)
          return;
        var notifyResize = createNotifier(function(setStateFunc) {
          return _this.setState(setStateFunc, function() {
            return onResize2 === null || onResize2 === void 0 ? void 0 : onResize2(_this.state.width, _this.state.height);
          });
        }, handleWidth, handleHeight);
        entries.forEach(function(entry) {
          var _a4 = entry && entry.contentRect || {}, width = _a4.width, height = _a4.height;
          var shouldSetSize = !_this.skipOnMount && !isSSR();
          if (shouldSetSize) {
            notifyResize({ width, height });
          }
          _this.skipOnMount = false;
        });
      };
      _this.getRenderType = function() {
        var _a3 = _this.props, render = _a3.render, children = _a3.children;
        if (isFunction(render)) {
          return "renderProp";
        }
        if (isFunction(children)) {
          return "childFunction";
        }
        if (reactExports.isValidElement(children)) {
          return "child";
        }
        if (Array.isArray(children)) {
          return "childArray";
        }
        return "parent";
      };
      var skipOnMount = props3.skipOnMount, refreshMode = props3.refreshMode, _a2 = props3.refreshRate, refreshRate = _a2 === void 0 ? 1e3 : _a2, refreshOptions = props3.refreshOptions;
      _this.state = {
        width: void 0,
        height: void 0
      };
      _this.skipOnMount = skipOnMount;
      _this.targetRef = reactExports.createRef();
      _this.observableElement = null;
      if (isSSR()) {
        return _this;
      }
      _this.resizeHandler = patchResizeHandler(_this.createResizeHandler, refreshMode, refreshRate, refreshOptions);
      _this.resizeObserver = new window.ResizeObserver(_this.resizeHandler);
      return _this;
    }
    ResizeDetector2.prototype.componentDidMount = function() {
      this.attachObserver();
    };
    ResizeDetector2.prototype.componentDidUpdate = function() {
      this.attachObserver();
    };
    ResizeDetector2.prototype.componentWillUnmount = function() {
      if (isSSR()) {
        return;
      }
      this.observableElement = null;
      this.resizeObserver.disconnect();
      this.cancelHandler();
    };
    ResizeDetector2.prototype.render = function() {
      var _a2 = this.props, render = _a2.render, children = _a2.children, _b = _a2.nodeType, WrapperTag = _b === void 0 ? "div" : _b;
      var _c = this.state, width = _c.width, height = _c.height;
      var childProps = { width, height, targetRef: this.targetRef };
      var renderType = this.getRenderType();
      switch (renderType) {
        case "renderProp":
          return render === null || render === void 0 ? void 0 : render(childProps);
        case "childFunction": {
          var childFunction = children;
          return childFunction === null || childFunction === void 0 ? void 0 : childFunction(childProps);
        }
        case "child": {
          var child = children;
          if (child.type && typeof child.type === "string") {
            childProps.targetRef;
            var nativeProps = __rest(childProps, ["targetRef"]);
            return reactExports.cloneElement(child, nativeProps);
          }
          return reactExports.cloneElement(child, childProps);
        }
        case "childArray": {
          var childArray = children;
          return childArray.map(function(el2) {
            return !!el2 && reactExports.cloneElement(el2, childProps);
          });
        }
        default:
          return React.createElement(WrapperTag, null);
      }
    };
    return ResizeDetector2;
  }(reactExports.PureComponent)
);
var warn = function warn2(condition, format2) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
};
function _extends$h() {
  _extends$h = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$h.apply(this, arguments);
}
function _slicedToArray$5(arr, i) {
  return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$b(arr, i) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$b(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$b(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$b(o3, minLen);
}
function _arrayLikeToArray$b(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$5(arr, i) {
  var _i2 = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i2) {
    var _s2, _e2, _x, _r, _arr = [], _n2 = true, _d = false;
    try {
      if (_x = (_i2 = _i2.call(arr)).next, 0 === i) {
        if (Object(_i2) !== _i2)
          return;
        _n2 = false;
      } else
        for (; !(_n2 = (_s2 = _x.call(_i2)).done) && (_arr.push(_s2.value), _arr.length !== i); _n2 = true)
          ;
    } catch (err) {
      _d = true, _e2 = err;
    } finally {
      try {
        if (!_n2 && null != _i2["return"] && (_r = _i2["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$5(arr) {
  if (Array.isArray(arr))
    return arr;
}
var ResponsiveContainer = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref) {
  var aspect = _ref.aspect, _ref$width = _ref.width, width = _ref$width === void 0 ? "100%" : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? "100%" : _ref$height, _ref$minWidth = _ref.minWidth, minWidth = _ref$minWidth === void 0 ? 0 : _ref$minWidth, minHeight = _ref.minHeight, maxHeight = _ref.maxHeight, children = _ref.children, _ref$debounce = _ref.debounce, debounce2 = _ref$debounce === void 0 ? 0 : _ref$debounce, id2 = _ref.id, className = _ref.className, onResize2 = _ref.onResize;
  var _useState = reactExports.useState({
    containerWidth: -1,
    containerHeight: -1
  }), _useState2 = _slicedToArray$5(_useState, 2), sizes = _useState2[0], setSizes = _useState2[1];
  var containerRef = reactExports.useRef(null);
  reactExports.useImperativeHandle(ref, function() {
    return containerRef;
  }, [containerRef]);
  var getContainerSize = reactExports.useCallback(function() {
    if (!containerRef.current) {
      return null;
    }
    return {
      containerWidth: containerRef.current.clientWidth,
      containerHeight: containerRef.current.clientHeight
    };
  }, []);
  var updateDimensionsImmediate = reactExports.useCallback(function() {
    var newSize = getContainerSize();
    if (newSize) {
      var containerWidth = newSize.containerWidth, containerHeight = newSize.containerHeight;
      if (onResize2)
        onResize2(containerWidth, containerHeight);
      setSizes(function(currentSizes) {
        var oldWidth = currentSizes.containerWidth, oldHeight = currentSizes.containerHeight;
        if (containerWidth !== oldWidth || containerHeight !== oldHeight) {
          return {
            containerWidth,
            containerHeight
          };
        }
        return currentSizes;
      });
    }
  }, [getContainerSize, onResize2]);
  var chartContent = reactExports.useMemo(function() {
    var containerWidth = sizes.containerWidth, containerHeight = sizes.containerHeight;
    if (containerWidth < 0 || containerHeight < 0) {
      return null;
    }
    warn(isPercent(width) || isPercent(height), "The width(%s) and height(%s) are both fixed numbers,\n       maybe you don't need to use a ResponsiveContainer.", width, height);
    warn(!aspect || aspect > 0, "The aspect(%s) must be greater than zero.", aspect);
    var calculatedWidth = isPercent(width) ? containerWidth : width;
    var calculatedHeight = isPercent(height) ? containerHeight : height;
    if (aspect && aspect > 0) {
      if (calculatedWidth) {
        calculatedHeight = calculatedWidth / aspect;
      } else if (calculatedHeight) {
        calculatedWidth = calculatedHeight * aspect;
      }
      if (maxHeight && calculatedHeight > maxHeight) {
        calculatedHeight = maxHeight;
      }
    }
    warn(calculatedWidth > 0 || calculatedHeight > 0, "The width(%s) and height(%s) of chart should be greater than 0,\n       please check the style of container, or the props width(%s) and height(%s),\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\n       height and width.", calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect);
    return /* @__PURE__ */ reactExports.cloneElement(children, {
      width: calculatedWidth,
      height: calculatedHeight
    });
  }, [aspect, children, height, maxHeight, minHeight, minWidth, sizes, width]);
  reactExports.useEffect(function() {
    var size = getContainerSize();
    if (size) {
      setSizes(size);
    }
  }, [getContainerSize]);
  var style = {
    width,
    height,
    minWidth,
    minHeight,
    maxHeight
  };
  return /* @__PURE__ */ React.createElement(ResizeDetector, {
    handleWidth: true,
    handleHeight: true,
    onResize: updateDimensionsImmediate,
    targetRef: containerRef,
    refreshMode: debounce2 > 0 ? "debounce" : void 0,
    refreshRate: debounce2
  }, /* @__PURE__ */ React.createElement("div", _extends$h({}, id2 != null ? {
    id: "".concat(id2)
  } : {}, {
    className: classNames("recharts-responsive-container", className),
    style,
    ref: containerRef
  }), chartContent));
});
var Cell = function Cell2(_props) {
  return null;
};
Cell.displayName = "Cell";
var dist$1 = { exports: {} };
var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);
var parse$1 = function(input) {
  var tokens2 = [];
  var value = input;
  var next, quote, prev, token2, escape2, escapePos, whitespacePos;
  var pos = 0;
  var code2 = value.charCodeAt(pos);
  var max3 = value.length;
  var stack = [{ nodes: tokens2 }];
  var balanced = 0;
  var parent;
  var name = "";
  var before = "";
  var after = "";
  while (pos < max3) {
    if (code2 <= 32) {
      next = pos;
      do {
        next += 1;
        code2 = value.charCodeAt(next);
      } while (code2 <= 32);
      token2 = value.slice(pos, next);
      prev = tokens2[tokens2.length - 1];
      if (code2 === closeParentheses && balanced) {
        after = token2;
      } else if (prev && prev.type === "div") {
        prev.after = token2;
      } else if (code2 === comma || code2 === colon || code2 === slash && value.charCodeAt(next + 1) !== star) {
        before = token2;
      } else {
        tokens2.push({
          type: "space",
          sourceIndex: pos,
          value: token2
        });
      }
      pos = next;
    } else if (code2 === singleQuote || code2 === doubleQuote) {
      next = pos;
      quote = code2 === singleQuote ? "'" : '"';
      token2 = {
        type: "string",
        sourceIndex: pos,
        quote
      };
      do {
        escape2 = false;
        next = value.indexOf(quote, next + 1);
        if (~next) {
          escapePos = next;
          while (value.charCodeAt(escapePos - 1) === backslash) {
            escapePos -= 1;
            escape2 = !escape2;
          }
        } else {
          value += quote;
          next = value.length - 1;
          token2.unclosed = true;
        }
      } while (escape2);
      token2.value = value.slice(pos + 1, next);
      tokens2.push(token2);
      pos = next + 1;
      code2 = value.charCodeAt(pos);
    } else if (code2 === slash && value.charCodeAt(pos + 1) === star) {
      token2 = {
        type: "comment",
        sourceIndex: pos
      };
      next = value.indexOf("*/", pos);
      if (next === -1) {
        token2.unclosed = true;
        next = value.length;
      }
      token2.value = value.slice(pos + 2, next);
      tokens2.push(token2);
      pos = next + 2;
      code2 = value.charCodeAt(pos);
    } else if (code2 === slash || code2 === comma || code2 === colon) {
      token2 = value[pos];
      tokens2.push({
        type: "div",
        sourceIndex: pos - before.length,
        value: token2,
        before,
        after: ""
      });
      before = "";
      pos += 1;
      code2 = value.charCodeAt(pos);
    } else if (openParentheses === code2) {
      next = pos;
      do {
        next += 1;
        code2 = value.charCodeAt(next);
      } while (code2 <= 32);
      token2 = {
        type: "function",
        sourceIndex: pos - name.length,
        value: name,
        before: value.slice(pos + 1, next)
      };
      pos = next;
      if (name === "url" && code2 !== singleQuote && code2 !== doubleQuote) {
        next -= 1;
        do {
          escape2 = false;
          next = value.indexOf(")", next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape2 = !escape2;
            }
          } else {
            value += ")";
            next = value.length - 1;
            token2.unclosed = true;
          }
        } while (escape2);
        whitespacePos = next;
        do {
          whitespacePos -= 1;
          code2 = value.charCodeAt(whitespacePos);
        } while (code2 <= 32);
        if (pos !== whitespacePos + 1) {
          token2.nodes = [
            {
              type: "word",
              sourceIndex: pos,
              value: value.slice(pos, whitespacePos + 1)
            }
          ];
        } else {
          token2.nodes = [];
        }
        if (token2.unclosed && whitespacePos + 1 !== next) {
          token2.after = "";
          token2.nodes.push({
            type: "space",
            sourceIndex: whitespacePos + 1,
            value: value.slice(whitespacePos + 1, next)
          });
        } else {
          token2.after = value.slice(whitespacePos + 1, next);
        }
        pos = next + 1;
        code2 = value.charCodeAt(pos);
        tokens2.push(token2);
      } else {
        balanced += 1;
        token2.after = "";
        tokens2.push(token2);
        stack.push(token2);
        tokens2 = token2.nodes = [];
        parent = token2;
      }
      name = "";
    } else if (closeParentheses === code2 && balanced) {
      pos += 1;
      code2 = value.charCodeAt(pos);
      parent.after = after;
      after = "";
      balanced -= 1;
      stack.pop();
      parent = stack[balanced];
      tokens2 = parent.nodes;
    } else {
      next = pos;
      do {
        if (code2 === backslash) {
          next += 1;
        }
        next += 1;
        code2 = value.charCodeAt(next);
      } while (next < max3 && !(code2 <= 32 || code2 === singleQuote || code2 === doubleQuote || code2 === comma || code2 === colon || code2 === slash || code2 === openParentheses || code2 === closeParentheses && balanced));
      token2 = value.slice(pos, next);
      if (openParentheses === code2) {
        name = token2;
      } else {
        tokens2.push({
          type: "word",
          sourceIndex: pos,
          value: token2
        });
      }
      pos = next;
    }
  }
  for (pos = stack.length - 1; pos; pos -= 1) {
    stack[pos].unclosed = true;
  }
  return stack[0].nodes;
};
var walk$1 = function walk(nodes, cb2, bubble2) {
  var i, max3, node, result;
  for (i = 0, max3 = nodes.length; i < max3; i += 1) {
    node = nodes[i];
    if (!bubble2) {
      result = cb2(node, i, nodes);
    }
    if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
      walk(node.nodes, cb2, bubble2);
    }
    if (bubble2) {
      cb2(node, i, nodes);
    }
  }
};
function stringifyNode(node, custom) {
  var type3 = node.type;
  var value = node.value;
  var buf;
  var customResult;
  if (custom && (customResult = custom(node)) !== void 0) {
    return customResult;
  } else if (type3 === "word" || type3 === "space") {
    return value;
  } else if (type3 === "string") {
    buf = node.quote || "";
    return buf + value + (node.unclosed ? "" : buf);
  } else if (type3 === "comment") {
    return "/*" + value + (node.unclosed ? "" : "*/");
  } else if (type3 === "div") {
    return (node.before || "") + value + (node.after || "");
  } else if (Array.isArray(node.nodes)) {
    buf = stringify$1(node.nodes);
    if (type3 !== "function") {
      return buf;
    }
    return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
  }
  return value;
}
function stringify$1(nodes, custom) {
  var result, i;
  if (Array.isArray(nodes)) {
    result = "";
    for (i = nodes.length - 1; ~i; i -= 1) {
      result = stringifyNode(nodes[i], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}
var stringify_1 = stringify$1;
var unit$1;
var hasRequiredUnit;
function requireUnit() {
  if (hasRequiredUnit)
    return unit$1;
  hasRequiredUnit = 1;
  var minus = "-".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var dot = ".".charCodeAt(0);
  var exp2 = "e".charCodeAt(0);
  var EXP = "E".charCodeAt(0);
  unit$1 = function(value) {
    var pos = 0;
    var length3 = value.length;
    var dotted = false;
    var sciPos = -1;
    var containsNumber = false;
    var code2;
    while (pos < length3) {
      code2 = value.charCodeAt(pos);
      if (code2 >= 48 && code2 <= 57) {
        containsNumber = true;
      } else if (code2 === exp2 || code2 === EXP) {
        if (sciPos > -1) {
          break;
        }
        sciPos = pos;
      } else if (code2 === dot) {
        if (dotted) {
          break;
        }
        dotted = true;
      } else if (code2 === plus || code2 === minus) {
        if (pos !== 0) {
          break;
        }
      } else {
        break;
      }
      pos += 1;
    }
    if (sciPos + 1 === pos)
      pos--;
    return containsNumber ? {
      number: value.slice(0, pos),
      unit: value.slice(pos)
    } : false;
  };
  return unit$1;
}
var parse = parse$1;
var walk2 = walk$1;
var stringify = stringify_1;
function ValueParser(value) {
  if (this instanceof ValueParser) {
    this.nodes = parse(value);
    return this;
  }
  return new ValueParser(value);
}
ValueParser.prototype.toString = function() {
  return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};
ValueParser.prototype.walk = function(cb2, bubble2) {
  walk2(this.nodes, cb2, bubble2);
  return this;
};
ValueParser.unit = requireUnit();
ValueParser.walk = walk2;
ValueParser.stringify = stringify;
var lib = ValueParser;
var parser = {};
(function(exports) {
  var parser2 = function() {
    function JisonParserError(msg, hash) {
      Object.defineProperty(this, "name", {
        enumerable: false,
        writable: false,
        value: "JisonParserError"
      });
      if (msg == null)
        msg = "???";
      Object.defineProperty(this, "message", {
        enumerable: false,
        writable: true,
        value: msg
      });
      this.hash = hash;
      var stacktrace;
      if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
      }
      if (!stacktrace) {
        if (Error.hasOwnProperty("captureStackTrace")) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          stacktrace = new Error(msg).stack;
        }
      }
      if (stacktrace) {
        Object.defineProperty(this, "stack", {
          enumerable: false,
          writable: false,
          value: stacktrace
        });
      }
    }
    if (typeof Object.setPrototypeOf === "function") {
      Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
    } else {
      JisonParserError.prototype = Object.create(Error.prototype);
    }
    JisonParserError.prototype.constructor = JisonParserError;
    JisonParserError.prototype.name = "JisonParserError";
    function bp(s3) {
      var rv = [];
      var p2 = s3.pop;
      var r2 = s3.rule;
      for (var i = 0, l2 = p2.length; i < l2; i++) {
        rv.push([
          p2[i],
          r2[i]
        ]);
      }
      return rv;
    }
    function bda(s3) {
      var rv = {};
      var d2 = s3.idx;
      var g2 = s3.goto;
      for (var i = 0, l2 = d2.length; i < l2; i++) {
        var j2 = d2[i];
        rv[j2] = g2[i];
      }
      return rv;
    }
    function bt(s3) {
      var rv = [];
      var d2 = s3.len;
      var y2 = s3.symbol;
      var t2 = s3.type;
      var a2 = s3.state;
      var m2 = s3.mode;
      var g2 = s3.goto;
      for (var i = 0, l2 = d2.length; i < l2; i++) {
        var n2 = d2[i];
        var q2 = {};
        for (var j2 = 0; j2 < n2; j2++) {
          var z2 = y2.shift();
          switch (t2.shift()) {
            case 2:
              q2[z2] = [
                m2.shift(),
                g2.shift()
              ];
              break;
            case 0:
              q2[z2] = a2.shift();
              break;
            default:
              q2[z2] = [
                3
              ];
          }
        }
        rv.push(q2);
      }
      return rv;
    }
    function s2(c3, l2, a2) {
      a2 = a2 || 0;
      for (var i = 0; i < l2; i++) {
        this.push(c3);
        c3 += a2;
      }
    }
    function c2(i, l2) {
      i = this.length - i;
      for (l2 += i; i < l2; i++) {
        this.push(this[i]);
      }
    }
    function u2(a2) {
      var rv = [];
      for (var i = 0, l2 = a2.length; i < l2; i++) {
        var e3 = a2[i];
        if (typeof e3 === "function") {
          i++;
          e3.apply(rv, a2[i]);
        } else {
          rv.push(e3);
        }
      }
      return rv;
    }
    var parser3 = {
      // Code Generator Information Report
      // ---------------------------------
      //
      // Options:
      //
      //   default action mode: ............. ["classic","merge"]
      //   test-compile action mode: ........ "parser:*,lexer:*"
      //   try..catch: ...................... true
      //   default resolve on conflict: ..... true
      //   on-demand look-ahead: ............ false
      //   error recovery token skip maximum: 3
      //   yyerror in parse actions is: ..... NOT recoverable,
      //   yyerror in lexer actions and other non-fatal lexer are:
      //   .................................. NOT recoverable,
      //   debug grammar/output: ............ false
      //   has partial LR conflict upgrade:   true
      //   rudimentary token-stack support:   false
      //   parser table compression mode: ... 2
      //   export debug tables: ............. false
      //   export *all* tables: ............. false
      //   module type: ..................... commonjs
      //   parser engine type: .............. lalr
      //   output main() in the module: ..... true
      //   has user-specified main(): ....... false
      //   has user-specified require()/import modules for main():
      //   .................................. false
      //   number of expected conflicts: .... 0
      //
      //
      // Parser Analysis flags:
      //
      //   no significant actions (parser is a language matcher only):
      //   .................................. false
      //   uses yyleng: ..................... false
      //   uses yylineno: ................... false
      //   uses yytext: ..................... false
      //   uses yylloc: ..................... false
      //   uses ParseError API: ............. false
      //   uses YYERROR: .................... false
      //   uses YYRECOVERING: ............... false
      //   uses YYERROK: .................... false
      //   uses YYCLEARIN: .................. false
      //   tracks rule values: .............. true
      //   assigns rule values: ............. true
      //   uses location tracking: .......... false
      //   assigns location: ................ false
      //   uses yystack: .................... false
      //   uses yysstack: ................... false
      //   uses yysp: ....................... true
      //   uses yyrulelength: ............... false
      //   uses yyMergeLocationInfo API: .... false
      //   has error recovery: .............. false
      //   has error reporting: ............. false
      //
      // --------- END OF REPORT -----------
      trace: function no_op_trace() {
      },
      JisonParserError,
      yy: {},
      options: {
        type: "lalr",
        hasPartialLrUpgradeOnConflict: true,
        errorRecoveryTokenDiscardCount: 3
      },
      symbols_: {
        "$accept": 0,
        "$end": 1,
        "ADD": 3,
        "ANGLE": 16,
        "CHS": 22,
        "COMMA": 14,
        "CSS_CPROP": 13,
        "CSS_VAR": 12,
        "DIV": 6,
        "EMS": 20,
        "EOF": 1,
        "EXS": 21,
        "FREQ": 18,
        "LENGTH": 15,
        "LPAREN": 7,
        "MUL": 5,
        "NESTED_CALC": 9,
        "NUMBER": 11,
        "PERCENTAGE": 28,
        "PREFIX": 10,
        "REMS": 23,
        "RES": 19,
        "RPAREN": 8,
        "SUB": 4,
        "TIME": 17,
        "VHS": 24,
        "VMAXS": 27,
        "VMINS": 26,
        "VWS": 25,
        "css_value": 33,
        "css_variable": 32,
        "error": 2,
        "expression": 29,
        "math_expression": 30,
        "value": 31
      },
      terminals_: {
        1: "EOF",
        2: "error",
        3: "ADD",
        4: "SUB",
        5: "MUL",
        6: "DIV",
        7: "LPAREN",
        8: "RPAREN",
        9: "NESTED_CALC",
        10: "PREFIX",
        11: "NUMBER",
        12: "CSS_VAR",
        13: "CSS_CPROP",
        14: "COMMA",
        15: "LENGTH",
        16: "ANGLE",
        17: "TIME",
        18: "FREQ",
        19: "RES",
        20: "EMS",
        21: "EXS",
        22: "CHS",
        23: "REMS",
        24: "VHS",
        25: "VWS",
        26: "VMINS",
        27: "VMAXS",
        28: "PERCENTAGE"
      },
      TERROR: 2,
      EOF: 1,
      // internals: defined here so the object *structure* doesn't get modified by parse() et al,
      // thus helping JIT compilers like Chrome V8.
      originalQuoteName: null,
      originalParseError: null,
      cleanupAfterParse: null,
      constructParseErrorInfo: null,
      yyMergeLocationInfo: null,
      __reentrant_call_depth: 0,
      // INTERNAL USE ONLY
      __error_infos: [],
      // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
      __error_recovery_infos: [],
      // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
      // APIs which will be set up depending on user action code analysis:
      //yyRecovering: 0,
      //yyErrOk: 0,
      //yyClearIn: 0,
      // Helper APIs
      // -----------
      // Helper function which can be overridden by user code later on: put suitable quotes around
      // literal IDs in a description string.
      quoteName: function parser_quoteName(id_str) {
        return '"' + id_str + '"';
      },
      // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
      //
      // Return NULL when the symbol is unknown to the parser.
      getSymbolName: function parser_getSymbolName(symbol4) {
        if (this.terminals_[symbol4]) {
          return this.terminals_[symbol4];
        }
        var s3 = this.symbols_;
        for (var key in s3) {
          if (s3[key] === symbol4) {
            return key;
          }
        }
        return null;
      },
      // Return a more-or-less human-readable description of the given symbol, when available,
      // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
      //
      // Return NULL when the symbol is unknown to the parser.
      describeSymbol: function parser_describeSymbol(symbol4) {
        if (symbol4 !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol4]) {
          return this.terminal_descriptions_[symbol4];
        } else if (symbol4 === this.EOF) {
          return "end of input";
        }
        var id2 = this.getSymbolName(symbol4);
        if (id2) {
          return this.quoteName(id2);
        }
        return null;
      },
      // Produce a (more or less) human-readable list of expected tokens at the point of failure.
      //
      // The produced list may contain token or token set descriptions instead of the tokens
      // themselves to help turning this output into something that easier to read by humans
      // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
      // expected terminals and nonterminals is produced.
      //
      // The returned list (array) will not contain any duplicate entries.
      collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
        var TERROR = this.TERROR;
        var tokenset = [];
        var check = {};
        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
          return [
            this.state_descriptions_[state]
          ];
        }
        for (var p2 in this.table[state]) {
          p2 = +p2;
          if (p2 !== TERROR) {
            var d2 = do_not_describe ? p2 : this.describeSymbol(p2);
            if (d2 && !check[d2]) {
              tokenset.push(d2);
              check[d2] = true;
            }
          }
        }
        return tokenset;
      },
      productions_: bp({
        pop: u2([
          29,
          s2,
          [30, 10],
          31,
          31,
          32,
          32,
          s2,
          [33, 15]
        ]),
        rule: u2([
          2,
          s2,
          [3, 5],
          4,
          7,
          s2,
          [1, 4],
          2,
          4,
          6,
          s2,
          [1, 14],
          2
        ])
      }),
      performAction: function parser__PerformAction(yystate, yysp, yyvstack) {
        var yy = this.yy;
        yy.parser;
        yy.lexer;
        switch (yystate) {
          case 0:
            this.$ = yyvstack[yysp - 1];
            break;
          case 1:
            this.$ = yyvstack[yysp - 1];
            return yyvstack[yysp - 1];
          case 2:
          case 3:
          case 4:
          case 5:
            this.$ = { type: "MathExpression", operator: yyvstack[yysp - 1], left: yyvstack[yysp - 2], right: yyvstack[yysp] };
            break;
          case 6:
            this.$ = yyvstack[yysp - 1];
            break;
          case 7:
            this.$ = { type: "Calc", value: yyvstack[yysp - 1] };
            break;
          case 8:
            this.$ = { type: "Calc", value: yyvstack[yysp - 1], prefix: yyvstack[yysp - 5] };
            break;
          case 9:
          case 10:
          case 11:
            this.$ = yyvstack[yysp];
            break;
          case 12:
            this.$ = { type: "Value", value: parseFloat(yyvstack[yysp]) };
            break;
          case 13:
            this.$ = { type: "Value", value: parseFloat(yyvstack[yysp]) * -1 };
            break;
          case 14:
            this.$ = { type: "CssVariable", value: yyvstack[yysp - 1] };
            break;
          case 15:
            this.$ = { type: "CssVariable", value: yyvstack[yysp - 3], fallback: yyvstack[yysp - 1] };
            break;
          case 16:
            this.$ = { type: "LengthValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
            break;
          case 17:
            this.$ = { type: "AngleValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
            break;
          case 18:
            this.$ = { type: "TimeValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
            break;
          case 19:
            this.$ = { type: "FrequencyValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
            break;
          case 20:
            this.$ = { type: "ResolutionValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
            break;
          case 21:
            this.$ = { type: "EmValue", value: parseFloat(yyvstack[yysp]), unit: "em" };
            break;
          case 22:
            this.$ = { type: "ExValue", value: parseFloat(yyvstack[yysp]), unit: "ex" };
            break;
          case 23:
            this.$ = { type: "ChValue", value: parseFloat(yyvstack[yysp]), unit: "ch" };
            break;
          case 24:
            this.$ = { type: "RemValue", value: parseFloat(yyvstack[yysp]), unit: "rem" };
            break;
          case 25:
            this.$ = { type: "VhValue", value: parseFloat(yyvstack[yysp]), unit: "vh" };
            break;
          case 26:
            this.$ = { type: "VwValue", value: parseFloat(yyvstack[yysp]), unit: "vw" };
            break;
          case 27:
            this.$ = { type: "VminValue", value: parseFloat(yyvstack[yysp]), unit: "vmin" };
            break;
          case 28:
            this.$ = { type: "VmaxValue", value: parseFloat(yyvstack[yysp]), unit: "vmax" };
            break;
          case 29:
            this.$ = { type: "PercentageValue", value: parseFloat(yyvstack[yysp]), unit: "%" };
            break;
          case 30:
            var prev = yyvstack[yysp];
            prev.value *= -1;
            this.$ = prev;
            break;
        }
      },
      table: bt({
        len: u2([
          24,
          1,
          5,
          23,
          1,
          18,
          s2,
          [0, 3],
          1,
          s2,
          [0, 16],
          s2,
          [23, 4],
          c2,
          [28, 3],
          0,
          0,
          16,
          1,
          6,
          6,
          s2,
          [0, 3],
          5,
          1,
          2,
          c2,
          [37, 3],
          c2,
          [20, 3],
          5,
          0,
          0
        ]),
        symbol: u2([
          4,
          7,
          9,
          11,
          12,
          s2,
          [15, 19, 1],
          1,
          1,
          s2,
          [3, 4, 1],
          c2,
          [30, 19],
          c2,
          [29, 4],
          7,
          4,
          10,
          11,
          c2,
          [22, 14],
          c2,
          [19, 3],
          c2,
          [43, 22],
          c2,
          [23, 69],
          c2,
          [139, 4],
          8,
          c2,
          [51, 24],
          4,
          c2,
          [138, 15],
          13,
          c2,
          [186, 5],
          8,
          c2,
          [6, 6],
          c2,
          [5, 5],
          9,
          8,
          14,
          c2,
          [159, 47],
          c2,
          [60, 10]
        ]),
        type: u2([
          s2,
          [2, 19],
          s2,
          [0, 5],
          1,
          s2,
          [2, 24],
          s2,
          [0, 4],
          c2,
          [22, 19],
          c2,
          [43, 42],
          c2,
          [23, 70],
          c2,
          [28, 25],
          c2,
          [45, 25],
          c2,
          [113, 54]
        ]),
        state: u2([
          1,
          2,
          8,
          6,
          7,
          30,
          c2,
          [4, 3],
          33,
          37,
          c2,
          [5, 3],
          38,
          c2,
          [4, 3],
          39,
          c2,
          [4, 3],
          40,
          c2,
          [4, 3],
          42,
          c2,
          [21, 4],
          50,
          c2,
          [5, 3],
          51,
          c2,
          [4, 3]
        ]),
        mode: u2([
          s2,
          [1, 179],
          s2,
          [2, 3],
          c2,
          [5, 5],
          c2,
          [6, 4],
          s2,
          [1, 57]
        ]),
        goto: u2([
          5,
          3,
          4,
          24,
          s2,
          [9, 15, 1],
          s2,
          [25, 5, 1],
          c2,
          [24, 19],
          31,
          35,
          32,
          34,
          c2,
          [18, 14],
          36,
          c2,
          [38, 19],
          c2,
          [19, 57],
          c2,
          [118, 4],
          41,
          c2,
          [24, 19],
          43,
          35,
          c2,
          [16, 14],
          44,
          s2,
          [2, 3],
          28,
          29,
          2,
          s2,
          [3, 3],
          28,
          29,
          3,
          c2,
          [53, 4],
          s2,
          [45, 5, 1],
          c2,
          [100, 42],
          52,
          c2,
          [5, 4],
          53
        ])
      }),
      defaultActions: bda({
        idx: u2([
          6,
          7,
          8,
          s2,
          [10, 16, 1],
          33,
          34,
          39,
          40,
          41,
          45,
          47,
          52,
          53
        ]),
        goto: u2([
          9,
          10,
          11,
          s2,
          [16, 14, 1],
          12,
          1,
          30,
          13,
          s2,
          [4, 4, 1],
          14,
          15,
          8
        ])
      }),
      parseError: function parseError(str, hash, ExceptionClass) {
        if (hash.recoverable) {
          if (typeof this.trace === "function") {
            this.trace(str);
          }
          hash.destroy();
        } else {
          if (typeof this.trace === "function") {
            this.trace(str);
          }
          if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
          }
          throw new ExceptionClass(str, hash);
        }
      },
      parse: function parse2(input) {
        var self2 = this;
        var stack = new Array(128);
        var sstack = new Array(128);
        var vstack = new Array(128);
        var table = this.table;
        var sp = 0;
        var symbol4 = 0;
        this.TERROR;
        var EOF = this.EOF;
        this.options.errorRecoveryTokenDiscardCount | 0 || 3;
        var NO_ACTION = [
          0,
          54
          /* === table.length :: ensures that anyone using this new state will fail dramatically! */
        ];
        var lexer2;
        if (this.__lexer__) {
          lexer2 = this.__lexer__;
        } else {
          lexer2 = this.__lexer__ = Object.create(this.lexer);
        }
        var sharedState_yy = {
          parseError: void 0,
          quoteName: void 0,
          lexer: void 0,
          parser: void 0,
          pre_parse: void 0,
          post_parse: void 0,
          pre_lex: void 0,
          post_lex: void 0
          // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
        };
        if (typeof assert !== "function")
          ;
        else {
          assert;
        }
        this.yyGetSharedState = function yyGetSharedState() {
          return sharedState_yy;
        };
        function shallow_copy_noclobber(dst, src) {
          for (var k2 in src) {
            if (typeof dst[k2] === "undefined" && Object.prototype.hasOwnProperty.call(src, k2)) {
              dst[k2] = src[k2];
            }
          }
        }
        shallow_copy_noclobber(sharedState_yy, this.yy);
        sharedState_yy.lexer = lexer2;
        sharedState_yy.parser = this;
        if (typeof sharedState_yy.parseError === "function") {
          this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
              ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
          };
        } else {
          this.parseError = this.originalParseError;
        }
        if (typeof sharedState_yy.quoteName === "function") {
          this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
          };
        } else {
          this.quoteName = this.originalQuoteName;
        }
        this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
          var rv;
          if (invoke_post_methods) {
            var hash;
            if (sharedState_yy.post_parse || this.post_parse) {
              hash = this.constructParseErrorInfo(null, null, null, false);
            }
            if (sharedState_yy.post_parse) {
              rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
              if (typeof rv !== "undefined")
                resultValue = rv;
            }
            if (this.post_parse) {
              rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
              if (typeof rv !== "undefined")
                resultValue = rv;
            }
            if (hash && hash.destroy) {
              hash.destroy();
            }
          }
          if (this.__reentrant_call_depth > 1)
            return resultValue;
          if (lexer2.cleanupAfterLex) {
            lexer2.cleanupAfterLex(do_not_nuke_errorinfos);
          }
          if (sharedState_yy) {
            sharedState_yy.lexer = void 0;
            sharedState_yy.parser = void 0;
            if (lexer2.yy === sharedState_yy) {
              lexer2.yy = void 0;
            }
          }
          sharedState_yy = void 0;
          this.parseError = this.originalParseError;
          this.quoteName = this.originalQuoteName;
          stack.length = 0;
          sstack.length = 0;
          vstack.length = 0;
          sp = 0;
          if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
              var el2 = this.__error_infos[i];
              if (el2 && typeof el2.destroy === "function") {
                el2.destroy();
              }
            }
            this.__error_infos.length = 0;
          }
          return resultValue;
        };
        this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected2, recoverable) {
          var pei = {
            errStr: msg,
            exception: ex,
            text: lexer2.match,
            value: lexer2.yytext,
            token: this.describeSymbol(symbol4) || symbol4,
            token_id: symbol4,
            line: lexer2.yylineno,
            expected: expected2,
            recoverable,
            state,
            action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,
            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer2,
            parser: this,
            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
              var rec = !!this.recoverable;
              for (var key in this) {
                if (this.hasOwnProperty(key) && typeof key === "object") {
                  this[key] = void 0;
                }
              }
              this.recoverable = rec;
            }
          };
          this.__error_infos.push(pei);
          return pei;
        };
        function stdLex() {
          var token2 = lexer2.lex();
          if (typeof token2 !== "number") {
            token2 = self2.symbols_[token2] || token2;
          }
          return token2 || EOF;
        }
        function fastLex() {
          var token2 = lexer2.fastLex();
          if (typeof token2 !== "number") {
            token2 = self2.symbols_[token2] || token2;
          }
          return token2 || EOF;
        }
        var lex = stdLex;
        var state, action, r2, t2;
        var yyval = {
          $: true,
          _$: void 0,
          yy: sharedState_yy
        };
        var p2;
        var yyrulelen;
        var this_production;
        var newState;
        var retval = false;
        try {
          this.__reentrant_call_depth++;
          lexer2.setInput(input, sharedState_yy);
          if (typeof lexer2.canIUse === "function") {
            var lexerInfo = lexer2.canIUse();
            if (lexerInfo.fastLex && typeof fastLex === "function") {
              lex = fastLex;
            }
          }
          vstack[sp] = null;
          sstack[sp] = 0;
          stack[sp] = 0;
          ++sp;
          if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy);
          }
          if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy);
          }
          newState = sstack[sp - 1];
          for (; ; ) {
            state = newState;
            if (this.defaultActions[state]) {
              action = 2;
              newState = this.defaultActions[state];
            } else {
              if (!symbol4) {
                symbol4 = lex();
              }
              t2 = table[state] && table[state][symbol4] || NO_ACTION;
              newState = t2[1];
              action = t2[0];
              if (!action) {
                var errStr;
                var errSymbolDescr = this.describeSymbol(symbol4) || symbol4;
                var expected = this.collect_expected_token_set(state);
                if (typeof lexer2.yylineno === "number") {
                  errStr = "Parse error on line " + (lexer2.yylineno + 1) + ": ";
                } else {
                  errStr = "Parse error: ";
                }
                if (typeof lexer2.showPosition === "function") {
                  errStr += "\n" + lexer2.showPosition(79 - 10, 10) + "\n";
                }
                if (expected.length) {
                  errStr += "Expecting " + expected.join(", ") + ", got unexpected " + errSymbolDescr;
                } else {
                  errStr += "Unexpected " + errSymbolDescr;
                }
                p2 = this.constructParseErrorInfo(errStr, null, expected, false);
                r2 = this.parseError(p2.errStr, p2, this.JisonParserError);
                if (typeof r2 !== "undefined") {
                  retval = r2;
                }
                break;
              }
            }
            switch (action) {
              default:
                if (action instanceof Array) {
                  p2 = this.constructParseErrorInfo("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol4, null, null, false);
                  r2 = this.parseError(p2.errStr, p2, this.JisonParserError);
                  if (typeof r2 !== "undefined") {
                    retval = r2;
                  }
                  break;
                }
                p2 = this.constructParseErrorInfo("Parsing halted. No viable error recovery approach available due to internal system failure.", null, null, false);
                r2 = this.parseError(p2.errStr, p2, this.JisonParserError);
                if (typeof r2 !== "undefined") {
                  retval = r2;
                }
                break;
              case 1:
                stack[sp] = symbol4;
                vstack[sp] = lexer2.yytext;
                sstack[sp] = newState;
                ++sp;
                symbol4 = 0;
                continue;
              case 2:
                this_production = this.productions_[newState - 1];
                yyrulelen = this_production[1];
                r2 = this.performAction.call(yyval, newState, sp - 1, vstack);
                if (typeof r2 !== "undefined") {
                  retval = r2;
                  break;
                }
                sp -= yyrulelen;
                var ntsymbol = this_production[0];
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;
                continue;
              case 3:
                if (sp !== -2) {
                  retval = true;
                  sp--;
                  if (typeof vstack[sp] !== "undefined") {
                    retval = vstack[sp];
                  }
                }
                break;
            }
            break;
          }
        } catch (ex) {
          if (ex instanceof this.JisonParserError) {
            throw ex;
          } else if (lexer2 && typeof lexer2.JisonLexerError === "function" && ex instanceof lexer2.JisonLexerError) {
            throw ex;
          }
          p2 = this.constructParseErrorInfo("Parsing aborted due to exception.", ex, null, false);
          retval = false;
          r2 = this.parseError(p2.errStr, p2, this.JisonParserError);
          if (typeof r2 !== "undefined") {
            retval = r2;
          }
        } finally {
          retval = this.cleanupAfterParse(retval, true, true);
          this.__reentrant_call_depth--;
        }
        return retval;
      }
    };
    parser3.originalParseError = parser3.parseError;
    parser3.originalQuoteName = parser3.quoteName;
    var lexer = function() {
      function JisonLexerError(msg, hash) {
        Object.defineProperty(this, "name", {
          enumerable: false,
          writable: false,
          value: "JisonLexerError"
        });
        if (msg == null)
          msg = "???";
        Object.defineProperty(this, "message", {
          enumerable: false,
          writable: true,
          value: msg
        });
        this.hash = hash;
        var stacktrace;
        if (hash && hash.exception instanceof Error) {
          var ex2 = hash.exception;
          this.message = ex2.message || msg;
          stacktrace = ex2.stack;
        }
        if (!stacktrace) {
          if (Error.hasOwnProperty("captureStackTrace")) {
            Error.captureStackTrace(this, this.constructor);
          } else {
            stacktrace = new Error(msg).stack;
          }
        }
        if (stacktrace) {
          Object.defineProperty(this, "stack", {
            enumerable: false,
            writable: false,
            value: stacktrace
          });
        }
      }
      if (typeof Object.setPrototypeOf === "function") {
        Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
      } else {
        JisonLexerError.prototype = Object.create(Error.prototype);
      }
      JisonLexerError.prototype.constructor = JisonLexerError;
      JisonLexerError.prototype.name = "JisonLexerError";
      var lexer2 = {
        // Code Generator Information Report
        // ---------------------------------
        //
        // Options:
        //
        //   backtracking: .................... false
        //   location.ranges: ................. false
        //   location line+column tracking: ... true
        //
        //
        // Forwarded Parser Analysis flags:
        //
        //   uses yyleng: ..................... false
        //   uses yylineno: ................... false
        //   uses yytext: ..................... false
        //   uses yylloc: ..................... false
        //   uses lexer values: ............... true / true
        //   location tracking: ............... false
        //   location assignment: ............. false
        //
        //
        // Lexer Analysis flags:
        //
        //   uses yyleng: ..................... ???
        //   uses yylineno: ................... ???
        //   uses yytext: ..................... ???
        //   uses yylloc: ..................... ???
        //   uses ParseError API: ............. ???
        //   uses yyerror: .................... ???
        //   uses location tracking & editing:  ???
        //   uses more() API: ................. ???
        //   uses unput() API: ................ ???
        //   uses reject() API: ............... ???
        //   uses less() API: ................. ???
        //   uses display APIs pastInput(), upcomingInput(), showPosition():
        //        ............................. ???
        //   uses describeYYLLOC() API: ....... ???
        //
        // --------- END OF REPORT -----------
        EOF: 1,
        ERROR: 2,
        // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator
        // options: {},                             /// <-- injected by the code generator
        // yy: ...,                                 /// <-- injected by setInput()
        __currentRuleSet__: null,
        /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  
        __error_infos: [],
        /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
        __decompressed: false,
        /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
        done: false,
        /// INTERNAL USE ONLY  
        _backtrack: false,
        /// INTERNAL USE ONLY  
        _input: "",
        /// INTERNAL USE ONLY  
        _more: false,
        /// INTERNAL USE ONLY  
        _signaled_error_token: false,
        /// INTERNAL USE ONLY  
        conditionStack: [],
        /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
        match: "",
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
        matched: "",
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
        matches: false,
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
        yytext: "",
        /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
        offset: 0,
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
        yyleng: 0,
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
        yylineno: 0,
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
        yylloc: null,
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  
        /**
         * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
         * 
         * @public
         * @this {RegExpLexer}
         */
        constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
          msg = "" + msg;
          if (show_input_position == void 0) {
            show_input_position = !(msg.indexOf("\n") > 0 && msg.indexOf("^") > 0);
          }
          if (this.yylloc && show_input_position) {
            if (typeof this.prettyPrintRange === "function") {
              this.prettyPrintRange(this.yylloc);
              if (!/\n\s*$/.test(msg)) {
                msg += "\n";
              }
              msg += "\n  Erroneous area:\n" + this.prettyPrintRange(this.yylloc);
            } else if (typeof this.showPosition === "function") {
              var pos_str = this.showPosition();
              if (pos_str) {
                if (msg.length && msg[msg.length - 1] !== "\n" && pos_str[0] !== "\n") {
                  msg += "\n" + pos_str;
                } else {
                  msg += pos_str;
                }
              }
            }
          }
          var pei = {
            errStr: msg,
            recoverable: !!recoverable,
            text: this.match,
            // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
            token: null,
            line: this.yylineno,
            loc: this.yylloc,
            yy: this.yy,
            lexer: this,
            /**
             * and make sure the error info doesn't stay due to potential
             * ref cycle via userland code manipulations.
             * These would otherwise all be memory leak opportunities!
             * 
             * Note that only array and object references are nuked as those
             * constitute the set of elements which can produce a cyclic ref.
             * The rest of the members is kept intact as they are harmless.
             * 
             * @public
             * @this {LexErrorInfo}
             */
            destroy: function destructLexErrorInfo() {
              var rec = !!this.recoverable;
              for (var key in this) {
                if (this.hasOwnProperty(key) && typeof key === "object") {
                  this[key] = void 0;
                }
              }
              this.recoverable = rec;
            }
          };
          this.__error_infos.push(pei);
          return pei;
        },
        /**
         * handler which is invoked when a lexer error occurs.
         * 
         * @public
         * @this {RegExpLexer}
         */
        parseError: function lexer_parseError(str, hash, ExceptionClass) {
          if (!ExceptionClass) {
            ExceptionClass = this.JisonLexerError;
          }
          if (this.yy) {
            if (this.yy.parser && typeof this.yy.parser.parseError === "function") {
              return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
            } else if (typeof this.yy.parseError === "function") {
              return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
            }
          }
          throw new ExceptionClass(str, hash);
        },
        /**
         * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
         * 
         * @public
         * @this {RegExpLexer}
         */
        yyerror: function yyError(str) {
          var lineno_msg = "";
          if (this.yylloc) {
            lineno_msg = " on line " + (this.yylineno + 1);
          }
          var p2 = this.constructLexErrorInfo(
            "Lexical error" + lineno_msg + ": " + str,
            this.options.lexerErrorsAreRecoverable
          );
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length) {
            p2.extra_error_attributes = args;
          }
          return this.parseError(p2.errStr, p2, this.JisonLexerError) || this.ERROR;
        },
        /**
         * final cleanup function for when we have completed lexing the input;
         * make it an API so that external code can use this one once userland
         * code has decided it's time to destroy any lingering lexer error
         * hash object instances and the like: this function helps to clean
         * up these constructs, which *may* carry cyclic references which would
         * otherwise prevent the instances from being properly and timely
         * garbage-collected, i.e. this function helps prevent memory leaks!
         * 
         * @public
         * @this {RegExpLexer}
         */
        cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
          this.setInput("", {});
          if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
              var el2 = this.__error_infos[i];
              if (el2 && typeof el2.destroy === "function") {
                el2.destroy();
              }
            }
            this.__error_infos.length = 0;
          }
          return this;
        },
        /**
         * clear the lexer token context; intended for internal use only
         * 
         * @public
         * @this {RegExpLexer}
         */
        clear: function lexer_clear() {
          this.yytext = "";
          this.yyleng = 0;
          this.match = "";
          this.matches = false;
          this._more = false;
          this._backtrack = false;
          var col = this.yylloc ? this.yylloc.last_column : 0;
          this.yylloc = {
            first_line: this.yylineno + 1,
            first_column: col,
            last_line: this.yylineno + 1,
            last_column: col,
            range: [this.offset, this.offset]
          };
        },
        /**
         * resets the lexer, sets new input
         * 
         * @public
         * @this {RegExpLexer}
         */
        setInput: function lexer_setInput(input, yy) {
          this.yy = yy || this.yy || {};
          if (!this.__decompressed) {
            var rules = this.rules;
            for (var i = 0, len = rules.length; i < len; i++) {
              var rule_re = rules[i];
              if (typeof rule_re === "number") {
                rules[i] = rules[rule_re];
              }
            }
            var conditions = this.conditions;
            for (var k2 in conditions) {
              var spec = conditions[k2];
              var rule_ids = spec.rules;
              var len = rule_ids.length;
              var rule_regexes = new Array(len + 1);
              var rule_new_ids = new Array(len + 1);
              for (var i = 0; i < len; i++) {
                var idx = rule_ids[i];
                var rule_re = rules[idx];
                rule_regexes[i + 1] = rule_re;
                rule_new_ids[i + 1] = idx;
              }
              spec.rules = rule_new_ids;
              spec.__rule_regexes = rule_regexes;
              spec.__rule_count = len;
            }
            this.__decompressed = true;
          }
          this._input = input || "";
          this.clear();
          this._signaled_error_token = false;
          this.done = false;
          this.yylineno = 0;
          this.matched = "";
          this.conditionStack = ["INITIAL"];
          this.__currentRuleSet__ = null;
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0,
            range: [0, 0]
          };
          this.offset = 0;
          return this;
        },
        /**
         * edit the remaining input via user-specified callback.
         * This can be used to forward-adjust the input-to-parse, 
         * e.g. inserting macro expansions and alike in the
         * input which has yet to be lexed.
         * The behaviour of this API contrasts the `unput()` et al
         * APIs as those act on the *consumed* input, while this
         * one allows one to manipulate the future, without impacting
         * the current `yyloc` cursor location or any history. 
         * 
         * Use this API to help implement C-preprocessor-like
         * `#include` statements, etc.
         * 
         * The provided callback must be synchronous and is
         * expected to return the edited input (string).
         *
         * The `cpsArg` argument value is passed to the callback
         * as-is.
         *
         * `callback` interface: 
         * `function callback(input, cpsArg)`
         * 
         * - `input` will carry the remaining-input-to-lex string
         *   from the lexer.
         * - `cpsArg` is `cpsArg` passed into this API.
         * 
         * The `this` reference for the callback will be set to
         * reference this lexer instance so that userland code
         * in the callback can easily and quickly access any lexer
         * API. 
         *
         * When the callback returns a non-string-type falsey value,
         * we assume the callback did not edit the input and we
         * will using the input as-is.
         *
         * When the callback returns a non-string-type value, it
         * is converted to a string for lexing via the `"" + retval`
         * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
         * -- that way any returned object's `toValue()` and `toString()`
         * methods will be invoked in a proper/desirable order.)
         * 
         * @public
         * @this {RegExpLexer}
         */
        editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
          var rv = callback.call(this, this._input, cpsArg);
          if (typeof rv !== "string") {
            if (rv) {
              this._input = "" + rv;
            }
          } else {
            this._input = rv;
          }
          return this;
        },
        /**
         * consumes and returns one char from the input
         * 
         * @public
         * @this {RegExpLexer}
         */
        input: function lexer_input() {
          if (!this._input) {
            return null;
          }
          var ch2 = this._input[0];
          this.yytext += ch2;
          this.yyleng++;
          this.offset++;
          this.match += ch2;
          this.matched += ch2;
          var slice_len = 1;
          var lines = false;
          if (ch2 === "\n") {
            lines = true;
          } else if (ch2 === "\r") {
            lines = true;
            var ch22 = this._input[1];
            if (ch22 === "\n") {
              slice_len++;
              ch2 += ch22;
              this.yytext += ch22;
              this.yyleng++;
              this.offset++;
              this.match += ch22;
              this.matched += ch22;
              this.yylloc.range[1]++;
            }
          }
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
            this.yylloc.last_column = 0;
          } else {
            this.yylloc.last_column++;
          }
          this.yylloc.range[1]++;
          this._input = this._input.slice(slice_len);
          return ch2;
        },
        /**
         * unshifts one char (or an entire string) into the input
         * 
         * @public
         * @this {RegExpLexer}
         */
        unput: function lexer_unput(ch2) {
          var len = ch2.length;
          var lines = ch2.split(/(?:\r\n?|\n)/g);
          this._input = ch2 + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.yyleng = this.yytext.length;
          this.offset -= len;
          this.match = this.match.substr(0, this.match.length - len);
          this.matched = this.matched.substr(0, this.matched.length - len);
          if (lines.length > 1) {
            this.yylineno -= lines.length - 1;
            this.yylloc.last_line = this.yylineno + 1;
            var pre = this.match;
            var pre_lines = pre.split(/(?:\r\n?|\n)/g);
            if (pre_lines.length === 1) {
              pre = this.matched;
              pre_lines = pre.split(/(?:\r\n?|\n)/g);
            }
            this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
          } else {
            this.yylloc.last_column -= len;
          }
          this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
          this.done = false;
          return this;
        },
        /**
         * cache matched text and append it on next action
         * 
         * @public
         * @this {RegExpLexer}
         */
        more: function lexer_more() {
          this._more = true;
          return this;
        },
        /**
         * signal the lexer that this rule fails to match the input, so the
         * next matching rule (regex) should be tested instead.
         * 
         * @public
         * @this {RegExpLexer}
         */
        reject: function lexer_reject() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            var lineno_msg = "";
            if (this.yylloc) {
              lineno_msg = " on line " + (this.yylineno + 1);
            }
            var p2 = this.constructLexErrorInfo(
              "Lexical error" + lineno_msg + ": You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).",
              false
            );
            this._signaled_error_token = this.parseError(p2.errStr, p2, this.JisonLexerError) || this.ERROR;
          }
          return this;
        },
        /**
         * retain first n characters of the match
         * 
         * @public
         * @this {RegExpLexer}
         */
        less: function lexer_less(n2) {
          return this.unput(this.match.slice(n2));
        },
        /**
         * return (part of the) already matched input, i.e. for error
         * messages.
         * 
         * Limit the returned string length to `maxSize` (default: 20).
         * 
         * Limit the returned string to the `maxLines` number of lines of
         * input (default: 1).
         * 
         * Negative limit values equal *unlimited*.
         * 
         * @public
         * @this {RegExpLexer}
         */
        pastInput: function lexer_pastInput(maxSize, maxLines) {
          var past = this.matched.substring(0, this.matched.length - this.match.length);
          if (maxSize < 0)
            maxSize = past.length;
          else if (!maxSize)
            maxSize = 20;
          if (maxLines < 0)
            maxLines = past.length;
          else if (!maxLines)
            maxLines = 1;
          past = past.substr(-maxSize * 2 - 2);
          var a2 = past.replace(/\r\n|\r/g, "\n").split("\n");
          a2 = a2.slice(-maxLines);
          past = a2.join("\n");
          if (past.length > maxSize) {
            past = "..." + past.substr(-maxSize);
          }
          return past;
        },
        /**
         * return (part of the) upcoming input, i.e. for error messages.
         * 
         * Limit the returned string length to `maxSize` (default: 20).
         * 
         * Limit the returned string to the `maxLines` number of lines of input (default: 1).
         * 
         * Negative limit values equal *unlimited*.
         *
         * > ### NOTE ###
         * >
         * > *"upcoming input"* is defined as the whole of the both
         * > the *currently lexed* input, together with any remaining input
         * > following that. *"currently lexed"* input is the input 
         * > already recognized by the lexer but not yet returned with
         * > the lexer token. This happens when you are invoking this API
         * > from inside any lexer rule action code block. 
         * >
         * 
         * @public
         * @this {RegExpLexer}
         */
        upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
          var next = this.match;
          if (maxSize < 0)
            maxSize = next.length + this._input.length;
          else if (!maxSize)
            maxSize = 20;
          if (maxLines < 0)
            maxLines = maxSize;
          else if (!maxLines)
            maxLines = 1;
          if (next.length < maxSize * 2 + 2) {
            next += this._input.substring(0, maxSize * 2 + 2);
          }
          var a2 = next.replace(/\r\n|\r/g, "\n").split("\n");
          a2 = a2.slice(0, maxLines);
          next = a2.join("\n");
          if (next.length > maxSize) {
            next = next.substring(0, maxSize) + "...";
          }
          return next;
        },
        /**
         * return a string which displays the character position where the
         * lexing error occurred, i.e. for error messages
         * 
         * @public
         * @this {RegExpLexer}
         */
        showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
          var pre = this.pastInput(maxPrefix).replace(/\s/g, " ");
          var c3 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput(maxPostfix).replace(/\s/g, " ") + "\n" + c3 + "^";
        },
        /**
         * return an YYLLOC info object derived off the given context (actual, preceding, following, current).
         * Use this method when the given `actual` location is not guaranteed to exist (i.e. when
         * it MAY be NULL) and you MUST have a valid location info object anyway:
         * then we take the given context of the `preceding` and `following` locations, IFF those are available,
         * and reconstruct the `actual` location info from those.
         * If this fails, the heuristic is to take the `current` location, IFF available.
         * If this fails as well, we assume the sought location is at/around the current lexer position
         * and then produce that one as a response. DO NOTE that these heuristic/derived location info
         * values MAY be inaccurate!
         *
         * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just
         * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).
         * 
         * @public
         * @this {RegExpLexer}
         */
        deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current2) {
          var loc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0,
            range: [0, 0]
          };
          if (actual) {
            loc.first_line = actual.first_line | 0;
            loc.last_line = actual.last_line | 0;
            loc.first_column = actual.first_column | 0;
            loc.last_column = actual.last_column | 0;
            if (actual.range) {
              loc.range[0] = actual.range[0] | 0;
              loc.range[1] = actual.range[1] | 0;
            }
          }
          if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
            if (loc.first_line <= 0 && preceding) {
              loc.first_line = preceding.last_line | 0;
              loc.first_column = preceding.last_column | 0;
              if (preceding.range) {
                loc.range[0] = actual.range[1] | 0;
              }
            }
            if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
              loc.last_line = following.first_line | 0;
              loc.last_column = following.first_column | 0;
              if (following.range) {
                loc.range[1] = actual.range[0] | 0;
              }
            }
            if (loc.first_line <= 0 && current2 && (loc.last_line <= 0 || current2.last_line <= loc.last_line)) {
              loc.first_line = current2.first_line | 0;
              loc.first_column = current2.first_column | 0;
              if (current2.range) {
                loc.range[0] = current2.range[0] | 0;
              }
            }
            if (loc.last_line <= 0 && current2 && (loc.first_line <= 0 || current2.first_line >= loc.first_line)) {
              loc.last_line = current2.last_line | 0;
              loc.last_column = current2.last_column | 0;
              if (current2.range) {
                loc.range[1] = current2.range[1] | 0;
              }
            }
          }
          if (loc.last_line <= 0) {
            if (loc.first_line <= 0) {
              loc.first_line = this.yylloc.first_line;
              loc.last_line = this.yylloc.last_line;
              loc.first_column = this.yylloc.first_column;
              loc.last_column = this.yylloc.last_column;
              loc.range[0] = this.yylloc.range[0];
              loc.range[1] = this.yylloc.range[1];
            } else {
              loc.last_line = this.yylloc.last_line;
              loc.last_column = this.yylloc.last_column;
              loc.range[1] = this.yylloc.range[1];
            }
          }
          if (loc.first_line <= 0) {
            loc.first_line = loc.last_line;
            loc.first_column = 0;
            loc.range[1] = loc.range[0];
          }
          if (loc.first_column < 0) {
            loc.first_column = 0;
          }
          if (loc.last_column < 0) {
            loc.last_column = loc.first_column > 0 ? loc.first_column : 80;
          }
          return loc;
        },
        /**
         * return a string which displays the lines & columns of input which are referenced 
         * by the given location info range, plus a few lines of context.
         * 
         * This function pretty-prints the indicated section of the input, with line numbers 
         * and everything!
         * 
         * This function is very useful to provide highly readable error reports, while
         * the location range may be specified in various flexible ways:
         * 
         * - `loc` is the location info object which references the area which should be
         *   displayed and 'marked up': these lines & columns of text are marked up by `^`
         *   characters below each character in the entire input range.
         * 
         * - `context_loc` is the *optional* location info object which instructs this
         *   pretty-printer how much *leading* context should be displayed alongside
         *   the area referenced by `loc`. This can help provide context for the displayed
         *   error, etc.
         * 
         *   When this location info is not provided, a default context of 3 lines is
         *   used.
         * 
         * - `context_loc2` is another *optional* location info object, which serves
         *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
         *   context lines to display in the pretty-print output.
         * 
         *   When this location info is not provided, a default context of 1 line only is
         *   used.
         * 
         * Special Notes:
         * 
         * - when the `loc`-indicated range is very large (about 5 lines or more), then
         *   only the first and last few lines of this block are printed while a
         *   `...continued...` message will be printed between them.
         * 
         *   This serves the purpose of not printing a huge amount of text when the `loc`
         *   range happens to be huge: this way a manageable & readable output results
         *   for arbitrary large ranges.
         * 
         * - this function can display lines of input which whave not yet been lexed.
         *   `prettyPrintRange()` can access the entire input!
         * 
         * @public
         * @this {RegExpLexer}
         */
        prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
          loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
          const CONTEXT = 3;
          const CONTEXT_TAIL = 1;
          const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
          var input = this.matched + this._input;
          var lines = input.split("\n");
          var l0 = Math.max(1, context_loc ? context_loc.first_line : loc.first_line - CONTEXT);
          var l1 = Math.max(1, context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL);
          var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
          var ws_prefix = new Array(lineno_display_width).join(" ");
          var nonempty_line_indexes = [];
          var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index3) {
            var lno = index3 + l0;
            var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
            var rv2 = lno_pfx + ": " + line;
            var errpfx = new Array(lineno_display_width + 1).join("^");
            var offset2 = 2 + 1;
            var len = 0;
            if (lno === loc.first_line) {
              offset2 += loc.first_column;
              len = Math.max(
                2,
                (lno === loc.last_line ? loc.last_column : line.length) - loc.first_column + 1
              );
            } else if (lno === loc.last_line) {
              len = Math.max(2, loc.last_column + 1);
            } else if (lno > loc.first_line && lno < loc.last_line) {
              len = Math.max(2, line.length + 1);
            }
            if (len) {
              var lead = new Array(offset2).join(".");
              var mark = new Array(len).join("^");
              rv2 += "\n" + errpfx + lead + mark;
              if (line.trim().length > 0) {
                nonempty_line_indexes.push(index3);
              }
            }
            rv2 = rv2.replace(/\t/g, " ");
            return rv2;
          });
          if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
            var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
            var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
            var intermediate_line = new Array(lineno_display_width + 1).join(" ") + "  (...continued...)";
            intermediate_line += "\n" + new Array(lineno_display_width + 1).join("-") + "  (---------------)";
            rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
          }
          return rv.join("\n");
        },
        /**
         * helper function, used to produce a human readable description as a string, given
         * the input `yylloc` location object.
         * 
         * Set `display_range_too` to TRUE to include the string character index position(s)
         * in the description if the `yylloc.range` is available.
         * 
         * @public
         * @this {RegExpLexer}
         */
        describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
          var l1 = yylloc.first_line;
          var l2 = yylloc.last_line;
          var c1 = yylloc.first_column;
          var c22 = yylloc.last_column;
          var dl2 = l2 - l1;
          var dc2 = c22 - c1;
          var rv;
          if (dl2 === 0) {
            rv = "line " + l1 + ", ";
            if (dc2 <= 1) {
              rv += "column " + c1;
            } else {
              rv += "columns " + c1 + " .. " + c22;
            }
          } else {
            rv = "lines " + l1 + "(column " + c1 + ") .. " + l2 + "(column " + c22 + ")";
          }
          if (yylloc.range && display_range_too) {
            var r1 = yylloc.range[0];
            var r2 = yylloc.range[1] - 1;
            if (r2 <= r1) {
              rv += " {String Offset: " + r1 + "}";
            } else {
              rv += " {String Offset range: " + r1 + " .. " + r2 + "}";
            }
          }
          return rv;
        },
        /**
         * test the lexed token: return FALSE when not a match, otherwise return token.
         * 
         * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
         * contains the actually matched text string.
         * 
         * Also move the input cursor forward and update the match collectors:
         * 
         * - `yytext`
         * - `yyleng`
         * - `match`
         * - `matches`
         * - `yylloc`
         * - `offset`
         * 
         * @public
         * @this {RegExpLexer}
         */
        test_match: function lexer_test_match(match5, indexed_rule) {
          var token2, lines, backup, match_str, match_str_len;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.yylloc.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column,
                range: this.yylloc.range.slice(0)
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              //_signaled_error_token: this._signaled_error_token,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
          }
          match_str = match5[0];
          match_str_len = match_str.length;
          lines = match_str.split(/(?:\r\n?|\n)/g);
          if (lines.length > 1) {
            this.yylineno += lines.length - 1;
            this.yylloc.last_line = this.yylineno + 1;
            this.yylloc.last_column = lines[lines.length - 1].length;
          } else {
            this.yylloc.last_column += match_str_len;
          }
          this.yytext += match_str;
          this.match += match_str;
          this.matched += match_str;
          this.matches = match5;
          this.yyleng = this.yytext.length;
          this.yylloc.range[1] += match_str_len;
          this.offset += match_str_len;
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match_str_len);
          token2 = this.performAction.call(
            this,
            this.yy,
            indexed_rule,
            this.conditionStack[this.conditionStack.length - 1]
            /* = YY_START */
          );
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            this.__currentRuleSet__ = null;
            return false;
          } else if (this._signaled_error_token) {
            token2 = this._signaled_error_token;
            this._signaled_error_token = false;
            return token2;
          }
          return false;
        },
        /**
         * return next match in input
         * 
         * @public
         * @this {RegExpLexer}
         */
        next: function lexer_next() {
          if (this.done) {
            this.clear();
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match5, tempMatch, index3;
          if (!this._more) {
            this.clear();
          }
          var spec = this.__currentRuleSet__;
          if (!spec) {
            spec = this.__currentRuleSet__ = this._currentRules();
            if (!spec || !spec.rules) {
              var lineno_msg = "";
              if (this.options.trackPosition) {
                lineno_msg = " on line " + (this.yylineno + 1);
              }
              var p2 = this.constructLexErrorInfo(
                "Internal lexer engine error" + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!',
                false
              );
              return this.parseError(p2.errStr, p2, this.JisonLexerError) || this.ERROR;
            }
          }
          var rule_ids = spec.rules;
          var regexes2 = spec.__rule_regexes;
          var len = spec.__rule_count;
          for (var i = 1; i <= len; i++) {
            tempMatch = this._input.match(regexes2[i]);
            if (tempMatch && (!match5 || tempMatch[0].length > match5[0].length)) {
              match5 = tempMatch;
              index3 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rule_ids[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match5 = void 0;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match5) {
            token2 = this.test_match(match5, rule_ids[index3]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (!this._input) {
            this.done = true;
            this.clear();
            return this.EOF;
          } else {
            var lineno_msg = "";
            if (this.options.trackPosition) {
              lineno_msg = " on line " + (this.yylineno + 1);
            }
            var p2 = this.constructLexErrorInfo(
              "Lexical error" + lineno_msg + ": Unrecognized text.",
              this.options.lexerErrorsAreRecoverable
            );
            var pendingInput = this._input;
            var activeCondition = this.topState();
            var conditionStackDepth = this.conditionStack.length;
            token2 = this.parseError(p2.errStr, p2, this.JisonLexerError) || this.ERROR;
            if (token2 === this.ERROR) {
              if (!this.matches && // and make sure the input has been modified/consumed ...
              pendingInput === this._input && // ...or the lexer state has been modified significantly enough
              // to merit a non-consuming error handling action right now.
              activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
                this.input();
              }
            }
            return token2;
          }
        },
        /**
         * return next match that has a token
         * 
         * @public
         * @this {RegExpLexer}
         */
        lex: function lexer_lex() {
          var r2;
          if (typeof this.pre_lex === "function") {
            r2 = this.pre_lex.call(this, 0);
          }
          if (typeof this.options.pre_lex === "function") {
            r2 = this.options.pre_lex.call(this, r2) || r2;
          }
          if (this.yy && typeof this.yy.pre_lex === "function") {
            r2 = this.yy.pre_lex.call(this, r2) || r2;
          }
          while (!r2) {
            r2 = this.next();
          }
          if (this.yy && typeof this.yy.post_lex === "function") {
            r2 = this.yy.post_lex.call(this, r2) || r2;
          }
          if (typeof this.options.post_lex === "function") {
            r2 = this.options.post_lex.call(this, r2) || r2;
          }
          if (typeof this.post_lex === "function") {
            r2 = this.post_lex.call(this, r2) || r2;
          }
          return r2;
        },
        /**
         * return next match that has a token. Identical to the `lex()` API but does not invoke any of the 
         * `pre_lex()` nor any of the `post_lex()` callbacks.
         * 
         * @public
         * @this {RegExpLexer}
         */
        fastLex: function lexer_fastLex() {
          var r2;
          while (!r2) {
            r2 = this.next();
          }
          return r2;
        },
        /**
         * return info about the lexer state that can help a parser or other lexer API user to use the
         * most efficient means available. This API is provided to aid run-time performance for larger
         * systems which employ this lexer.
         * 
         * @public
         * @this {RegExpLexer}
         */
        canIUse: function lexer_canIUse() {
          var rv = {
            fastLex: !(typeof this.pre_lex === "function" || typeof this.options.pre_lex === "function" || this.yy && typeof this.yy.pre_lex === "function" || this.yy && typeof this.yy.post_lex === "function" || typeof this.options.post_lex === "function" || typeof this.post_lex === "function") && typeof this.fastLex === "function"
          };
          return rv;
        },
        /**
         * backwards compatible alias for `pushState()`;
         * the latter is symmetrical with `popState()` and we advise to use
         * those APIs in any modern lexer code, rather than `begin()`.
         * 
         * @public
         * @this {RegExpLexer}
         */
        begin: function lexer_begin(condition) {
          return this.pushState(condition);
        },
        /**
         * activates a new lexer condition state (pushes the new lexer
         * condition state onto the condition stack)
         * 
         * @public
         * @this {RegExpLexer}
         */
        pushState: function lexer_pushState(condition) {
          this.conditionStack.push(condition);
          this.__currentRuleSet__ = null;
          return this;
        },
        /**
         * pop the previously active lexer condition state off the condition
         * stack
         * 
         * @public
         * @this {RegExpLexer}
         */
        popState: function lexer_popState() {
          var n2 = this.conditionStack.length - 1;
          if (n2 > 0) {
            this.__currentRuleSet__ = null;
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        /**
         * return the currently active lexer condition state; when an index
         * argument is provided it produces the N-th previous condition state,
         * if available
         * 
         * @public
         * @this {RegExpLexer}
         */
        topState: function lexer_topState(n2) {
          n2 = this.conditionStack.length - 1 - Math.abs(n2 || 0);
          if (n2 >= 0) {
            return this.conditionStack[n2];
          } else {
            return "INITIAL";
          }
        },
        /**
         * (internal) determine the lexer rule set which is active for the
         * currently active lexer condition state
         * 
         * @public
         * @this {RegExpLexer}
         */
        _currentRules: function lexer__currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
          } else {
            return this.conditions["INITIAL"];
          }
        },
        /**
         * return the number of states currently on the stack
         * 
         * @public
         * @this {RegExpLexer}
         */
        stateStackSize: function lexer_stateStackSize() {
          return this.conditionStack.length;
        },
        options: {
          trackPosition: true
        },
        JisonLexerError,
        performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
          switch (yyrulenumber) {
            case 1:
              break;
            default:
              return this.simpleCaseActionClusters[yyrulenumber];
          }
        },
        simpleCaseActionClusters: {
          /*! Conditions:: INITIAL */
          /*! Rule::       (--[0-9a-z-A-Z-]*) */
          0: 13,
          /*! Conditions:: INITIAL */
          /*! Rule::       \* */
          2: 5,
          /*! Conditions:: INITIAL */
          /*! Rule::       \/ */
          3: 6,
          /*! Conditions:: INITIAL */
          /*! Rule::       \+ */
          4: 3,
          /*! Conditions:: INITIAL */
          /*! Rule::       - */
          5: 4,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)px\b */
          6: 15,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)cm\b */
          7: 15,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)mm\b */
          8: 15,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)in\b */
          9: 15,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)pt\b */
          10: 15,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)pc\b */
          11: 15,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)deg\b */
          12: 16,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)grad\b */
          13: 16,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)rad\b */
          14: 16,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)turn\b */
          15: 16,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)s\b */
          16: 17,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)ms\b */
          17: 17,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)Hz\b */
          18: 18,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)kHz\b */
          19: 18,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)dpi\b */
          20: 19,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)dpcm\b */
          21: 19,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)dppx\b */
          22: 19,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)em\b */
          23: 20,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)ex\b */
          24: 21,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)ch\b */
          25: 22,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)rem\b */
          26: 23,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vw\b */
          27: 25,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vh\b */
          28: 24,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vmin\b */
          29: 26,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vmax\b */
          30: 27,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)% */
          31: 28,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)\b */
          32: 11,
          /*! Conditions:: INITIAL */
          /*! Rule::       (calc) */
          33: 9,
          /*! Conditions:: INITIAL */
          /*! Rule::       (var) */
          34: 12,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([a-z]+) */
          35: 10,
          /*! Conditions:: INITIAL */
          /*! Rule::       \( */
          36: 7,
          /*! Conditions:: INITIAL */
          /*! Rule::       \) */
          37: 8,
          /*! Conditions:: INITIAL */
          /*! Rule::       , */
          38: 14,
          /*! Conditions:: INITIAL */
          /*! Rule::       $ */
          39: 1
        },
        rules: [
          /*  0: */
          /^(?:(--[\d\-A-Za-z]*))/,
          /*  1: */
          /^(?:\s+)/,
          /*  2: */
          /^(?:\*)/,
          /*  3: */
          /^(?:\/)/,
          /*  4: */
          /^(?:\+)/,
          /*  5: */
          /^(?:-)/,
          /*  6: */
          /^(?:(\d+(\.\d*)?|\.\d+)px\b)/,
          /*  7: */
          /^(?:(\d+(\.\d*)?|\.\d+)cm\b)/,
          /*  8: */
          /^(?:(\d+(\.\d*)?|\.\d+)mm\b)/,
          /*  9: */
          /^(?:(\d+(\.\d*)?|\.\d+)in\b)/,
          /* 10: */
          /^(?:(\d+(\.\d*)?|\.\d+)pt\b)/,
          /* 11: */
          /^(?:(\d+(\.\d*)?|\.\d+)pc\b)/,
          /* 12: */
          /^(?:(\d+(\.\d*)?|\.\d+)deg\b)/,
          /* 13: */
          /^(?:(\d+(\.\d*)?|\.\d+)grad\b)/,
          /* 14: */
          /^(?:(\d+(\.\d*)?|\.\d+)rad\b)/,
          /* 15: */
          /^(?:(\d+(\.\d*)?|\.\d+)turn\b)/,
          /* 16: */
          /^(?:(\d+(\.\d*)?|\.\d+)s\b)/,
          /* 17: */
          /^(?:(\d+(\.\d*)?|\.\d+)ms\b)/,
          /* 18: */
          /^(?:(\d+(\.\d*)?|\.\d+)Hz\b)/,
          /* 19: */
          /^(?:(\d+(\.\d*)?|\.\d+)kHz\b)/,
          /* 20: */
          /^(?:(\d+(\.\d*)?|\.\d+)dpi\b)/,
          /* 21: */
          /^(?:(\d+(\.\d*)?|\.\d+)dpcm\b)/,
          /* 22: */
          /^(?:(\d+(\.\d*)?|\.\d+)dppx\b)/,
          /* 23: */
          /^(?:(\d+(\.\d*)?|\.\d+)em\b)/,
          /* 24: */
          /^(?:(\d+(\.\d*)?|\.\d+)ex\b)/,
          /* 25: */
          /^(?:(\d+(\.\d*)?|\.\d+)ch\b)/,
          /* 26: */
          /^(?:(\d+(\.\d*)?|\.\d+)rem\b)/,
          /* 27: */
          /^(?:(\d+(\.\d*)?|\.\d+)vw\b)/,
          /* 28: */
          /^(?:(\d+(\.\d*)?|\.\d+)vh\b)/,
          /* 29: */
          /^(?:(\d+(\.\d*)?|\.\d+)vmin\b)/,
          /* 30: */
          /^(?:(\d+(\.\d*)?|\.\d+)vmax\b)/,
          /* 31: */
          /^(?:(\d+(\.\d*)?|\.\d+)%)/,
          /* 32: */
          /^(?:(\d+(\.\d*)?|\.\d+)\b)/,
          /* 33: */
          /^(?:(calc))/,
          /* 34: */
          /^(?:(var))/,
          /* 35: */
          /^(?:([a-z]+))/,
          /* 36: */
          /^(?:\()/,
          /* 37: */
          /^(?:\))/,
          /* 38: */
          /^(?:,)/,
          /* 39: */
          /^(?:$)/
        ],
        conditions: {
          "INITIAL": {
            rules: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17,
              18,
              19,
              20,
              21,
              22,
              23,
              24,
              25,
              26,
              27,
              28,
              29,
              30,
              31,
              32,
              33,
              34,
              35,
              36,
              37,
              38,
              39
            ],
            inclusive: true
          }
        }
      };
      return lexer2;
    }();
    parser3.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser3;
    parser3.Parser = Parser;
    return new Parser();
  }();
  if (typeof commonjsRequire !== "undefined" && true) {
    exports.parser = parser2;
    exports.Parser = parser2.Parser;
    exports.parse = function() {
      return parser2.parse.apply(parser2, arguments);
    };
  }
})(parser);
var reducer = {};
var convert = { exports: {} };
var conversions = {
  // length
  "px": {
    "px": 1,
    "cm": 96 / 2.54,
    "mm": 96 / 25.4,
    "in": 96,
    "pt": 96 / 72,
    "pc": 16
  },
  "cm": {
    "px": 2.54 / 96,
    "cm": 1,
    "mm": 0.1,
    "in": 2.54,
    "pt": 2.54 / 72,
    "pc": 2.54 / 6
  },
  "mm": {
    "px": 25.4 / 96,
    "cm": 10,
    "mm": 1,
    "in": 25.4,
    "pt": 25.4 / 72,
    "pc": 25.4 / 6
  },
  "in": {
    "px": 1 / 96,
    "cm": 1 / 2.54,
    "mm": 1 / 25.4,
    "in": 1,
    "pt": 1 / 72,
    "pc": 1 / 6
  },
  "pt": {
    "px": 0.75,
    "cm": 72 / 2.54,
    "mm": 72 / 25.4,
    "in": 72,
    "pt": 1,
    "pc": 12
  },
  "pc": {
    "px": 6 / 96,
    "cm": 6 / 2.54,
    "mm": 6 / 25.4,
    "in": 6,
    "pt": 6 / 72,
    "pc": 1
  },
  // angle
  "deg": {
    "deg": 1,
    "grad": 0.9,
    "rad": 180 / Math.PI,
    "turn": 360
  },
  "grad": {
    "deg": 400 / 360,
    "grad": 1,
    "rad": 200 / Math.PI,
    "turn": 400
  },
  "rad": {
    "deg": Math.PI / 180,
    "grad": Math.PI / 200,
    "rad": 1,
    "turn": Math.PI * 2
  },
  "turn": {
    "deg": 1 / 360,
    "grad": 1 / 400,
    "rad": 0.5 / Math.PI,
    "turn": 1
  },
  // time
  "s": {
    "s": 1,
    "ms": 1 / 1e3
  },
  "ms": {
    "s": 1e3,
    "ms": 1
  },
  // frequency
  "Hz": {
    "Hz": 1,
    "kHz": 1e3
  },
  "kHz": {
    "Hz": 1 / 1e3,
    "kHz": 1
  },
  // resolution
  "dpi": {
    "dpi": 1,
    "dpcm": 1 / 2.54,
    "dppx": 1 / 96
  },
  "dpcm": {
    "dpi": 2.54,
    "dpcm": 1,
    "dppx": 2.54 / 96
  },
  "dppx": {
    "dpi": 96,
    "dpcm": 96 / 2.54,
    "dppx": 1
  }
};
var cssUnitConverter = function(value, sourceUnit, targetUnit, precision) {
  if (!conversions.hasOwnProperty(targetUnit))
    throw new Error("Cannot convert to " + targetUnit);
  if (!conversions[targetUnit].hasOwnProperty(sourceUnit))
    throw new Error("Cannot convert from " + sourceUnit + " to " + targetUnit);
  var converted = conversions[targetUnit][sourceUnit] * value;
  if (precision !== false) {
    precision = Math.pow(10, parseInt(precision) || 5);
    return Math.round(converted * precision) / precision;
  }
  return converted;
};
(function(module2, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _cssUnitConverter = cssUnitConverter;
  var _cssUnitConverter2 = _interopRequireDefault2(_cssUnitConverter);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function convertNodes(left, right, precision) {
    switch (left.type) {
      case "LengthValue":
      case "AngleValue":
      case "TimeValue":
      case "FrequencyValue":
      case "ResolutionValue":
        return convertAbsoluteLength(left, right, precision);
      default:
        return { left, right };
    }
  }
  function convertAbsoluteLength(left, right, precision) {
    if (right.type === left.type) {
      right = {
        type: left.type,
        value: (0, _cssUnitConverter2.default)(right.value, right.unit, left.unit, precision),
        unit: left.unit
      };
    }
    return { left, right };
  }
  exports.default = convertNodes;
  module2.exports = exports["default"];
})(convert, convert.exports);
var convertExports = convert.exports;
Object.defineProperty(reducer, "__esModule", {
  value: true
});
reducer.flip = flip2;
var _convert = convertExports;
var _convert2 = _interopRequireDefault(_convert);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function reduce(node, precision) {
  if (node.type === "MathExpression")
    return reduceMathExpression(node, precision);
  if (node.type === "Calc")
    return reduce(node.value, precision);
  return node;
}
function isEqual$1(left, right) {
  return left.type === right.type && left.value === right.value;
}
function isValueType(type3) {
  switch (type3) {
    case "LengthValue":
    case "AngleValue":
    case "TimeValue":
    case "FrequencyValue":
    case "ResolutionValue":
    case "EmValue":
    case "ExValue":
    case "ChValue":
    case "RemValue":
    case "VhValue":
    case "VwValue":
    case "VminValue":
    case "VmaxValue":
    case "PercentageValue":
    case "Value":
      return true;
  }
  return false;
}
function convertMathExpression(node, precision) {
  var nodes = (0, _convert2.default)(node.left, node.right, precision);
  var left = reduce(nodes.left, precision);
  var right = reduce(nodes.right, precision);
  if (left.type === "MathExpression" && right.type === "MathExpression") {
    if (left.operator === "/" && right.operator === "*" || left.operator === "-" && right.operator === "+" || left.operator === "*" && right.operator === "/" || left.operator === "+" && right.operator === "-") {
      if (isEqual$1(left.right, right.right))
        nodes = (0, _convert2.default)(left.left, right.left, precision);
      else if (isEqual$1(left.right, right.left))
        nodes = (0, _convert2.default)(left.left, right.right, precision);
      left = reduce(nodes.left, precision);
      right = reduce(nodes.right, precision);
    }
  }
  node.left = left;
  node.right = right;
  return node;
}
function flip2(operator) {
  return operator === "+" ? "-" : "+";
}
function flipValue(node) {
  if (isValueType(node.type))
    node.value = -node.value;
  else if (node.type == "MathExpression") {
    node.left = flipValue(node.left);
    node.right = flipValue(node.right);
  }
  return node;
}
function reduceAddSubExpression(node, precision) {
  var _node = node, left = _node.left, right = _node.right, op = _node.operator;
  if (left.type === "CssVariable" || right.type === "CssVariable")
    return node;
  if (right.value === 0)
    return left;
  if (left.value === 0 && op === "+")
    return right;
  if (left.value === 0 && op === "-")
    return flipValue(right);
  if (left.type === right.type && isValueType(left.type)) {
    node = Object.assign({}, left);
    if (op === "+")
      node.value = left.value + right.value;
    else
      node.value = left.value - right.value;
  }
  if (isValueType(left.type) && (right.operator === "+" || right.operator === "-") && right.type === "MathExpression") {
    if (left.type === right.left.type) {
      node = Object.assign({}, node);
      node.left = reduce({
        type: "MathExpression",
        operator: op,
        left,
        right: right.left
      }, precision);
      node.right = right.right;
      node.operator = op === "-" ? flip2(right.operator) : right.operator;
      return reduce(node, precision);
    } else if (left.type === right.right.type) {
      node = Object.assign({}, node);
      node.left = reduce({
        type: "MathExpression",
        operator: op === "-" ? flip2(right.operator) : right.operator,
        left,
        right: right.right
      }, precision);
      node.right = right.left;
      return reduce(node, precision);
    }
  }
  if (left.type === "MathExpression" && (left.operator === "+" || left.operator === "-") && isValueType(right.type)) {
    if (right.type === left.left.type) {
      node = Object.assign({}, left);
      node.left = reduce({
        type: "MathExpression",
        operator: op,
        left: left.left,
        right
      }, precision);
      return reduce(node, precision);
    } else if (right.type === left.right.type) {
      node = Object.assign({}, left);
      if (left.operator === "-") {
        node.right = reduce({
          type: "MathExpression",
          operator: op === "-" ? "+" : "-",
          left: right,
          right: left.right
        }, precision);
        node.operator = op === "-" ? "-" : "+";
      } else {
        node.right = reduce({
          type: "MathExpression",
          operator: op,
          left: left.right,
          right
        }, precision);
      }
      if (node.right.value < 0) {
        node.right.value *= -1;
        node.operator = node.operator === "-" ? "+" : "-";
      }
      return reduce(node, precision);
    }
  }
  return node;
}
function reduceDivisionExpression(node, precision) {
  if (!isValueType(node.right.type))
    return node;
  if (node.right.type !== "Value")
    throw new Error('Cannot divide by "' + node.right.unit + '", number expected');
  if (node.right.value === 0)
    throw new Error("Cannot divide by zero");
  if (node.left.type === "MathExpression") {
    if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {
      node.left.left.value /= node.right.value;
      node.left.right.value /= node.right.value;
      return reduce(node.left, precision);
    }
    return node;
  } else if (isValueType(node.left.type)) {
    node.left.value /= node.right.value;
    return node.left;
  }
  return node;
}
function reduceMultiplicationExpression(node) {
  if (node.left.type === "MathExpression" && node.right.type === "Value") {
    if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {
      node.left.left.value *= node.right.value;
      node.left.right.value *= node.right.value;
      return node.left;
    }
  } else if (isValueType(node.left.type) && node.right.type === "Value") {
    node.left.value *= node.right.value;
    return node.left;
  } else if (node.left.type === "Value" && node.right.type === "MathExpression") {
    if (isValueType(node.right.left.type) && isValueType(node.right.right.type)) {
      node.right.left.value *= node.left.value;
      node.right.right.value *= node.left.value;
      return node.right;
    }
  } else if (node.left.type === "Value" && isValueType(node.right.type)) {
    node.right.value *= node.left.value;
    return node.right;
  }
  return node;
}
function reduceMathExpression(node, precision) {
  node = convertMathExpression(node, precision);
  switch (node.operator) {
    case "+":
    case "-":
      return reduceAddSubExpression(node, precision);
    case "/":
      return reduceDivisionExpression(node, precision);
    case "*":
      return reduceMultiplicationExpression(node);
  }
  return node;
}
reducer.default = reduce;
var stringifier = { exports: {} };
(function(module2, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(calc, node, precision) {
    var str = stringify2(node, precision);
    if (node.type === "MathExpression") {
      str = calc + "(" + str + ")";
    }
    return str;
  };
  var _reducer = reducer;
  var order = {
    "*": 0,
    "/": 0,
    "+": 1,
    "-": 1
  };
  function round2(value, prec) {
    if (prec !== false) {
      var precision = Math.pow(10, prec);
      return Math.round(value * precision) / precision;
    }
    return value;
  }
  function stringify2(node, prec) {
    switch (node.type) {
      case "MathExpression": {
        var left = node.left, right = node.right, op = node.operator;
        var str = "";
        if (left.type === "MathExpression" && order[op] < order[left.operator])
          str += "(" + stringify2(left, prec) + ")";
        else
          str += stringify2(left, prec);
        str += " " + node.operator + " ";
        if (right.type === "MathExpression" && order[op] < order[right.operator]) {
          str += "(" + stringify2(right, prec) + ")";
        } else if (right.type === "MathExpression" && op === "-" && ["+", "-"].includes(right.operator)) {
          right.operator = (0, _reducer.flip)(right.operator);
          str += stringify2(right, prec);
        } else {
          str += stringify2(right, prec);
        }
        return str;
      }
      case "Value":
        return round2(node.value, prec);
      case "CssVariable":
        if (node.fallback) {
          return "var(" + node.value + ", " + stringify2(node.fallback, prec) + ")";
        }
        return "var(" + node.value + ")";
      case "Calc":
        if (node.prefix) {
          return "-" + node.prefix + "-calc(" + stringify2(node.value, prec) + ")";
        }
        return "calc(" + stringify2(node.value, prec) + ")";
      default:
        return round2(node.value, prec) + node.unit;
    }
  }
  module2.exports = exports["default"];
})(stringifier, stringifier.exports);
var stringifierExports = stringifier.exports;
(function(module2, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _postcssValueParser = lib;
  var _postcssValueParser2 = _interopRequireDefault2(_postcssValueParser);
  var _parser = parser;
  var _reducer = reducer;
  var _reducer2 = _interopRequireDefault2(_reducer);
  var _stringifier = stringifierExports;
  var _stringifier2 = _interopRequireDefault2(_stringifier);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var MATCH_CALC = /((?:\-[a-z]+\-)?calc)/;
  exports.default = function(value) {
    var precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
    return (0, _postcssValueParser2.default)(value).walk(function(node) {
      if (node.type !== "function" || !MATCH_CALC.test(node.value))
        return;
      var contents = _postcssValueParser2.default.stringify(node.nodes);
      if (contents.indexOf("constant") >= 0 || contents.indexOf("env") >= 0)
        return;
      var ast = _parser.parser.parse(contents);
      var reducedAst = (0, _reducer2.default)(ast, precision);
      node.type = "word";
      node.value = (0, _stringifier2.default)(node.value, reducedAst, precision);
    }, true).toString();
  };
  module2.exports = exports["default"];
})(dist$1, dist$1.exports);
var distExports = dist$1.exports;
const reduceCSSCalc = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
function _typeof$k(obj) {
  "@babel/helpers - typeof";
  return _typeof$k = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$k(obj);
}
function ownKeys$g(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$g(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$g(Object(source), true).forEach(function(key) {
      _defineProperty$j(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$g(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$j(obj, key, value) {
  key = _toPropertyKey$k(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$k(arg) {
  var key = _toPrimitive$k(arg, "string");
  return _typeof$k(key) === "symbol" ? key : String(key);
}
function _toPrimitive$k(input, hint) {
  if (_typeof$k(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$k(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toConsumableArray$7(arr) {
  return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$a(arr) || _nonIterableSpread$7();
}
function _nonIterableSpread$7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$a(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$a(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$a(o3, minLen);
}
function _iterableToArray$7(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$7(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$a(arr);
}
function _arrayLikeToArray$a(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var stringCache = {
  widthCache: {},
  cacheCount: 0
};
var MAX_CACHE_NUM = 2e3;
var SPAN_STYLE = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
};
var STYLE_LIST = ["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height", "top", "left", "fontSize", "lineHeight", "padding", "margin", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom"];
var MEASUREMENT_SPAN_ID = "recharts_measurement_span";
function autoCompleteStyle(name, value) {
  if (STYLE_LIST.indexOf(name) >= 0 && value === +value) {
    return "".concat(value, "px");
  }
  return value;
}
function camelToMiddleLine(text) {
  var strs = text.split("");
  var formatStrs = strs.reduce(function(result, entry) {
    if (entry === entry.toUpperCase()) {
      return [].concat(_toConsumableArray$7(result), ["-", entry.toLowerCase()]);
    }
    return [].concat(_toConsumableArray$7(result), [entry]);
  }, []);
  return formatStrs.join("");
}
var getStyleString = function getStyleString2(style) {
  return Object.keys(style).reduce(function(result, s2) {
    return "".concat(result).concat(camelToMiddleLine(s2), ":").concat(autoCompleteStyle(s2, style[s2]), ";");
  }, "");
};
var getStringSize = function getStringSize2(text) {
  var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (text === void 0 || text === null || Global.isSsr) {
    return {
      width: 0,
      height: 0
    };
  }
  var str = "".concat(text);
  var styleString = getStyleString(style);
  var cacheKey = "".concat(str, "-").concat(styleString);
  if (stringCache.widthCache[cacheKey]) {
    return stringCache.widthCache[cacheKey];
  }
  try {
    var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
    if (!measurementSpan) {
      measurementSpan = document.createElement("span");
      measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
      measurementSpan.setAttribute("aria-hidden", "true");
      document.body.appendChild(measurementSpan);
    }
    var measurementSpanStyle = _objectSpread$g(_objectSpread$g({}, SPAN_STYLE), style);
    Object.keys(measurementSpanStyle).map(function(styleKey) {
      measurementSpan.style[styleKey] = measurementSpanStyle[styleKey];
      return styleKey;
    });
    measurementSpan.textContent = str;
    var rect = measurementSpan.getBoundingClientRect();
    var result = {
      width: rect.width,
      height: rect.height
    };
    stringCache.widthCache[cacheKey] = result;
    if (++stringCache.cacheCount > MAX_CACHE_NUM) {
      stringCache.cacheCount = 0;
      stringCache.widthCache = {};
    }
    return result;
  } catch (e3) {
    return {
      width: 0,
      height: 0
    };
  }
};
var getOffset = function getOffset2(el2) {
  var html = el2.ownerDocument.documentElement;
  var box = {
    top: 0,
    left: 0
  };
  if (typeof el2.getBoundingClientRect !== "undefined") {
    box = el2.getBoundingClientRect();
  }
  return {
    top: box.top + window.pageYOffset - html.clientTop,
    left: box.left + window.pageXOffset - html.clientLeft
  };
};
var calculateChartCoordinate = function calculateChartCoordinate2(event, offset2) {
  return {
    chartX: Math.round(event.pageX - offset2.left),
    chartY: Math.round(event.pageY - offset2.top)
  };
};
var _excluded$6 = ["dx", "dy", "textAnchor", "verticalAnchor", "scaleToFit", "angle", "lineHeight", "capHeight", "className", "breakAll"];
function _extends$g() {
  _extends$g = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$g.apply(this, arguments);
}
function _objectWithoutProperties$6(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$6(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$6(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _slicedToArray$4(arr, i) {
  return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$9(arr, i) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$9(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$9(o3, minLen);
}
function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$4(arr, i) {
  var _i2 = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i2) {
    var _s2, _e2, _x, _r, _arr = [], _n2 = true, _d = false;
    try {
      if (_x = (_i2 = _i2.call(arr)).next, 0 === i) {
        if (Object(_i2) !== _i2)
          return;
        _n2 = false;
      } else
        for (; !(_n2 = (_s2 = _x.call(_i2)).done) && (_arr.push(_s2.value), _arr.length !== i); _n2 = true)
          ;
    } catch (err) {
      _d = true, _e2 = err;
    } finally {
      try {
        if (!_n2 && null != _i2["return"] && (_r = _i2["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$4(arr) {
  if (Array.isArray(arr))
    return arr;
}
var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/;
var calculateWordWidths = function calculateWordWidths2(_ref) {
  var children = _ref.children, breakAll = _ref.breakAll, style = _ref.style;
  try {
    var words = [];
    if (!_isNil(children)) {
      if (breakAll) {
        words = children.toString().split("");
      } else {
        words = children.toString().split(BREAKING_SPACES);
      }
    }
    var wordsWithComputedWidth = words.map(function(word) {
      return {
        word,
        width: getStringSize(word, style).width
      };
    });
    var spaceWidth = breakAll ? 0 : getStringSize("", style).width;
    return {
      wordsWithComputedWidth,
      spaceWidth
    };
  } catch (e3) {
    return null;
  }
};
var calculateWordsByLines = function calculateWordsByLines2(_ref2, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) {
  var maxLines = _ref2.maxLines, children = _ref2.children, style = _ref2.style, breakAll = _ref2.breakAll;
  var shouldLimitLines = isNumber(maxLines);
  var text = children;
  var calculate = function calculate2() {
    var words = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return words.reduce(function(result2, _ref3) {
      var word = _ref3.word, width = _ref3.width;
      var currentLine = result2[result2.length - 1];
      if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < Number(lineWidth))) {
        currentLine.words.push(word);
        currentLine.width += width + spaceWidth;
      } else {
        var newLine = {
          words: [word],
          width
        };
        result2.push(newLine);
      }
      return result2;
    }, []);
  };
  var originalResult = calculate(initialWordsWithComputedWith);
  var findLongestLine = function findLongestLine2(words) {
    return words.reduce(function(a2, b2) {
      return a2.width > b2.width ? a2 : b2;
    });
  };
  if (!shouldLimitLines) {
    return originalResult;
  }
  var suffix = "";
  var checkOverflow2 = function checkOverflow3(index3) {
    var tempText = text.slice(0, index3);
    var words = calculateWordWidths({
      breakAll,
      style,
      children: tempText + suffix
    }).wordsWithComputedWidth;
    var result2 = calculate(words);
    var doesOverflow = result2.length > maxLines || findLongestLine(result2).width > Number(lineWidth);
    return [doesOverflow, result2];
  };
  var start = 0;
  var end = text.length - 1;
  var iterations = 0;
  var trimmedResult;
  while (start <= end && iterations <= text.length - 1) {
    var middle = Math.floor((start + end) / 2);
    var prev = middle - 1;
    var _checkOverflow = checkOverflow2(prev), _checkOverflow2 = _slicedToArray$4(_checkOverflow, 2), doesPrevOverflow = _checkOverflow2[0], result = _checkOverflow2[1];
    var _checkOverflow3 = checkOverflow2(middle), _checkOverflow4 = _slicedToArray$4(_checkOverflow3, 1), doesMiddleOverflow = _checkOverflow4[0];
    if (!doesPrevOverflow && !doesMiddleOverflow) {
      start = middle + 1;
    }
    if (doesPrevOverflow && doesMiddleOverflow) {
      end = middle - 1;
    }
    if (!doesPrevOverflow && doesMiddleOverflow) {
      trimmedResult = result;
      break;
    }
    iterations++;
  }
  return trimmedResult || originalResult;
};
var getWordsWithoutCalculate = function getWordsWithoutCalculate2(children) {
  var words = !_isNil(children) ? children.toString().split(BREAKING_SPACES) : [];
  return [{
    words
  }];
};
var getWordsByLines = function getWordsByLines2(_ref4) {
  var width = _ref4.width, scaleToFit = _ref4.scaleToFit, children = _ref4.children, style = _ref4.style, breakAll = _ref4.breakAll, maxLines = _ref4.maxLines;
  if ((width || scaleToFit) && !Global.isSsr) {
    var wordsWithComputedWidth, spaceWidth;
    var wordWidths = calculateWordWidths({
      breakAll,
      children,
      style
    });
    if (wordWidths) {
      var wcw = wordWidths.wordsWithComputedWidth, sw = wordWidths.spaceWidth;
      wordsWithComputedWidth = wcw;
      spaceWidth = sw;
    } else {
      return getWordsWithoutCalculate(children);
    }
    return calculateWordsByLines({
      breakAll,
      children,
      maxLines,
      style
    }, wordsWithComputedWidth, spaceWidth, width, scaleToFit);
  }
  return getWordsWithoutCalculate(children);
};
var textDefaultProps = {
  x: 0,
  y: 0,
  lineHeight: "1em",
  capHeight: "0.71em",
  // Magic number from d3
  scaleToFit: false,
  textAnchor: "start",
  verticalAnchor: "end",
  // Maintain compat with existing charts / default SVG behavior
  fill: "#808080"
};
var Text2 = function Text3(props3) {
  var wordsByLines = reactExports.useMemo(function() {
    return getWordsByLines({
      breakAll: props3.breakAll,
      children: props3.children,
      maxLines: props3.maxLines,
      scaleToFit: props3.scaleToFit,
      style: props3.style,
      width: props3.width
    });
  }, [props3.breakAll, props3.children, props3.maxLines, props3.scaleToFit, props3.style, props3.width]);
  var dx = props3.dx, dy = props3.dy, textAnchor = props3.textAnchor, verticalAnchor = props3.verticalAnchor, scaleToFit = props3.scaleToFit, angle = props3.angle, lineHeight = props3.lineHeight, capHeight = props3.capHeight, className = props3.className, breakAll = props3.breakAll, textProps = _objectWithoutProperties$6(props3, _excluded$6);
  if (!isNumOrStr(textProps.x) || !isNumOrStr(textProps.y)) {
    return null;
  }
  var x2 = textProps.x + (isNumber(dx) ? dx : 0);
  var y2 = textProps.y + (isNumber(dy) ? dy : 0);
  var startDy;
  switch (verticalAnchor) {
    case "start":
      startDy = reduceCSSCalc("calc(".concat(capHeight, ")"));
      break;
    case "middle":
      startDy = reduceCSSCalc("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
      break;
    default:
      startDy = reduceCSSCalc("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
      break;
  }
  var transforms = [];
  if (scaleToFit) {
    var lineWidth = wordsByLines[0].width;
    var width = props3.width;
    transforms.push("scale(".concat((isNumber(width) ? width / lineWidth : 1) / lineWidth, ")"));
  }
  if (angle) {
    transforms.push("rotate(".concat(angle, ", ").concat(x2, ", ").concat(y2, ")"));
  }
  if (transforms.length) {
    textProps.transform = transforms.join(" ");
  }
  return /* @__PURE__ */ React.createElement("text", _extends$g({}, filterProps(textProps, true), {
    x: x2,
    y: y2,
    className: classNames("recharts-text", className),
    textAnchor,
    fill: textProps.fill.includes("url") ? textDefaultProps.fill : textProps.fill
  }), wordsByLines.map(function(line, index3) {
    return (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ React.createElement("tspan", {
        x: x2,
        dy: index3 === 0 ? startDy : lineHeight,
        key: index3
      }, line.words.join(breakAll ? "" : " "))
    );
  }));
};
Text2.defaultProps = textDefaultProps;
var baseIsEqual = _baseIsEqual;
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
var isEqual_1 = isEqual;
const _isEqual = /* @__PURE__ */ getDefaultExportFromCjs(isEqual_1);
var isSymbol = isSymbol_1;
function baseExtremum$2(array3, iteratee, comparator3) {
  var index3 = -1, length3 = array3.length;
  while (++index3 < length3) {
    var value = array3[index3], current2 = iteratee(value);
    if (current2 != null && (computed === void 0 ? current2 === current2 && !isSymbol(current2) : comparator3(current2, computed))) {
      var computed = current2, result = value;
    }
  }
  return result;
}
var _baseExtremum = baseExtremum$2;
function baseGt$1(value, other) {
  return value > other;
}
var _baseGt = baseGt$1;
var baseExtremum$1 = _baseExtremum, baseGt = _baseGt, identity$5 = identity_1;
function max$1(array3) {
  return array3 && array3.length ? baseExtremum$1(array3, identity$5, baseGt) : void 0;
}
var max_1 = max$1;
const _max = /* @__PURE__ */ getDefaultExportFromCjs(max_1);
function baseLt$1(value, other) {
  return value < other;
}
var _baseLt = baseLt$1;
var baseExtremum = _baseExtremum, baseLt = _baseLt, identity$4 = identity_1;
function min$1(array3) {
  return array3 && array3.length ? baseExtremum(array3, identity$4, baseLt) : void 0;
}
var min_1 = min$1;
const _min = /* @__PURE__ */ getDefaultExportFromCjs(min_1);
var arrayMap = _arrayMap, baseIteratee$5 = _baseIteratee, baseMap = _baseMap, isArray$2 = isArray_1;
function map$3(collection, iteratee) {
  var func3 = isArray$2(collection) ? arrayMap : baseMap;
  return func3(collection, baseIteratee$5(iteratee));
}
var map_1 = map$3;
var baseFlatten = _baseFlatten, map$2 = map_1;
function flatMap2(collection, iteratee) {
  return baseFlatten(map$2(collection, iteratee), 1);
}
var flatMap_1 = flatMap2;
const _flatMap = /* @__PURE__ */ getDefaultExportFromCjs(flatMap_1);
function ascending(a2, b2) {
  return a2 == null || b2 == null ? NaN : a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function descending(a2, b2) {
  return a2 == null || b2 == null ? NaN : b2 < a2 ? -1 : b2 > a2 ? 1 : b2 >= a2 ? 0 : NaN;
}
function bisector(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending;
    compare2 = (d2, x2) => ascending(f2(d2), x2);
    delta = (d2, x2) => f2(d2) - x2;
  } else {
    compare1 = f2 === ascending || f2 === descending ? f2 : zero$1;
    compare2 = f2;
    delta = f2;
  }
  function left(a2, x2, lo = 0, hi2 = a2.length) {
    if (lo < hi2) {
      if (compare1(x2, x2) !== 0)
        return hi2;
      do {
        const mid = lo + hi2 >>> 1;
        if (compare2(a2[mid], x2) < 0)
          lo = mid + 1;
        else
          hi2 = mid;
      } while (lo < hi2);
    }
    return lo;
  }
  function right(a2, x2, lo = 0, hi2 = a2.length) {
    if (lo < hi2) {
      if (compare1(x2, x2) !== 0)
        return hi2;
      do {
        const mid = lo + hi2 >>> 1;
        if (compare2(a2[mid], x2) <= 0)
          lo = mid + 1;
        else
          hi2 = mid;
      } while (lo < hi2);
    }
    return lo;
  }
  function center(a2, x2, lo = 0, hi2 = a2.length) {
    const i = left(a2, x2, lo, hi2 - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero$1() {
  return 0;
}
function number$2(x2) {
  return x2 === null ? NaN : +x2;
}
function* numbers(values3, valueof) {
  if (valueof === void 0) {
    for (let value of values3) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values3) {
      if ((value = valueof(value, ++index3, values3)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}
const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
bisector(number$2).center;
const bisect = bisectRight;
class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value] of entries)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function compareDefined(compare = ascending) {
  if (compare === ascending)
    return ascendingDefined;
  if (typeof compare !== "function")
    throw new TypeError("compare is not a function");
  return (a2, b2) => {
    const x2 = compare(a2, b2);
    if (x2 || x2 === 0)
      return x2;
    return (compare(b2, b2) === 0) - (compare(a2, a2) === 0);
  };
}
function ascendingDefined(a2, b2) {
  return (a2 == null || !(a2 >= a2)) - (b2 == null || !(b2 >= b2)) || (a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
}
const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(start, stop, count2) {
  const step = (stop - start) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc2;
  if (power < 0) {
    inc2 = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc2);
    i2 = Math.round(stop * inc2);
    if (i1 / inc2 < start)
      ++i1;
    if (i2 / inc2 > stop)
      --i2;
    inc2 = -inc2;
  } else {
    inc2 = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc2);
    i2 = Math.round(stop / inc2);
    if (i1 * inc2 < start)
      ++i1;
    if (i2 * inc2 > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count2 && count2 < 2)
    return tickSpec(start, stop, count2 * 2);
  return [i1, i2, inc2];
}
function ticks(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  if (!(count2 > 0))
    return [];
  if (start === stop)
    return [start];
  const reverse4 = stop < start, [i1, i2, inc2] = reverse4 ? tickSpec(stop, start, count2) : tickSpec(start, stop, count2);
  if (!(i2 >= i1))
    return [];
  const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
  if (reverse4) {
    if (inc2 < 0)
      for (let i = 0; i < n2; ++i)
        ticks2[i] = (i2 - i) / -inc2;
    else
      for (let i = 0; i < n2; ++i)
        ticks2[i] = (i2 - i) * inc2;
  } else {
    if (inc2 < 0)
      for (let i = 0; i < n2; ++i)
        ticks2[i] = (i1 + i) / -inc2;
    else
      for (let i = 0; i < n2; ++i)
        ticks2[i] = (i1 + i) * inc2;
  }
  return ticks2;
}
function tickIncrement(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  return tickSpec(start, stop, count2)[2];
}
function tickStep(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  const reverse4 = stop < start, inc2 = reverse4 ? tickIncrement(stop, start, count2) : tickIncrement(start, stop, count2);
  return (reverse4 ? -1 : 1) * (inc2 < 0 ? 1 / -inc2 : inc2);
}
function max2(values3, valueof) {
  let max3;
  if (valueof === void 0) {
    for (const value of values3) {
      if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values3) {
      if ((value = valueof(value, ++index3, values3)) != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  }
  return max3;
}
function min2(values3, valueof) {
  let min3;
  if (valueof === void 0) {
    for (const value of values3) {
      if (value != null && (min3 > value || min3 === void 0 && value >= value)) {
        min3 = value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values3) {
      if ((value = valueof(value, ++index3, values3)) != null && (min3 > value || min3 === void 0 && value >= value)) {
        min3 = value;
      }
    }
  }
  return min3;
}
function quickselect(array3, k2, left = 0, right = Infinity, compare) {
  k2 = Math.floor(k2);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array3.length - 1, right));
  if (!(left <= k2 && k2 <= right))
    return array3;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right > left) {
    if (right - left > 600) {
      const n2 = right - left + 1;
      const m2 = k2 - left + 1;
      const z2 = Math.log(n2);
      const s2 = 0.5 * Math.exp(2 * z2 / 3);
      const sd2 = 0.5 * Math.sqrt(z2 * s2 * (n2 - s2) / n2) * (m2 - n2 / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k2 - m2 * s2 / n2 + sd2));
      const newRight = Math.min(right, Math.floor(k2 + (n2 - m2) * s2 / n2 + sd2));
      quickselect(array3, k2, newLeft, newRight, compare);
    }
    const t2 = array3[k2];
    let i = left;
    let j2 = right;
    swap(array3, left, k2);
    if (compare(array3[right], t2) > 0)
      swap(array3, left, right);
    while (i < j2) {
      swap(array3, i, j2), ++i, --j2;
      while (compare(array3[i], t2) < 0)
        ++i;
      while (compare(array3[j2], t2) > 0)
        --j2;
    }
    if (compare(array3[left], t2) === 0)
      swap(array3, left, j2);
    else
      ++j2, swap(array3, j2, right);
    if (j2 <= k2)
      left = j2 + 1;
    if (k2 <= j2)
      right = j2 - 1;
  }
  return array3;
}
function swap(array3, i, j2) {
  const t2 = array3[i];
  array3[i] = array3[j2];
  array3[j2] = t2;
}
function quantile$1(values3, p2, valueof) {
  values3 = Float64Array.from(numbers(values3, valueof));
  if (!(n2 = values3.length) || isNaN(p2 = +p2))
    return;
  if (p2 <= 0 || n2 < 2)
    return min2(values3);
  if (p2 >= 1)
    return max2(values3);
  var n2, i = (n2 - 1) * p2, i0 = Math.floor(i), value0 = max2(quickselect(values3, i0).subarray(0, i0 + 1)), value1 = min2(values3.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values3, p2, valueof = number$2) {
  if (!(n2 = values3.length) || isNaN(p2 = +p2))
    return;
  if (p2 <= 0 || n2 < 2)
    return +valueof(values3[0], 0, values3);
  if (p2 >= 1)
    return +valueof(values3[n2 - 1], n2 - 1, values3);
  var n2, i = (n2 - 1) * p2, i0 = Math.floor(i), value0 = +valueof(values3[i0], i0, values3), value1 = +valueof(values3[i0 + 1], i0 + 1, values3);
  return value0 + (value1 - value0) * (i - i0);
}
function range$2(start, stop, step) {
  start = +start, stop = +stop, step = (n2 = arguments.length) < 2 ? (stop = start, start = 0, 1) : n2 < 3 ? 1 : +step;
  var i = -1, n2 = Math.max(0, Math.ceil((stop - start) / step)) | 0, range4 = new Array(n2);
  while (++i < n2) {
    range4[i] = start + i * step;
  }
  return range4;
}
function initRange(domain, range4) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range4).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function")
        this.interpolator(domain);
      else
        this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}
const implicit = Symbol("implicit");
function ordinal() {
  var index3 = new InternMap(), domain = [], range4 = [], unknown = implicit;
  function scale(d2) {
    let i = index3.get(d2);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index3.set(d2, i = domain.push(d2) - 1);
    }
    return range4[i % range4.length];
  }
  scale.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index3 = new InternMap();
    for (const value of _2) {
      if (index3.has(value))
        continue;
      index3.set(value, domain.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_2) {
    return arguments.length ? (range4 = Array.from(_2), scale) : range4.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range4).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n2 = domain().length, reverse4 = r1 < r0, start = reverse4 ? r1 : r0, stop = reverse4 ? r0 : r1;
    step = (stop - start) / Math.max(1, n2 - paddingInner + paddingOuter * 2);
    if (round2)
      step = Math.floor(step);
    start += (stop - start - step * (n2 - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round2)
      start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values3 = range$2(n2).map(function(i) {
      return start + step * i;
    });
    return ordinalRange(reverse4 ? values3.reverse() : values3);
  }
  scale.domain = function(_2) {
    return arguments.length ? (domain(_2), rescale()) : domain();
  };
  scale.range = function(_2) {
    return arguments.length ? ([r0, r1] = _2, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_2) {
    return [r0, r1] = _2, r0 = +r0, r1 = +r1, round2 = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_2) {
    return arguments.length ? (round2 = !!_2, rescale()) : round2;
  };
  scale.padding = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_2), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, _2), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_2) {
    return arguments.length ? (paddingOuter = +_2, rescale()) : paddingOuter;
  };
  scale.align = function(_2) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _2)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy2 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy2());
  };
  return scale;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}
function define(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend(parent, definition) {
  var prototype2 = Object.create(parent.prototype);
  for (var key in definition)
    prototype2[key] = definition[key];
  return prototype2;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m2, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r2, g2, b2, a2) {
  if (a2 <= 0)
    r2 = g2 = b2 = NaN;
  return new Rgb(r2, g2, b2, a2);
}
function rgbConvert(o3) {
  if (!(o3 instanceof Color))
    o3 = color(o3);
  if (!o3)
    return new Rgb();
  o3 = o3.rgb();
  return new Rgb(o3.r, o3.g, o3.b, o3.opacity);
}
function rgb$1(r2, g2, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b2, opacity == null ? 1 : opacity);
}
function Rgb(r2, g2, b2, opacity) {
  this.r = +r2;
  this.g = +g2;
  this.b = +b2;
  this.opacity = +opacity;
}
define(Rgb, rgb$1, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s2, l2, a2) {
  if (a2 <= 0)
    h2 = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1)
    h2 = s2 = NaN;
  else if (s2 <= 0)
    h2 = NaN;
  return new Hsl(h2, s2, l2, a2);
}
function hslConvert(o3) {
  if (o3 instanceof Hsl)
    return new Hsl(o3.h, o3.s, o3.l, o3.opacity);
  if (!(o3 instanceof Color))
    o3 = color(o3);
  if (!o3)
    return new Hsl();
  if (o3 instanceof Hsl)
    return o3;
  o3 = o3.rgb();
  var r2 = o3.r / 255, g2 = o3.g / 255, b2 = o3.b / 255, min3 = Math.min(r2, g2, b2), max3 = Math.max(r2, g2, b2), h2 = NaN, s2 = max3 - min3, l2 = (max3 + min3) / 2;
  if (s2) {
    if (r2 === max3)
      h2 = (g2 - b2) / s2 + (g2 < b2) * 6;
    else if (g2 === max3)
      h2 = (b2 - r2) / s2 + 2;
    else
      h2 = (r2 - g2) / s2 + 4;
    s2 /= l2 < 0.5 ? max3 + min3 : 2 - max3 - min3;
    h2 *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l2, o3.opacity);
}
function hsl(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const constant = (x2) => () => x2;
function linear$1(a2, d2) {
  return function(t2) {
    return a2 + t2 * d2;
  };
}
function exponential(a2, b2, y2) {
  return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t2) {
    return Math.pow(a2 + t2 * b2, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b2) {
    return b2 - a2 ? exponential(a2, b2, y2) : constant(isNaN(a2) ? b2 : a2);
  };
}
function nogamma(a2, b2) {
  var d2 = b2 - a2;
  return d2 ? linear$1(a2, d2) : constant(isNaN(a2) ? b2 : a2);
}
const rgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end) {
    var r2 = color2((start = rgb$1(start)).r, (end = rgb$1(end)).r), g2 = color2(start.g, end.g), b2 = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t2) {
      start.r = r2(t2);
      start.g = g2(t2);
      start.b = b2(t2);
      start.opacity = opacity(t2);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function numberArray(a2, b2) {
  if (!b2)
    b2 = [];
  var n2 = a2 ? Math.min(b2.length, a2.length) : 0, c2 = b2.slice(), i;
  return function(t2) {
    for (i = 0; i < n2; ++i)
      c2[i] = a2[i] * (1 - t2) + b2[i] * t2;
    return c2;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray(a2, b2) {
  var nb2 = b2 ? b2.length : 0, na2 = a2 ? Math.min(nb2, a2.length) : 0, x2 = new Array(na2), c2 = new Array(nb2), i;
  for (i = 0; i < na2; ++i)
    x2[i] = interpolate(a2[i], b2[i]);
  for (; i < nb2; ++i)
    c2[i] = b2[i];
  return function(t2) {
    for (i = 0; i < na2; ++i)
      c2[i] = x2[i](t2);
    return c2;
  };
}
function date$1(a2, b2) {
  var d2 = /* @__PURE__ */ new Date();
  return a2 = +a2, b2 = +b2, function(t2) {
    return d2.setTime(a2 * (1 - t2) + b2 * t2), d2;
  };
}
function interpolateNumber$1(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return a2 * (1 - t2) + b2 * t2;
  };
}
function object(a2, b2) {
  var i = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b2 === null || typeof b2 !== "object")
    b2 = {};
  for (k2 in b2) {
    if (k2 in a2) {
      i[k2] = interpolate(a2[k2], b2[k2]);
    } else {
      c2[k2] = b2[k2];
    }
  }
  return function(t2) {
    for (k2 in i)
      c2[k2] = i[k2](t2);
    return c2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function string3(a2, b2) {
  var bi2 = reA.lastIndex = reB.lastIndex = 0, am, bm, bs2, i = -1, s2 = [], q2 = [];
  a2 = a2 + "", b2 = b2 + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b2))) {
    if ((bs2 = bm.index) > bi2) {
      bs2 = b2.slice(bi2, bs2);
      if (s2[i])
        s2[i] += bs2;
      else
        s2[++i] = bs2;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i])
        s2[i] += bm;
      else
        s2[++i] = bm;
    } else {
      s2[++i] = null;
      q2.push({ i, x: interpolateNumber$1(am, bm) });
    }
    bi2 = reB.lastIndex;
  }
  if (bi2 < b2.length) {
    bs2 = b2.slice(bi2);
    if (s2[i])
      s2[i] += bs2;
    else
      s2[++i] = bs2;
  }
  return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero(b2) : (b2 = q2.length, function(t2) {
    for (var i2 = 0, o3; i2 < b2; ++i2)
      s2[(o3 = q2[i2]).i] = o3.x(t2);
    return s2.join("");
  });
}
function interpolate(a2, b2) {
  var t2 = typeof b2, c2;
  return b2 == null || t2 === "boolean" ? constant(b2) : (t2 === "number" ? interpolateNumber$1 : t2 === "string" ? (c2 = color(b2)) ? (b2 = c2, rgb) : string3 : b2 instanceof color ? rgb : b2 instanceof Date ? date$1 : isNumberArray(b2) ? numberArray : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object : interpolateNumber$1)(a2, b2);
}
function interpolateRound(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return Math.round(a2 * (1 - t2) + b2 * t2);
  };
}
function piecewise(interpolate$1, values3) {
  if (values3 === void 0)
    values3 = interpolate$1, interpolate$1 = interpolate;
  var i = 0, n2 = values3.length - 1, v2 = values3[0], I2 = new Array(n2 < 0 ? 0 : n2);
  while (i < n2)
    I2[i] = interpolate$1(v2, v2 = values3[++i]);
  return function(t2) {
    var i2 = Math.max(0, Math.min(n2 - 1, Math.floor(t2 *= n2)));
    return I2[i2](t2 - i2);
  };
}
function constants(x2) {
  return function() {
    return x2;
  };
}
function number$1(x2) {
  return +x2;
}
var unit = [0, 1];
function identity$3(x2) {
  return x2;
}
function normalize(a2, b2) {
  return (b2 -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b2;
  } : constants(isNaN(b2) ? NaN : 0.5);
}
function clamper(a2, b2) {
  var t2;
  if (a2 > b2)
    t2 = a2, a2 = b2, b2 = t2;
  return function(x2) {
    return Math.max(a2, Math.min(b2, x2));
  };
}
function bimap(domain, range4, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range4[0], r1 = range4[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range4, interpolate2) {
  var j2 = Math.min(domain.length, range4.length) - 1, d2 = new Array(j2), r2 = new Array(j2), i = -1;
  if (domain[j2] < domain[0]) {
    domain = domain.slice().reverse();
    range4 = range4.slice().reverse();
  }
  while (++i < j2) {
    d2[i] = normalize(domain[i], domain[i + 1]);
    r2[i] = interpolate2(range4[i], range4[i + 1]);
  }
  return function(x2) {
    var i2 = bisect(domain, x2, 1, j2) - 1;
    return r2[i2](d2[i2](x2));
  };
}
function copy$1(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$2() {
  var domain = unit, range4 = unit, interpolate$1 = interpolate, transform, untransform, unknown, clamp3 = identity$3, piecewise2, output, input;
  function rescale() {
    var n2 = Math.min(domain.length, range4.length);
    if (clamp3 !== identity$3)
      clamp3 = clamper(domain[0], domain[n2 - 1]);
    piecewise2 = n2 > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform), range4, interpolate$1)))(transform(clamp3(x2)));
  }
  scale.invert = function(y2) {
    return clamp3(untransform((input || (input = piecewise2(range4, domain.map(transform), interpolateNumber$1)))(y2)));
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number$1), rescale()) : domain.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range4 = Array.from(_2), rescale()) : range4.slice();
  };
  scale.rangeRound = function(_2) {
    return range4 = Array.from(_2), interpolate$1 = interpolateRound, rescale();
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp3 = _2 ? true : identity$3, rescale()) : clamp3 !== identity$3;
  };
  scale.interpolate = function(_2) {
    return arguments.length ? (interpolate$1 = _2, rescale()) : interpolate$1;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t2, u2) {
    transform = t2, untransform = u2;
    return rescale();
  };
}
function continuous() {
  return transformer$2()(identity$3, identity$3);
}
function formatDecimal(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p2) {
  if ((i = (x2 = p2 ? x2.toExponential(p2 - 1) : x2.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}
function exponent(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t2 = [], j2 = 0, g2 = grouping[0], length3 = 0;
    while (i > 0 && g2 > 0) {
      if (length3 + g2 + 1 > width)
        g2 = Math.max(1, width - length3);
      t2.push(value.substring(i -= g2, i + g2));
      if ((length3 += g2 + 1) > width)
        break;
      g2 = grouping[j2 = (j2 + 1) % grouping.length];
    }
    return t2.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match5 = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match5;
  return new FormatSpecifier({
    fill: match5[1],
    align: match5[2],
    sign: match5[3],
    symbol: match5[4],
    zero: match5[5],
    width: match5[6],
    comma: match5[7],
    precision: match5[8] && match5[8].slice(1),
    trim: match5[9],
    type: match5[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s2) {
  out:
    for (var n2 = s2.length, i = 1, i0 = -1, i1; i < n2; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}
var prefixExponent;
function formatPrefixAuto(x2, p2) {
  var d2 = formatDecimalParts(x2, p2);
  if (!d2)
    return x2 + "";
  var coefficient = d2[0], exponent2 = d2[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n2 = coefficient.length;
  return i === n2 ? coefficient : i > n2 ? coefficient + new Array(i - n2 + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p2 + i - 1))[0];
}
function formatRounded(x2, p2) {
  var d2 = formatDecimalParts(x2, p2);
  if (!d2)
    return x2 + "";
  var coefficient = d2[0], exponent2 = d2[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": (x2, p2) => (x2 * 100).toFixed(p2),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal,
  "e": (x2, p2) => x2.toExponential(p2),
  "f": (x2, p2) => x2.toFixed(p2),
  "g": (x2, p2) => x2.toPrecision(p2),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p2) => formatRounded(x2 * 100, p2),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};
function identity$2(x2) {
  return x2;
}
var map$1 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$1(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$2 : formatGroup(map$1.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$2 : formatNumerals(map$1.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol4 = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma2 = specifier.comma, precision = specifier.precision, trim4 = specifier.trim, type3 = specifier.type;
    if (type3 === "n")
      comma2 = true, type3 = "g";
    else if (!formatTypes[type3])
      precision === void 0 && (precision = 12), trim4 = true, type3 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix2 = symbol4 === "$" ? currencyPrefix : symbol4 === "#" && /[boxX]/.test(type3) ? "0" + type3.toLowerCase() : "", suffix = symbol4 === "$" ? currencySuffix : /[%p]/.test(type3) ? percent : "";
    var formatType = formatTypes[type3], maybeSuffix = /[defgprs%]/.test(type3);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type3) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix2, valueSuffix = suffix, i, n2, c2;
      if (type3 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim4)
          value = formatTrim(value);
        if (valueNegative && +value === 0 && sign2 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type3 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n2 = value.length;
          while (++i < n2) {
            if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma2 && !zero2)
        value = group(value, Infinity);
      var length3 = valuePrefix.length + value.length + valueSuffix.length, padding = length3 < width ? new Array(width - length3 + 1).join(fill) : "";
      if (comma2 && zero2)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length3 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length3);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k2 = Math.pow(10, -e3), prefix2 = prefixes[8 + e3 / 3];
    return function(value2) {
      return f2(k2 * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale$1;
var format;
var formatPrefix;
defaultLocale$1({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  format = locale$1.format;
  formatPrefix = locale$1.formatPrefix;
  return locale$1;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max3) {
  step = Math.abs(step), max3 = Math.abs(max3) - step;
  return Math.max(0, exponent(max3) - exponent(step)) + 1;
}
function tickFormat(start, stop, count2, specifier) {
  var step = tickStep(start, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d2 = domain();
    return ticks(d2[0], d2[d2.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d2 = domain();
    return tickFormat(d2[0], d2[d2.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d2 = domain();
    var i0 = 0;
    var i1 = d2.length - 1;
    var start = d2[i0];
    var stop = d2[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count2);
      if (step === prestep) {
        d2[i0] = start;
        d2[i1] = stop;
        return domain(d2);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous();
  scale.copy = function() {
    return copy$1(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
function identity$1(domain) {
  var unknown;
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : x2;
  }
  scale.invert = scale;
  scale.domain = scale.range = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number$1), scale) : domain.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return identity$1(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number$1) : [0, 1];
  return linearish(scale);
}
function nice(domain, interval) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t2;
  if (x1 < x0) {
    t2 = i0, i0 = i1, i1 = t2;
    t2 = x0, x0 = x1, x1 = t2;
  }
  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}
function transformLog(x2) {
  return Math.log(x2);
}
function transformExp(x2) {
  return Math.exp(x2);
}
function transformLogn(x2) {
  return -Math.log(-x2);
}
function transformExpn(x2) {
  return -Math.exp(-x2);
}
function pow10(x2) {
  return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x2) => Math.pow(base, x2);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x2) => Math.log(x2) / base);
}
function reflect(f2) {
  return (x2, k2) => -f2(-x2, k2);
}
function loggish(transform) {
  const scale = transform(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_2) {
    return arguments.length ? (base = +_2, rescale()) : base;
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain(_2), rescale()) : domain();
  };
  scale.ticks = (count2) => {
    const d2 = domain();
    let u2 = d2[0];
    let v2 = d2[d2.length - 1];
    const r2 = v2 < u2;
    if (r2)
      [u2, v2] = [v2, u2];
    let i = logs(u2);
    let j2 = logs(v2);
    let k2;
    let t2;
    const n2 = count2 == null ? 10 : +count2;
    let z2 = [];
    if (!(base % 1) && j2 - i < n2) {
      i = Math.floor(i), j2 = Math.ceil(j2);
      if (u2 > 0)
        for (; i <= j2; ++i) {
          for (k2 = 1; k2 < base; ++k2) {
            t2 = i < 0 ? k2 / pows(-i) : k2 * pows(i);
            if (t2 < u2)
              continue;
            if (t2 > v2)
              break;
            z2.push(t2);
          }
        }
      else
        for (; i <= j2; ++i) {
          for (k2 = base - 1; k2 >= 1; --k2) {
            t2 = i > 0 ? k2 / pows(-i) : k2 * pows(i);
            if (t2 < u2)
              continue;
            if (t2 > v2)
              break;
            z2.push(t2);
          }
        }
      if (z2.length * 2 < n2)
        z2 = ticks(u2, v2, n2);
    } else {
      z2 = ticks(i, j2, Math.min(j2 - i, n2)).map(pows);
    }
    return r2 ? z2.reverse() : z2;
  };
  scale.tickFormat = (count2, specifier) => {
    if (count2 == null)
      count2 = 10;
    if (specifier == null)
      specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
        specifier.trim = true;
      specifier = format(specifier);
    }
    if (count2 === Infinity)
      return specifier;
    const k2 = Math.max(1, base * count2 / scale.ticks().length);
    return (d2) => {
      let i = d2 / pows(Math.round(logs(d2)));
      if (i * base < base - 0.5)
        i *= base;
      return i <= k2 ? specifier(d2) : "";
    };
  };
  scale.nice = () => {
    return domain(nice(domain(), {
      floor: (x2) => pows(Math.floor(logs(x2))),
      ceil: (x2) => pows(Math.ceil(logs(x2)))
    }));
  };
  return scale;
}
function log() {
  const scale = loggish(transformer$2()).domain([1, 10]);
  scale.copy = () => copy$1(scale, log()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}
function transformSymlog(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
  };
}
function transformSymexp(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
  };
}
function symlogish(transform) {
  var c2 = 1, scale = transform(transformSymlog(c2), transformSymexp(c2));
  scale.constant = function(_2) {
    return arguments.length ? transform(transformSymlog(c2 = +_2), transformSymexp(c2)) : c2;
  };
  return linearish(scale);
}
function symlog() {
  var scale = symlogish(transformer$2());
  scale.copy = function() {
    return copy$1(scale, symlog()).constant(scale.constant());
  };
  return initRange.apply(scale, arguments);
}
function transformPow(exponent2) {
  return function(x2) {
    return x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
  };
}
function transformSqrt(x2) {
  return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
}
function transformSquare(x2) {
  return x2 < 0 ? -x2 * x2 : x2 * x2;
}
function powish(transform) {
  var scale = transform(identity$3, identity$3), exponent2 = 1;
  function rescale() {
    return exponent2 === 1 ? transform(identity$3, identity$3) : exponent2 === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent2), transformPow(1 / exponent2));
  }
  scale.exponent = function(_2) {
    return arguments.length ? (exponent2 = +_2, rescale()) : exponent2;
  };
  return linearish(scale);
}
function pow() {
  var scale = powish(transformer$2());
  scale.copy = function() {
    return copy$1(scale, pow()).exponent(scale.exponent());
  };
  initRange.apply(scale, arguments);
  return scale;
}
function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}
function square(x2) {
  return Math.sign(x2) * x2 * x2;
}
function unsquare(x2) {
  return Math.sign(x2) * Math.sqrt(Math.abs(x2));
}
function radial() {
  var squared = continuous(), range4 = [0, 1], round2 = false, unknown;
  function scale(x2) {
    var y2 = unsquare(squared(x2));
    return isNaN(y2) ? unknown : round2 ? Math.round(y2) : y2;
  }
  scale.invert = function(y2) {
    return squared.invert(square(y2));
  };
  scale.domain = function(_2) {
    return arguments.length ? (squared.domain(_2), scale) : squared.domain();
  };
  scale.range = function(_2) {
    return arguments.length ? (squared.range((range4 = Array.from(_2, number$1)).map(square)), scale) : range4.slice();
  };
  scale.rangeRound = function(_2) {
    return scale.range(_2).round(true);
  };
  scale.round = function(_2) {
    return arguments.length ? (round2 = !!_2, scale) : round2;
  };
  scale.clamp = function(_2) {
    return arguments.length ? (squared.clamp(_2), scale) : squared.clamp();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return radial(squared.domain(), range4).round(round2).clamp(squared.clamp()).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
function quantile() {
  var domain = [], range4 = [], thresholds2 = [], unknown;
  function rescale() {
    var i = 0, n2 = Math.max(1, range4.length);
    thresholds2 = new Array(n2 - 1);
    while (++i < n2)
      thresholds2[i - 1] = quantileSorted(domain, i / n2);
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : range4[bisect(thresholds2, x2)];
  }
  scale.invertExtent = function(y2) {
    var i = range4.indexOf(y2);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds2[i - 1] : domain[0],
      i < thresholds2.length ? thresholds2[i] : domain[domain.length - 1]
    ];
  };
  scale.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (let d2 of _2)
      if (d2 != null && !isNaN(d2 = +d2))
        domain.push(d2);
    domain.sort(ascending);
    return rescale();
  };
  scale.range = function(_2) {
    return arguments.length ? (range4 = Array.from(_2), rescale()) : range4.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.quantiles = function() {
    return thresholds2.slice();
  };
  scale.copy = function() {
    return quantile().domain(domain).range(range4).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}
function quantize() {
  var x0 = 0, x1 = 1, n2 = 1, domain = [0.5], range4 = [0, 1], unknown;
  function scale(x2) {
    return x2 != null && x2 <= x2 ? range4[bisect(domain, x2, 0, n2)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n2);
    while (++i < n2)
      domain[i] = ((i + 1) * x1 - (i - n2) * x0) / (n2 + 1);
    return scale;
  }
  scale.domain = function(_2) {
    return arguments.length ? ([x0, x1] = _2, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };
  scale.range = function(_2) {
    return arguments.length ? (n2 = (range4 = Array.from(_2)).length - 1, rescale()) : range4.slice();
  };
  scale.invertExtent = function(y2) {
    var i = range4.indexOf(y2);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n2 ? [domain[n2 - 1], x1] : [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : scale;
  };
  scale.thresholds = function() {
    return domain.slice();
  };
  scale.copy = function() {
    return quantize().domain([x0, x1]).range(range4).unknown(unknown);
  };
  return initRange.apply(linearish(scale), arguments);
}
function threshold() {
  var domain = [0.5], range4 = [0, 1], unknown, n2 = 1;
  function scale(x2) {
    return x2 != null && x2 <= x2 ? range4[bisect(domain, x2, 0, n2)] : unknown;
  }
  scale.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2), n2 = Math.min(domain.length, range4.length - 1), scale) : domain.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range4 = Array.from(_2), n2 = Math.min(domain.length, range4.length - 1), scale) : range4.slice();
  };
  scale.invertExtent = function(y2) {
    var i = range4.indexOf(y2);
    return [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return threshold().domain(domain).range(range4).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}
const t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count2, field) {
  function interval(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval.round = (date2) => {
    const d0 = interval(date2), d1 = interval.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval.range = (start, stop, step) => {
    const range4 = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0))
      return range4;
    let previous;
    do
      range4.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range4;
  };
  interval.filter = (test3) => {
    return timeInterval((date2) => {
      if (date2 >= date2)
        while (floori(date2), !test3(date2))
          date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test3(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test3(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval.count = (start, end) => {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count2(t0, t1));
    };
    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d2) => field(d2) % step === 0 : (d2) => interval.count(0, d2) % step === 0);
    };
  }
  return interval;
}
const millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start, end) => {
  return end - start;
});
millisecond.every = (k2) => {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0))
    return null;
  if (!(k2 > 1))
    return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k2) * k2);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k2);
  }, (start, end) => {
    return (end - start) / k2;
  });
};
millisecond.range;
const durationSecond = 1e3;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;
const second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
second.range;
const timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
timeMinute.range;
const utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
utcMinute.range;
const timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getHours();
});
timeHour.range;
const utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
utcHour.range;
const timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
timeDay.range;
const utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
utcDay.range;
const unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
unixDay.range;
function timeWeekday(i) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
const timeSunday = timeWeekday(0);
const timeMonday = timeWeekday(1);
const timeTuesday = timeWeekday(2);
const timeWednesday = timeWeekday(3);
const timeThursday = timeWeekday(4);
const timeFriday = timeWeekday(5);
const timeSaturday = timeWeekday(6);
timeSunday.range;
timeMonday.range;
timeTuesday.range;
timeWednesday.range;
timeThursday.range;
timeFriday.range;
timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
const utcSunday = utcWeekday(0);
const utcMonday = utcWeekday(1);
const utcTuesday = utcWeekday(2);
const utcWednesday = utcWeekday(3);
const utcThursday = utcWeekday(4);
const utcFriday = utcWeekday(5);
const utcSaturday = utcWeekday(6);
utcSunday.range;
utcMonday.range;
utcTuesday.range;
utcWednesday.range;
utcThursday.range;
utcFriday.range;
utcSaturday.range;
const timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
timeMonth.range;
const utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
utcMonth.range;
const timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k2);
  });
};
timeYear.range;
const utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
  });
};
utcYear.range;
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start, stop, count2) {
    const reverse4 = stop < start;
    if (reverse4)
      [start, stop] = [stop, start];
    const interval = count2 && typeof count2.range === "function" ? count2 : tickInterval(start, stop, count2);
    const ticks3 = interval ? interval.range(start, +stop + 1) : [];
    return reverse4 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start, stop, count2) {
    const target = Math.abs(stop - start) / count2;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length)
      return year.every(tickStep(start / durationYear, stop / durationYear, count2));
    if (i === 0)
      return millisecond.every(Math.max(tickStep(start, stop, count2), 1));
    const [t2, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t2.every(step);
  }
  return [ticks2, tickInterval];
}
const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
function localDate(d2) {
  if (0 <= d2.y && d2.y < 100) {
    var date2 = new Date(-1, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L);
    date2.setFullYear(d2.y);
    return date2;
  }
  return new Date(d2.y, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L);
}
function utcDate(d2) {
  if (0 <= d2.y && d2.y < 100) {
    var date2 = new Date(Date.UTC(-1, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L));
    date2.setUTCFullYear(d2.y);
    return date2;
  }
  return new Date(Date.UTC(d2.y, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L));
}
function newDate(y2, m2, d2) {
  return { y: y2, m: m2, d: d2, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale2) {
  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday2,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string4 = [], i = -1, j2 = 0, n2 = specifier.length, c2, pad3, format2;
      if (!(date2 instanceof Date))
        date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n2) {
        if (specifier.charCodeAt(i) === 37) {
          string4.push(specifier.slice(j2, i));
          if ((pad3 = pads[c2 = specifier.charAt(++i)]) != null)
            c2 = specifier.charAt(++i);
          else
            pad3 = c2 === "e" ? " " : "0";
          if (format2 = formats2[c2])
            c2 = format2(date2, pad3);
          string4.push(c2);
          j2 = i + 1;
        }
      }
      string4.push(specifier.slice(j2, i));
      return string4.join("");
    };
  }
  function newParse(specifier, Z2) {
    return function(string4) {
      var d2 = newDate(1900, void 0, 1), i = parseSpecifier(d2, specifier, string4 += "", 0), week, day;
      if (i != string4.length)
        return null;
      if ("Q" in d2)
        return new Date(d2.Q);
      if ("s" in d2)
        return new Date(d2.s * 1e3 + ("L" in d2 ? d2.L : 0));
      if (Z2 && !("Z" in d2))
        d2.Z = 0;
      if ("p" in d2)
        d2.H = d2.H % 12 + d2.p * 12;
      if (d2.m === void 0)
        d2.m = "q" in d2 ? d2.q : 0;
      if ("V" in d2) {
        if (d2.V < 1 || d2.V > 53)
          return null;
        if (!("w" in d2))
          d2.w = 1;
        if ("Z" in d2) {
          week = utcDate(newDate(d2.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d2.V - 1) * 7);
          d2.y = week.getUTCFullYear();
          d2.m = week.getUTCMonth();
          d2.d = week.getUTCDate() + (d2.w + 6) % 7;
        } else {
          week = localDate(newDate(d2.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d2.V - 1) * 7);
          d2.y = week.getFullYear();
          d2.m = week.getMonth();
          d2.d = week.getDate() + (d2.w + 6) % 7;
        }
      } else if ("W" in d2 || "U" in d2) {
        if (!("w" in d2))
          d2.w = "u" in d2 ? d2.u % 7 : "W" in d2 ? 1 : 0;
        day = "Z" in d2 ? utcDate(newDate(d2.y, 0, 1)).getUTCDay() : localDate(newDate(d2.y, 0, 1)).getDay();
        d2.m = 0;
        d2.d = "W" in d2 ? (d2.w + 6) % 7 + d2.W * 7 - (day + 5) % 7 : d2.w + d2.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d2) {
        d2.H += d2.Z / 100 | 0;
        d2.M += d2.Z % 100;
        return utcDate(d2);
      }
      return localDate(d2);
    };
  }
  function parseSpecifier(d2, specifier, string4, j2) {
    var i = 0, n2 = specifier.length, m2 = string4.length, c2, parse2;
    while (i < n2) {
      if (j2 >= m2)
        return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse2 = parses[c2 in pads ? specifier.charAt(i++) : c2];
        if (!parse2 || (j2 = parse2(d2, string4, j2)) < 0)
          return -1;
      } else if (c2 != string4.charCodeAt(j2++)) {
        return -1;
      }
    }
    return j2;
  }
  function parsePeriod(d2, string4, i) {
    var n2 = periodRe.exec(string4.slice(i));
    return n2 ? (d2.p = periodLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
  }
  function parseShortWeekday(d2, string4, i) {
    var n2 = shortWeekdayRe.exec(string4.slice(i));
    return n2 ? (d2.w = shortWeekdayLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
  }
  function parseWeekday2(d2, string4, i) {
    var n2 = weekdayRe.exec(string4.slice(i));
    return n2 ? (d2.w = weekdayLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
  }
  function parseShortMonth(d2, string4, i) {
    var n2 = shortMonthRe.exec(string4.slice(i));
    return n2 ? (d2.m = shortMonthLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
  }
  function parseMonth(d2, string4, i) {
    var n2 = monthRe.exec(string4.slice(i));
    return n2 ? (d2.m = monthLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
  }
  function parseLocaleDateTime(d2, string4, i) {
    return parseSpecifier(d2, locale_dateTime, string4, i);
  }
  function parseLocaleDate(d2, string4, i) {
    return parseSpecifier(d2, locale_date, string4, i);
  }
  function parseLocaleTime(d2, string4, i) {
    return parseSpecifier(d2, locale_time, string4, i);
  }
  function formatShortWeekday(d2) {
    return locale_shortWeekdays[d2.getDay()];
  }
  function formatWeekday(d2) {
    return locale_weekdays[d2.getDay()];
  }
  function formatShortMonth(d2) {
    return locale_shortMonths[d2.getMonth()];
  }
  function formatMonth(d2) {
    return locale_months[d2.getMonth()];
  }
  function formatPeriod(d2) {
    return locale_periods[+(d2.getHours() >= 12)];
  }
  function formatQuarter(d2) {
    return 1 + ~~(d2.getMonth() / 3);
  }
  function formatUTCShortWeekday(d2) {
    return locale_shortWeekdays[d2.getUTCDay()];
  }
  function formatUTCWeekday(d2) {
    return locale_weekdays[d2.getUTCDay()];
  }
  function formatUTCShortMonth(d2) {
    return locale_shortMonths[d2.getUTCMonth()];
  }
  function formatUTCMonth(d2) {
    return locale_months[d2.getUTCMonth()];
  }
  function formatUTCPeriod(d2) {
    return locale_periods[+(d2.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d2) {
    return 1 + ~~(d2.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f2 = newFormat(specifier += "", formats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    parse: function(specifier) {
      var p2 = newParse(specifier += "", false);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    },
    utcFormat: function(specifier) {
      var f2 = newFormat(specifier += "", utcFormats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    utcParse: function(specifier) {
      var p2 = newParse(specifier += "", true);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad2(value, fill, width) {
  var sign2 = value < 0 ? "-" : "", string4 = (sign2 ? -value : value) + "", length3 = string4.length;
  return sign2 + (length3 < width ? new Array(width - length3 + 1).join(fill) + string4 : string4);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 1));
  return n2 ? (d2.w = +n2[0], i + n2[0].length) : -1;
}
function parseWeekdayNumberMonday(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 1));
  return n2 ? (d2.u = +n2[0], i + n2[0].length) : -1;
}
function parseWeekNumberSunday(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 2));
  return n2 ? (d2.U = +n2[0], i + n2[0].length) : -1;
}
function parseWeekNumberISO(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 2));
  return n2 ? (d2.V = +n2[0], i + n2[0].length) : -1;
}
function parseWeekNumberMonday(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 2));
  return n2 ? (d2.W = +n2[0], i + n2[0].length) : -1;
}
function parseFullYear(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 4));
  return n2 ? (d2.y = +n2[0], i + n2[0].length) : -1;
}
function parseYear(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 2));
  return n2 ? (d2.y = +n2[0] + (+n2[0] > 68 ? 1900 : 2e3), i + n2[0].length) : -1;
}
function parseZone(d2, string4, i) {
  var n2 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string4.slice(i, i + 6));
  return n2 ? (d2.Z = n2[1] ? 0 : -(n2[2] + (n2[3] || "00")), i + n2[0].length) : -1;
}
function parseQuarter(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 1));
  return n2 ? (d2.q = n2[0] * 3 - 3, i + n2[0].length) : -1;
}
function parseMonthNumber(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 2));
  return n2 ? (d2.m = n2[0] - 1, i + n2[0].length) : -1;
}
function parseDayOfMonth(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 2));
  return n2 ? (d2.d = +n2[0], i + n2[0].length) : -1;
}
function parseDayOfYear(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 3));
  return n2 ? (d2.m = 0, d2.d = +n2[0], i + n2[0].length) : -1;
}
function parseHour24(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 2));
  return n2 ? (d2.H = +n2[0], i + n2[0].length) : -1;
}
function parseMinutes(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 2));
  return n2 ? (d2.M = +n2[0], i + n2[0].length) : -1;
}
function parseSeconds(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 2));
  return n2 ? (d2.S = +n2[0], i + n2[0].length) : -1;
}
function parseMilliseconds(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 3));
  return n2 ? (d2.L = +n2[0], i + n2[0].length) : -1;
}
function parseMicroseconds(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i, i + 6));
  return n2 ? (d2.L = Math.floor(n2[0] / 1e3), i + n2[0].length) : -1;
}
function parseLiteralPercent(d2, string4, i) {
  var n2 = percentRe.exec(string4.slice(i, i + 1));
  return n2 ? i + n2[0].length : -1;
}
function parseUnixTimestamp(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i));
  return n2 ? (d2.Q = +n2[0], i + n2[0].length) : -1;
}
function parseUnixTimestampSeconds(d2, string4, i) {
  var n2 = numberRe.exec(string4.slice(i));
  return n2 ? (d2.s = +n2[0], i + n2[0].length) : -1;
}
function formatDayOfMonth(d2, p2) {
  return pad2(d2.getDate(), p2, 2);
}
function formatHour24(d2, p2) {
  return pad2(d2.getHours(), p2, 2);
}
function formatHour12(d2, p2) {
  return pad2(d2.getHours() % 12 || 12, p2, 2);
}
function formatDayOfYear(d2, p2) {
  return pad2(1 + timeDay.count(timeYear(d2), d2), p2, 3);
}
function formatMilliseconds(d2, p2) {
  return pad2(d2.getMilliseconds(), p2, 3);
}
function formatMicroseconds(d2, p2) {
  return formatMilliseconds(d2, p2) + "000";
}
function formatMonthNumber(d2, p2) {
  return pad2(d2.getMonth() + 1, p2, 2);
}
function formatMinutes(d2, p2) {
  return pad2(d2.getMinutes(), p2, 2);
}
function formatSeconds(d2, p2) {
  return pad2(d2.getSeconds(), p2, 2);
}
function formatWeekdayNumberMonday(d2) {
  var day = d2.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d2, p2) {
  return pad2(timeSunday.count(timeYear(d2) - 1, d2), p2, 2);
}
function dISO(d2) {
  var day = d2.getDay();
  return day >= 4 || day === 0 ? timeThursday(d2) : timeThursday.ceil(d2);
}
function formatWeekNumberISO(d2, p2) {
  d2 = dISO(d2);
  return pad2(timeThursday.count(timeYear(d2), d2) + (timeYear(d2).getDay() === 4), p2, 2);
}
function formatWeekdayNumberSunday(d2) {
  return d2.getDay();
}
function formatWeekNumberMonday(d2, p2) {
  return pad2(timeMonday.count(timeYear(d2) - 1, d2), p2, 2);
}
function formatYear(d2, p2) {
  return pad2(d2.getFullYear() % 100, p2, 2);
}
function formatYearISO(d2, p2) {
  d2 = dISO(d2);
  return pad2(d2.getFullYear() % 100, p2, 2);
}
function formatFullYear(d2, p2) {
  return pad2(d2.getFullYear() % 1e4, p2, 4);
}
function formatFullYearISO(d2, p2) {
  var day = d2.getDay();
  d2 = day >= 4 || day === 0 ? timeThursday(d2) : timeThursday.ceil(d2);
  return pad2(d2.getFullYear() % 1e4, p2, 4);
}
function formatZone(d2) {
  var z2 = d2.getTimezoneOffset();
  return (z2 > 0 ? "-" : (z2 *= -1, "+")) + pad2(z2 / 60 | 0, "0", 2) + pad2(z2 % 60, "0", 2);
}
function formatUTCDayOfMonth(d2, p2) {
  return pad2(d2.getUTCDate(), p2, 2);
}
function formatUTCHour24(d2, p2) {
  return pad2(d2.getUTCHours(), p2, 2);
}
function formatUTCHour12(d2, p2) {
  return pad2(d2.getUTCHours() % 12 || 12, p2, 2);
}
function formatUTCDayOfYear(d2, p2) {
  return pad2(1 + utcDay.count(utcYear(d2), d2), p2, 3);
}
function formatUTCMilliseconds(d2, p2) {
  return pad2(d2.getUTCMilliseconds(), p2, 3);
}
function formatUTCMicroseconds(d2, p2) {
  return formatUTCMilliseconds(d2, p2) + "000";
}
function formatUTCMonthNumber(d2, p2) {
  return pad2(d2.getUTCMonth() + 1, p2, 2);
}
function formatUTCMinutes(d2, p2) {
  return pad2(d2.getUTCMinutes(), p2, 2);
}
function formatUTCSeconds(d2, p2) {
  return pad2(d2.getUTCSeconds(), p2, 2);
}
function formatUTCWeekdayNumberMonday(d2) {
  var dow = d2.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d2, p2) {
  return pad2(utcSunday.count(utcYear(d2) - 1, d2), p2, 2);
}
function UTCdISO(d2) {
  var day = d2.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d2) : utcThursday.ceil(d2);
}
function formatUTCWeekNumberISO(d2, p2) {
  d2 = UTCdISO(d2);
  return pad2(utcThursday.count(utcYear(d2), d2) + (utcYear(d2).getUTCDay() === 4), p2, 2);
}
function formatUTCWeekdayNumberSunday(d2) {
  return d2.getUTCDay();
}
function formatUTCWeekNumberMonday(d2, p2) {
  return pad2(utcMonday.count(utcYear(d2) - 1, d2), p2, 2);
}
function formatUTCYear(d2, p2) {
  return pad2(d2.getUTCFullYear() % 100, p2, 2);
}
function formatUTCYearISO(d2, p2) {
  d2 = UTCdISO(d2);
  return pad2(d2.getUTCFullYear() % 100, p2, 2);
}
function formatUTCFullYear(d2, p2) {
  return pad2(d2.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCFullYearISO(d2, p2) {
  var day = d2.getUTCDay();
  d2 = day >= 4 || day === 0 ? utcThursday(d2) : utcThursday.ceil(d2);
  return pad2(d2.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d2) {
  return +d2;
}
function formatUnixTimestampSeconds(d2) {
  return Math.floor(+d2 / 1e3);
}
var locale;
var timeFormat;
var utcFormat;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  timeFormat = locale.format;
  locale.parse;
  utcFormat = locale.utcFormat;
  locale.utcParse;
  return locale;
}
function date(t2) {
  return new Date(t2);
}
function number(t2) {
  return t2 instanceof Date ? +t2 : +/* @__PURE__ */ new Date(+t2);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
  var scale = continuous(), invert3 = scale.invert, domain = scale.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale.invert = function(y2) {
    return new Date(invert3(y2));
  };
  scale.domain = function(_2) {
    return arguments.length ? domain(Array.from(_2, number)) : domain().map(date);
  };
  scale.ticks = function(interval) {
    var d2 = domain();
    return ticks2(d2[0], d2[d2.length - 1], interval == null ? 10 : interval);
  };
  scale.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval) {
    var d2 = domain();
    if (!interval || typeof interval.range !== "function")
      interval = tickInterval(d2[0], d2[d2.length - 1], interval == null ? 10 : interval);
    return interval ? domain(nice(d2, interval)) : scale;
  };
  scale.copy = function() {
    return copy$1(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function transformer$1() {
  var x0 = 0, x1 = 1, t02, t12, k10, transform, interpolator = identity$3, clamp3 = false, unknown;
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform(x2) - t02) * k10, clamp3 ? Math.max(0, Math.min(1, x2)) : x2));
  }
  scale.domain = function(_2) {
    return arguments.length ? ([x0, x1] = _2, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale) : [x0, x1];
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp3 = !!_2, scale) : clamp3;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  function range4(interpolate2) {
    return function(_2) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _2, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }
  scale.range = range4(interpolate);
  scale.rangeRound = range4(interpolateRound);
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t2) {
    transform = t2, t02 = t2(x0), t12 = t2(x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
    return scale;
  };
}
function copy(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = linearish(transformer$1()(identity$3));
  scale.copy = function() {
    return copy(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
  var scale = loggish(transformer$1()).domain([1, 10]);
  scale.copy = function() {
    return copy(scale, sequentialLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
  var scale = symlogish(transformer$1());
  scale.copy = function() {
    return copy(scale, sequentialSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
  var scale = powish(transformer$1());
  scale.copy = function() {
    return copy(scale, sequentialPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}
function sequentialQuantile() {
  var domain = [], interpolator = identity$3;
  function scale(x2) {
    if (x2 != null && !isNaN(x2 = +x2))
      return interpolator((bisect(domain, x2, 1) - 1) / (domain.length - 1));
  }
  scale.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (let d2 of _2)
      if (d2 != null && !isNaN(d2 = +d2))
        domain.push(d2);
    domain.sort(ascending);
    return scale;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  scale.range = function() {
    return domain.map((d2, i) => interpolator(i / (domain.length - 1)));
  };
  scale.quantiles = function(n2) {
    return Array.from({ length: n2 + 1 }, (_2, i) => quantile$1(domain, i / n2));
  };
  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };
  return initInterpolator.apply(scale, arguments);
}
function transformer() {
  var x0 = 0, x1 = 0.5, x2 = 1, s2 = 1, t02, t12, t2, k10, k21, interpolator = identity$3, transform, clamp3 = false, unknown;
  function scale(x3) {
    return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform(x3)) - t12) * (s2 * x3 < s2 * t12 ? k10 : k21), interpolator(clamp3 ? Math.max(0, Math.min(1, x3)) : x3));
  }
  scale.domain = function(_2) {
    return arguments.length ? ([x0, x1, x2] = _2, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), s2 = t12 < t02 ? -1 : 1, scale) : [x0, x1, x2];
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp3 = !!_2, scale) : clamp3;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  function range4(interpolate2) {
    return function(_2) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _2, interpolator = piecewise(interpolate2, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale.range = range4(interpolate);
  scale.rangeRound = range4(interpolateRound);
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t3) {
    transform = t3, t02 = t3(x0), t12 = t3(x1), t2 = t3(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), s2 = t12 < t02 ? -1 : 1;
    return scale;
  };
}
function diverging() {
  var scale = linearish(transformer()(identity$3));
  scale.copy = function() {
    return copy(scale, diverging());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
  var scale = loggish(transformer()).domain([0.1, 1, 10]);
  scale.copy = function() {
    return copy(scale, divergingLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
  var scale = symlogish(transformer());
  scale.copy = function() {
    return copy(scale, divergingSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
  var scale = powish(transformer());
  scale.copy = function() {
    return copy(scale, divergingPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}
const d3Scales = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  scaleBand: band,
  scaleDiverging: diverging,
  scaleDivergingLog: divergingLog,
  scaleDivergingPow: divergingPow,
  scaleDivergingSqrt: divergingSqrt,
  scaleDivergingSymlog: divergingSymlog,
  scaleIdentity: identity$1,
  scaleImplicit: implicit,
  scaleLinear: linear,
  scaleLog: log,
  scaleOrdinal: ordinal,
  scalePoint: point,
  scalePow: pow,
  scaleQuantile: quantile,
  scaleQuantize: quantize,
  scaleRadial: radial,
  scaleSequential: sequential,
  scaleSequentialLog: sequentialLog,
  scaleSequentialPow: sequentialPow,
  scaleSequentialQuantile: sequentialQuantile,
  scaleSequentialSqrt: sequentialSqrt,
  scaleSequentialSymlog: sequentialSymlog,
  scaleSqrt: sqrt,
  scaleSymlog: symlog,
  scaleThreshold: threshold,
  scaleTime: time,
  scaleUtc: utcTime,
  tickFormat
}, Symbol.toStringTag, { value: "Module" }));
var MAX_DIGITS = 1e9, defaults = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
}, Decimal, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE), P = {};
P.absoluteValue = P.abs = function() {
  var x2 = new this.constructor(this);
  if (x2.s)
    x2.s = 1;
  return x2;
};
P.comparedTo = P.cmp = function(y2) {
  var i, j2, xdL, ydL, x2 = this;
  y2 = new x2.constructor(y2);
  if (x2.s !== y2.s)
    return x2.s || -y2.s;
  if (x2.e !== y2.e)
    return x2.e > y2.e ^ x2.s < 0 ? 1 : -1;
  xdL = x2.d.length;
  ydL = y2.d.length;
  for (i = 0, j2 = xdL < ydL ? xdL : ydL; i < j2; ++i) {
    if (x2.d[i] !== y2.d[i])
      return x2.d[i] > y2.d[i] ^ x2.s < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ x2.s < 0 ? 1 : -1;
};
P.decimalPlaces = P.dp = function() {
  var x2 = this, w2 = x2.d.length - 1, dp = (w2 - x2.e) * LOG_BASE;
  w2 = x2.d[w2];
  if (w2)
    for (; w2 % 10 == 0; w2 /= 10)
      dp--;
  return dp < 0 ? 0 : dp;
};
P.dividedBy = P.div = function(y2) {
  return divide2(this, new this.constructor(y2));
};
P.dividedToIntegerBy = P.idiv = function(y2) {
  var x2 = this, Ctor = x2.constructor;
  return round(divide2(x2, new Ctor(y2), 0, 1), Ctor.precision);
};
P.equals = P.eq = function(y2) {
  return !this.cmp(y2);
};
P.exponent = function() {
  return getBase10Exponent(this);
};
P.greaterThan = P.gt = function(y2) {
  return this.cmp(y2) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y2) {
  return this.cmp(y2) >= 0;
};
P.isInteger = P.isint = function() {
  return this.e > this.d.length - 2;
};
P.isNegative = P.isneg = function() {
  return this.s < 0;
};
P.isPositive = P.ispos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return this.s === 0;
};
P.lessThan = P.lt = function(y2) {
  return this.cmp(y2) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y2) {
  return this.cmp(y2) < 1;
};
P.logarithm = P.log = function(base) {
  var r2, x2 = this, Ctor = x2.constructor, pr = Ctor.precision, wpr = pr + 5;
  if (base === void 0) {
    base = new Ctor(10);
  } else {
    base = new Ctor(base);
    if (base.s < 1 || base.eq(ONE))
      throw Error(decimalError + "NaN");
  }
  if (x2.s < 1)
    throw Error(decimalError + (x2.s ? "NaN" : "-Infinity"));
  if (x2.eq(ONE))
    return new Ctor(0);
  external = false;
  r2 = divide2(ln(x2, wpr), ln(base, wpr), wpr);
  external = true;
  return round(r2, pr);
};
P.minus = P.sub = function(y2) {
  var x2 = this;
  y2 = new x2.constructor(y2);
  return x2.s == y2.s ? subtract2(x2, y2) : add2(x2, (y2.s = -y2.s, y2));
};
P.modulo = P.mod = function(y2) {
  var q2, x2 = this, Ctor = x2.constructor, pr = Ctor.precision;
  y2 = new Ctor(y2);
  if (!y2.s)
    throw Error(decimalError + "NaN");
  if (!x2.s)
    return round(new Ctor(x2), pr);
  external = false;
  q2 = divide2(x2, y2, 0, 1).times(y2);
  external = true;
  return x2.minus(q2);
};
P.naturalExponential = P.exp = function() {
  return exp(this);
};
P.naturalLogarithm = P.ln = function() {
  return ln(this);
};
P.negated = P.neg = function() {
  var x2 = new this.constructor(this);
  x2.s = -x2.s || 0;
  return x2;
};
P.plus = P.add = function(y2) {
  var x2 = this;
  y2 = new x2.constructor(y2);
  return x2.s == y2.s ? add2(x2, y2) : subtract2(x2, (y2.s = -y2.s, y2));
};
P.precision = P.sd = function(z2) {
  var e3, sd2, w2, x2 = this;
  if (z2 !== void 0 && z2 !== !!z2 && z2 !== 1 && z2 !== 0)
    throw Error(invalidArgument + z2);
  e3 = getBase10Exponent(x2) + 1;
  w2 = x2.d.length - 1;
  sd2 = w2 * LOG_BASE + 1;
  w2 = x2.d[w2];
  if (w2) {
    for (; w2 % 10 == 0; w2 /= 10)
      sd2--;
    for (w2 = x2.d[0]; w2 >= 10; w2 /= 10)
      sd2++;
  }
  return z2 && e3 > sd2 ? e3 : sd2;
};
P.squareRoot = P.sqrt = function() {
  var e3, n2, pr, r2, s2, t2, wpr, x2 = this, Ctor = x2.constructor;
  if (x2.s < 1) {
    if (!x2.s)
      return new Ctor(0);
    throw Error(decimalError + "NaN");
  }
  e3 = getBase10Exponent(x2);
  external = false;
  s2 = Math.sqrt(+x2);
  if (s2 == 0 || s2 == 1 / 0) {
    n2 = digitsToString(x2.d);
    if ((n2.length + e3) % 2 == 0)
      n2 += "0";
    s2 = Math.sqrt(n2);
    e3 = mathfloor((e3 + 1) / 2) - (e3 < 0 || e3 % 2);
    if (s2 == 1 / 0) {
      n2 = "5e" + e3;
    } else {
      n2 = s2.toExponential();
      n2 = n2.slice(0, n2.indexOf("e") + 1) + e3;
    }
    r2 = new Ctor(n2);
  } else {
    r2 = new Ctor(s2.toString());
  }
  pr = Ctor.precision;
  s2 = wpr = pr + 3;
  for (; ; ) {
    t2 = r2;
    r2 = t2.plus(divide2(x2, t2, wpr + 2)).times(0.5);
    if (digitsToString(t2.d).slice(0, wpr) === (n2 = digitsToString(r2.d)).slice(0, wpr)) {
      n2 = n2.slice(wpr - 3, wpr + 1);
      if (s2 == wpr && n2 == "4999") {
        round(t2, pr + 1, 0);
        if (t2.times(t2).eq(x2)) {
          r2 = t2;
          break;
        }
      } else if (n2 != "9999") {
        break;
      }
      wpr += 4;
    }
  }
  external = true;
  return round(r2, pr);
};
P.times = P.mul = function(y2) {
  var carry, e3, i, k2, r2, rL, t2, xdL, ydL, x2 = this, Ctor = x2.constructor, xd2 = x2.d, yd2 = (y2 = new Ctor(y2)).d;
  if (!x2.s || !y2.s)
    return new Ctor(0);
  y2.s *= x2.s;
  e3 = x2.e + y2.e;
  xdL = xd2.length;
  ydL = yd2.length;
  if (xdL < ydL) {
    r2 = xd2;
    xd2 = yd2;
    yd2 = r2;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r2 = [];
  rL = xdL + ydL;
  for (i = rL; i--; )
    r2.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k2 = xdL + i; k2 > i; ) {
      t2 = r2[k2] + yd2[i] * xd2[k2 - i - 1] + carry;
      r2[k2--] = t2 % BASE | 0;
      carry = t2 / BASE | 0;
    }
    r2[k2] = (r2[k2] + carry) % BASE | 0;
  }
  for (; !r2[--rL]; )
    r2.pop();
  if (carry)
    ++e3;
  else
    r2.shift();
  y2.d = r2;
  y2.e = e3;
  return external ? round(y2, Ctor.precision) : y2;
};
P.toDecimalPlaces = P.todp = function(dp, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (dp === void 0)
    return x2;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return round(x2, dp + getBase10Exponent(x2) + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) {
    str = toString3(x2, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x2 = round(new Ctor(x2), dp + 1, rm);
    str = toString3(x2, true, dp + 1);
  }
  return str;
};
P.toFixed = function(dp, rm) {
  var str, y2, x2 = this, Ctor = x2.constructor;
  if (dp === void 0)
    return toString3(x2);
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  y2 = round(new Ctor(x2), dp + getBase10Exponent(x2) + 1, rm);
  str = toString3(y2.abs(), false, dp + getBase10Exponent(y2) + 1);
  return x2.isneg() && !x2.isZero() ? "-" + str : str;
};
P.toInteger = P.toint = function() {
  var x2 = this, Ctor = x2.constructor;
  return round(new Ctor(x2), getBase10Exponent(x2) + 1, Ctor.rounding);
};
P.toNumber = function() {
  return +this;
};
P.toPower = P.pow = function(y2) {
  var e3, k2, pr, r2, sign2, yIsInt, x2 = this, Ctor = x2.constructor, guard = 12, yn2 = +(y2 = new Ctor(y2));
  if (!y2.s)
    return new Ctor(ONE);
  x2 = new Ctor(x2);
  if (!x2.s) {
    if (y2.s < 1)
      throw Error(decimalError + "Infinity");
    return x2;
  }
  if (x2.eq(ONE))
    return x2;
  pr = Ctor.precision;
  if (y2.eq(ONE))
    return round(x2, pr);
  e3 = y2.e;
  k2 = y2.d.length - 1;
  yIsInt = e3 >= k2;
  sign2 = x2.s;
  if (!yIsInt) {
    if (sign2 < 0)
      throw Error(decimalError + "NaN");
  } else if ((k2 = yn2 < 0 ? -yn2 : yn2) <= MAX_SAFE_INTEGER) {
    r2 = new Ctor(ONE);
    e3 = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (k2 % 2) {
        r2 = r2.times(x2);
        truncate(r2.d, e3);
      }
      k2 = mathfloor(k2 / 2);
      if (k2 === 0)
        break;
      x2 = x2.times(x2);
      truncate(x2.d, e3);
    }
    external = true;
    return y2.s < 0 ? new Ctor(ONE).div(r2) : round(r2, pr);
  }
  sign2 = sign2 < 0 && y2.d[Math.max(e3, k2)] & 1 ? -1 : 1;
  x2.s = 1;
  external = false;
  r2 = y2.times(ln(x2, pr + guard));
  external = true;
  r2 = exp(r2);
  r2.s = sign2;
  return r2;
};
P.toPrecision = function(sd2, rm) {
  var e3, str, x2 = this, Ctor = x2.constructor;
  if (sd2 === void 0) {
    e3 = getBase10Exponent(x2);
    str = toString3(x2, e3 <= Ctor.toExpNeg || e3 >= Ctor.toExpPos);
  } else {
    checkInt32(sd2, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x2 = round(new Ctor(x2), sd2, rm);
    e3 = getBase10Exponent(x2);
    str = toString3(x2, sd2 <= e3 || e3 <= Ctor.toExpNeg, sd2);
  }
  return str;
};
P.toSignificantDigits = P.tosd = function(sd2, rm) {
  var x2 = this, Ctor = x2.constructor;
  if (sd2 === void 0) {
    sd2 = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd2, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return round(new Ctor(x2), sd2, rm);
};
P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var x2 = this, e3 = getBase10Exponent(x2), Ctor = x2.constructor;
  return toString3(x2, e3 <= Ctor.toExpNeg || e3 >= Ctor.toExpPos);
};
function add2(x2, y2) {
  var carry, d2, e3, i, k2, len, xd2, yd2, Ctor = x2.constructor, pr = Ctor.precision;
  if (!x2.s || !y2.s) {
    if (!y2.s)
      y2 = new Ctor(x2);
    return external ? round(y2, pr) : y2;
  }
  xd2 = x2.d;
  yd2 = y2.d;
  k2 = x2.e;
  e3 = y2.e;
  xd2 = xd2.slice();
  i = k2 - e3;
  if (i) {
    if (i < 0) {
      d2 = xd2;
      i = -i;
      len = yd2.length;
    } else {
      d2 = yd2;
      e3 = k2;
      len = xd2.length;
    }
    k2 = Math.ceil(pr / LOG_BASE);
    len = k2 > len ? k2 + 1 : len + 1;
    if (i > len) {
      i = len;
      d2.length = 1;
    }
    d2.reverse();
    for (; i--; )
      d2.push(0);
    d2.reverse();
  }
  len = xd2.length;
  i = yd2.length;
  if (len - i < 0) {
    i = len;
    d2 = yd2;
    yd2 = xd2;
    xd2 = d2;
  }
  for (carry = 0; i; ) {
    carry = (xd2[--i] = xd2[i] + yd2[i] + carry) / BASE | 0;
    xd2[i] %= BASE;
  }
  if (carry) {
    xd2.unshift(carry);
    ++e3;
  }
  for (len = xd2.length; xd2[--len] == 0; )
    xd2.pop();
  y2.d = xd2;
  y2.e = e3;
  return external ? round(y2, pr) : y2;
}
function checkInt32(i, min3, max3) {
  if (i !== ~~i || i < min3 || i > max3) {
    throw Error(invalidArgument + i);
  }
}
function digitsToString(d2) {
  var i, k2, ws2, indexOfLastWord = d2.length - 1, str = "", w2 = d2[0];
  if (indexOfLastWord > 0) {
    str += w2;
    for (i = 1; i < indexOfLastWord; i++) {
      ws2 = d2[i] + "";
      k2 = LOG_BASE - ws2.length;
      if (k2)
        str += getZeroString(k2);
      str += ws2;
    }
    w2 = d2[i];
    ws2 = w2 + "";
    k2 = LOG_BASE - ws2.length;
    if (k2)
      str += getZeroString(k2);
  } else if (w2 === 0) {
    return "0";
  }
  for (; w2 % 10 === 0; )
    w2 /= 10;
  return str + w2;
}
var divide2 = function() {
  function multiplyInteger(x2, k2) {
    var temp, carry = 0, i = x2.length;
    for (x2 = x2.slice(); i--; ) {
      temp = x2[i] * k2 + carry;
      x2[i] = temp % BASE | 0;
      carry = temp / BASE | 0;
    }
    if (carry)
      x2.unshift(carry);
    return x2;
  }
  function compare(a2, b2, aL, bL) {
    var i, r2;
    if (aL != bL) {
      r2 = aL > bL ? 1 : -1;
    } else {
      for (i = r2 = 0; i < aL; i++) {
        if (a2[i] != b2[i]) {
          r2 = a2[i] > b2[i] ? 1 : -1;
          break;
        }
      }
    }
    return r2;
  }
  function subtract3(a2, b2, aL) {
    var i = 0;
    for (; aL--; ) {
      a2[aL] -= i;
      i = a2[aL] < b2[aL] ? 1 : 0;
      a2[aL] = i * BASE + a2[aL] - b2[aL];
    }
    for (; !a2[0] && a2.length > 1; )
      a2.shift();
  }
  return function(x2, y2, pr, dp) {
    var cmp, e3, i, k2, prod, prodL, q2, qd2, rem, remL, rem0, sd2, t2, xi2, xL, yd0, yL, yz, Ctor = x2.constructor, sign2 = x2.s == y2.s ? 1 : -1, xd2 = x2.d, yd2 = y2.d;
    if (!x2.s)
      return new Ctor(x2);
    if (!y2.s)
      throw Error(decimalError + "Division by zero");
    e3 = x2.e - y2.e;
    yL = yd2.length;
    xL = xd2.length;
    q2 = new Ctor(sign2);
    qd2 = q2.d = [];
    for (i = 0; yd2[i] == (xd2[i] || 0); )
      ++i;
    if (yd2[i] > (xd2[i] || 0))
      --e3;
    if (pr == null) {
      sd2 = pr = Ctor.precision;
    } else if (dp) {
      sd2 = pr + (getBase10Exponent(x2) - getBase10Exponent(y2)) + 1;
    } else {
      sd2 = pr;
    }
    if (sd2 < 0)
      return new Ctor(0);
    sd2 = sd2 / LOG_BASE + 2 | 0;
    i = 0;
    if (yL == 1) {
      k2 = 0;
      yd2 = yd2[0];
      sd2++;
      for (; (i < xL || k2) && sd2--; i++) {
        t2 = k2 * BASE + (xd2[i] || 0);
        qd2[i] = t2 / yd2 | 0;
        k2 = t2 % yd2 | 0;
      }
    } else {
      k2 = BASE / (yd2[0] + 1) | 0;
      if (k2 > 1) {
        yd2 = multiplyInteger(yd2, k2);
        xd2 = multiplyInteger(xd2, k2);
        yL = yd2.length;
        xL = xd2.length;
      }
      xi2 = yL;
      rem = xd2.slice(0, yL);
      remL = rem.length;
      for (; remL < yL; )
        rem[remL++] = 0;
      yz = yd2.slice();
      yz.unshift(0);
      yd0 = yd2[0];
      if (yd2[1] >= BASE / 2)
        ++yd0;
      do {
        k2 = 0;
        cmp = compare(yd2, rem, yL, remL);
        if (cmp < 0) {
          rem0 = rem[0];
          if (yL != remL)
            rem0 = rem0 * BASE + (rem[1] || 0);
          k2 = rem0 / yd0 | 0;
          if (k2 > 1) {
            if (k2 >= BASE)
              k2 = BASE - 1;
            prod = multiplyInteger(yd2, k2);
            prodL = prod.length;
            remL = rem.length;
            cmp = compare(prod, rem, prodL, remL);
            if (cmp == 1) {
              k2--;
              subtract3(prod, yL < prodL ? yz : yd2, prodL);
            }
          } else {
            if (k2 == 0)
              cmp = k2 = 1;
            prod = yd2.slice();
          }
          prodL = prod.length;
          if (prodL < remL)
            prod.unshift(0);
          subtract3(rem, prod, remL);
          if (cmp == -1) {
            remL = rem.length;
            cmp = compare(yd2, rem, yL, remL);
            if (cmp < 1) {
              k2++;
              subtract3(rem, yL < remL ? yz : yd2, remL);
            }
          }
          remL = rem.length;
        } else if (cmp === 0) {
          k2++;
          rem = [0];
        }
        qd2[i++] = k2;
        if (cmp && rem[0]) {
          rem[remL++] = xd2[xi2] || 0;
        } else {
          rem = [xd2[xi2]];
          remL = 1;
        }
      } while ((xi2++ < xL || rem[0] !== void 0) && sd2--);
    }
    if (!qd2[0])
      qd2.shift();
    q2.e = e3;
    return round(q2, dp ? pr + getBase10Exponent(q2) + 1 : pr);
  };
}();
function exp(x2, sd2) {
  var denominator, guard, pow2, sum2, t2, wpr, i = 0, k2 = 0, Ctor = x2.constructor, pr = Ctor.precision;
  if (getBase10Exponent(x2) > 16)
    throw Error(exponentOutOfRange + getBase10Exponent(x2));
  if (!x2.s)
    return new Ctor(ONE);
  if (sd2 == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd2;
  }
  t2 = new Ctor(0.03125);
  while (x2.abs().gte(0.1)) {
    x2 = x2.times(t2);
    k2 += 5;
  }
  guard = Math.log(mathpow(2, k2)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum2 = new Ctor(ONE);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = round(pow2.times(x2), wpr);
    denominator = denominator.times(++i);
    t2 = sum2.plus(divide2(pow2, denominator, wpr));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      while (k2--)
        sum2 = round(sum2.times(sum2), wpr);
      Ctor.precision = pr;
      return sd2 == null ? (external = true, round(sum2, pr)) : sum2;
    }
    sum2 = t2;
  }
}
function getBase10Exponent(x2) {
  var e3 = x2.e * LOG_BASE, w2 = x2.d[0];
  for (; w2 >= 10; w2 /= 10)
    e3++;
  return e3;
}
function getLn10(Ctor, sd2, pr) {
  if (sd2 > Ctor.LN10.sd()) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(decimalError + "LN10 precision limit exceeded");
  }
  return round(new Ctor(Ctor.LN10), sd2);
}
function getZeroString(k2) {
  var zs2 = "";
  for (; k2--; )
    zs2 += "0";
  return zs2;
}
function ln(y2, sd2) {
  var c2, c0, denominator, e3, numerator, sum2, t2, wpr, x2, n2 = 1, guard = 10, x3 = y2, xd2 = x3.d, Ctor = x3.constructor, pr = Ctor.precision;
  if (x3.s < 1)
    throw Error(decimalError + (x3.s ? "NaN" : "-Infinity"));
  if (x3.eq(ONE))
    return new Ctor(0);
  if (sd2 == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd2;
  }
  if (x3.eq(10)) {
    if (sd2 == null)
      external = true;
    return getLn10(Ctor, wpr);
  }
  wpr += guard;
  Ctor.precision = wpr;
  c2 = digitsToString(xd2);
  c0 = c2.charAt(0);
  e3 = getBase10Exponent(x3);
  if (Math.abs(e3) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
      x3 = x3.times(y2);
      c2 = digitsToString(x3.d);
      c0 = c2.charAt(0);
      n2++;
    }
    e3 = getBase10Exponent(x3);
    if (c0 > 1) {
      x3 = new Ctor("0." + c2);
      e3++;
    } else {
      x3 = new Ctor(c0 + "." + c2.slice(1));
    }
  } else {
    t2 = getLn10(Ctor, wpr + 2, pr).times(e3 + "");
    x3 = ln(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t2);
    Ctor.precision = pr;
    return sd2 == null ? (external = true, round(x3, pr)) : x3;
  }
  sum2 = numerator = x3 = divide2(x3.minus(ONE), x3.plus(ONE), wpr);
  x2 = round(x3.times(x3), wpr);
  denominator = 3;
  for (; ; ) {
    numerator = round(numerator.times(x2), wpr);
    t2 = sum2.plus(divide2(numerator, new Ctor(denominator), wpr));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e3 !== 0)
        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e3 + ""));
      sum2 = divide2(sum2, new Ctor(n2), wpr);
      Ctor.precision = pr;
      return sd2 == null ? (external = true, round(sum2, pr)) : sum2;
    }
    sum2 = t2;
    denominator += 2;
  }
}
function parseDecimal(x2, str) {
  var e3, i, len;
  if ((e3 = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e3 < 0)
      e3 = i;
    e3 += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e3 < 0) {
    e3 = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; )
    ++i;
  for (len = str.length; str.charCodeAt(len - 1) === 48; )
    --len;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    e3 = e3 - i - 1;
    x2.e = mathfloor(e3 / LOG_BASE);
    x2.d = [];
    i = (e3 + 1) % LOG_BASE;
    if (e3 < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x2.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; )
        x2.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; )
      str += "0";
    x2.d.push(+str);
    if (external && (x2.e > MAX_E || x2.e < -MAX_E))
      throw Error(exponentOutOfRange + e3);
  } else {
    x2.s = 0;
    x2.e = 0;
    x2.d = [0];
  }
  return x2;
}
function round(x2, sd2, rm) {
  var i, j2, k2, n2, rd2, doRound, w2, xdi, xd2 = x2.d;
  for (n2 = 1, k2 = xd2[0]; k2 >= 10; k2 /= 10)
    n2++;
  i = sd2 - n2;
  if (i < 0) {
    i += LOG_BASE;
    j2 = sd2;
    w2 = xd2[xdi = 0];
  } else {
    xdi = Math.ceil((i + 1) / LOG_BASE);
    k2 = xd2.length;
    if (xdi >= k2)
      return x2;
    w2 = k2 = xd2[xdi];
    for (n2 = 1; k2 >= 10; k2 /= 10)
      n2++;
    i %= LOG_BASE;
    j2 = i - LOG_BASE + n2;
  }
  if (rm !== void 0) {
    k2 = mathpow(10, n2 - j2 - 1);
    rd2 = w2 / k2 % 10 | 0;
    doRound = sd2 < 0 || xd2[xdi + 1] !== void 0 || w2 % k2;
    doRound = rm < 4 ? (rd2 || doRound) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd2 > 5 || rd2 == 5 && (rm == 4 || doRound || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i > 0 ? j2 > 0 ? w2 / mathpow(10, n2 - j2) : 0 : xd2[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
  }
  if (sd2 < 1 || !xd2[0]) {
    if (doRound) {
      k2 = getBase10Exponent(x2);
      xd2.length = 1;
      sd2 = sd2 - k2 - 1;
      xd2[0] = mathpow(10, (LOG_BASE - sd2 % LOG_BASE) % LOG_BASE);
      x2.e = mathfloor(-sd2 / LOG_BASE) || 0;
    } else {
      xd2.length = 1;
      xd2[0] = x2.e = x2.s = 0;
    }
    return x2;
  }
  if (i == 0) {
    xd2.length = xdi;
    k2 = 1;
    xdi--;
  } else {
    xd2.length = xdi + 1;
    k2 = mathpow(10, LOG_BASE - i);
    xd2[xdi] = j2 > 0 ? (w2 / mathpow(10, n2 - j2) % mathpow(10, j2) | 0) * k2 : 0;
  }
  if (doRound) {
    for (; ; ) {
      if (xdi == 0) {
        if ((xd2[0] += k2) == BASE) {
          xd2[0] = 1;
          ++x2.e;
        }
        break;
      } else {
        xd2[xdi] += k2;
        if (xd2[xdi] != BASE)
          break;
        xd2[xdi--] = 0;
        k2 = 1;
      }
    }
  }
  for (i = xd2.length; xd2[--i] === 0; )
    xd2.pop();
  if (external && (x2.e > MAX_E || x2.e < -MAX_E)) {
    throw Error(exponentOutOfRange + getBase10Exponent(x2));
  }
  return x2;
}
function subtract2(x2, y2) {
  var d2, e3, i, j2, k2, len, xd2, xe, xLTy, yd2, Ctor = x2.constructor, pr = Ctor.precision;
  if (!x2.s || !y2.s) {
    if (y2.s)
      y2.s = -y2.s;
    else
      y2 = new Ctor(x2);
    return external ? round(y2, pr) : y2;
  }
  xd2 = x2.d;
  yd2 = y2.d;
  e3 = y2.e;
  xe = x2.e;
  xd2 = xd2.slice();
  k2 = xe - e3;
  if (k2) {
    xLTy = k2 < 0;
    if (xLTy) {
      d2 = xd2;
      k2 = -k2;
      len = yd2.length;
    } else {
      d2 = yd2;
      e3 = xe;
      len = xd2.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k2 > i) {
      k2 = i;
      d2.length = 1;
    }
    d2.reverse();
    for (i = k2; i--; )
      d2.push(0);
    d2.reverse();
  } else {
    i = xd2.length;
    len = yd2.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0; i < len; i++) {
      if (xd2[i] != yd2[i]) {
        xLTy = xd2[i] < yd2[i];
        break;
      }
    }
    k2 = 0;
  }
  if (xLTy) {
    d2 = xd2;
    xd2 = yd2;
    yd2 = d2;
    y2.s = -y2.s;
  }
  len = xd2.length;
  for (i = yd2.length - len; i > 0; --i)
    xd2[len++] = 0;
  for (i = yd2.length; i > k2; ) {
    if (xd2[--i] < yd2[i]) {
      for (j2 = i; j2 && xd2[--j2] === 0; )
        xd2[j2] = BASE - 1;
      --xd2[j2];
      xd2[i] += BASE;
    }
    xd2[i] -= yd2[i];
  }
  for (; xd2[--len] === 0; )
    xd2.pop();
  for (; xd2[0] === 0; xd2.shift())
    --e3;
  if (!xd2[0])
    return new Ctor(0);
  y2.d = xd2;
  y2.e = e3;
  return external ? round(y2, pr) : y2;
}
function toString3(x2, isExp, sd2) {
  var k2, e3 = getBase10Exponent(x2), str = digitsToString(x2.d), len = str.length;
  if (isExp) {
    if (sd2 && (k2 = sd2 - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k2);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (e3 < 0 ? "e" : "e+") + e3;
  } else if (e3 < 0) {
    str = "0." + getZeroString(-e3 - 1) + str;
    if (sd2 && (k2 = sd2 - len) > 0)
      str += getZeroString(k2);
  } else if (e3 >= len) {
    str += getZeroString(e3 + 1 - len);
    if (sd2 && (k2 = sd2 - e3 - 1) > 0)
      str = str + "." + getZeroString(k2);
  } else {
    if ((k2 = e3 + 1) < len)
      str = str.slice(0, k2) + "." + str.slice(k2);
    if (sd2 && (k2 = sd2 - len) > 0) {
      if (e3 + 1 === len)
        str += ".";
      str += getZeroString(k2);
    }
  }
  return x2.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function clone2(obj) {
  var i, p2, ps2;
  function Decimal2(value) {
    var x2 = this;
    if (!(x2 instanceof Decimal2))
      return new Decimal2(value);
    x2.constructor = Decimal2;
    if (value instanceof Decimal2) {
      x2.s = value.s;
      x2.e = value.e;
      x2.d = (value = value.d) ? value.slice() : value;
      return;
    }
    if (typeof value === "number") {
      if (value * 0 !== 0) {
        throw Error(invalidArgument + value);
      }
      if (value > 0) {
        x2.s = 1;
      } else if (value < 0) {
        value = -value;
        x2.s = -1;
      } else {
        x2.s = 0;
        x2.e = 0;
        x2.d = [0];
        return;
      }
      if (value === ~~value && value < 1e7) {
        x2.e = 0;
        x2.d = [value];
        return;
      }
      return parseDecimal(x2, value.toString());
    } else if (typeof value !== "string") {
      throw Error(invalidArgument + value);
    }
    if (value.charCodeAt(0) === 45) {
      value = value.slice(1);
      x2.s = -1;
    } else {
      x2.s = 1;
    }
    if (isDecimal.test(value))
      parseDecimal(x2, value);
    else
      throw Error(invalidArgument + value);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.clone = clone2;
  Decimal2.config = Decimal2.set = config;
  if (obj === void 0)
    obj = {};
  if (obj) {
    ps2 = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
    for (i = 0; i < ps2.length; )
      if (!obj.hasOwnProperty(p2 = ps2[i++]))
        obj[p2] = this[p2];
  }
  Decimal2.config(obj);
  return Decimal2;
}
function config(obj) {
  if (!obj || typeof obj !== "object") {
    throw Error(decimalError + "Object expected");
  }
  var i, p2, v2, ps2 = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (i = 0; i < ps2.length; i += 3) {
    if ((v2 = obj[p2 = ps2[i]]) !== void 0) {
      if (mathfloor(v2) === v2 && v2 >= ps2[i + 1] && v2 <= ps2[i + 2])
        this[p2] = v2;
      else
        throw Error(invalidArgument + p2 + ": " + v2);
    }
  }
  if ((v2 = obj[p2 = "LN10"]) !== void 0) {
    if (v2 == Math.LN10)
      this[p2] = new this(v2);
    else
      throw Error(invalidArgument + p2 + ": " + v2);
  }
  return this;
}
var Decimal = clone2(defaults);
ONE = new Decimal(1);
const Decimal$1 = Decimal;
function _toConsumableArray$6(arr) {
  return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread$6();
}
function _nonIterableSpread$6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$8(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$8(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$8(o3, minLen);
}
function _iterableToArray$6(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _arrayWithoutHoles$6(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$8(arr);
}
function _arrayLikeToArray$8(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var identity3 = function identity4(i) {
  return i;
};
var PLACE_HOLDER = {
  "@@functional/placeholder": true
};
var isPlaceHolder = function isPlaceHolder2(val) {
  return val === PLACE_HOLDER;
};
var curry0 = function curry02(fn2) {
  return function _curried() {
    if (arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? void 0 : arguments[0])) {
      return _curried;
    }
    return fn2.apply(void 0, arguments);
  };
};
var curryN2 = function curryN3(n2, fn2) {
  if (n2 === 1) {
    return fn2;
  }
  return curry0(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var argsLength = args.filter(function(arg) {
      return arg !== PLACE_HOLDER;
    }).length;
    if (argsLength >= n2) {
      return fn2.apply(void 0, args);
    }
    return curryN3(n2 - argsLength, curry0(function() {
      for (var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        restArgs[_key2] = arguments[_key2];
      }
      var newArgs = args.map(function(arg) {
        return isPlaceHolder(arg) ? restArgs.shift() : arg;
      });
      return fn2.apply(void 0, _toConsumableArray$6(newArgs).concat(restArgs));
    }));
  });
};
var curry2 = function curry3(fn2) {
  return curryN2(fn2.length, fn2);
};
var range$1 = function range2(begin, end) {
  var arr = [];
  for (var i = begin; i < end; ++i) {
    arr[i - begin] = i;
  }
  return arr;
};
var map2 = curry2(function(fn2, arr) {
  if (Array.isArray(arr)) {
    return arr.map(fn2);
  }
  return Object.keys(arr).map(function(key) {
    return arr[key];
  }).map(fn2);
});
var compose = function compose2() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }
  if (!args.length) {
    return identity3;
  }
  var fns = args.reverse();
  var firstFn = fns[0];
  var tailsFn = fns.slice(1);
  return function() {
    return tailsFn.reduce(function(res, fn2) {
      return fn2(res);
    }, firstFn.apply(void 0, arguments));
  };
};
var reverse2 = function reverse3(arr) {
  if (Array.isArray(arr)) {
    return arr.reverse();
  }
  return arr.split("").reverse.join("");
};
var memoize = function memoize2(fn2) {
  var lastArgs = null;
  var lastResult2 = null;
  return function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    if (lastArgs && args.every(function(val, i) {
      return val === lastArgs[i];
    })) {
      return lastResult2;
    }
    lastArgs = args;
    lastResult2 = fn2.apply(void 0, args);
    return lastResult2;
  };
};
function getDigitCount(value) {
  var result;
  if (value === 0) {
    result = 1;
  } else {
    result = Math.floor(new Decimal$1(value).abs().log(10).toNumber()) + 1;
  }
  return result;
}
function rangeStep(start, end, step) {
  var num = new Decimal$1(start);
  var i = 0;
  var result = [];
  while (num.lt(end) && i < 1e5) {
    result.push(num.toNumber());
    num = num.add(step);
    i++;
  }
  return result;
}
var interpolateNumber2 = curry2(function(a2, b2, t2) {
  var newA = +a2;
  var newB = +b2;
  return newA + t2 * (newB - newA);
});
var uninterpolateNumber = curry2(function(a2, b2, x2) {
  var diff2 = b2 - +a2;
  diff2 = diff2 || Infinity;
  return (x2 - a2) / diff2;
});
var uninterpolateTruncation = curry2(function(a2, b2, x2) {
  var diff2 = b2 - +a2;
  diff2 = diff2 || Infinity;
  return Math.max(0, Math.min(1, (x2 - a2) / diff2));
});
const Arithmetic = {
  rangeStep,
  getDigitCount,
  interpolateNumber: interpolateNumber2,
  uninterpolateNumber,
  uninterpolateTruncation
};
function _toConsumableArray$5(arr) {
  return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$5();
}
function _nonIterableSpread$5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$5(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _arrayWithoutHoles$5(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$7(arr);
}
function _slicedToArray$3(arr, i) {
  return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$7(arr, i) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$7(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$7(o3, minLen);
}
function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$3(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _e2 = void 0;
  try {
    for (var _i2 = arr[Symbol.iterator](), _s2; !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
      _arr.push(_s2.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i2["return"] != null)
        _i2["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles$3(arr) {
  if (Array.isArray(arr))
    return arr;
}
function getValidInterval(_ref) {
  var _ref2 = _slicedToArray$3(_ref, 2), min3 = _ref2[0], max3 = _ref2[1];
  var validMin = min3, validMax = max3;
  if (min3 > max3) {
    validMin = max3;
    validMax = min3;
  }
  return [validMin, validMax];
}
function getFormatStep(roughStep, allowDecimals, correctionFactor) {
  if (roughStep.lte(0)) {
    return new Decimal$1(0);
  }
  var digitCount = Arithmetic.getDigitCount(roughStep.toNumber());
  var digitCountValue = new Decimal$1(10).pow(digitCount);
  var stepRatio = roughStep.div(digitCountValue);
  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;
  var amendStepRatio = new Decimal$1(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);
  var formatStep = amendStepRatio.mul(digitCountValue);
  return allowDecimals ? formatStep : new Decimal$1(Math.ceil(formatStep));
}
function getTickOfSingleValue(value, tickCount, allowDecimals) {
  var step = 1;
  var middle = new Decimal$1(value);
  if (!middle.isint() && allowDecimals) {
    var absVal = Math.abs(value);
    if (absVal < 1) {
      step = new Decimal$1(10).pow(Arithmetic.getDigitCount(value) - 1);
      middle = new Decimal$1(Math.floor(middle.div(step).toNumber())).mul(step);
    } else if (absVal > 1) {
      middle = new Decimal$1(Math.floor(value));
    }
  } else if (value === 0) {
    middle = new Decimal$1(Math.floor((tickCount - 1) / 2));
  } else if (!allowDecimals) {
    middle = new Decimal$1(Math.floor(value));
  }
  var middleIndex = Math.floor((tickCount - 1) / 2);
  var fn2 = compose(map2(function(n2) {
    return middle.add(new Decimal$1(n2 - middleIndex).mul(step)).toNumber();
  }), range$1);
  return fn2(0, tickCount);
}
function calculateStep(min3, max3, tickCount, allowDecimals) {
  var correctionFactor = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  if (!Number.isFinite((max3 - min3) / (tickCount - 1))) {
    return {
      step: new Decimal$1(0),
      tickMin: new Decimal$1(0),
      tickMax: new Decimal$1(0)
    };
  }
  var step = getFormatStep(new Decimal$1(max3).sub(min3).div(tickCount - 1), allowDecimals, correctionFactor);
  var middle;
  if (min3 <= 0 && max3 >= 0) {
    middle = new Decimal$1(0);
  } else {
    middle = new Decimal$1(min3).add(max3).div(2);
    middle = middle.sub(new Decimal$1(middle).mod(step));
  }
  var belowCount = Math.ceil(middle.sub(min3).div(step).toNumber());
  var upCount = Math.ceil(new Decimal$1(max3).sub(middle).div(step).toNumber());
  var scaleCount = belowCount + upCount + 1;
  if (scaleCount > tickCount) {
    return calculateStep(min3, max3, tickCount, allowDecimals, correctionFactor + 1);
  }
  if (scaleCount < tickCount) {
    upCount = max3 > 0 ? upCount + (tickCount - scaleCount) : upCount;
    belowCount = max3 > 0 ? belowCount : belowCount + (tickCount - scaleCount);
  }
  return {
    step,
    tickMin: middle.sub(new Decimal$1(belowCount).mul(step)),
    tickMax: middle.add(new Decimal$1(upCount).mul(step))
  };
}
function getNiceTickValuesFn(_ref3) {
  var _ref4 = _slicedToArray$3(_ref3, 2), min3 = _ref4[0], max3 = _ref4[1];
  var tickCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
  var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var count2 = Math.max(tickCount, 2);
  var _getValidInterval = getValidInterval([min3, max3]), _getValidInterval2 = _slicedToArray$3(_getValidInterval, 2), cormin = _getValidInterval2[0], cormax = _getValidInterval2[1];
  if (cormin === -Infinity || cormax === Infinity) {
    var _values = cormax === Infinity ? [cormin].concat(_toConsumableArray$5(range$1(0, tickCount - 1).map(function() {
      return Infinity;
    }))) : [].concat(_toConsumableArray$5(range$1(0, tickCount - 1).map(function() {
      return -Infinity;
    })), [cormax]);
    return min3 > max3 ? reverse2(_values) : _values;
  }
  if (cormin === cormax) {
    return getTickOfSingleValue(cormin, tickCount, allowDecimals);
  }
  var _calculateStep = calculateStep(cormin, cormax, count2, allowDecimals), step = _calculateStep.step, tickMin = _calculateStep.tickMin, tickMax = _calculateStep.tickMax;
  var values3 = Arithmetic.rangeStep(tickMin, tickMax.add(new Decimal$1(0.1).mul(step)), step);
  return min3 > max3 ? reverse2(values3) : values3;
}
function getTickValuesFixedDomainFn(_ref7, tickCount) {
  var _ref8 = _slicedToArray$3(_ref7, 2), min3 = _ref8[0], max3 = _ref8[1];
  var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var _getValidInterval5 = getValidInterval([min3, max3]), _getValidInterval6 = _slicedToArray$3(_getValidInterval5, 2), cormin = _getValidInterval6[0], cormax = _getValidInterval6[1];
  if (cormin === -Infinity || cormax === Infinity) {
    return [min3, max3];
  }
  if (cormin === cormax) {
    return [cormin];
  }
  var count2 = Math.max(tickCount, 2);
  var step = getFormatStep(new Decimal$1(cormax).sub(cormin).div(count2 - 1), allowDecimals, 0);
  var values3 = [].concat(_toConsumableArray$5(Arithmetic.rangeStep(new Decimal$1(cormin), new Decimal$1(cormax).sub(new Decimal$1(0.99).mul(step)), step)), [cormax]);
  return min3 > max3 ? reverse2(values3) : values3;
}
var getNiceTickValues = memoize(getNiceTickValuesFn);
var getTickValuesFixedDomain = memoize(getTickValuesFixedDomainFn);
var _excluded$5 = ["offset", "layout", "width", "dataKey", "data", "dataPointFormatter", "xAxis", "yAxis"];
function _extends$f() {
  _extends$f = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$f.apply(this, arguments);
}
function _slicedToArray$2(arr, i) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$6(arr, i) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$6(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$6(o3, minLen);
}
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$2(arr, i) {
  var _i2 = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i2) {
    var _s2, _e2, _x, _r, _arr = [], _n2 = true, _d = false;
    try {
      if (_x = (_i2 = _i2.call(arr)).next, 0 === i) {
        if (Object(_i2) !== _i2)
          return;
        _n2 = false;
      } else
        for (; !(_n2 = (_s2 = _x.call(_i2)).done) && (_arr.push(_s2.value), _arr.length !== i); _n2 = true)
          ;
    } catch (err) {
      _d = true, _e2 = err;
    } finally {
      try {
        if (!_n2 && null != _i2["return"] && (_r = _i2["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _objectWithoutProperties$5(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$5(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function ErrorBar(props3) {
  var offset2 = props3.offset, layout = props3.layout, width = props3.width, dataKey = props3.dataKey, data2 = props3.data, dataPointFormatter = props3.dataPointFormatter, xAxis = props3.xAxis, yAxis = props3.yAxis, others = _objectWithoutProperties$5(props3, _excluded$5);
  var svgProps = filterProps(others);
  var errorBars = data2.map(function(entry, i) {
    var _dataPointFormatter = dataPointFormatter(entry, dataKey), x2 = _dataPointFormatter.x, y2 = _dataPointFormatter.y, value = _dataPointFormatter.value, errorVal = _dataPointFormatter.errorVal;
    if (!errorVal) {
      return null;
    }
    var lineCoordinates = [];
    var lowBound, highBound;
    if (Array.isArray(errorVal)) {
      var _errorVal = _slicedToArray$2(errorVal, 2);
      lowBound = _errorVal[0];
      highBound = _errorVal[1];
    } else {
      lowBound = highBound = errorVal;
    }
    if (layout === "vertical") {
      var scale = xAxis.scale;
      var yMid = y2 + offset2;
      var yMin = yMid + width;
      var yMax = yMid - width;
      var xMin = scale(value - lowBound);
      var xMax = scale(value + highBound);
      lineCoordinates.push({
        x1: xMax,
        y1: yMin,
        x2: xMax,
        y2: yMax
      });
      lineCoordinates.push({
        x1: xMin,
        y1: yMid,
        x2: xMax,
        y2: yMid
      });
      lineCoordinates.push({
        x1: xMin,
        y1: yMin,
        x2: xMin,
        y2: yMax
      });
    } else if (layout === "horizontal") {
      var _scale = yAxis.scale;
      var xMid = x2 + offset2;
      var _xMin = xMid - width;
      var _xMax = xMid + width;
      var _yMin = _scale(value - lowBound);
      var _yMax = _scale(value + highBound);
      lineCoordinates.push({
        x1: _xMin,
        y1: _yMax,
        x2: _xMax,
        y2: _yMax
      });
      lineCoordinates.push({
        x1: xMid,
        y1: _yMin,
        x2: xMid,
        y2: _yMax
      });
      lineCoordinates.push({
        x1: _xMin,
        y1: _yMin,
        x2: _xMax,
        y2: _yMin
      });
    }
    return (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ React.createElement(Layer, _extends$f({
        className: "recharts-errorBar",
        key: "bar-".concat(i)
      }, svgProps), lineCoordinates.map(function(coordinates, index3) {
        return (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ React.createElement("line", _extends$f({}, coordinates, {
            key: "line-".concat(index3)
          }))
        );
      }))
    );
  });
  return /* @__PURE__ */ React.createElement(Layer, {
    className: "recharts-errorBars"
  }, errorBars);
}
ErrorBar.defaultProps = {
  stroke: "black",
  strokeWidth: 1.5,
  width: 5,
  offset: 0,
  layout: "horizontal"
};
ErrorBar.displayName = "ErrorBar";
function _typeof$j(obj) {
  "@babel/helpers - typeof";
  return _typeof$j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$j(obj);
}
function _toConsumableArray$4(arr) {
  return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$5(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$5(o3, minLen);
}
function _iterableToArray$4(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$4(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$5(arr);
}
function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function ownKeys$f(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$f(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$f(Object(source), true).forEach(function(key) {
      _defineProperty$i(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$i(obj, key, value) {
  key = _toPropertyKey$j(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$j(arg) {
  var key = _toPrimitive$j(arg, "string");
  return _typeof$j(key) === "symbol" ? key : String(key);
}
function _toPrimitive$j(input, hint) {
  if (_typeof$j(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$j(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function getValueByDataKey(obj, dataKey, defaultValue) {
  if (_isNil(obj) || _isNil(dataKey)) {
    return defaultValue;
  }
  if (isNumOrStr(dataKey)) {
    return _get(obj, dataKey, defaultValue);
  }
  if (_isFunction(dataKey)) {
    return dataKey(obj);
  }
  return defaultValue;
}
function getDomainOfDataByKey(data2, key, type3, filterNil) {
  var flattenData = _flatMap(data2, function(entry) {
    return getValueByDataKey(entry, key);
  });
  if (type3 === "number") {
    var domain = flattenData.filter(function(entry) {
      return isNumber(entry) || parseFloat(entry);
    });
    return domain.length ? [_min(domain), _max(domain)] : [Infinity, -Infinity];
  }
  var validateData = filterNil ? flattenData.filter(function(entry) {
    return !_isNil(entry);
  }) : flattenData;
  return validateData.map(function(entry) {
    return isNumOrStr(entry) || entry instanceof Date ? entry : "";
  });
}
var calculateActiveTickIndex = function calculateActiveTickIndex2(coordinate) {
  var _ticks$length;
  var ticks2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var unsortedTicks = arguments.length > 2 ? arguments[2] : void 0;
  var axis = arguments.length > 3 ? arguments[3] : void 0;
  var index3 = -1;
  var len = (_ticks$length = ticks2 === null || ticks2 === void 0 ? void 0 : ticks2.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;
  if (len <= 1) {
    return 0;
  }
  if (axis && axis.axisType === "angleAxis" && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {
    var range4 = axis.range;
    for (var i = 0; i < len; i++) {
      var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;
      var cur = unsortedTicks[i].coordinate;
      var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;
      var sameDirectionCoord = void 0;
      if (mathSign(cur - before) !== mathSign(after - cur)) {
        var diffInterval = [];
        if (mathSign(after - cur) === mathSign(range4[1] - range4[0])) {
          sameDirectionCoord = after;
          var curInRange = cur + range4[1] - range4[0];
          diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);
          diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);
        } else {
          sameDirectionCoord = before;
          var afterInRange = after + range4[1] - range4[0];
          diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);
          diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
        }
        var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];
        if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
          index3 = unsortedTicks[i].index;
          break;
        }
      } else {
        var min3 = Math.min(before, after);
        var max3 = Math.max(before, after);
        if (coordinate > (min3 + cur) / 2 && coordinate <= (max3 + cur) / 2) {
          index3 = unsortedTicks[i].index;
          break;
        }
      }
    }
  } else {
    for (var _i2 = 0; _i2 < len; _i2++) {
      if (_i2 === 0 && coordinate <= (ticks2[_i2].coordinate + ticks2[_i2 + 1].coordinate) / 2 || _i2 > 0 && _i2 < len - 1 && coordinate > (ticks2[_i2].coordinate + ticks2[_i2 - 1].coordinate) / 2 && coordinate <= (ticks2[_i2].coordinate + ticks2[_i2 + 1].coordinate) / 2 || _i2 === len - 1 && coordinate > (ticks2[_i2].coordinate + ticks2[_i2 - 1].coordinate) / 2) {
        index3 = ticks2[_i2].index;
        break;
      }
    }
  }
  return index3;
};
var getMainColorOfGraphicItem = function getMainColorOfGraphicItem2(item) {
  var _ref = item, displayName = _ref.type.displayName;
  var _item$props = item.props, stroke = _item$props.stroke, fill = _item$props.fill;
  var result;
  switch (displayName) {
    case "Line":
      result = stroke;
      break;
    case "Area":
    case "Radar":
      result = stroke && stroke !== "none" ? stroke : fill;
      break;
    default:
      result = fill;
      break;
  }
  return result;
};
var getLegendProps = function getLegendProps2(_ref2) {
  var children = _ref2.children, formattedGraphicalItems = _ref2.formattedGraphicalItems, legendWidth = _ref2.legendWidth, legendContent = _ref2.legendContent;
  var legendItem = findChildByType(children, Legend);
  if (!legendItem) {
    return null;
  }
  var legendData;
  if (legendItem.props && legendItem.props.payload) {
    legendData = legendItem.props && legendItem.props.payload;
  } else if (legendContent === "children") {
    legendData = (formattedGraphicalItems || []).reduce(function(result, _ref3) {
      var item = _ref3.item, props3 = _ref3.props;
      var data2 = props3.sectors || props3.data || [];
      return result.concat(data2.map(function(entry) {
        return {
          type: legendItem.props.iconType || item.props.legendType,
          value: entry.name,
          color: entry.fill,
          payload: entry
        };
      }));
    }, []);
  } else {
    legendData = (formattedGraphicalItems || []).map(function(_ref4) {
      var item = _ref4.item;
      var _item$props2 = item.props, dataKey = _item$props2.dataKey, name = _item$props2.name, legendType = _item$props2.legendType, hide = _item$props2.hide;
      return {
        inactive: hide,
        dataKey,
        type: legendItem.props.iconType || legendType || "square",
        color: getMainColorOfGraphicItem(item),
        value: name || dataKey,
        payload: item.props
      };
    });
  }
  return _objectSpread$f(_objectSpread$f(_objectSpread$f({}, legendItem.props), Legend.getWithHeight(legendItem, legendWidth)), {}, {
    payload: legendData,
    item: legendItem
  });
};
var getBarSizeList = function getBarSizeList2(_ref5) {
  var globalSize = _ref5.barSize, _ref5$stackGroups = _ref5.stackGroups, stackGroups = _ref5$stackGroups === void 0 ? {} : _ref5$stackGroups;
  if (!stackGroups) {
    return {};
  }
  var result = {};
  var numericAxisIds = Object.keys(stackGroups);
  for (var i = 0, len = numericAxisIds.length; i < len; i++) {
    var sgs = stackGroups[numericAxisIds[i]].stackGroups;
    var stackIds = Object.keys(sgs);
    for (var j2 = 0, sLen = stackIds.length; j2 < sLen; j2++) {
      var _sgs$stackIds$j = sgs[stackIds[j2]], items = _sgs$stackIds$j.items, cateAxisId = _sgs$stackIds$j.cateAxisId;
      var barItems = items.filter(function(item) {
        return getDisplayName(item.type).indexOf("Bar") >= 0;
      });
      if (barItems && barItems.length) {
        var selfSize = barItems[0].props.barSize;
        var cateId = barItems[0].props[cateAxisId];
        if (!result[cateId]) {
          result[cateId] = [];
        }
        result[cateId].push({
          item: barItems[0],
          stackList: barItems.slice(1),
          barSize: _isNil(selfSize) ? globalSize : selfSize
        });
      }
    }
  }
  return result;
};
var getBarPosition = function getBarPosition2(_ref6) {
  var barGap = _ref6.barGap, barCategoryGap = _ref6.barCategoryGap, bandSize = _ref6.bandSize, _ref6$sizeList = _ref6.sizeList, sizeList = _ref6$sizeList === void 0 ? [] : _ref6$sizeList, maxBarSize = _ref6.maxBarSize;
  var len = sizeList.length;
  if (len < 1)
    return null;
  var realBarGap = getPercentValue(barGap, bandSize, 0, true);
  var result;
  if (sizeList[0].barSize === +sizeList[0].barSize) {
    var useFull = false;
    var fullBarSize = bandSize / len;
    var sum2 = sizeList.reduce(function(res, entry) {
      return res + entry.barSize || 0;
    }, 0);
    sum2 += (len - 1) * realBarGap;
    if (sum2 >= bandSize) {
      sum2 -= (len - 1) * realBarGap;
      realBarGap = 0;
    }
    if (sum2 >= bandSize && fullBarSize > 0) {
      useFull = true;
      fullBarSize *= 0.9;
      sum2 = len * fullBarSize;
    }
    var offset2 = (bandSize - sum2) / 2 >> 0;
    var prev = {
      offset: offset2 - realBarGap,
      size: 0
    };
    result = sizeList.reduce(function(res, entry) {
      var newRes = [].concat(_toConsumableArray$4(res), [{
        item: entry.item,
        position: {
          offset: prev.offset + prev.size + realBarGap,
          size: useFull ? fullBarSize : entry.barSize
        }
      }]);
      prev = newRes[newRes.length - 1].position;
      if (entry.stackList && entry.stackList.length) {
        entry.stackList.forEach(function(item) {
          newRes.push({
            item,
            position: prev
          });
        });
      }
      return newRes;
    }, []);
  } else {
    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);
    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {
      realBarGap = 0;
    }
    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
    if (originalSize > 1) {
      originalSize >>= 0;
    }
    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;
    result = sizeList.reduce(function(res, entry, i) {
      var newRes = [].concat(_toConsumableArray$4(res), [{
        item: entry.item,
        position: {
          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,
          size
        }
      }]);
      if (entry.stackList && entry.stackList.length) {
        entry.stackList.forEach(function(item) {
          newRes.push({
            item,
            position: newRes[newRes.length - 1].position
          });
        });
      }
      return newRes;
    }, []);
  }
  return result;
};
var appendOffsetOfLegend = function appendOffsetOfLegend2(offset2, items, props3, legendBox) {
  var children = props3.children, width = props3.width, margin = props3.margin;
  var legendWidth = width - (margin.left || 0) - (margin.right || 0);
  var legendProps = getLegendProps({
    children,
    legendWidth
  });
  var newOffset = offset2;
  if (legendProps) {
    var box = legendBox || {};
    var align = legendProps.align, verticalAlign = legendProps.verticalAlign, layout = legendProps.layout;
    if ((layout === "vertical" || layout === "horizontal" && verticalAlign === "middle") && isNumber(offset2[align])) {
      newOffset = _objectSpread$f(_objectSpread$f({}, offset2), {}, _defineProperty$i({}, align, newOffset[align] + (box.width || 0)));
    }
    if ((layout === "horizontal" || layout === "vertical" && align === "center") && isNumber(offset2[verticalAlign])) {
      newOffset = _objectSpread$f(_objectSpread$f({}, offset2), {}, _defineProperty$i({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));
    }
  }
  return newOffset;
};
var isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis2(layout, axisType, direction) {
  if (_isNil(axisType)) {
    return true;
  }
  if (layout === "horizontal") {
    return axisType === "yAxis";
  }
  if (layout === "vertical") {
    return axisType === "xAxis";
  }
  if (direction === "x") {
    return axisType === "xAxis";
  }
  if (direction === "y") {
    return axisType === "yAxis";
  }
  return true;
};
var getDomainOfErrorBars = function getDomainOfErrorBars2(data2, item, dataKey, layout, axisType) {
  var children = item.props.children;
  var errorBars = findAllByType(children, ErrorBar).filter(function(errorBarChild) {
    return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);
  });
  if (errorBars && errorBars.length) {
    var keys4 = errorBars.map(function(errorBarChild) {
      return errorBarChild.props.dataKey;
    });
    return data2.reduce(function(result, entry) {
      var entryValue = getValueByDataKey(entry, dataKey, 0);
      var mainValue = _isArray2(entryValue) ? [_min(entryValue), _max(entryValue)] : [entryValue, entryValue];
      var errorDomain = keys4.reduce(function(prevErrorArr, k2) {
        var errorValue = getValueByDataKey(entry, k2, 0);
        var lowerValue = mainValue[0] - Math.abs(_isArray2(errorValue) ? errorValue[0] : errorValue);
        var upperValue = mainValue[1] + Math.abs(_isArray2(errorValue) ? errorValue[1] : errorValue);
        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];
      }, [Infinity, -Infinity]);
      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];
    }, [Infinity, -Infinity]);
  }
  return null;
};
var parseErrorBarsOfAxis = function parseErrorBarsOfAxis2(data2, items, dataKey, axisType, layout) {
  var domains = items.map(function(item) {
    return getDomainOfErrorBars(data2, item, dataKey, layout, axisType);
  }).filter(function(entry) {
    return !_isNil(entry);
  });
  if (domains && domains.length) {
    return domains.reduce(function(result, entry) {
      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
    }, [Infinity, -Infinity]);
  }
  return null;
};
var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis2(data2, items, type3, layout, filterNil) {
  var domains = items.map(function(item) {
    var dataKey = item.props.dataKey;
    if (type3 === "number" && dataKey) {
      return getDomainOfErrorBars(data2, item, dataKey, layout) || getDomainOfDataByKey(data2, dataKey, type3, filterNil);
    }
    return getDomainOfDataByKey(data2, dataKey, type3, filterNil);
  });
  if (type3 === "number") {
    return domains.reduce(function(result, entry) {
      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
    }, [Infinity, -Infinity]);
  }
  var tag = {};
  return domains.reduce(function(result, entry) {
    for (var i = 0, len = entry.length; i < len; i++) {
      if (!tag[entry[i]]) {
        tag[entry[i]] = true;
        result.push(entry[i]);
      }
    }
    return result;
  }, []);
};
var isCategoricalAxis = function isCategoricalAxis2(layout, axisType) {
  return layout === "horizontal" && axisType === "xAxis" || layout === "vertical" && axisType === "yAxis" || layout === "centric" && axisType === "angleAxis" || layout === "radial" && axisType === "radiusAxis";
};
var getCoordinatesOfGrid = function getCoordinatesOfGrid2(ticks2, min3, max3) {
  var hasMin, hasMax;
  var values3 = ticks2.map(function(entry) {
    if (entry.coordinate === min3) {
      hasMin = true;
    }
    if (entry.coordinate === max3) {
      hasMax = true;
    }
    return entry.coordinate;
  });
  if (!hasMin) {
    values3.push(min3);
  }
  if (!hasMax) {
    values3.push(max3);
  }
  return values3;
};
var getTicksOfAxis = function getTicksOfAxis2(axis, isGrid, isAll) {
  if (!axis)
    return null;
  var scale = axis.scale;
  var duplicateDomain = axis.duplicateDomain, type3 = axis.type, range4 = axis.range;
  var offsetForBand = axis.realScaleType === "scaleBand" ? scale.bandwidth() / 2 : 2;
  var offset2 = (isGrid || isAll) && type3 === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
  offset2 = axis.axisType === "angleAxis" && (range4 === null || range4 === void 0 ? void 0 : range4.length) >= 2 ? mathSign(range4[0] - range4[1]) * 2 * offset2 : offset2;
  if (isGrid && (axis.ticks || axis.niceTicks)) {
    var result = (axis.ticks || axis.niceTicks).map(function(entry) {
      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
      return {
        // If the scaleContent is not a number, the coordinate will be NaN.
        // That could be the case for example with a PointScale and a string as domain.
        coordinate: scale(scaleContent) + offset2,
        value: entry,
        offset: offset2
      };
    });
    return result.filter(function(row) {
      return !_isNaN$1(row.coordinate);
    });
  }
  if (axis.isCategorical && axis.categoricalDomain) {
    return axis.categoricalDomain.map(function(entry, index3) {
      return {
        coordinate: scale(entry) + offset2,
        value: entry,
        index: index3,
        offset: offset2
      };
    });
  }
  if (scale.ticks && !isAll) {
    return scale.ticks(axis.tickCount).map(function(entry) {
      return {
        coordinate: scale(entry) + offset2,
        value: entry,
        offset: offset2
      };
    });
  }
  return scale.domain().map(function(entry, index3) {
    return {
      coordinate: scale(entry) + offset2,
      value: duplicateDomain ? duplicateDomain[entry] : entry,
      index: index3,
      offset: offset2
    };
  });
};
var combineEventHandlers = function combineEventHandlers2(defaultHandler, parentHandler, childHandler) {
  var customizedHandler;
  if (_isFunction(childHandler)) {
    customizedHandler = childHandler;
  } else if (_isFunction(parentHandler)) {
    customizedHandler = parentHandler;
  }
  if (_isFunction(defaultHandler) || customizedHandler) {
    return function(arg1, arg2, arg3, arg4) {
      if (_isFunction(defaultHandler)) {
        defaultHandler(arg1, arg2, arg3, arg4);
      }
      if (_isFunction(customizedHandler)) {
        customizedHandler(arg1, arg2, arg3, arg4);
      }
    };
  }
  return null;
};
var parseScale = function parseScale2(axis, chartType, hasBar) {
  var scale = axis.scale, type3 = axis.type, layout = axis.layout, axisType = axis.axisType;
  if (scale === "auto") {
    if (layout === "radial" && axisType === "radiusAxis") {
      return {
        scale: band(),
        realScaleType: "band"
      };
    }
    if (layout === "radial" && axisType === "angleAxis") {
      return {
        scale: linear(),
        realScaleType: "linear"
      };
    }
    if (type3 === "category" && chartType && (chartType.indexOf("LineChart") >= 0 || chartType.indexOf("AreaChart") >= 0 || chartType.indexOf("ComposedChart") >= 0 && !hasBar)) {
      return {
        scale: point(),
        realScaleType: "point"
      };
    }
    if (type3 === "category") {
      return {
        scale: band(),
        realScaleType: "band"
      };
    }
    return {
      scale: linear(),
      realScaleType: "linear"
    };
  }
  if (_isString(scale)) {
    var name = "scale".concat(_upperFirst(scale));
    return {
      scale: (d3Scales[name] || point)(),
      realScaleType: d3Scales[name] ? name : "point"
    };
  }
  return _isFunction(scale) ? {
    scale
  } : {
    scale: point(),
    realScaleType: "point"
  };
};
var EPS = 1e-4;
var checkDomainOfScale = function checkDomainOfScale2(scale) {
  var domain = scale.domain();
  if (!domain || domain.length <= 2) {
    return;
  }
  var len = domain.length;
  var range4 = scale.range();
  var min3 = Math.min(range4[0], range4[1]) - EPS;
  var max3 = Math.max(range4[0], range4[1]) + EPS;
  var first = scale(domain[0]);
  var last2 = scale(domain[len - 1]);
  if (first < min3 || first > max3 || last2 < min3 || last2 > max3) {
    scale.domain([domain[0], domain[len - 1]]);
  }
};
var findPositionOfBar = function findPositionOfBar2(barPosition, child) {
  if (!barPosition) {
    return null;
  }
  for (var i = 0, len = barPosition.length; i < len; i++) {
    if (barPosition[i].item === child) {
      return barPosition[i].position;
    }
  }
  return null;
};
var truncateByDomain = function truncateByDomain2(value, domain) {
  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {
    return value;
  }
  var min3 = Math.min(domain[0], domain[1]);
  var max3 = Math.max(domain[0], domain[1]);
  var result = [value[0], value[1]];
  if (!isNumber(value[0]) || value[0] < min3) {
    result[0] = min3;
  }
  if (!isNumber(value[1]) || value[1] > max3) {
    result[1] = max3;
  }
  if (result[0] > max3) {
    result[0] = max3;
  }
  if (result[1] < min3) {
    result[1] = min3;
  }
  return result;
};
var offsetSign = function offsetSign2(series) {
  var n2 = series.length;
  if (n2 <= 0) {
    return;
  }
  for (var j2 = 0, m2 = series[0].length; j2 < m2; ++j2) {
    var positive = 0;
    var negative = 0;
    for (var i = 0; i < n2; ++i) {
      var value = _isNaN$1(series[i][j2][1]) ? series[i][j2][0] : series[i][j2][1];
      if (value >= 0) {
        series[i][j2][0] = positive;
        series[i][j2][1] = positive + value;
        positive = series[i][j2][1];
      } else {
        series[i][j2][0] = negative;
        series[i][j2][1] = negative + value;
        negative = series[i][j2][1];
      }
    }
  }
};
var offsetPositive = function offsetPositive2(series) {
  var n2 = series.length;
  if (n2 <= 0) {
    return;
  }
  for (var j2 = 0, m2 = series[0].length; j2 < m2; ++j2) {
    var positive = 0;
    for (var i = 0; i < n2; ++i) {
      var value = _isNaN$1(series[i][j2][1]) ? series[i][j2][0] : series[i][j2][1];
      if (value >= 0) {
        series[i][j2][0] = positive;
        series[i][j2][1] = positive + value;
        positive = series[i][j2][1];
      } else {
        series[i][j2][0] = 0;
        series[i][j2][1] = 0;
      }
    }
  }
};
var STACK_OFFSET_MAP = {
  sign: offsetSign,
  expand: stackOffsetExpand,
  none: stackOffsetNone,
  silhouette: stackOffsetSilhouette,
  wiggle: stackOffsetWiggle,
  positive: offsetPositive
};
var getStackedData = function getStackedData2(data2, stackItems, offsetType) {
  var dataKeys = stackItems.map(function(item) {
    return item.props.dataKey;
  });
  var stack = shapeStack().keys(dataKeys).value(function(d2, key) {
    return +getValueByDataKey(d2, key, 0);
  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);
  return stack(data2);
};
var getStackGroupsByAxisId = function getStackGroupsByAxisId2(data2, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {
  if (!data2) {
    return null;
  }
  var items = reverseStackOrder ? _items.reverse() : _items;
  var stackGroups = items.reduce(function(result, item) {
    var _item$props3 = item.props, stackId = _item$props3.stackId, hide = _item$props3.hide;
    if (hide) {
      return result;
    }
    var axisId = item.props[numericAxisId];
    var parentGroup = result[axisId] || {
      hasStack: false,
      stackGroups: {}
    };
    if (isNumOrStr(stackId)) {
      var childGroup = parentGroup.stackGroups[stackId] || {
        numericAxisId,
        cateAxisId,
        items: []
      };
      childGroup.items.push(item);
      parentGroup.hasStack = true;
      parentGroup.stackGroups[stackId] = childGroup;
    } else {
      parentGroup.stackGroups[uniqueId("_stackId_")] = {
        numericAxisId,
        cateAxisId,
        items: [item]
      };
    }
    return _objectSpread$f(_objectSpread$f({}, result), {}, _defineProperty$i({}, axisId, parentGroup));
  }, {});
  return Object.keys(stackGroups).reduce(function(result, axisId) {
    var group = stackGroups[axisId];
    if (group.hasStack) {
      group.stackGroups = Object.keys(group.stackGroups).reduce(function(res, stackId) {
        var g2 = group.stackGroups[stackId];
        return _objectSpread$f(_objectSpread$f({}, res), {}, _defineProperty$i({}, stackId, {
          numericAxisId,
          cateAxisId,
          items: g2.items,
          stackedData: getStackedData(data2, g2.items, offsetType)
        }));
      }, {});
    }
    return _objectSpread$f(_objectSpread$f({}, result), {}, _defineProperty$i({}, axisId, group));
  }, {});
};
var getTicksOfScale = function getTicksOfScale2(scale, opts) {
  var realScaleType = opts.realScaleType, type3 = opts.type, tickCount = opts.tickCount, originalDomain = opts.originalDomain, allowDecimals = opts.allowDecimals;
  var scaleType = realScaleType || opts.scale;
  if (scaleType !== "auto" && scaleType !== "linear") {
    return null;
  }
  if (tickCount && type3 === "number" && originalDomain && (originalDomain[0] === "auto" || originalDomain[1] === "auto")) {
    var domain = scale.domain();
    if (!domain.length) {
      return null;
    }
    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);
    scale.domain([_min(tickValues), _max(tickValues)]);
    return {
      niceTicks: tickValues
    };
  }
  if (tickCount && type3 === "number") {
    var _domain = scale.domain();
    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);
    return {
      niceTicks: _tickValues
    };
  }
  return null;
};
var getCateCoordinateOfBar = function getCateCoordinateOfBar2(_ref8) {
  var axis = _ref8.axis, ticks2 = _ref8.ticks, offset2 = _ref8.offset, bandSize = _ref8.bandSize, entry = _ref8.entry, index3 = _ref8.index;
  if (axis.type === "category") {
    return ticks2[index3] ? ticks2[index3].coordinate + offset2 : null;
  }
  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index3]);
  return !_isNil(value) ? axis.scale(value) - bandSize / 2 + offset2 : null;
};
var getBaseValueOfBar = function getBaseValueOfBar2(_ref9) {
  var numericAxis = _ref9.numericAxis;
  var domain = numericAxis.scale.domain();
  if (numericAxis.type === "number") {
    var min3 = Math.min(domain[0], domain[1]);
    var max3 = Math.max(domain[0], domain[1]);
    if (min3 <= 0 && max3 >= 0) {
      return 0;
    }
    if (max3 < 0) {
      return max3;
    }
    return min3;
  }
  return domain[0];
};
var getStackedDataOfItem = function getStackedDataOfItem2(item, stackGroups) {
  var stackId = item.props.stackId;
  if (isNumOrStr(stackId)) {
    var group = stackGroups[stackId];
    if (group && group.items.length) {
      var itemIndex = -1;
      for (var i = 0, len = group.items.length; i < len; i++) {
        if (group.items[i] === item) {
          itemIndex = i;
          break;
        }
      }
      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;
    }
  }
  return null;
};
var getDomainOfSingle = function getDomainOfSingle2(data2) {
  return data2.reduce(function(result, entry) {
    return [_min(entry.concat([result[0]]).filter(isNumber)), _max(entry.concat([result[1]]).filter(isNumber))];
  }, [Infinity, -Infinity]);
};
var getDomainOfStackGroups = function getDomainOfStackGroups2(stackGroups, startIndex, endIndex) {
  return Object.keys(stackGroups).reduce(function(result, stackId) {
    var group = stackGroups[stackId];
    var stackedData = group.stackedData;
    var domain = stackedData.reduce(function(res, entry) {
      var s2 = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));
      return [Math.min(res[0], s2[0]), Math.max(res[1], s2[1])];
    }, [Infinity, -Infinity]);
    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
  }, [Infinity, -Infinity]).map(function(result) {
    return result === Infinity || result === -Infinity ? 0 : result;
  });
};
var MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var parseSpecifiedDomain = function parseSpecifiedDomain2(specifiedDomain, dataDomain, allowDataOverflow) {
  if (_isFunction(specifiedDomain)) {
    return specifiedDomain(dataDomain, allowDataOverflow);
  }
  if (!_isArray2(specifiedDomain)) {
    return dataDomain;
  }
  var domain = [];
  if (isNumber(specifiedDomain[0])) {
    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);
  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {
    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];
    domain[0] = dataDomain[0] - value;
  } else if (_isFunction(specifiedDomain[0])) {
    domain[0] = specifiedDomain[0](dataDomain[0]);
  } else {
    domain[0] = dataDomain[0];
  }
  if (isNumber(specifiedDomain[1])) {
    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);
  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {
    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];
    domain[1] = dataDomain[1] + _value;
  } else if (_isFunction(specifiedDomain[1])) {
    domain[1] = specifiedDomain[1](dataDomain[1]);
  } else {
    domain[1] = dataDomain[1];
  }
  return domain;
};
var getBandSizeOfAxis = function getBandSizeOfAxis2(axis, ticks2, isBar) {
  if (axis && axis.scale && axis.scale.bandwidth) {
    var bandWidth = axis.scale.bandwidth();
    if (!isBar || bandWidth > 0) {
      return bandWidth;
    }
  }
  if (axis && ticks2 && ticks2.length >= 2) {
    var orderedTicks = _sortBy(ticks2, function(o3) {
      return o3.coordinate;
    });
    var bandSize = Infinity;
    for (var i = 1, len = orderedTicks.length; i < len; i++) {
      var cur = orderedTicks[i];
      var prev = orderedTicks[i - 1];
      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
    }
    return bandSize === Infinity ? 0 : bandSize;
  }
  return isBar ? void 0 : 0;
};
var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis2(specifiedDomain, calculatedDomain, axisChild) {
  if (!specifiedDomain || !specifiedDomain.length) {
    return calculatedDomain;
  }
  if (_isEqual(specifiedDomain, _get(axisChild, "type.defaultProps.domain"))) {
    return calculatedDomain;
  }
  return specifiedDomain;
};
var getTooltipItem = function getTooltipItem2(graphicalItem, payload) {
  var _graphicalItem$props = graphicalItem.props, dataKey = _graphicalItem$props.dataKey, name = _graphicalItem$props.name, unit2 = _graphicalItem$props.unit, formatter = _graphicalItem$props.formatter, tooltipType = _graphicalItem$props.tooltipType, chartType = _graphicalItem$props.chartType;
  return _objectSpread$f(_objectSpread$f({}, filterProps(graphicalItem)), {}, {
    dataKey,
    unit: unit2,
    formatter,
    name: name || dataKey,
    color: getMainColorOfGraphicItem(graphicalItem),
    value: getValueByDataKey(payload, dataKey),
    type: tooltipType,
    payload,
    chartType
  });
};
function _typeof$i(obj) {
  "@babel/helpers - typeof";
  return _typeof$i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$i(obj);
}
function ownKeys$e(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$e(Object(source), true).forEach(function(key) {
      _defineProperty$h(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$h(obj, key, value) {
  key = _toPropertyKey$i(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$i(arg) {
  var key = _toPrimitive$i(arg, "string");
  return _typeof$i(key) === "symbol" ? key : String(key);
}
function _toPrimitive$i(input, hint) {
  if (_typeof$i(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$i(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var RADIAN = Math.PI / 180;
var radianToDegree = function radianToDegree2(angleInRadian) {
  return angleInRadian * 180 / Math.PI;
};
var polarToCartesian = function polarToCartesian2(cx, cy, radius, angle) {
  return {
    x: cx + Math.cos(-RADIAN * angle) * radius,
    y: cy + Math.sin(-RADIAN * angle) * radius
  };
};
var distanceBetweenPoints = function distanceBetweenPoints2(point2, anotherPoint) {
  var x1 = point2.x, y1 = point2.y;
  var x2 = anotherPoint.x, y2 = anotherPoint.y;
  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
};
var getAngleOfPoint = function getAngleOfPoint2(_ref, _ref2) {
  var x2 = _ref.x, y2 = _ref.y;
  var cx = _ref2.cx, cy = _ref2.cy;
  var radius = distanceBetweenPoints({
    x: x2,
    y: y2
  }, {
    x: cx,
    y: cy
  });
  if (radius <= 0) {
    return {
      radius
    };
  }
  var cos2 = (x2 - cx) / radius;
  var angleInRadian = Math.acos(cos2);
  if (y2 > cy) {
    angleInRadian = 2 * Math.PI - angleInRadian;
  }
  return {
    radius,
    angle: radianToDegree(angleInRadian),
    angleInRadian
  };
};
var formatAngleOfSector = function formatAngleOfSector2(_ref3) {
  var startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;
  var startCnt = Math.floor(startAngle / 360);
  var endCnt = Math.floor(endAngle / 360);
  var min3 = Math.min(startCnt, endCnt);
  return {
    startAngle: startAngle - min3 * 360,
    endAngle: endAngle - min3 * 360
  };
};
var reverseFormatAngleOfSetor = function reverseFormatAngleOfSetor2(angle, _ref4) {
  var startAngle = _ref4.startAngle, endAngle = _ref4.endAngle;
  var startCnt = Math.floor(startAngle / 360);
  var endCnt = Math.floor(endAngle / 360);
  var min3 = Math.min(startCnt, endCnt);
  return angle + min3 * 360;
};
var inRangeOfSector = function inRangeOfSector2(_ref5, sector) {
  var x2 = _ref5.x, y2 = _ref5.y;
  var _getAngleOfPoint = getAngleOfPoint({
    x: x2,
    y: y2
  }, sector), radius = _getAngleOfPoint.radius, angle = _getAngleOfPoint.angle;
  var innerRadius = sector.innerRadius, outerRadius = sector.outerRadius;
  if (radius < innerRadius || radius > outerRadius) {
    return false;
  }
  if (radius === 0) {
    return true;
  }
  var _formatAngleOfSector = formatAngleOfSector(sector), startAngle = _formatAngleOfSector.startAngle, endAngle = _formatAngleOfSector.endAngle;
  var formatAngle = angle;
  var inRange;
  if (startAngle <= endAngle) {
    while (formatAngle > endAngle) {
      formatAngle -= 360;
    }
    while (formatAngle < startAngle) {
      formatAngle += 360;
    }
    inRange = formatAngle >= startAngle && formatAngle <= endAngle;
  } else {
    while (formatAngle > startAngle) {
      formatAngle -= 360;
    }
    while (formatAngle < endAngle) {
      formatAngle += 360;
    }
    inRange = formatAngle >= endAngle && formatAngle <= startAngle;
  }
  if (inRange) {
    return _objectSpread$e(_objectSpread$e({}, sector), {}, {
      radius,
      angle: reverseFormatAngleOfSetor(formatAngle, sector)
    });
  }
  return null;
};
function _typeof$h(obj) {
  "@babel/helpers - typeof";
  return _typeof$h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$h(obj);
}
function _toConsumableArray$3(arr) {
  return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$4(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$4(o3, minLen);
}
function _iterableToArray$3(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$3(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$4(arr);
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function ownKeys$d(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$d(Object(source), true).forEach(function(key) {
      _defineProperty$g(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$g(obj, key, value) {
  key = _toPropertyKey$h(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$h(arg) {
  var key = _toPrimitive$h(arg, "string");
  return _typeof$h(key) === "symbol" ? key : String(key);
}
function _toPrimitive$h(input, hint) {
  if (_typeof$h(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$h(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _extends$e() {
  _extends$e = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$e.apply(this, arguments);
}
var getLabel = function getLabel2(props3) {
  var value = props3.value, formatter = props3.formatter;
  var label = _isNil(props3.children) ? value : props3.children;
  if (_isFunction(formatter)) {
    return formatter(label);
  }
  return label;
};
var getDeltaAngle$1 = function getDeltaAngle(startAngle, endAngle) {
  var sign2 = mathSign(endAngle - startAngle);
  var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
  return sign2 * deltaAngle;
};
var renderRadialLabel = function renderRadialLabel2(labelProps, label, attrs) {
  var position = labelProps.position, viewBox = labelProps.viewBox, offset2 = labelProps.offset, className = labelProps.className;
  var _ref = viewBox, cx = _ref.cx, cy = _ref.cy, innerRadius = _ref.innerRadius, outerRadius = _ref.outerRadius, startAngle = _ref.startAngle, endAngle = _ref.endAngle, clockWise = _ref.clockWise;
  var radius = (innerRadius + outerRadius) / 2;
  var deltaAngle = getDeltaAngle$1(startAngle, endAngle);
  var sign2 = deltaAngle >= 0 ? 1 : -1;
  var labelAngle, direction;
  if (position === "insideStart") {
    labelAngle = startAngle + sign2 * offset2;
    direction = clockWise;
  } else if (position === "insideEnd") {
    labelAngle = endAngle - sign2 * offset2;
    direction = !clockWise;
  } else if (position === "end") {
    labelAngle = endAngle + sign2 * offset2;
    direction = clockWise;
  }
  direction = deltaAngle <= 0 ? direction : !direction;
  var startPoint = polarToCartesian(cx, cy, radius, labelAngle);
  var endPoint = polarToCartesian(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);
  var path3 = "M".concat(startPoint.x, ",").concat(startPoint.y, "\n    A").concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, ",\n    ").concat(endPoint.x, ",").concat(endPoint.y);
  var id2 = _isNil(labelProps.id) ? uniqueId("recharts-radial-line-") : labelProps.id;
  return /* @__PURE__ */ React.createElement("text", _extends$e({}, attrs, {
    dominantBaseline: "central",
    className: classNames("recharts-radial-bar-label", className)
  }), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("path", {
    id: id2,
    d: path3
  })), /* @__PURE__ */ React.createElement("textPath", {
    xlinkHref: "#".concat(id2)
  }, label));
};
var getAttrsOfPolarLabel = function getAttrsOfPolarLabel2(props3) {
  var viewBox = props3.viewBox, offset2 = props3.offset, position = props3.position;
  var _ref2 = viewBox, cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle;
  var midAngle = (startAngle + endAngle) / 2;
  if (position === "outside") {
    var _polarToCartesian = polarToCartesian(cx, cy, outerRadius + offset2, midAngle), _x = _polarToCartesian.x, _y = _polarToCartesian.y;
    return {
      x: _x,
      y: _y,
      textAnchor: _x >= cx ? "start" : "end",
      verticalAnchor: "middle"
    };
  }
  if (position === "center") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "middle"
    };
  }
  if (position === "centerTop") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "start"
    };
  }
  if (position === "centerBottom") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "end"
    };
  }
  var r2 = (innerRadius + outerRadius) / 2;
  var _polarToCartesian2 = polarToCartesian(cx, cy, r2, midAngle), x2 = _polarToCartesian2.x, y2 = _polarToCartesian2.y;
  return {
    x: x2,
    y: y2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  };
};
var getAttrsOfCartesianLabel = function getAttrsOfCartesianLabel2(props3) {
  var viewBox = props3.viewBox, parentViewBox = props3.parentViewBox, offset2 = props3.offset, position = props3.position;
  var _ref3 = viewBox, x2 = _ref3.x, y2 = _ref3.y, width = _ref3.width, height = _ref3.height;
  var verticalSign = height >= 0 ? 1 : -1;
  var verticalOffset = verticalSign * offset2;
  var verticalEnd = verticalSign > 0 ? "end" : "start";
  var verticalStart = verticalSign > 0 ? "start" : "end";
  var horizontalSign = width >= 0 ? 1 : -1;
  var horizontalOffset = horizontalSign * offset2;
  var horizontalEnd = horizontalSign > 0 ? "end" : "start";
  var horizontalStart = horizontalSign > 0 ? "start" : "end";
  if (position === "top") {
    var attrs = {
      x: x2 + width / 2,
      y: y2 - verticalSign * offset2,
      textAnchor: "middle",
      verticalAnchor: verticalEnd
    };
    return _objectSpread$d(_objectSpread$d({}, attrs), parentViewBox ? {
      height: Math.max(y2 - parentViewBox.y, 0),
      width
    } : {});
  }
  if (position === "bottom") {
    var _attrs = {
      x: x2 + width / 2,
      y: y2 + height + verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalStart
    };
    return _objectSpread$d(_objectSpread$d({}, _attrs), parentViewBox ? {
      height: Math.max(parentViewBox.y + parentViewBox.height - (y2 + height), 0),
      width
    } : {});
  }
  if (position === "left") {
    var _attrs2 = {
      x: x2 - horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalEnd,
      verticalAnchor: "middle"
    };
    return _objectSpread$d(_objectSpread$d({}, _attrs2), parentViewBox ? {
      width: Math.max(_attrs2.x - parentViewBox.x, 0),
      height
    } : {});
  }
  if (position === "right") {
    var _attrs3 = {
      x: x2 + width + horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalStart,
      verticalAnchor: "middle"
    };
    return _objectSpread$d(_objectSpread$d({}, _attrs3), parentViewBox ? {
      width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
      height
    } : {});
  }
  var sizeAttrs = parentViewBox ? {
    width,
    height
  } : {};
  if (position === "insideLeft") {
    return _objectSpread$d({
      x: x2 + horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalStart,
      verticalAnchor: "middle"
    }, sizeAttrs);
  }
  if (position === "insideRight") {
    return _objectSpread$d({
      x: x2 + width - horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalEnd,
      verticalAnchor: "middle"
    }, sizeAttrs);
  }
  if (position === "insideTop") {
    return _objectSpread$d({
      x: x2 + width / 2,
      y: y2 + verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position === "insideBottom") {
    return _objectSpread$d({
      x: x2 + width / 2,
      y: y2 + height - verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (position === "insideTopLeft") {
    return _objectSpread$d({
      x: x2 + horizontalOffset,
      y: y2 + verticalOffset,
      textAnchor: horizontalStart,
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position === "insideTopRight") {
    return _objectSpread$d({
      x: x2 + width - horizontalOffset,
      y: y2 + verticalOffset,
      textAnchor: horizontalEnd,
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position === "insideBottomLeft") {
    return _objectSpread$d({
      x: x2 + horizontalOffset,
      y: y2 + height - verticalOffset,
      textAnchor: horizontalStart,
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (position === "insideBottomRight") {
    return _objectSpread$d({
      x: x2 + width - horizontalOffset,
      y: y2 + height - verticalOffset,
      textAnchor: horizontalEnd,
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (_isObject(position) && (isNumber(position.x) || isPercent(position.x)) && (isNumber(position.y) || isPercent(position.y))) {
    return _objectSpread$d({
      x: x2 + getPercentValue(position.x, width),
      y: y2 + getPercentValue(position.y, height),
      textAnchor: "end",
      verticalAnchor: "end"
    }, sizeAttrs);
  }
  return _objectSpread$d({
    x: x2 + width / 2,
    y: y2 + height / 2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  }, sizeAttrs);
};
var isPolar = function isPolar2(viewBox) {
  return "cx" in viewBox && isNumber(viewBox.cx);
};
function Label2(props3) {
  var viewBox = props3.viewBox, position = props3.position, value = props3.value, children = props3.children, content = props3.content, _props$className = props3.className, className = _props$className === void 0 ? "" : _props$className, textBreakAll = props3.textBreakAll;
  if (!viewBox || _isNil(value) && _isNil(children) && !/* @__PURE__ */ reactExports.isValidElement(content) && !_isFunction(content)) {
    return null;
  }
  if (/* @__PURE__ */ reactExports.isValidElement(content)) {
    return /* @__PURE__ */ reactExports.cloneElement(content, props3);
  }
  var label;
  if (_isFunction(content)) {
    label = /* @__PURE__ */ reactExports.createElement(content, props3);
    if (/* @__PURE__ */ reactExports.isValidElement(label)) {
      return label;
    }
  } else {
    label = getLabel(props3);
  }
  var isPolarLabel = isPolar(viewBox);
  var attrs = filterProps(props3, true);
  if (isPolarLabel && (position === "insideStart" || position === "insideEnd" || position === "end")) {
    return renderRadialLabel(props3, label, attrs);
  }
  var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(props3) : getAttrsOfCartesianLabel(props3);
  return /* @__PURE__ */ React.createElement(Text2, _extends$e({
    className: classNames("recharts-label", className)
  }, attrs, positionAttrs, {
    breakAll: textBreakAll
  }), label);
}
Label2.displayName = "Label";
Label2.defaultProps = {
  offset: 5
};
var parseViewBox = function parseViewBox2(props3) {
  var cx = props3.cx, cy = props3.cy, angle = props3.angle, startAngle = props3.startAngle, endAngle = props3.endAngle, r2 = props3.r, radius = props3.radius, innerRadius = props3.innerRadius, outerRadius = props3.outerRadius, x2 = props3.x, y2 = props3.y, top = props3.top, left = props3.left, width = props3.width, height = props3.height, clockWise = props3.clockWise, labelViewBox = props3.labelViewBox;
  if (labelViewBox) {
    return labelViewBox;
  }
  if (isNumber(width) && isNumber(height)) {
    if (isNumber(x2) && isNumber(y2)) {
      return {
        x: x2,
        y: y2,
        width,
        height
      };
    }
    if (isNumber(top) && isNumber(left)) {
      return {
        x: top,
        y: left,
        width,
        height
      };
    }
  }
  if (isNumber(x2) && isNumber(y2)) {
    return {
      x: x2,
      y: y2,
      width: 0,
      height: 0
    };
  }
  if (isNumber(cx) && isNumber(cy)) {
    return {
      cx,
      cy,
      startAngle: startAngle || angle || 0,
      endAngle: endAngle || angle || 0,
      innerRadius: innerRadius || 0,
      outerRadius: outerRadius || radius || r2 || 0,
      clockWise
    };
  }
  if (props3.viewBox) {
    return props3.viewBox;
  }
  return {};
};
var parseLabel = function parseLabel2(label, viewBox) {
  if (!label) {
    return null;
  }
  if (label === true) {
    return /* @__PURE__ */ React.createElement(Label2, {
      key: "label-implicit",
      viewBox
    });
  }
  if (isNumOrStr(label)) {
    return /* @__PURE__ */ React.createElement(Label2, {
      key: "label-implicit",
      viewBox,
      value: label
    });
  }
  if (/* @__PURE__ */ reactExports.isValidElement(label)) {
    if (label.type === Label2) {
      return /* @__PURE__ */ reactExports.cloneElement(label, {
        key: "label-implicit",
        viewBox
      });
    }
    return /* @__PURE__ */ React.createElement(Label2, {
      key: "label-implicit",
      content: label,
      viewBox
    });
  }
  if (_isFunction(label)) {
    return /* @__PURE__ */ React.createElement(Label2, {
      key: "label-implicit",
      content: label,
      viewBox
    });
  }
  if (_isObject(label)) {
    return /* @__PURE__ */ React.createElement(Label2, _extends$e({
      viewBox
    }, label, {
      key: "label-implicit"
    }));
  }
  return null;
};
var renderCallByParent$1 = function renderCallByParent(parentProps, viewBox) {
  var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {
    return null;
  }
  var children = parentProps.children;
  var parentViewBox = parseViewBox(parentProps);
  var explicitChildren = findAllByType(children, Label2).map(function(child, index3) {
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      viewBox: viewBox || parentViewBox,
      // eslint-disable-next-line react/no-array-index-key
      key: "label-".concat(index3)
    });
  });
  if (!checkPropsLabel) {
    return explicitChildren;
  }
  var implicitLabel = parseLabel(parentProps.label, viewBox || parentViewBox);
  return [implicitLabel].concat(_toConsumableArray$3(explicitChildren));
};
Label2.parseViewBox = parseViewBox;
Label2.renderCallByParent = renderCallByParent$1;
function last(array3) {
  var length3 = array3 == null ? 0 : array3.length;
  return length3 ? array3[length3 - 1] : void 0;
}
var last_1 = last;
const _last = /* @__PURE__ */ getDefaultExportFromCjs(last_1);
function _typeof$g(obj) {
  "@babel/helpers - typeof";
  return _typeof$g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$g(obj);
}
var _excluded$4 = ["data", "valueAccessor", "dataKey", "clockWise", "id", "textBreakAll"];
function _toConsumableArray$2(arr) {
  return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$3(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$3(o3, minLen);
}
function _iterableToArray$2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$2(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$3(arr);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _extends$d() {
  _extends$d = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$d.apply(this, arguments);
}
function ownKeys$c(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$c(Object(source), true).forEach(function(key) {
      _defineProperty$f(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$f(obj, key, value) {
  key = _toPropertyKey$g(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$g(arg) {
  var key = _toPrimitive$g(arg, "string");
  return _typeof$g(key) === "symbol" ? key : String(key);
}
function _toPrimitive$g(input, hint) {
  if (_typeof$g(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$g(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _objectWithoutProperties$4(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$4(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var defaultProps = {
  valueAccessor: function valueAccessor(entry) {
    return _isArray2(entry.value) ? _last(entry.value) : entry.value;
  }
};
function LabelList(props3) {
  var data2 = props3.data, valueAccessor2 = props3.valueAccessor, dataKey = props3.dataKey, clockWise = props3.clockWise, id2 = props3.id, textBreakAll = props3.textBreakAll, others = _objectWithoutProperties$4(props3, _excluded$4);
  if (!data2 || !data2.length) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(Layer, {
    className: "recharts-label-list"
  }, data2.map(function(entry, index3) {
    var value = _isNil(dataKey) ? valueAccessor2(entry, index3) : getValueByDataKey(entry && entry.payload, dataKey);
    var idProps = _isNil(id2) ? {} : {
      id: "".concat(id2, "-").concat(index3)
    };
    return /* @__PURE__ */ React.createElement(Label2, _extends$d({}, filterProps(entry, true), others, idProps, {
      parentViewBox: entry.parentViewBox,
      index: index3,
      value,
      textBreakAll,
      viewBox: Label2.parseViewBox(_isNil(clockWise) ? entry : _objectSpread$c(_objectSpread$c({}, entry), {}, {
        clockWise
      })),
      key: "label-".concat(index3)
      // eslint-disable-line react/no-array-index-key
    }));
  }));
}
LabelList.displayName = "LabelList";
function parseLabelList(label, data2) {
  if (!label) {
    return null;
  }
  if (label === true) {
    return /* @__PURE__ */ React.createElement(LabelList, {
      key: "labelList-implicit",
      data: data2
    });
  }
  if (/* @__PURE__ */ React.isValidElement(label) || _isFunction(label)) {
    return /* @__PURE__ */ React.createElement(LabelList, {
      key: "labelList-implicit",
      data: data2,
      content: label
    });
  }
  if (_isObject(label)) {
    return /* @__PURE__ */ React.createElement(LabelList, _extends$d({
      data: data2
    }, label, {
      key: "labelList-implicit"
    }));
  }
  return null;
}
function renderCallByParent2(parentProps, data2) {
  var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {
    return null;
  }
  var children = parentProps.children;
  var explicitChildren = findAllByType(children, LabelList).map(function(child, index3) {
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      data: data2,
      // eslint-disable-next-line react/no-array-index-key
      key: "labelList-".concat(index3)
    });
  });
  if (!checkPropsLabel) {
    return explicitChildren;
  }
  var implicitLabelList = parseLabelList(parentProps.label, data2);
  return [implicitLabelList].concat(_toConsumableArray$2(explicitChildren));
}
LabelList.renderCallByParent = renderCallByParent2;
LabelList.defaultProps = defaultProps;
function _typeof$f(obj) {
  "@babel/helpers - typeof";
  return _typeof$f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$f(obj);
}
function _extends$c() {
  _extends$c = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$c.apply(this, arguments);
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$9(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$f(descriptor.key), descriptor);
  }
}
function _createClass$9(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$9(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$9(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$7(subClass, superClass);
}
function _setPrototypeOf$7(o3, p2) {
  _setPrototypeOf$7 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$7(o3, p2);
}
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$7(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$7(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$7(this, result);
  };
}
function _possibleConstructorReturn$7(self2, call3) {
  if (call3 && (_typeof$f(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$7(self2);
}
function _assertThisInitialized$7(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$7(o3) {
  _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$7(o3);
}
function _defineProperty$e(obj, key, value) {
  key = _toPropertyKey$f(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$f(arg) {
  var key = _toPrimitive$f(arg, "string");
  return _typeof$f(key) === "symbol" ? key : String(key);
}
function _toPrimitive$f(input, hint) {
  if (_typeof$f(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$f(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var getDeltaAngle2 = function getDeltaAngle3(startAngle, endAngle) {
  var sign2 = mathSign(endAngle - startAngle);
  var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);
  return sign2 * deltaAngle;
};
var getTangentCircle = function getTangentCircle2(_ref) {
  var cx = _ref.cx, cy = _ref.cy, radius = _ref.radius, angle = _ref.angle, sign2 = _ref.sign, isExternal = _ref.isExternal, cornerRadius = _ref.cornerRadius, cornerIsExternal = _ref.cornerIsExternal;
  var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;
  var theta = Math.asin(cornerRadius / centerRadius) / RADIAN;
  var centerAngle = cornerIsExternal ? angle : angle + sign2 * theta;
  var center = polarToCartesian(cx, cy, centerRadius, centerAngle);
  var circleTangency = polarToCartesian(cx, cy, radius, centerAngle);
  var lineTangencyAngle = cornerIsExternal ? angle - sign2 * theta : angle;
  var lineTangency = polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN), lineTangencyAngle);
  return {
    center,
    circleTangency,
    lineTangency,
    theta
  };
};
var getSectorPath = function getSectorPath2(_ref2) {
  var cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle;
  var angle = getDeltaAngle2(startAngle, endAngle);
  var tempEndAngle = startAngle + angle;
  var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);
  var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);
  var path3 = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, "\n    A ").concat(outerRadius, ",").concat(outerRadius, ",0,\n    ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle > tempEndAngle), ",\n    ").concat(outerEndPoint.x, ",").concat(outerEndPoint.y, "\n  ");
  if (innerRadius > 0) {
    var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);
    var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);
    path3 += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, "\n            A ").concat(innerRadius, ",").concat(innerRadius, ",0,\n            ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle <= tempEndAngle), ",\n            ").concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
  } else {
    path3 += "L ".concat(cx, ",").concat(cy, " Z");
  }
  return path3;
};
var getSectorWithCorner = function getSectorWithCorner2(_ref3) {
  var cx = _ref3.cx, cy = _ref3.cy, innerRadius = _ref3.innerRadius, outerRadius = _ref3.outerRadius, cornerRadius = _ref3.cornerRadius, forceCornerRadius = _ref3.forceCornerRadius, cornerIsExternal = _ref3.cornerIsExternal, startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;
  var sign2 = mathSign(endAngle - startAngle);
  var _getTangentCircle = getTangentCircle({
    cx,
    cy,
    radius: outerRadius,
    angle: startAngle,
    sign: sign2,
    cornerRadius,
    cornerIsExternal
  }), soct = _getTangentCircle.circleTangency, solt = _getTangentCircle.lineTangency, sot = _getTangentCircle.theta;
  var _getTangentCircle2 = getTangentCircle({
    cx,
    cy,
    radius: outerRadius,
    angle: endAngle,
    sign: -sign2,
    cornerRadius,
    cornerIsExternal
  }), eoct = _getTangentCircle2.circleTangency, eolt = _getTangentCircle2.lineTangency, eot = _getTangentCircle2.theta;
  var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;
  if (outerArcAngle < 0) {
    if (forceCornerRadius) {
      return "M ".concat(solt.x, ",").concat(solt.y, "\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, ",0\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, ",0\n      ");
    }
    return getSectorPath({
      cx,
      cy,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    });
  }
  var path3 = "M ".concat(solt.x, ",").concat(solt.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(soct.x, ",").concat(soct.y, "\n    A").concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign2 < 0), ",").concat(eoct.x, ",").concat(eoct.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eolt.x, ",").concat(eolt.y, "\n  ");
  if (innerRadius > 0) {
    var _getTangentCircle3 = getTangentCircle({
      cx,
      cy,
      radius: innerRadius,
      angle: startAngle,
      sign: sign2,
      isExternal: true,
      cornerRadius,
      cornerIsExternal
    }), sict = _getTangentCircle3.circleTangency, silt = _getTangentCircle3.lineTangency, sit = _getTangentCircle3.theta;
    var _getTangentCircle4 = getTangentCircle({
      cx,
      cy,
      radius: innerRadius,
      angle: endAngle,
      sign: -sign2,
      isExternal: true,
      cornerRadius,
      cornerIsExternal
    }), eict = _getTangentCircle4.circleTangency, eilt = _getTangentCircle4.lineTangency, eit = _getTangentCircle4.theta;
    var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;
    if (innerArcAngle < 0 && cornerRadius === 0) {
      return "".concat(path3, "L").concat(cx, ",").concat(cy, "Z");
    }
    path3 += "L".concat(eilt.x, ",").concat(eilt.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eict.x, ",").concat(eict.y, "\n      A").concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign2 > 0), ",").concat(sict.x, ",").concat(sict.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
  } else {
    path3 += "L".concat(cx, ",").concat(cy, "Z");
  }
  return path3;
};
var Sector = /* @__PURE__ */ function(_PureComponent) {
  _inherits$7(Sector2, _PureComponent);
  var _super = _createSuper$7(Sector2);
  function Sector2() {
    _classCallCheck$9(this, Sector2);
    return _super.apply(this, arguments);
  }
  _createClass$9(Sector2, [{
    key: "render",
    value: function render() {
      var _this$props = this.props, cx = _this$props.cx, cy = _this$props.cy, innerRadius = _this$props.innerRadius, outerRadius = _this$props.outerRadius, cornerRadius = _this$props.cornerRadius, forceCornerRadius = _this$props.forceCornerRadius, cornerIsExternal = _this$props.cornerIsExternal, startAngle = _this$props.startAngle, endAngle = _this$props.endAngle, className = _this$props.className;
      if (outerRadius < innerRadius || startAngle === endAngle) {
        return null;
      }
      var layerClass = classNames("recharts-sector", className);
      var deltaRadius = outerRadius - innerRadius;
      var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);
      var path3;
      if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {
        path3 = getSectorWithCorner({
          cx,
          cy,
          innerRadius,
          outerRadius,
          cornerRadius: Math.min(cr, deltaRadius / 2),
          forceCornerRadius,
          cornerIsExternal,
          startAngle,
          endAngle
        });
      } else {
        path3 = getSectorPath({
          cx,
          cy,
          innerRadius,
          outerRadius,
          startAngle,
          endAngle
        });
      }
      return /* @__PURE__ */ React.createElement("path", _extends$c({}, filterProps(this.props, true), {
        className: layerClass,
        d: path3,
        role: "img"
      }));
    }
  }]);
  return Sector2;
}(reactExports.PureComponent);
_defineProperty$e(Sector, "defaultProps", {
  cx: 0,
  cy: 0,
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0,
  endAngle: 0,
  cornerRadius: 0,
  forceCornerRadius: false,
  cornerIsExternal: false
});
function _typeof$e(obj) {
  "@babel/helpers - typeof";
  return _typeof$e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$e(obj);
}
function _extends$b() {
  _extends$b = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$b.apply(this, arguments);
}
function ownKeys$b(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$b(Object(source), true).forEach(function(key) {
      _defineProperty$d(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$d(obj, key, value) {
  key = _toPropertyKey$e(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$e(arg) {
  var key = _toPrimitive$e(arg, "string");
  return _typeof$e(key) === "symbol" ? key : String(key);
}
function _toPrimitive$e(input, hint) {
  if (_typeof$e(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$e(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var CURVE_FACTORIES = {
  curveBasisClosed,
  curveBasisOpen,
  curveBasis,
  curveLinearClosed,
  curveLinear,
  curveMonotoneX: monotoneX,
  curveMonotoneY: monotoneY,
  curveNatural,
  curveStep,
  curveStepAfter: stepAfter,
  curveStepBefore: stepBefore
};
var defined = function defined2(p2) {
  return p2.x === +p2.x && p2.y === +p2.y;
};
var getX = function getX2(p2) {
  return p2.x;
};
var getY = function getY2(p2) {
  return p2.y;
};
var getCurveFactory = function getCurveFactory2(type3, layout) {
  if (_isFunction(type3)) {
    return type3;
  }
  var name = "curve".concat(_upperFirst(type3));
  if (name === "curveMonotone" && layout) {
    return CURVE_FACTORIES["".concat(name).concat(layout === "vertical" ? "Y" : "X")];
  }
  return CURVE_FACTORIES[name] || curveLinear;
};
var getPath$1 = function getPath(_ref) {
  var type3 = _ref.type, points = _ref.points, baseLine = _ref.baseLine, layout = _ref.layout, connectNulls = _ref.connectNulls;
  var curveFactory = getCurveFactory(type3, layout);
  var formatPoints = connectNulls ? points.filter(function(entry) {
    return defined(entry);
  }) : points;
  var lineFunction;
  if (_isArray2(baseLine)) {
    var formatBaseLine = connectNulls ? baseLine.filter(function(base) {
      return defined(base);
    }) : baseLine;
    var areaPoints = formatPoints.map(function(entry, index3) {
      return _objectSpread$b(_objectSpread$b({}, entry), {}, {
        base: formatBaseLine[index3]
      });
    });
    if (layout === "vertical") {
      lineFunction = shapeArea().y(getY).x1(getX).x0(function(d2) {
        return d2.base.x;
      });
    } else {
      lineFunction = shapeArea().x(getX).y1(getY).y0(function(d2) {
        return d2.base.y;
      });
    }
    lineFunction.defined(defined).curve(curveFactory);
    return lineFunction(areaPoints);
  }
  if (layout === "vertical" && isNumber(baseLine)) {
    lineFunction = shapeArea().y(getY).x1(getX).x0(baseLine);
  } else if (isNumber(baseLine)) {
    lineFunction = shapeArea().x(getX).y1(getY).y0(baseLine);
  } else {
    lineFunction = shapeLine().x(getX).y(getY);
  }
  lineFunction.defined(defined).curve(curveFactory);
  return lineFunction(formatPoints);
};
var Curve = function Curve2(props3) {
  var className = props3.className, points = props3.points, path3 = props3.path, pathRef = props3.pathRef;
  if ((!points || !points.length) && !path3) {
    return null;
  }
  var realPath = points && points.length ? getPath$1(props3) : path3;
  return /* @__PURE__ */ React.createElement("path", _extends$b({}, filterProps(props3), adaptEventHandlers(props3), {
    className: classNames("recharts-curve", className),
    d: realPath,
    ref: pathRef
  }));
};
Curve.defaultProps = {
  type: "linear",
  points: [],
  connectNulls: false
};
function _typeof$d(obj) {
  "@babel/helpers - typeof";
  return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$d(obj);
}
function _extends$a() {
  _extends$a = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$a.apply(this, arguments);
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$8(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$d(descriptor.key), descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$8(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$8(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o3, p2) {
  _setPrototypeOf$6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$6(o3, p2);
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$6(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$6(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$6(this, result);
  };
}
function _possibleConstructorReturn$6(self2, call3) {
  if (call3 && (_typeof$d(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$6(self2);
}
function _assertThisInitialized$6(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$6(o3) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$6(o3);
}
function _defineProperty$c(obj, key, value) {
  key = _toPropertyKey$d(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$d(arg) {
  var key = _toPrimitive$d(arg, "string");
  return _typeof$d(key) === "symbol" ? key : String(key);
}
function _toPrimitive$d(input, hint) {
  if (_typeof$d(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$d(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var getRectanglePath = function getRectanglePath2(x2, y2, width, height, radius) {
  var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);
  var ySign = height >= 0 ? 1 : -1;
  var xSign = width >= 0 ? 1 : -1;
  var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;
  var path3;
  if (maxRadius > 0 && radius instanceof Array) {
    var newRadius = [0, 0, 0, 0];
    for (var i = 0, len = 4; i < len; i++) {
      newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];
    }
    path3 = "M".concat(x2, ",").concat(y2 + ySign * newRadius[0]);
    if (newRadius[0] > 0) {
      path3 += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x2 + xSign * newRadius[0], ",").concat(y2);
    }
    path3 += "L ".concat(x2 + width - xSign * newRadius[1], ",").concat(y2);
    if (newRadius[1] > 0) {
      path3 += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width, ",").concat(y2 + ySign * newRadius[1]);
    }
    path3 += "L ".concat(x2 + width, ",").concat(y2 + height - ySign * newRadius[2]);
    if (newRadius[2] > 0) {
      path3 += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width - xSign * newRadius[2], ",").concat(y2 + height);
    }
    path3 += "L ".concat(x2 + xSign * newRadius[3], ",").concat(y2 + height);
    if (newRadius[3] > 0) {
      path3 += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, ",\n        ").concat(x2, ",").concat(y2 + height - ySign * newRadius[3]);
    }
    path3 += "Z";
  } else if (maxRadius > 0 && radius === +radius && radius > 0) {
    var _newRadius = Math.min(maxRadius, radius);
    path3 = "M ".concat(x2, ",").concat(y2 + ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + xSign * _newRadius, ",").concat(y2, "\n            L ").concat(x2 + width - xSign * _newRadius, ",").concat(y2, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width, ",").concat(y2 + ySign * _newRadius, "\n            L ").concat(x2 + width, ",").concat(y2 + height - ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width - xSign * _newRadius, ",").concat(y2 + height, "\n            L ").concat(x2 + xSign * _newRadius, ",").concat(y2 + height, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2, ",").concat(y2 + height - ySign * _newRadius, " Z");
  } else {
    path3 = "M ".concat(x2, ",").concat(y2, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
  }
  return path3;
};
var isInRectangle = function isInRectangle2(point2, rect) {
  if (!point2 || !rect) {
    return false;
  }
  var px = point2.x, py = point2.y;
  var x2 = rect.x, y2 = rect.y, width = rect.width, height = rect.height;
  if (Math.abs(width) > 0 && Math.abs(height) > 0) {
    var minX = Math.min(x2, x2 + width);
    var maxX = Math.max(x2, x2 + width);
    var minY = Math.min(y2, y2 + height);
    var maxY = Math.max(y2, y2 + height);
    return px >= minX && px <= maxX && py >= minY && py <= maxY;
  }
  return false;
};
var Rectangle = /* @__PURE__ */ function(_PureComponent) {
  _inherits$6(Rectangle2, _PureComponent);
  var _super = _createSuper$6(Rectangle2);
  function Rectangle2() {
    var _this;
    _classCallCheck$8(this, Rectangle2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$c(_assertThisInitialized$6(_this), "state", {
      totalLength: -1
    });
    return _this;
  }
  _createClass$8(Rectangle2, [{
    key: "componentDidMount",
    value: (
      /* eslint-disable  react/no-did-mount-set-state */
      function componentDidMount() {
        if (this.node && this.node.getTotalLength) {
          try {
            var totalLength = this.node.getTotalLength();
            if (totalLength) {
              this.setState({
                totalLength
              });
            }
          } catch (err) {
          }
        }
      }
    )
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props = this.props, x2 = _this$props.x, y2 = _this$props.y, width = _this$props.width, height = _this$props.height, radius = _this$props.radius, className = _this$props.className;
      var totalLength = this.state.totalLength;
      var _this$props2 = this.props, animationEasing = _this$props2.animationEasing, animationDuration = _this$props2.animationDuration, animationBegin = _this$props2.animationBegin, isAnimationActive = _this$props2.isAnimationActive, isUpdateAnimationActive = _this$props2.isUpdateAnimationActive;
      if (x2 !== +x2 || y2 !== +y2 || width !== +width || height !== +height || width === 0 || height === 0) {
        return null;
      }
      var layerClass = classNames("recharts-rectangle", className);
      if (!isUpdateAnimationActive) {
        return /* @__PURE__ */ React.createElement("path", _extends$a({}, filterProps(this.props, true), {
          className: layerClass,
          d: getRectanglePath(x2, y2, width, height, radius)
        }));
      }
      return /* @__PURE__ */ React.createElement(Animate, {
        canBegin: totalLength > 0,
        from: {
          width,
          height,
          x: x2,
          y: y2
        },
        to: {
          width,
          height,
          x: x2,
          y: y2
        },
        duration: animationDuration,
        animationEasing,
        isActive: isUpdateAnimationActive
      }, function(_ref) {
        var currWidth = _ref.width, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;
        return /* @__PURE__ */ React.createElement(Animate, {
          canBegin: totalLength > 0,
          from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
          to: "".concat(totalLength, "px 0px"),
          attributeName: "strokeDasharray",
          begin: animationBegin,
          duration: animationDuration,
          isActive: isAnimationActive,
          easing: animationEasing
        }, /* @__PURE__ */ React.createElement("path", _extends$a({}, filterProps(_this2.props, true), {
          className: layerClass,
          d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
          ref: function ref(node) {
            _this2.node = node;
          }
        })));
      });
    }
  }]);
  return Rectangle2;
}(reactExports.PureComponent);
_defineProperty$c(Rectangle, "defaultProps", {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  // The radius of border
  // The radius of four corners when radius is a number
  // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
  radius: 0,
  isAnimationActive: false,
  isUpdateAnimationActive: false,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
});
function _typeof$c(obj) {
  "@babel/helpers - typeof";
  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$c(obj);
}
function _extends$9() {
  _extends$9 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$9.apply(this, arguments);
}
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$7(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$c(descriptor.key), descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$7(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$7(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$c(arg) {
  var key = _toPrimitive$c(arg, "string");
  return _typeof$c(key) === "symbol" ? key : String(key);
}
function _toPrimitive$c(input, hint) {
  if (_typeof$c(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$c(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o3, p2) {
  _setPrototypeOf$5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$5(o3, p2);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
function _possibleConstructorReturn$5(self2, call3) {
  if (call3 && (_typeof$c(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$5(self2);
}
function _assertThisInitialized$5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$5(o3) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$5(o3);
}
var Dot = /* @__PURE__ */ function(_PureComponent) {
  _inherits$5(Dot2, _PureComponent);
  var _super = _createSuper$5(Dot2);
  function Dot2() {
    _classCallCheck$7(this, Dot2);
    return _super.apply(this, arguments);
  }
  _createClass$7(Dot2, [{
    key: "render",
    value: function render() {
      var _this$props = this.props, cx = _this$props.cx, cy = _this$props.cy, r2 = _this$props.r, className = _this$props.className;
      var layerClass = classNames("recharts-dot", className);
      if (cx === +cx && cy === +cy && r2 === +r2) {
        return /* @__PURE__ */ React.createElement("circle", _extends$9({}, filterProps(this.props), adaptEventHandlers(this.props), {
          className: layerClass,
          cx,
          cy,
          r: r2
        }));
      }
      return null;
    }
  }]);
  return Dot2;
}(reactExports.PureComponent);
function _extends$8() {
  _extends$8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
var getPath2 = function getPath3(x2, y2, width, height, top, left) {
  return "M".concat(x2, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y2, "h").concat(width);
};
var Cross = function Cross2(props3) {
  var x2 = props3.x, y2 = props3.y, width = props3.width, height = props3.height, top = props3.top, left = props3.left, className = props3.className;
  if (!isNumber(x2) || !isNumber(y2) || !isNumber(width) || !isNumber(height) || !isNumber(top) || !isNumber(left)) {
    return null;
  }
  return /* @__PURE__ */ React.createElement("path", _extends$8({}, filterProps(props3, true), {
    className: classNames("recharts-cross", className),
    d: getPath2(x2, y2, width, height, top, left)
  }));
};
Cross.defaultProps = {
  x: 0,
  y: 0,
  top: 0,
  left: 0,
  width: 0,
  height: 0
};
var nativeCeil = Math.ceil, nativeMax$1 = Math.max;
function baseRange$1(start, end, step, fromRight) {
  var index3 = -1, length3 = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0), result = Array(length3);
  while (length3--) {
    result[fromRight ? length3 : ++index3] = start;
    start += step;
  }
  return result;
}
var _baseRange = baseRange$1;
var toNumber = toNumber_1;
var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$2(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign2 = value < 0 ? -1 : 1;
    return sign2 * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite$2;
var baseRange = _baseRange, isIterateeCall$2 = _isIterateeCall, toFinite$1 = toFinite_1;
function createRange$1(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != "number" && isIterateeCall$2(start, end, step)) {
      end = step = void 0;
    }
    start = toFinite$1(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite$1(end);
    }
    step = step === void 0 ? start < end ? 1 : -1 : toFinite$1(step);
    return baseRange(start, end, step, fromRight);
  };
}
var _createRange = createRange$1;
var createRange = _createRange;
var range3 = createRange();
var range_1 = range3;
const _range = /* @__PURE__ */ getDefaultExportFromCjs(range_1);
function _typeof$b(obj) {
  "@babel/helpers - typeof";
  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$b(obj);
}
function ownKeys$a(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$a(Object(source), true).forEach(function(key) {
      _defineProperty$b(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$b(obj, key, value) {
  key = _toPropertyKey$b(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$b(arg) {
  var key = _toPrimitive$b(arg, "string");
  return _typeof$b(key) === "symbol" ? key : String(key);
}
function _toPrimitive$b(input, hint) {
  if (_typeof$b(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$b(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var PREFIX_LIST = ["Webkit", "Moz", "O", "ms"];
var generatePrefixStyle2 = function generatePrefixStyle3(name, value) {
  if (!name) {
    return null;
  }
  var camelName = name.replace(/(\w)/, function(v2) {
    return v2.toUpperCase();
  });
  var result = PREFIX_LIST.reduce(function(res, entry) {
    return _objectSpread$a(_objectSpread$a({}, res), {}, _defineProperty$b({}, entry + camelName, value));
  }, {});
  result[name] = value;
  return result;
};
function _typeof$a(obj) {
  "@babel/helpers - typeof";
  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$a(obj);
}
function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
function ownKeys$9(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$9(Object(source), true).forEach(function(key) {
      _defineProperty$a(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$a(descriptor.key), descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$6(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$6(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o3, p2) {
  _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$4(o3, p2);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self2, call3) {
  if (call3 && (_typeof$a(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$4(self2);
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$4(o3) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$4(o3);
}
function _defineProperty$a(obj, key, value) {
  key = _toPropertyKey$a(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$a(arg) {
  var key = _toPrimitive$a(arg, "string");
  return _typeof$a(key) === "symbol" ? key : String(key);
}
function _toPrimitive$a(input, hint) {
  if (_typeof$a(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$a(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var createScale = function createScale2(_ref) {
  var data2 = _ref.data, startIndex = _ref.startIndex, endIndex = _ref.endIndex, x2 = _ref.x, width = _ref.width, travellerWidth = _ref.travellerWidth;
  if (!data2 || !data2.length) {
    return {};
  }
  var len = data2.length;
  var scale = point().domain(_range(0, len)).range([x2, x2 + width - travellerWidth]);
  var scaleValues = scale.domain().map(function(entry) {
    return scale(entry);
  });
  return {
    isTextActive: false,
    isSlideMoving: false,
    isTravellerMoving: false,
    startX: scale(startIndex),
    endX: scale(endIndex),
    scale,
    scaleValues
  };
};
var isTouch = function isTouch2(e3) {
  return e3.changedTouches && !!e3.changedTouches.length;
};
var Brush = /* @__PURE__ */ function(_PureComponent) {
  _inherits$4(Brush2, _PureComponent);
  var _super = _createSuper$4(Brush2);
  function Brush2(props3) {
    var _this;
    _classCallCheck$6(this, Brush2);
    _this = _super.call(this, props3);
    _defineProperty$a(_assertThisInitialized$4(_this), "handleDrag", function(e3) {
      if (_this.leaveTimer) {
        clearTimeout(_this.leaveTimer);
        _this.leaveTimer = null;
      }
      if (_this.state.isTravellerMoving) {
        _this.handleTravellerMove(e3);
      } else if (_this.state.isSlideMoving) {
        _this.handleSlideDrag(e3);
      }
    });
    _defineProperty$a(_assertThisInitialized$4(_this), "handleTouchMove", function(e3) {
      if (e3.changedTouches != null && e3.changedTouches.length > 0) {
        _this.handleDrag(e3.changedTouches[0]);
      }
    });
    _defineProperty$a(_assertThisInitialized$4(_this), "handleDragEnd", function() {
      _this.setState({
        isTravellerMoving: false,
        isSlideMoving: false
      });
      _this.detachDragEndListener();
    });
    _defineProperty$a(_assertThisInitialized$4(_this), "handleLeaveWrapper", function() {
      if (_this.state.isTravellerMoving || _this.state.isSlideMoving) {
        _this.leaveTimer = window.setTimeout(_this.handleDragEnd, _this.props.leaveTimeOut);
      }
    });
    _defineProperty$a(_assertThisInitialized$4(_this), "handleEnterSlideOrTraveller", function() {
      _this.setState({
        isTextActive: true
      });
    });
    _defineProperty$a(_assertThisInitialized$4(_this), "handleLeaveSlideOrTraveller", function() {
      _this.setState({
        isTextActive: false
      });
    });
    _defineProperty$a(_assertThisInitialized$4(_this), "handleSlideDragStart", function(e3) {
      var event = isTouch(e3) ? e3.changedTouches[0] : e3;
      _this.setState({
        isTravellerMoving: false,
        isSlideMoving: true,
        slideMoveStartX: event.pageX
      });
      _this.attachDragEndListener();
    });
    _this.travellerDragStartHandlers = {
      startX: _this.handleTravellerDragStart.bind(_assertThisInitialized$4(_this), "startX"),
      endX: _this.handleTravellerDragStart.bind(_assertThisInitialized$4(_this), "endX")
    };
    _this.state = {};
    return _this;
  }
  _createClass$6(Brush2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.leaveTimer) {
        clearTimeout(this.leaveTimer);
        this.leaveTimer = null;
      }
      this.detachDragEndListener();
    }
  }, {
    key: "getIndex",
    value: function getIndex(_ref2) {
      var startX = _ref2.startX, endX = _ref2.endX;
      var scaleValues = this.state.scaleValues;
      var _this$props = this.props, gap = _this$props.gap, data2 = _this$props.data;
      var lastIndex = data2.length - 1;
      var min3 = Math.min(startX, endX);
      var max3 = Math.max(startX, endX);
      var minIndex = Brush2.getIndexInRange(scaleValues, min3);
      var maxIndex = Brush2.getIndexInRange(scaleValues, max3);
      return {
        startIndex: minIndex - minIndex % gap,
        endIndex: maxIndex === lastIndex ? lastIndex : maxIndex - maxIndex % gap
      };
    }
  }, {
    key: "getTextOfTick",
    value: function getTextOfTick(index3) {
      var _this$props2 = this.props, data2 = _this$props2.data, tickFormatter = _this$props2.tickFormatter, dataKey = _this$props2.dataKey;
      var text = getValueByDataKey(data2[index3], dataKey, index3);
      return _isFunction(tickFormatter) ? tickFormatter(text, index3) : text;
    }
  }, {
    key: "attachDragEndListener",
    value: function attachDragEndListener() {
      window.addEventListener("mouseup", this.handleDragEnd, true);
      window.addEventListener("touchend", this.handleDragEnd, true);
      window.addEventListener("mousemove", this.handleDrag, true);
    }
  }, {
    key: "detachDragEndListener",
    value: function detachDragEndListener() {
      window.removeEventListener("mouseup", this.handleDragEnd, true);
      window.removeEventListener("touchend", this.handleDragEnd, true);
      window.removeEventListener("mousemove", this.handleDrag, true);
    }
  }, {
    key: "handleSlideDrag",
    value: function handleSlideDrag(e3) {
      var _this$state = this.state, slideMoveStartX = _this$state.slideMoveStartX, startX = _this$state.startX, endX = _this$state.endX;
      var _this$props3 = this.props, x2 = _this$props3.x, width = _this$props3.width, travellerWidth = _this$props3.travellerWidth, startIndex = _this$props3.startIndex, endIndex = _this$props3.endIndex, onChange = _this$props3.onChange;
      var delta = e3.pageX - slideMoveStartX;
      if (delta > 0) {
        delta = Math.min(delta, x2 + width - travellerWidth - endX, x2 + width - travellerWidth - startX);
      } else if (delta < 0) {
        delta = Math.max(delta, x2 - startX, x2 - endX);
      }
      var newIndex = this.getIndex({
        startX: startX + delta,
        endX: endX + delta
      });
      if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) {
        onChange(newIndex);
      }
      this.setState({
        startX: startX + delta,
        endX: endX + delta,
        slideMoveStartX: e3.pageX
      });
    }
  }, {
    key: "handleTravellerDragStart",
    value: function handleTravellerDragStart(id2, e3) {
      var event = isTouch(e3) ? e3.changedTouches[0] : e3;
      this.setState({
        isSlideMoving: false,
        isTravellerMoving: true,
        movingTravellerId: id2,
        brushMoveStartX: event.pageX
      });
      this.attachDragEndListener();
    }
  }, {
    key: "handleTravellerMove",
    value: function handleTravellerMove(e3) {
      var _this$setState;
      var _this$state2 = this.state, brushMoveStartX = _this$state2.brushMoveStartX, movingTravellerId = _this$state2.movingTravellerId, endX = _this$state2.endX, startX = _this$state2.startX;
      var prevValue = this.state[movingTravellerId];
      var _this$props4 = this.props, x2 = _this$props4.x, width = _this$props4.width, travellerWidth = _this$props4.travellerWidth, onChange = _this$props4.onChange, gap = _this$props4.gap, data2 = _this$props4.data;
      var params = {
        startX: this.state.startX,
        endX: this.state.endX
      };
      var delta = e3.pageX - brushMoveStartX;
      if (delta > 0) {
        delta = Math.min(delta, x2 + width - travellerWidth - prevValue);
      } else if (delta < 0) {
        delta = Math.max(delta, x2 - prevValue);
      }
      params[movingTravellerId] = prevValue + delta;
      var newIndex = this.getIndex(params);
      var startIndex = newIndex.startIndex, endIndex = newIndex.endIndex;
      var isFullGap = function isFullGap2() {
        var lastIndex = data2.length - 1;
        if (movingTravellerId === "startX" && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === "endX" && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) {
          return true;
        }
        return false;
      };
      this.setState((_this$setState = {}, _defineProperty$a(_this$setState, movingTravellerId, prevValue + delta), _defineProperty$a(_this$setState, "brushMoveStartX", e3.pageX), _this$setState), function() {
        if (onChange) {
          if (isFullGap()) {
            onChange(newIndex);
          }
        }
      });
    }
  }, {
    key: "renderBackground",
    value: function renderBackground() {
      var _this$props5 = this.props, x2 = _this$props5.x, y2 = _this$props5.y, width = _this$props5.width, height = _this$props5.height, fill = _this$props5.fill, stroke = _this$props5.stroke;
      return /* @__PURE__ */ React.createElement("rect", {
        stroke,
        fill,
        x: x2,
        y: y2,
        width,
        height
      });
    }
  }, {
    key: "renderPanorama",
    value: function renderPanorama() {
      var _this$props6 = this.props, x2 = _this$props6.x, y2 = _this$props6.y, width = _this$props6.width, height = _this$props6.height, data2 = _this$props6.data, children = _this$props6.children, padding = _this$props6.padding;
      var chartElement = reactExports.Children.only(children);
      if (!chartElement) {
        return null;
      }
      return /* @__PURE__ */ React.cloneElement(chartElement, {
        x: x2,
        y: y2,
        width,
        height,
        margin: padding,
        compact: true,
        data: data2
      });
    }
  }, {
    key: "renderTravellerLayer",
    value: function renderTravellerLayer(travellerX, id2) {
      var _this$props7 = this.props, y2 = _this$props7.y, travellerWidth = _this$props7.travellerWidth, height = _this$props7.height, traveller = _this$props7.traveller;
      var x2 = Math.max(travellerX, this.props.x);
      var travellerProps = _objectSpread$9(_objectSpread$9({}, filterProps(this.props)), {}, {
        x: x2,
        y: y2,
        width: travellerWidth,
        height
      });
      return /* @__PURE__ */ React.createElement(Layer, {
        className: "recharts-brush-traveller",
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.travellerDragStartHandlers[id2],
        onTouchStart: this.travellerDragStartHandlers[id2],
        style: {
          cursor: "col-resize"
        }
      }, Brush2.renderTraveller(traveller, travellerProps));
    }
  }, {
    key: "renderSlide",
    value: function renderSlide(startX, endX) {
      var _this$props8 = this.props, y2 = _this$props8.y, height = _this$props8.height, stroke = _this$props8.stroke, travellerWidth = _this$props8.travellerWidth;
      var x2 = Math.min(startX, endX) + travellerWidth;
      var width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);
      return /* @__PURE__ */ React.createElement("rect", {
        className: "recharts-brush-slide",
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.handleSlideDragStart,
        onTouchStart: this.handleSlideDragStart,
        style: {
          cursor: "move"
        },
        stroke: "none",
        fill: stroke,
        fillOpacity: 0.2,
        x: x2,
        y: y2,
        width,
        height
      });
    }
  }, {
    key: "renderText",
    value: function renderText() {
      var _this$props9 = this.props, startIndex = _this$props9.startIndex, endIndex = _this$props9.endIndex, y2 = _this$props9.y, height = _this$props9.height, travellerWidth = _this$props9.travellerWidth, stroke = _this$props9.stroke;
      var _this$state3 = this.state, startX = _this$state3.startX, endX = _this$state3.endX;
      var offset2 = 5;
      var attrs = {
        pointerEvents: "none",
        fill: stroke
      };
      return /* @__PURE__ */ React.createElement(Layer, {
        className: "recharts-brush-texts"
      }, /* @__PURE__ */ React.createElement(Text2, _extends$7({
        textAnchor: "end",
        verticalAnchor: "middle",
        x: Math.min(startX, endX) - offset2,
        y: y2 + height / 2
      }, attrs), this.getTextOfTick(startIndex)), /* @__PURE__ */ React.createElement(Text2, _extends$7({
        textAnchor: "start",
        verticalAnchor: "middle",
        x: Math.max(startX, endX) + travellerWidth + offset2,
        y: y2 + height / 2
      }, attrs), this.getTextOfTick(endIndex)));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props10 = this.props, data2 = _this$props10.data, className = _this$props10.className, children = _this$props10.children, x2 = _this$props10.x, y2 = _this$props10.y, width = _this$props10.width, height = _this$props10.height, alwaysShowText = _this$props10.alwaysShowText;
      var _this$state4 = this.state, startX = _this$state4.startX, endX = _this$state4.endX, isTextActive = _this$state4.isTextActive, isSlideMoving = _this$state4.isSlideMoving, isTravellerMoving = _this$state4.isTravellerMoving;
      if (!data2 || !data2.length || !isNumber(x2) || !isNumber(y2) || !isNumber(width) || !isNumber(height) || width <= 0 || height <= 0) {
        return null;
      }
      var layerClass = classNames("recharts-brush", className);
      var isPanoramic = React.Children.count(children) === 1;
      var style = generatePrefixStyle2("userSelect", "none");
      return /* @__PURE__ */ React.createElement(Layer, {
        className: layerClass,
        onMouseLeave: this.handleLeaveWrapper,
        onTouchMove: this.handleTouchMove,
        style
      }, this.renderBackground(), isPanoramic && this.renderPanorama(), this.renderSlide(startX, endX), this.renderTravellerLayer(startX, "startX"), this.renderTravellerLayer(endX, "endX"), (isTextActive || isSlideMoving || isTravellerMoving || alwaysShowText) && this.renderText());
    }
  }], [{
    key: "renderDefaultTraveller",
    value: function renderDefaultTraveller(props3) {
      var x2 = props3.x, y2 = props3.y, width = props3.width, height = props3.height, stroke = props3.stroke;
      var lineY = Math.floor(y2 + height / 2) - 1;
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("rect", {
        x: x2,
        y: y2,
        width,
        height,
        fill: stroke,
        stroke: "none"
      }), /* @__PURE__ */ React.createElement("line", {
        x1: x2 + 1,
        y1: lineY,
        x2: x2 + width - 1,
        y2: lineY,
        fill: "none",
        stroke: "#fff"
      }), /* @__PURE__ */ React.createElement("line", {
        x1: x2 + 1,
        y1: lineY + 2,
        x2: x2 + width - 1,
        y2: lineY + 2,
        fill: "none",
        stroke: "#fff"
      }));
    }
  }, {
    key: "renderTraveller",
    value: function renderTraveller(option, props3) {
      var rectangle;
      if (/* @__PURE__ */ React.isValidElement(option)) {
        rectangle = /* @__PURE__ */ React.cloneElement(option, props3);
      } else if (_isFunction(option)) {
        rectangle = option(props3);
      } else {
        rectangle = Brush2.renderDefaultTraveller(props3);
      }
      return rectangle;
    }
  }, {
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var data2 = nextProps.data, width = nextProps.width, x2 = nextProps.x, travellerWidth = nextProps.travellerWidth, updateId = nextProps.updateId, startIndex = nextProps.startIndex, endIndex = nextProps.endIndex;
      if (data2 !== prevState.prevData || updateId !== prevState.prevUpdateId) {
        return _objectSpread$9({
          prevData: data2,
          prevTravellerWidth: travellerWidth,
          prevUpdateId: updateId,
          prevX: x2,
          prevWidth: width
        }, data2 && data2.length ? createScale({
          data: data2,
          width,
          x: x2,
          travellerWidth,
          startIndex,
          endIndex
        }) : {
          scale: null,
          scaleValues: null
        });
      }
      if (prevState.scale && (width !== prevState.prevWidth || x2 !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {
        prevState.scale.range([x2, x2 + width - travellerWidth]);
        var scaleValues = prevState.scale.domain().map(function(entry) {
          return prevState.scale(entry);
        });
        return {
          prevData: data2,
          prevTravellerWidth: travellerWidth,
          prevUpdateId: updateId,
          prevX: x2,
          prevWidth: width,
          startX: prevState.scale(nextProps.startIndex),
          endX: prevState.scale(nextProps.endIndex),
          scaleValues
        };
      }
      return null;
    }
  }, {
    key: "getIndexInRange",
    value: function getIndexInRange(range4, x2) {
      var len = range4.length;
      var start = 0;
      var end = len - 1;
      while (end - start > 1) {
        var middle = Math.floor((start + end) / 2);
        if (range4[middle] > x2) {
          end = middle;
        } else {
          start = middle;
        }
      }
      return x2 >= range4[end] ? end : start;
    }
  }]);
  return Brush2;
}(reactExports.PureComponent);
_defineProperty$a(Brush, "displayName", "Brush");
_defineProperty$a(Brush, "defaultProps", {
  height: 40,
  travellerWidth: 5,
  gap: 1,
  fill: "#fff",
  stroke: "#666",
  padding: {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  },
  leaveTimeOut: 1e3,
  alwaysShowText: false
});
var baseEach$1 = _baseEach;
function baseSome$1(collection, predicate3) {
  var result;
  baseEach$1(collection, function(value, index3, collection2) {
    result = predicate3(value, index3, collection2);
    return !result;
  });
  return !!result;
}
var _baseSome = baseSome$1;
var arraySome = _arraySome, baseIteratee$4 = _baseIteratee, baseSome = _baseSome, isArray$1 = isArray_1, isIterateeCall$1 = _isIterateeCall;
function some(collection, predicate3, guard) {
  var func3 = isArray$1(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall$1(collection, predicate3, guard)) {
    predicate3 = void 0;
  }
  return func3(collection, baseIteratee$4(predicate3));
}
var some_1 = some;
const _some = /* @__PURE__ */ getDefaultExportFromCjs(some_1);
var ifOverflowMatches = function ifOverflowMatches2(props3, value) {
  var alwaysShow = props3.alwaysShow;
  var ifOverflow = props3.ifOverflow;
  if (alwaysShow) {
    ifOverflow = "extendDomain";
  }
  return ifOverflow === value;
};
function arrayEvery$1(array3, predicate3) {
  var index3 = -1, length3 = array3 == null ? 0 : array3.length;
  while (++index3 < length3) {
    if (!predicate3(array3[index3], index3, array3)) {
      return false;
    }
  }
  return true;
}
var _arrayEvery = arrayEvery$1;
var baseEach = _baseEach;
function baseEvery$1(collection, predicate3) {
  var result = true;
  baseEach(collection, function(value, index3, collection2) {
    result = !!predicate3(value, index3, collection2);
    return result;
  });
  return result;
}
var _baseEvery = baseEvery$1;
var arrayEvery = _arrayEvery, baseEvery = _baseEvery, baseIteratee$3 = _baseIteratee, isArray = isArray_1, isIterateeCall = _isIterateeCall;
function every(collection, predicate3, guard) {
  var func3 = isArray(collection) ? arrayEvery : baseEvery;
  if (guard && isIterateeCall(collection, predicate3, guard)) {
    predicate3 = void 0;
  }
  return func3(collection, baseIteratee$3(predicate3));
}
var every_1 = every;
const _every = /* @__PURE__ */ getDefaultExportFromCjs(every_1);
var defineProperty = _defineProperty$m;
function baseAssignValue$1(object2, key, value) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object2[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$1;
var baseAssignValue = _baseAssignValue, baseForOwn = _baseForOwn, baseIteratee$2 = _baseIteratee;
function mapValues(object2, iteratee) {
  var result = {};
  iteratee = baseIteratee$2(iteratee);
  baseForOwn(object2, function(value, key, object3) {
    baseAssignValue(result, key, iteratee(value, key, object3));
  });
  return result;
}
var mapValues_1 = mapValues;
const _mapValues = /* @__PURE__ */ getDefaultExportFromCjs(mapValues_1);
var _excluded$3 = ["value", "background"];
function _typeof$9(obj) {
  "@babel/helpers - typeof";
  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$9(obj);
}
function _objectWithoutProperties$3(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$3(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
function ownKeys$8(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$8(Object(source), true).forEach(function(key) {
      _defineProperty$9(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$9(descriptor.key), descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$5(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o3, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$3(o3, p2);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self2, call3) {
  if (call3 && (_typeof$9(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$3(o3) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$3(o3);
}
function _defineProperty$9(obj, key, value) {
  key = _toPropertyKey$9(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$9(arg) {
  var key = _toPrimitive$9(arg, "string");
  return _typeof$9(key) === "symbol" ? key : String(key);
}
function _toPrimitive$9(input, hint) {
  if (_typeof$9(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$9(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Bar = /* @__PURE__ */ function(_PureComponent) {
  _inherits$3(Bar2, _PureComponent);
  var _super = _createSuper$3(Bar2);
  function Bar2() {
    var _this;
    _classCallCheck$5(this, Bar2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$9(_assertThisInitialized$3(_this), "state", {
      isAnimationFinished: false
    });
    _defineProperty$9(_assertThisInitialized$3(_this), "id", uniqueId("recharts-bar-"));
    _defineProperty$9(_assertThisInitialized$3(_this), "handleAnimationEnd", function() {
      var onAnimationEnd2 = _this.props.onAnimationEnd;
      _this.setState({
        isAnimationFinished: true
      });
      if (onAnimationEnd2) {
        onAnimationEnd2();
      }
    });
    _defineProperty$9(_assertThisInitialized$3(_this), "handleAnimationStart", function() {
      var onAnimationStart2 = _this.props.onAnimationStart;
      _this.setState({
        isAnimationFinished: false
      });
      if (onAnimationStart2) {
        onAnimationStart2();
      }
    });
    return _this;
  }
  _createClass$5(Bar2, [{
    key: "renderRectanglesStatically",
    value: function renderRectanglesStatically(data2) {
      var _this2 = this;
      var shape = this.props.shape;
      var baseProps = filterProps(this.props);
      return data2 && data2.map(function(entry, i) {
        var props3 = _objectSpread$8(_objectSpread$8(_objectSpread$8({}, baseProps), entry), {}, {
          index: i
        });
        return /* @__PURE__ */ React.createElement(Layer, _extends$6({
          className: "recharts-bar-rectangle"
        }, adaptEventsOfChild(_this2.props, entry, i), {
          key: "rectangle-".concat(i),
          role: "img"
        }), Bar2.renderRectangle(shape, props3));
      });
    }
  }, {
    key: "renderRectanglesWithAnimation",
    value: function renderRectanglesWithAnimation() {
      var _this3 = this;
      var _this$props = this.props, data2 = _this$props.data, layout = _this$props.layout, isAnimationActive = _this$props.isAnimationActive, animationBegin = _this$props.animationBegin, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, animationId = _this$props.animationId;
      var prevData = this.state.prevData;
      return /* @__PURE__ */ React.createElement(Animate, {
        begin: animationBegin,
        duration: animationDuration,
        isActive: isAnimationActive,
        easing: animationEasing,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "bar-".concat(animationId),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(_ref) {
        var t2 = _ref.t;
        var stepData = data2.map(function(entry, index3) {
          var prev = prevData && prevData[index3];
          if (prev) {
            var interpolatorX = interpolateNumber$2(prev.x, entry.x);
            var interpolatorY = interpolateNumber$2(prev.y, entry.y);
            var interpolatorWidth = interpolateNumber$2(prev.width, entry.width);
            var interpolatorHeight = interpolateNumber$2(prev.height, entry.height);
            return _objectSpread$8(_objectSpread$8({}, entry), {}, {
              x: interpolatorX(t2),
              y: interpolatorY(t2),
              width: interpolatorWidth(t2),
              height: interpolatorHeight(t2)
            });
          }
          if (layout === "horizontal") {
            var _interpolatorHeight = interpolateNumber$2(0, entry.height);
            var h2 = _interpolatorHeight(t2);
            return _objectSpread$8(_objectSpread$8({}, entry), {}, {
              y: entry.y + entry.height - h2,
              height: h2
            });
          }
          var interpolator = interpolateNumber$2(0, entry.width);
          var w2 = interpolator(t2);
          return _objectSpread$8(_objectSpread$8({}, entry), {}, {
            width: w2
          });
        });
        return /* @__PURE__ */ React.createElement(Layer, null, _this3.renderRectanglesStatically(stepData));
      });
    }
  }, {
    key: "renderRectangles",
    value: function renderRectangles() {
      var _this$props2 = this.props, data2 = _this$props2.data, isAnimationActive = _this$props2.isAnimationActive;
      var prevData = this.state.prevData;
      if (isAnimationActive && data2 && data2.length && (!prevData || !_isEqual(prevData, data2))) {
        return this.renderRectanglesWithAnimation();
      }
      return this.renderRectanglesStatically(data2);
    }
  }, {
    key: "renderBackground",
    value: function renderBackground() {
      var _this4 = this;
      var data2 = this.props.data;
      var backgroundProps = filterProps(this.props.background);
      return data2.map(function(entry, i) {
        entry.value;
        var background = entry.background, rest = _objectWithoutProperties$3(entry, _excluded$3);
        if (!background) {
          return null;
        }
        var props3 = _objectSpread$8(_objectSpread$8(_objectSpread$8(_objectSpread$8(_objectSpread$8({}, rest), {}, {
          fill: "#eee"
        }, background), backgroundProps), adaptEventsOfChild(_this4.props, entry, i)), {}, {
          index: i,
          key: "background-bar-".concat(i),
          className: "recharts-bar-background-rectangle"
        });
        return Bar2.renderRectangle(_this4.props.background, props3);
      });
    }
  }, {
    key: "renderErrorBar",
    value: function renderErrorBar(needClip, clipPathId) {
      if (this.props.isAnimationActive && !this.state.isAnimationFinished) {
        return null;
      }
      var _this$props3 = this.props, data2 = _this$props3.data, xAxis = _this$props3.xAxis, yAxis = _this$props3.yAxis, layout = _this$props3.layout, children = _this$props3.children;
      var errorBarItems = findAllByType(children, ErrorBar);
      if (!errorBarItems) {
        return null;
      }
      var offset2 = layout === "vertical" ? data2[0].height / 2 : data2[0].width / 2;
      function dataPointFormatter(dataPoint, dataKey) {
        return {
          x: dataPoint.x,
          y: dataPoint.y,
          value: dataPoint.value,
          errorVal: getValueByDataKey(dataPoint, dataKey)
        };
      }
      var errorBarProps = {
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
      };
      return /* @__PURE__ */ React.createElement(Layer, errorBarProps, errorBarItems.map(function(item, i) {
        return /* @__PURE__ */ React.cloneElement(item, {
          key: "error-bar-".concat(i),
          // eslint-disable-line react/no-array-index-key
          data: data2,
          xAxis,
          yAxis,
          layout,
          offset: offset2,
          dataPointFormatter
        });
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props4 = this.props, hide = _this$props4.hide, data2 = _this$props4.data, className = _this$props4.className, xAxis = _this$props4.xAxis, yAxis = _this$props4.yAxis, left = _this$props4.left, top = _this$props4.top, width = _this$props4.width, height = _this$props4.height, isAnimationActive = _this$props4.isAnimationActive, background = _this$props4.background, id2 = _this$props4.id;
      if (hide || !data2 || !data2.length) {
        return null;
      }
      var isAnimationFinished = this.state.isAnimationFinished;
      var layerClass = classNames("recharts-bar", className);
      var needClip = xAxis && xAxis.allowDataOverflow || yAxis && yAxis.allowDataOverflow;
      var clipPathId = _isNil(id2) ? this.id : id2;
      return /* @__PURE__ */ React.createElement(Layer, {
        className: layerClass
      }, needClip ? /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", {
        id: "clipPath-".concat(clipPathId)
      }, /* @__PURE__ */ React.createElement("rect", {
        x: left,
        y: top,
        width,
        height
      }))) : null, /* @__PURE__ */ React.createElement(Layer, {
        className: "recharts-bar-rectangles",
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
      }, background ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(needClip, clipPathId), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, data2));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.animationId !== prevState.prevAnimationId) {
        return {
          prevAnimationId: nextProps.animationId,
          curData: nextProps.data,
          prevData: prevState.curData
        };
      }
      if (nextProps.data !== prevState.curData) {
        return {
          curData: nextProps.data
        };
      }
      return null;
    }
  }, {
    key: "renderRectangle",
    value: function renderRectangle(option, props3) {
      var rectangle;
      if (/* @__PURE__ */ React.isValidElement(option)) {
        rectangle = /* @__PURE__ */ React.cloneElement(option, props3);
      } else if (_isFunction(option)) {
        rectangle = option(props3);
      } else {
        rectangle = /* @__PURE__ */ React.createElement(Rectangle, props3);
      }
      return rectangle;
    }
  }]);
  return Bar2;
}(reactExports.PureComponent);
_defineProperty$9(Bar, "displayName", "Bar");
_defineProperty$9(Bar, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  legendType: "rect",
  minPointSize: 0,
  hide: false,
  // data of bar
  data: [],
  layout: "vertical",
  isAnimationActive: !Global.isSsr,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease"
});
_defineProperty$9(Bar, "getComposedData", function(_ref2) {
  var props3 = _ref2.props, item = _ref2.item, barPosition = _ref2.barPosition, bandSize = _ref2.bandSize, xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, stackedData = _ref2.stackedData, dataStartIndex = _ref2.dataStartIndex, displayedData = _ref2.displayedData, offset2 = _ref2.offset;
  var pos = findPositionOfBar(barPosition, item);
  if (!pos) {
    return null;
  }
  var layout = props3.layout;
  var _item$props = item.props, dataKey = _item$props.dataKey, children = _item$props.children, minPointSize = _item$props.minPointSize;
  var numericAxis = layout === "horizontal" ? yAxis : xAxis;
  var stackedDomain = stackedData ? numericAxis.scale.domain() : null;
  var baseValue = getBaseValueOfBar({
    numericAxis
  });
  var cells = findAllByType(children, Cell);
  var rects = displayedData.map(function(entry, index3) {
    var value, x2, y2, width, height, background;
    if (stackedData) {
      value = truncateByDomain(stackedData[dataStartIndex + index3], stackedDomain);
    } else {
      value = getValueByDataKey(entry, dataKey);
      if (!_isArray2(value)) {
        value = [baseValue, value];
      }
    }
    if (layout === "horizontal") {
      var _ref4;
      var _ref3 = [yAxis.scale(value[0]), yAxis.scale(value[1])], baseValueScale = _ref3[0], currentValueScale = _ref3[1];
      x2 = getCateCoordinateOfBar({
        axis: xAxis,
        ticks: xAxisTicks,
        bandSize,
        offset: pos.offset,
        entry,
        index: index3
      });
      y2 = (_ref4 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref4 !== void 0 ? _ref4 : void 0;
      width = pos.size;
      var computedHeight = baseValueScale - currentValueScale;
      height = Number.isNaN(computedHeight) ? 0 : computedHeight;
      background = {
        x: x2,
        y: yAxis.y,
        width,
        height: yAxis.height
      };
      if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {
        var delta = mathSign(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));
        y2 -= delta;
        height += delta;
      }
    } else {
      var _ref5 = [xAxis.scale(value[0]), xAxis.scale(value[1])], _baseValueScale = _ref5[0], _currentValueScale = _ref5[1];
      x2 = _baseValueScale;
      y2 = getCateCoordinateOfBar({
        axis: yAxis,
        ticks: yAxisTicks,
        bandSize,
        offset: pos.offset,
        entry,
        index: index3
      });
      width = _currentValueScale - _baseValueScale;
      height = pos.size;
      background = {
        x: xAxis.x,
        y: y2,
        width: xAxis.width,
        height
      };
      if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {
        var _delta = mathSign(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));
        width += _delta;
      }
    }
    return _objectSpread$8(_objectSpread$8(_objectSpread$8({}, entry), {}, {
      x: x2,
      y: y2,
      width,
      height,
      value: stackedData ? value : value[1],
      payload: entry,
      background
    }, cells && cells[index3] && cells[index3].props), {}, {
      tooltipPayload: [getTooltipItem(item, entry)],
      tooltipPosition: {
        x: x2 + width / 2,
        y: y2 + height / 2
      }
    });
  });
  return _objectSpread$8({
    data: rects,
    layout
  }, offset2);
});
function _typeof$8(obj) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$8(obj);
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$8(descriptor.key), descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function ownKeys$7(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$7(Object(source), true).forEach(function(key) {
      _defineProperty$8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$8(obj, key, value) {
  key = _toPropertyKey$8(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$8(arg) {
  var key = _toPrimitive$8(arg, "string");
  return _typeof$8(key) === "symbol" ? key : String(key);
}
function _toPrimitive$8(input, hint) {
  if (_typeof$8(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$8(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var formatAxisMap = function formatAxisMap2(props3, axisMap, offset2, axisType, chartName) {
  var width = props3.width, height = props3.height, layout = props3.layout, children = props3.children;
  var ids2 = Object.keys(axisMap);
  var steps = {
    left: offset2.left,
    leftMirror: offset2.left,
    right: width - offset2.right,
    rightMirror: width - offset2.right,
    top: offset2.top,
    topMirror: offset2.top,
    bottom: height - offset2.bottom,
    bottomMirror: height - offset2.bottom
  };
  var hasBar = !!findChildByType(children, Bar);
  return ids2.reduce(function(result, id2) {
    var axis = axisMap[id2];
    var orientation = axis.orientation, domain = axis.domain, _axis$padding = axis.padding, padding = _axis$padding === void 0 ? {} : _axis$padding, mirror = axis.mirror, reversed = axis.reversed;
    var offsetKey = "".concat(orientation).concat(mirror ? "Mirror" : "");
    var calculatedPadding, range4, x2, y2, needSpace;
    if (axis.type === "number" && (axis.padding === "gap" || axis.padding === "no-gap")) {
      var diff2 = domain[1] - domain[0];
      var smallestDistanceBetweenValues = Infinity;
      var sortedValues = axis.categoricalDomain.sort();
      sortedValues.forEach(function(value, index3) {
        if (index3 > 0) {
          smallestDistanceBetweenValues = Math.min((value || 0) - (sortedValues[index3 - 1] || 0), smallestDistanceBetweenValues);
        }
      });
      var smallestDistanceInPercent = smallestDistanceBetweenValues / diff2;
      var rangeWidth = axis.layout === "vertical" ? offset2.height : offset2.width;
      if (axis.padding === "gap") {
        calculatedPadding = smallestDistanceInPercent * rangeWidth / 2;
      }
      if (axis.padding === "no-gap") {
        var gap = getPercentValue(props3.barCategoryGap, smallestDistanceInPercent * rangeWidth);
        var halfBand = smallestDistanceInPercent * rangeWidth / 2;
        calculatedPadding = halfBand - gap - (halfBand - gap) / rangeWidth * gap;
      }
    }
    if (axisType === "xAxis") {
      range4 = [offset2.left + (padding.left || 0) + (calculatedPadding || 0), offset2.left + offset2.width - (padding.right || 0) - (calculatedPadding || 0)];
    } else if (axisType === "yAxis") {
      range4 = layout === "horizontal" ? [offset2.top + offset2.height - (padding.bottom || 0), offset2.top + (padding.top || 0)] : [offset2.top + (padding.top || 0) + (calculatedPadding || 0), offset2.top + offset2.height - (padding.bottom || 0) - (calculatedPadding || 0)];
    } else {
      range4 = axis.range;
    }
    if (reversed) {
      range4 = [range4[1], range4[0]];
    }
    var _parseScale = parseScale(axis, chartName, hasBar), scale = _parseScale.scale, realScaleType = _parseScale.realScaleType;
    scale.domain(domain).range(range4);
    checkDomainOfScale(scale);
    var ticks2 = getTicksOfScale(scale, _objectSpread$7(_objectSpread$7({}, axis), {}, {
      realScaleType
    }));
    if (axisType === "xAxis") {
      needSpace = orientation === "top" && !mirror || orientation === "bottom" && mirror;
      x2 = offset2.left;
      y2 = steps[offsetKey] - needSpace * axis.height;
    } else if (axisType === "yAxis") {
      needSpace = orientation === "left" && !mirror || orientation === "right" && mirror;
      x2 = steps[offsetKey] - needSpace * axis.width;
      y2 = offset2.top;
    }
    var finalAxis = _objectSpread$7(_objectSpread$7(_objectSpread$7({}, axis), ticks2), {}, {
      realScaleType,
      x: x2,
      y: y2,
      scale,
      width: axisType === "xAxis" ? offset2.width : axis.width,
      height: axisType === "yAxis" ? offset2.height : axis.height
    });
    finalAxis.bandSize = getBandSizeOfAxis(finalAxis, ticks2);
    if (!axis.hide && axisType === "xAxis") {
      steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.height;
    } else if (!axis.hide) {
      steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.width;
    }
    return _objectSpread$7(_objectSpread$7({}, result), {}, _defineProperty$8({}, id2, finalAxis));
  }, {});
};
var rectWithPoints = function rectWithPoints2(_ref, _ref2) {
  var x1 = _ref.x, y1 = _ref.y;
  var x2 = _ref2.x, y2 = _ref2.y;
  return {
    x: Math.min(x1, x2),
    y: Math.min(y1, y2),
    width: Math.abs(x2 - x1),
    height: Math.abs(y2 - y1)
  };
};
var rectWithCoords = function rectWithCoords2(_ref3) {
  var x1 = _ref3.x1, y1 = _ref3.y1, x2 = _ref3.x2, y2 = _ref3.y2;
  return rectWithPoints({
    x: x1,
    y: y1
  }, {
    x: x2,
    y: y2
  });
};
var ScaleHelper = /* @__PURE__ */ function() {
  function ScaleHelper2(scale) {
    _classCallCheck$4(this, ScaleHelper2);
    this.scale = scale;
  }
  _createClass$4(ScaleHelper2, [{
    key: "domain",
    get: function get3() {
      return this.scale.domain;
    }
  }, {
    key: "range",
    get: function get3() {
      return this.scale.range;
    }
  }, {
    key: "rangeMin",
    get: function get3() {
      return this.range()[0];
    }
  }, {
    key: "rangeMax",
    get: function get3() {
      return this.range()[1];
    }
  }, {
    key: "bandwidth",
    get: function get3() {
      return this.scale.bandwidth;
    }
  }, {
    key: "apply",
    value: function apply3(value) {
      var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bandAware = _ref4.bandAware, position = _ref4.position;
      if (value === void 0) {
        return void 0;
      }
      if (position) {
        switch (position) {
          case "start": {
            return this.scale(value);
          }
          case "middle": {
            var offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
            return this.scale(value) + offset2;
          }
          case "end": {
            var _offset = this.bandwidth ? this.bandwidth() : 0;
            return this.scale(value) + _offset;
          }
          default: {
            return this.scale(value);
          }
        }
      }
      if (bandAware) {
        var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
        return this.scale(value) + _offset2;
      }
      return this.scale(value);
    }
  }, {
    key: "isInRange",
    value: function isInRange(value) {
      var range4 = this.range();
      var first = range4[0];
      var last2 = range4[range4.length - 1];
      return first <= last2 ? value >= first && value <= last2 : value >= last2 && value <= first;
    }
  }], [{
    key: "create",
    value: function create(obj) {
      return new ScaleHelper2(obj);
    }
  }]);
  return ScaleHelper2;
}();
_defineProperty$8(ScaleHelper, "EPS", 1e-4);
var createLabeledScales = function createLabeledScales2(options) {
  var scales = Object.keys(options).reduce(function(res, key) {
    return _objectSpread$7(_objectSpread$7({}, res), {}, _defineProperty$8({}, key, ScaleHelper.create(options[key])));
  }, {});
  return _objectSpread$7(_objectSpread$7({}, scales), {}, {
    apply: function apply3(coord) {
      var _ref5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bandAware = _ref5.bandAware, position = _ref5.position;
      return _mapValues(coord, function(value, label) {
        return scales[label].apply(value, {
          bandAware,
          position
        });
      });
    },
    isInRange: function isInRange(coord) {
      return _every(coord, function(value, label) {
        return scales[label].isInRange(value);
      });
    }
  });
};
function _typeof$7(obj) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$7(obj);
}
function ownKeys$6(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
      _defineProperty$7(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$7(obj, key, value) {
  key = _toPropertyKey$7(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$7(arg) {
  var key = _toPrimitive$7(arg, "string");
  return _typeof$7(key) === "symbol" ? key : String(key);
}
function _toPrimitive$7(input, hint) {
  if (_typeof$7(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$7(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$2(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o3, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$1(arr, i) {
  var _i2 = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i2) {
    var _s2, _e2, _x, _r, _arr = [], _n2 = true, _d = false;
    try {
      if (_x = (_i2 = _i2.call(arr)).next, 0 === i) {
        if (Object(_i2) !== _i2)
          return;
        _n2 = false;
      } else
        for (; !(_n2 = (_s2 = _x.call(_i2)).done) && (_arr.push(_s2.value), _arr.length !== i); _n2 = true)
          ;
    } catch (err) {
      _d = true, _e2 = err;
    } finally {
      try {
        if (!_n2 && null != _i2["return"] && (_r = _i2["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
var renderLine = function renderLine2(option, props3) {
  var line;
  if (/* @__PURE__ */ React.isValidElement(option)) {
    line = /* @__PURE__ */ React.cloneElement(option, props3);
  } else if (_isFunction(option)) {
    line = option(props3);
  } else {
    line = /* @__PURE__ */ React.createElement("line", _extends$5({}, props3, {
      className: "recharts-reference-line-line"
    }));
  }
  return line;
};
var getEndPoints = function getEndPoints2(scales, isFixedX, isFixedY, isSegment, props3) {
  var _props$viewBox = props3.viewBox, x2 = _props$viewBox.x, y2 = _props$viewBox.y, width = _props$viewBox.width, height = _props$viewBox.height, position = props3.position;
  if (isFixedY) {
    var yCoord = props3.y, orientation = props3.yAxis.orientation;
    var coord = scales.y.apply(yCoord, {
      position
    });
    if (ifOverflowMatches(props3, "discard") && !scales.y.isInRange(coord)) {
      return null;
    }
    var points = [{
      x: x2 + width,
      y: coord
    }, {
      x: x2,
      y: coord
    }];
    return orientation === "left" ? points.reverse() : points;
  }
  if (isFixedX) {
    var xCoord = props3.x, _orientation = props3.xAxis.orientation;
    var _coord = scales.x.apply(xCoord, {
      position
    });
    if (ifOverflowMatches(props3, "discard") && !scales.x.isInRange(_coord)) {
      return null;
    }
    var _points = [{
      x: _coord,
      y: y2 + height
    }, {
      x: _coord,
      y: y2
    }];
    return _orientation === "top" ? _points.reverse() : _points;
  }
  if (isSegment) {
    var segment = props3.segment;
    var _points2 = segment.map(function(p2) {
      return scales.apply(p2, {
        position
      });
    });
    if (ifOverflowMatches(props3, "discard") && _some(_points2, function(p2) {
      return !scales.isInRange(p2);
    })) {
      return null;
    }
    return _points2;
  }
  return null;
};
function ReferenceLine(props3) {
  var fixedX = props3.x, fixedY = props3.y, segment = props3.segment, xAxis = props3.xAxis, yAxis = props3.yAxis, shape = props3.shape, className = props3.className, alwaysShow = props3.alwaysShow, clipPathId = props3.clipPathId;
  warn(alwaysShow === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
  var scales = createLabeledScales({
    x: xAxis.scale,
    y: yAxis.scale
  });
  var isX = isNumOrStr(fixedX);
  var isY = isNumOrStr(fixedY);
  var isSegment = segment && segment.length === 2;
  var endPoints = getEndPoints(scales, isX, isY, isSegment, props3);
  if (!endPoints) {
    return null;
  }
  var _endPoints = _slicedToArray$1(endPoints, 2), _endPoints$ = _endPoints[0], x1 = _endPoints$.x, y1 = _endPoints$.y, _endPoints$2 = _endPoints[1], x2 = _endPoints$2.x, y2 = _endPoints$2.y;
  var clipPath = ifOverflowMatches(props3, "hidden") ? "url(#".concat(clipPathId, ")") : void 0;
  var lineProps = _objectSpread$6(_objectSpread$6({
    clipPath
  }, filterProps(props3, true)), {}, {
    x1,
    y1,
    x2,
    y2
  });
  return /* @__PURE__ */ React.createElement(Layer, {
    className: classNames("recharts-reference-line", className)
  }, renderLine(shape, lineProps), Label2.renderCallByParent(props3, rectWithCoords({
    x1,
    y1,
    x2,
    y2
  })));
}
ReferenceLine.displayName = "ReferenceLine";
ReferenceLine.defaultProps = {
  isFront: false,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  fill: "none",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1,
  position: "middle"
};
function _typeof$6(obj) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$6(obj);
}
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function ownKeys$5(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$6(obj, key, value) {
  key = _toPropertyKey$6(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$6(arg) {
  var key = _toPrimitive$6(arg, "string");
  return _typeof$6(key) === "symbol" ? key : String(key);
}
function _toPrimitive$6(input, hint) {
  if (_typeof$6(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$6(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var getCoordinate = function getCoordinate2(props3) {
  var x2 = props3.x, y2 = props3.y, xAxis = props3.xAxis, yAxis = props3.yAxis;
  var scales = createLabeledScales({
    x: xAxis.scale,
    y: yAxis.scale
  });
  var result = scales.apply({
    x: x2,
    y: y2
  }, {
    bandAware: true
  });
  if (ifOverflowMatches(props3, "discard") && !scales.isInRange(result)) {
    return null;
  }
  return result;
};
function ReferenceDot(props3) {
  var x2 = props3.x, y2 = props3.y, r2 = props3.r, alwaysShow = props3.alwaysShow, clipPathId = props3.clipPathId;
  var isX = isNumOrStr(x2);
  var isY = isNumOrStr(y2);
  warn(alwaysShow === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
  if (!isX || !isY) {
    return null;
  }
  var coordinate = getCoordinate(props3);
  if (!coordinate) {
    return null;
  }
  var cx = coordinate.x, cy = coordinate.y;
  var shape = props3.shape, className = props3.className;
  var clipPath = ifOverflowMatches(props3, "hidden") ? "url(#".concat(clipPathId, ")") : void 0;
  var dotProps = _objectSpread$5(_objectSpread$5({
    clipPath
  }, filterProps(props3, true)), {}, {
    cx,
    cy
  });
  return /* @__PURE__ */ React.createElement(Layer, {
    className: classNames("recharts-reference-dot", className)
  }, ReferenceDot.renderDot(shape, dotProps), Label2.renderCallByParent(props3, {
    x: cx - r2,
    y: cy - r2,
    width: 2 * r2,
    height: 2 * r2
  }));
}
ReferenceDot.displayName = "ReferenceDot";
ReferenceDot.defaultProps = {
  isFront: false,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#fff",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1
};
ReferenceDot.renderDot = function(option, props3) {
  var dot;
  if (/* @__PURE__ */ React.isValidElement(option)) {
    dot = /* @__PURE__ */ React.cloneElement(option, props3);
  } else if (_isFunction(option)) {
    dot = option(props3);
  } else {
    dot = /* @__PURE__ */ React.createElement(Dot, _extends$4({}, props3, {
      cx: props3.cx,
      cy: props3.cy,
      className: "recharts-reference-dot-dot"
    }));
  }
  return dot;
};
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$5(obj);
}
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function ownKeys$4(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
      _defineProperty$5(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$5(obj, key, value) {
  key = _toPropertyKey$5(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$5(arg) {
  var key = _toPrimitive$5(arg, "string");
  return _typeof$5(key) === "symbol" ? key : String(key);
}
function _toPrimitive$5(input, hint) {
  if (_typeof$5(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$5(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var getRect = function getRect2(hasX1, hasX2, hasY1, hasY2, props3) {
  var xValue1 = props3.x1, xValue2 = props3.x2, yValue1 = props3.y1, yValue2 = props3.y2, xAxis = props3.xAxis, yAxis = props3.yAxis;
  if (!xAxis || !yAxis)
    return null;
  var scales = createLabeledScales({
    x: xAxis.scale,
    y: yAxis.scale
  });
  var p1 = {
    x: hasX1 ? scales.x.apply(xValue1, {
      position: "start"
    }) : scales.x.rangeMin,
    y: hasY1 ? scales.y.apply(yValue1, {
      position: "start"
    }) : scales.y.rangeMin
  };
  var p2 = {
    x: hasX2 ? scales.x.apply(xValue2, {
      position: "end"
    }) : scales.x.rangeMax,
    y: hasY2 ? scales.y.apply(yValue2, {
      position: "end"
    }) : scales.y.rangeMax
  };
  if (ifOverflowMatches(props3, "discard") && (!scales.isInRange(p1) || !scales.isInRange(p2))) {
    return null;
  }
  return rectWithPoints(p1, p2);
};
function ReferenceArea(props3) {
  var x1 = props3.x1, x2 = props3.x2, y1 = props3.y1, y2 = props3.y2, className = props3.className, alwaysShow = props3.alwaysShow, clipPathId = props3.clipPathId;
  warn(alwaysShow === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
  var hasX1 = isNumOrStr(x1);
  var hasX2 = isNumOrStr(x2);
  var hasY1 = isNumOrStr(y1);
  var hasY2 = isNumOrStr(y2);
  var shape = props3.shape;
  if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape) {
    return null;
  }
  var rect = getRect(hasX1, hasX2, hasY1, hasY2, props3);
  if (!rect && !shape) {
    return null;
  }
  var clipPath = ifOverflowMatches(props3, "hidden") ? "url(#".concat(clipPathId, ")") : void 0;
  return /* @__PURE__ */ React.createElement(Layer, {
    className: classNames("recharts-reference-area", className)
  }, ReferenceArea.renderRect(shape, _objectSpread$4(_objectSpread$4({
    clipPath
  }, filterProps(props3, true)), rect)), Label2.renderCallByParent(props3, rect));
}
ReferenceArea.displayName = "ReferenceArea";
ReferenceArea.defaultProps = {
  isFront: false,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#ccc",
  fillOpacity: 0.5,
  stroke: "none",
  strokeWidth: 1
};
ReferenceArea.renderRect = function(option, props3) {
  var rect;
  if (/* @__PURE__ */ React.isValidElement(option)) {
    rect = /* @__PURE__ */ React.cloneElement(option, props3);
  } else if (_isFunction(option)) {
    rect = option(props3);
  } else {
    rect = /* @__PURE__ */ React.createElement(Rectangle, _extends$3({}, props3, {
      className: "recharts-reference-area-rect"
    }));
  }
  return rect;
};
function getEveryNthWithCondition(array3, n2, isValid2) {
  if (n2 < 1) {
    return [];
  }
  if (n2 === 1 && isValid2 === void 0) {
    return array3;
  }
  var result = [];
  for (var i = 0; i < array3.length; i += n2) {
    if (isValid2 === void 0 || isValid2(array3[i]) === true) {
      result.push(array3[i]);
    } else {
      return void 0;
    }
  }
  return result;
}
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$4(obj);
}
function ownKeys$3(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$4(obj, key, value) {
  key = _toPropertyKey$4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$4(arg) {
  var key = _toPrimitive$4(arg, "string");
  return _typeof$4(key) === "symbol" ? key : String(key);
}
function _toPrimitive$4(input, hint) {
  if (_typeof$4(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$4(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function getEveryNThTick(ticks2) {
  var N2 = 1;
  var previous = getEveryNthWithCondition(ticks2, N2, function(tickItem) {
    return tickItem.isShow;
  });
  while (N2 <= ticks2.length) {
    if (previous !== void 0) {
      return previous;
    }
    N2++;
    previous = getEveryNthWithCondition(ticks2, N2, function(tickItem) {
      return tickItem.isShow;
    });
  }
  return ticks2.slice(0, 1);
}
function getNumberIntervalTicks(ticks2, interval) {
  return getEveryNthWithCondition(ticks2, interval + 1);
}
function getTicksEnd(_ref) {
  var ticks2 = _ref.ticks, tickFormatter = _ref.tickFormatter, viewBox = _ref.viewBox, orientation = _ref.orientation, minTickGap = _ref.minTickGap, unit2 = _ref.unit, fontSize = _ref.fontSize, letterSpacing = _ref.letterSpacing;
  var x2 = viewBox.x, y2 = viewBox.y, width = viewBox.width, height = viewBox.height;
  var sizeKey = orientation === "top" || orientation === "bottom" ? "width" : "height";
  var unitSize = unit2 && sizeKey === "width" ? getStringSize(unit2, {
    fontSize,
    letterSpacing
  })[sizeKey] : 0;
  var result = (ticks2 || []).slice();
  var len = result.length;
  var sign2 = len >= 2 ? mathSign(result[1].coordinate - result[0].coordinate) : 1;
  var start, end;
  if (sign2 === 1) {
    start = sizeKey === "width" ? x2 : y2;
    end = sizeKey === "width" ? x2 + width : y2 + height;
  } else {
    start = sizeKey === "width" ? x2 + width : y2 + height;
    end = sizeKey === "width" ? x2 : y2;
  }
  for (var i = len - 1; i >= 0; i--) {
    var entry = result[i];
    var content = _isFunction(tickFormatter) ? tickFormatter(entry.value, len - i - 1) : entry.value;
    var size = getStringSize(content, {
      fontSize,
      letterSpacing
    })[sizeKey] + unitSize;
    if (i === len - 1) {
      var gap = sign2 * (entry.coordinate + sign2 * size / 2 - end);
      result[i] = entry = _objectSpread$3(_objectSpread$3({}, entry), {}, {
        tickCoord: gap > 0 ? entry.coordinate - gap * sign2 : entry.coordinate
      });
    } else {
      result[i] = entry = _objectSpread$3(_objectSpread$3({}, entry), {}, {
        tickCoord: entry.coordinate
      });
    }
    var isShow = sign2 * (entry.tickCoord - sign2 * size / 2 - start) >= 0 && sign2 * (entry.tickCoord + sign2 * size / 2 - end) <= 0;
    if (isShow) {
      end = entry.tickCoord - sign2 * (size / 2 + minTickGap);
      result[i] = _objectSpread$3(_objectSpread$3({}, entry), {}, {
        isShow: true
      });
    }
  }
  return result;
}
function getTicksStart(_ref2, preserveEnd) {
  var ticks2 = _ref2.ticks, tickFormatter = _ref2.tickFormatter, viewBox = _ref2.viewBox, orientation = _ref2.orientation, minTickGap = _ref2.minTickGap, unit2 = _ref2.unit, fontSize = _ref2.fontSize, letterSpacing = _ref2.letterSpacing;
  var x2 = viewBox.x, y2 = viewBox.y, width = viewBox.width, height = viewBox.height;
  var sizeKey = orientation === "top" || orientation === "bottom" ? "width" : "height";
  var result = (ticks2 || []).slice();
  var unitSize = unit2 && sizeKey === "width" ? getStringSize(unit2, {
    fontSize,
    letterSpacing
  })[sizeKey] : 0;
  var len = result.length;
  var sign2 = len >= 2 ? mathSign(result[1].coordinate - result[0].coordinate) : 1;
  var start, end;
  if (sign2 === 1) {
    start = sizeKey === "width" ? x2 : y2;
    end = sizeKey === "width" ? x2 + width : y2 + height;
  } else {
    start = sizeKey === "width" ? x2 + width : y2 + height;
    end = sizeKey === "width" ? x2 : y2;
  }
  if (preserveEnd) {
    var tail2 = ticks2[len - 1];
    var tailContent = _isFunction(tickFormatter) ? tickFormatter(tail2.value, len - 1) : tail2.value;
    var tailSize = getStringSize(tailContent, {
      fontSize,
      letterSpacing
    })[sizeKey] + unitSize;
    var tailGap = sign2 * (tail2.coordinate + sign2 * tailSize / 2 - end);
    result[len - 1] = tail2 = _objectSpread$3(_objectSpread$3({}, tail2), {}, {
      tickCoord: tailGap > 0 ? tail2.coordinate - tailGap * sign2 : tail2.coordinate
    });
    var isTailShow = sign2 * (tail2.tickCoord - sign2 * tailSize / 2 - start) >= 0 && sign2 * (tail2.tickCoord + sign2 * tailSize / 2 - end) <= 0;
    if (isTailShow) {
      end = tail2.tickCoord - sign2 * (tailSize / 2 + minTickGap);
      result[len - 1] = _objectSpread$3(_objectSpread$3({}, tail2), {}, {
        isShow: true
      });
    }
  }
  var count2 = preserveEnd ? len - 1 : len;
  for (var i = 0; i < count2; i++) {
    var entry = result[i];
    var content = _isFunction(tickFormatter) ? tickFormatter(entry.value, i) : entry.value;
    var size = getStringSize(content, {
      fontSize,
      letterSpacing
    })[sizeKey] + unitSize;
    if (i === 0) {
      var gap = sign2 * (entry.coordinate - sign2 * size / 2 - start);
      result[i] = entry = _objectSpread$3(_objectSpread$3({}, entry), {}, {
        tickCoord: gap < 0 ? entry.coordinate - gap * sign2 : entry.coordinate
      });
    } else {
      result[i] = entry = _objectSpread$3(_objectSpread$3({}, entry), {}, {
        tickCoord: entry.coordinate
      });
    }
    var isShow = sign2 * (entry.tickCoord - sign2 * size / 2 - start) >= 0 && sign2 * (entry.tickCoord + sign2 * size / 2 - end) <= 0;
    if (isShow) {
      start = entry.tickCoord + sign2 * (size / 2 + minTickGap);
      result[i] = _objectSpread$3(_objectSpread$3({}, entry), {}, {
        isShow: true
      });
    }
  }
  return result;
}
function getTicks(props3, fontSize, letterSpacing) {
  var tick = props3.tick, ticks2 = props3.ticks, viewBox = props3.viewBox, minTickGap = props3.minTickGap, orientation = props3.orientation, interval = props3.interval, tickFormatter = props3.tickFormatter, unit2 = props3.unit;
  if (!ticks2 || !ticks2.length || !tick) {
    return [];
  }
  if (isNumber(interval) || Global.isSsr) {
    return getNumberIntervalTicks(ticks2, typeof interval === "number" && isNumber(interval) ? interval : 0);
  }
  var candidates = [];
  if (interval === "equidistantPreserveStart") {
    candidates = getTicksStart({
      ticks: ticks2,
      tickFormatter,
      viewBox,
      orientation,
      minTickGap,
      unit: unit2,
      fontSize,
      letterSpacing
    });
    return getEveryNThTick(candidates);
  }
  if (interval === "preserveStart" || interval === "preserveStartEnd") {
    candidates = getTicksStart({
      ticks: ticks2,
      tickFormatter,
      viewBox,
      orientation,
      minTickGap,
      unit: unit2,
      fontSize,
      letterSpacing
    }, interval === "preserveStartEnd");
  } else {
    candidates = getTicksEnd({
      ticks: ticks2,
      tickFormatter,
      viewBox,
      orientation,
      minTickGap,
      unit: unit2,
      fontSize,
      letterSpacing
    });
  }
  return candidates.filter(function(entry) {
    return entry.isShow;
  });
}
var _excluded$2 = ["viewBox"], _excluded2$1 = ["viewBox"], _excluded3 = ["ticks"];
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$3(obj);
}
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function ownKeys$2(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$3(descriptor.key), descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o3, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$2(o3, p2);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self2, call3) {
  if (call3 && (_typeof$3(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$2(o3) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$2(o3);
}
function _defineProperty$3(obj, key, value) {
  key = _toPropertyKey$3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$3(arg) {
  var key = _toPrimitive$3(arg, "string");
  return _typeof$3(key) === "symbol" ? key : String(key);
}
function _toPrimitive$3(input, hint) {
  if (_typeof$3(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$3(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var CartesianAxis = /* @__PURE__ */ function(_Component) {
  _inherits$2(CartesianAxis2, _Component);
  var _super = _createSuper$2(CartesianAxis2);
  function CartesianAxis2(props3) {
    var _this;
    _classCallCheck$3(this, CartesianAxis2);
    _this = _super.call(this, props3);
    _this.state = {
      fontSize: "",
      letterSpacing: ""
    };
    return _this;
  }
  _createClass$3(CartesianAxis2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(_ref, nextState) {
      var viewBox = _ref.viewBox, restProps = _objectWithoutProperties$2(_ref, _excluded$2);
      var _this$props = this.props, viewBoxOld = _this$props.viewBox, restPropsOld = _objectWithoutProperties$2(_this$props, _excluded2$1);
      return !shallowEqual(viewBox, viewBoxOld) || !shallowEqual(restProps, restPropsOld) || !shallowEqual(nextState, this.state);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var htmlLayer = this.layerReference;
      if (!htmlLayer)
        return;
      var tick = htmlLayer.getElementsByClassName("recharts-cartesian-axis-tick-value")[0];
      if (tick) {
        this.setState({
          fontSize: window.getComputedStyle(tick).fontSize,
          letterSpacing: window.getComputedStyle(tick).letterSpacing
        });
      }
    }
    /**
     * Calculate the coordinates of endpoints in ticks
     * @param  {Object} data The data of a simple tick
     * @return {Object} (x1, y1): The coordinate of endpoint close to tick text
     *  (x2, y2): The coordinate of endpoint close to axis
     */
  }, {
    key: "getTickLineCoord",
    value: function getTickLineCoord(data2) {
      var _this$props2 = this.props, x2 = _this$props2.x, y2 = _this$props2.y, width = _this$props2.width, height = _this$props2.height, orientation = _this$props2.orientation, tickSize = _this$props2.tickSize, mirror = _this$props2.mirror, tickMargin = _this$props2.tickMargin;
      var x1, x22, y1, y22, tx, ty;
      var sign2 = mirror ? -1 : 1;
      var finalTickSize = data2.tickSize || tickSize;
      var tickCoord = isNumber(data2.tickCoord) ? data2.tickCoord : data2.coordinate;
      switch (orientation) {
        case "top":
          x1 = x22 = data2.coordinate;
          y22 = y2 + +!mirror * height;
          y1 = y22 - sign2 * finalTickSize;
          ty = y1 - sign2 * tickMargin;
          tx = tickCoord;
          break;
        case "left":
          y1 = y22 = data2.coordinate;
          x22 = x2 + +!mirror * width;
          x1 = x22 - sign2 * finalTickSize;
          tx = x1 - sign2 * tickMargin;
          ty = tickCoord;
          break;
        case "right":
          y1 = y22 = data2.coordinate;
          x22 = x2 + +mirror * width;
          x1 = x22 + sign2 * finalTickSize;
          tx = x1 + sign2 * tickMargin;
          ty = tickCoord;
          break;
        default:
          x1 = x22 = data2.coordinate;
          y22 = y2 + +mirror * height;
          y1 = y22 + sign2 * finalTickSize;
          ty = y1 + sign2 * tickMargin;
          tx = tickCoord;
          break;
      }
      return {
        line: {
          x1,
          y1,
          x2: x22,
          y2: y22
        },
        tick: {
          x: tx,
          y: ty
        }
      };
    }
  }, {
    key: "getTickTextAnchor",
    value: function getTickTextAnchor() {
      var _this$props3 = this.props, orientation = _this$props3.orientation, mirror = _this$props3.mirror;
      var textAnchor;
      switch (orientation) {
        case "left":
          textAnchor = mirror ? "start" : "end";
          break;
        case "right":
          textAnchor = mirror ? "end" : "start";
          break;
        default:
          textAnchor = "middle";
          break;
      }
      return textAnchor;
    }
  }, {
    key: "getTickVerticalAnchor",
    value: function getTickVerticalAnchor() {
      var _this$props4 = this.props, orientation = _this$props4.orientation, mirror = _this$props4.mirror;
      var verticalAnchor = "end";
      switch (orientation) {
        case "left":
        case "right":
          verticalAnchor = "middle";
          break;
        case "top":
          verticalAnchor = mirror ? "start" : "end";
          break;
        default:
          verticalAnchor = mirror ? "end" : "start";
          break;
      }
      return verticalAnchor;
    }
  }, {
    key: "renderAxisLine",
    value: function renderAxisLine() {
      var _this$props5 = this.props, x2 = _this$props5.x, y2 = _this$props5.y, width = _this$props5.width, height = _this$props5.height, orientation = _this$props5.orientation, mirror = _this$props5.mirror, axisLine = _this$props5.axisLine;
      var props3 = _objectSpread$2(_objectSpread$2(_objectSpread$2({}, filterProps(this.props)), filterProps(axisLine)), {}, {
        fill: "none"
      });
      if (orientation === "top" || orientation === "bottom") {
        var needHeight = +(orientation === "top" && !mirror || orientation === "bottom" && mirror);
        props3 = _objectSpread$2(_objectSpread$2({}, props3), {}, {
          x1: x2,
          y1: y2 + needHeight * height,
          x2: x2 + width,
          y2: y2 + needHeight * height
        });
      } else {
        var needWidth = +(orientation === "left" && !mirror || orientation === "right" && mirror);
        props3 = _objectSpread$2(_objectSpread$2({}, props3), {}, {
          x1: x2 + needWidth * width,
          y1: y2,
          x2: x2 + needWidth * width,
          y2: y2 + height
        });
      }
      return /* @__PURE__ */ React.createElement("line", _extends$2({}, props3, {
        className: classNames("recharts-cartesian-axis-line", _get(axisLine, "className"))
      }));
    }
  }, {
    key: "renderTicks",
    value: (
      /**
       * render the ticks
       * @param {Array} ticks The ticks to actually render (overrides what was passed in props)
       * @param {string} fontSize Fontsize to consider for tick spacing
       * @param {string} letterSpacing Letterspacing to consider for tick spacing
       * @return {ReactComponent} renderedTicks
       */
      function renderTicks(ticks2, fontSize, letterSpacing) {
        var _this2 = this;
        var _this$props6 = this.props, tickLine = _this$props6.tickLine, stroke = _this$props6.stroke, tick = _this$props6.tick, tickFormatter = _this$props6.tickFormatter, unit2 = _this$props6.unit;
        var finalTicks = getTicks(_objectSpread$2(_objectSpread$2({}, this.props), {}, {
          ticks: ticks2
        }), fontSize, letterSpacing);
        var textAnchor = this.getTickTextAnchor();
        var verticalAnchor = this.getTickVerticalAnchor();
        var axisProps = filterProps(this.props);
        var customTickProps = filterProps(tick);
        var tickLineProps = _objectSpread$2(_objectSpread$2({}, axisProps), {}, {
          fill: "none"
        }, filterProps(tickLine));
        var items = finalTicks.map(function(entry, i) {
          var _this2$getTickLineCoo = _this2.getTickLineCoord(entry), lineCoord = _this2$getTickLineCoo.line, tickCoord = _this2$getTickLineCoo.tick;
          var tickProps = _objectSpread$2(_objectSpread$2(_objectSpread$2(_objectSpread$2({
            textAnchor,
            verticalAnchor
          }, axisProps), {}, {
            stroke: "none",
            fill: stroke
          }, customTickProps), tickCoord), {}, {
            index: i,
            payload: entry,
            visibleTicksCount: finalTicks.length,
            tickFormatter
          });
          return /* @__PURE__ */ React.createElement(Layer, _extends$2({
            className: "recharts-cartesian-axis-tick",
            key: "tick-".concat(i)
            // eslint-disable-line react/no-array-index-key
          }, adaptEventsOfChild(_this2.props, entry, i)), tickLine && /* @__PURE__ */ React.createElement("line", _extends$2({}, tickLineProps, lineCoord, {
            className: classNames("recharts-cartesian-axis-tick-line", _get(tickLine, "className"))
          })), tick && CartesianAxis2.renderTickItem(tick, tickProps, "".concat(_isFunction(tickFormatter) ? tickFormatter(entry.value, i) : entry.value).concat(unit2 || "")));
        });
        return /* @__PURE__ */ React.createElement("g", {
          className: "recharts-cartesian-axis-ticks"
        }, items);
      }
    )
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;
      var _this$props7 = this.props, axisLine = _this$props7.axisLine, width = _this$props7.width, height = _this$props7.height, ticksGenerator = _this$props7.ticksGenerator, className = _this$props7.className, hide = _this$props7.hide;
      if (hide) {
        return null;
      }
      var _this$props8 = this.props, ticks2 = _this$props8.ticks, noTicksProps = _objectWithoutProperties$2(_this$props8, _excluded3);
      var finalTicks = ticks2;
      if (_isFunction(ticksGenerator)) {
        finalTicks = ticks2 && ticks2.length > 0 ? ticksGenerator(this.props) : ticksGenerator(noTicksProps);
      }
      if (width <= 0 || height <= 0 || !finalTicks || !finalTicks.length) {
        return null;
      }
      return /* @__PURE__ */ React.createElement(Layer, {
        className: classNames("recharts-cartesian-axis", className),
        ref: function ref(_ref2) {
          _this3.layerReference = _ref2;
        }
      }, axisLine && this.renderAxisLine(), this.renderTicks(finalTicks, this.state.fontSize, this.state.letterSpacing), Label2.renderCallByParent(this.props));
    }
  }], [{
    key: "renderTickItem",
    value: function renderTickItem(option, props3, value) {
      var tickItem;
      if (/* @__PURE__ */ React.isValidElement(option)) {
        tickItem = /* @__PURE__ */ React.cloneElement(option, props3);
      } else if (_isFunction(option)) {
        tickItem = option(props3);
      } else {
        tickItem = /* @__PURE__ */ React.createElement(Text2, _extends$2({}, props3, {
          className: "recharts-cartesian-axis-tick-value"
        }), value);
      }
      return tickItem;
    }
  }]);
  return CartesianAxis2;
}(reactExports.Component);
_defineProperty$3(CartesianAxis, "displayName", "CartesianAxis");
_defineProperty$3(CartesianAxis, "defaultProps", {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  // The orientation of axis
  orientation: "bottom",
  // The ticks
  ticks: [],
  stroke: "#666",
  tickLine: true,
  axisLine: true,
  tick: true,
  mirror: false,
  minTickGap: 5,
  // The width or height of tick
  tickSize: 6,
  tickMargin: 2,
  interval: "preserveEnd"
});
var _excluded$1 = ["x1", "y1", "x2", "y2", "key"];
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function ownKeys$1(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$2(descriptor.key), descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o3, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$1(o3, p2);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self2, call3) {
  if (call3 && (_typeof$2(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$1(o3) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf$1(o3);
}
function _defineProperty$2(obj, key, value) {
  key = _toPropertyKey$2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$2(arg) {
  var key = _toPrimitive$2(arg, "string");
  return _typeof$2(key) === "symbol" ? key : String(key);
}
function _toPrimitive$2(input, hint) {
  if (_typeof$2(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$2(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var CartesianGrid = /* @__PURE__ */ function(_PureComponent) {
  _inherits$1(CartesianGrid2, _PureComponent);
  var _super = _createSuper$1(CartesianGrid2);
  function CartesianGrid2() {
    _classCallCheck$2(this, CartesianGrid2);
    return _super.apply(this, arguments);
  }
  _createClass$2(CartesianGrid2, [{
    key: "renderHorizontal",
    value: (
      /**
       * Draw the horizontal grid lines
       * @param {Array} horizontalPoints either passed in as props or generated from function
       * @return {Group} Horizontal lines
       */
      function renderHorizontal(horizontalPoints) {
        var _this = this;
        var _this$props = this.props, x2 = _this$props.x, width = _this$props.width, horizontal = _this$props.horizontal;
        if (!horizontalPoints || !horizontalPoints.length) {
          return null;
        }
        var items = horizontalPoints.map(function(entry, i) {
          var props3 = _objectSpread$1(_objectSpread$1({}, _this.props), {}, {
            x1: x2,
            y1: entry,
            x2: x2 + width,
            y2: entry,
            key: "line-".concat(i),
            index: i
          });
          return CartesianGrid2.renderLineItem(horizontal, props3);
        });
        return /* @__PURE__ */ React.createElement("g", {
          className: "recharts-cartesian-grid-horizontal"
        }, items);
      }
    )
    /**
     * Draw vertical grid lines
     * @param {Array} verticalPoints either passed in as props or generated from function
     * @return {Group} Vertical lines
     */
  }, {
    key: "renderVertical",
    value: function renderVertical(verticalPoints) {
      var _this2 = this;
      var _this$props2 = this.props, y2 = _this$props2.y, height = _this$props2.height, vertical = _this$props2.vertical;
      if (!verticalPoints || !verticalPoints.length) {
        return null;
      }
      var items = verticalPoints.map(function(entry, i) {
        var props3 = _objectSpread$1(_objectSpread$1({}, _this2.props), {}, {
          x1: entry,
          y1: y2,
          x2: entry,
          y2: y2 + height,
          key: "line-".concat(i),
          index: i
        });
        return CartesianGrid2.renderLineItem(vertical, props3);
      });
      return /* @__PURE__ */ React.createElement("g", {
        className: "recharts-cartesian-grid-vertical"
      }, items);
    }
    /**
     * Draw vertical grid stripes filled by colors
     * @param {Array} verticalPoints either passed in as props or generated from function
     * @return {Group} Vertical stripes
     */
  }, {
    key: "renderVerticalStripes",
    value: function renderVerticalStripes(verticalPoints) {
      var verticalFill = this.props.verticalFill;
      if (!verticalFill || !verticalFill.length) {
        return null;
      }
      var _this$props3 = this.props, fillOpacity = _this$props3.fillOpacity, x2 = _this$props3.x, y2 = _this$props3.y, width = _this$props3.width, height = _this$props3.height;
      var roundedSortedVerticalPoints = verticalPoints.map(function(e3) {
        return Math.round(e3 + x2 - x2);
      }).sort(function(a2, b2) {
        return a2 - b2;
      });
      if (x2 !== roundedSortedVerticalPoints[0]) {
        roundedSortedVerticalPoints.unshift(0);
      }
      var items = roundedSortedVerticalPoints.map(function(entry, i) {
        var lastStripe = !roundedSortedVerticalPoints[i + 1];
        var lineWidth = lastStripe ? x2 + width - entry : roundedSortedVerticalPoints[i + 1] - entry;
        if (lineWidth <= 0) {
          return null;
        }
        var colorIndex = i % verticalFill.length;
        return /* @__PURE__ */ React.createElement("rect", {
          key: "react-".concat(i),
          x: entry,
          y: y2,
          width: lineWidth,
          height,
          stroke: "none",
          fill: verticalFill[colorIndex],
          fillOpacity,
          className: "recharts-cartesian-grid-bg"
        });
      });
      return /* @__PURE__ */ React.createElement("g", {
        className: "recharts-cartesian-gridstripes-vertical"
      }, items);
    }
    /**
     * Draw horizontal grid stripes filled by colors
     * @param {Array} horizontalPoints either passed in as props or generated from function
     * @return {Group} Horizontal stripes
     */
  }, {
    key: "renderHorizontalStripes",
    value: function renderHorizontalStripes(horizontalPoints) {
      var horizontalFill = this.props.horizontalFill;
      if (!horizontalFill || !horizontalFill.length) {
        return null;
      }
      var _this$props4 = this.props, fillOpacity = _this$props4.fillOpacity, x2 = _this$props4.x, y2 = _this$props4.y, width = _this$props4.width, height = _this$props4.height;
      var roundedSortedHorizontalPoints = horizontalPoints.map(function(e3) {
        return Math.round(e3 + y2 - y2);
      }).sort(function(a2, b2) {
        return a2 - b2;
      });
      if (y2 !== roundedSortedHorizontalPoints[0]) {
        roundedSortedHorizontalPoints.unshift(0);
      }
      var items = roundedSortedHorizontalPoints.map(function(entry, i) {
        var lastStripe = !roundedSortedHorizontalPoints[i + 1];
        var lineHeight = lastStripe ? y2 + height - entry : roundedSortedHorizontalPoints[i + 1] - entry;
        if (lineHeight <= 0) {
          return null;
        }
        var colorIndex = i % horizontalFill.length;
        return /* @__PURE__ */ React.createElement("rect", {
          key: "react-".concat(i),
          y: entry,
          x: x2,
          height: lineHeight,
          width,
          stroke: "none",
          fill: horizontalFill[colorIndex],
          fillOpacity,
          className: "recharts-cartesian-grid-bg"
        });
      });
      return /* @__PURE__ */ React.createElement("g", {
        className: "recharts-cartesian-gridstripes-horizontal"
      }, items);
    }
  }, {
    key: "renderBackground",
    value: function renderBackground() {
      var fill = this.props.fill;
      if (!fill || fill === "none") {
        return null;
      }
      var _this$props5 = this.props, fillOpacity = _this$props5.fillOpacity, x2 = _this$props5.x, y2 = _this$props5.y, width = _this$props5.width, height = _this$props5.height;
      return /* @__PURE__ */ React.createElement("rect", {
        x: x2,
        y: y2,
        width,
        height,
        stroke: "none",
        fill,
        fillOpacity,
        className: "recharts-cartesian-grid-bg"
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props6 = this.props, x2 = _this$props6.x, y2 = _this$props6.y, width = _this$props6.width, height = _this$props6.height, horizontal = _this$props6.horizontal, vertical = _this$props6.vertical, horizontalCoordinatesGenerator = _this$props6.horizontalCoordinatesGenerator, verticalCoordinatesGenerator = _this$props6.verticalCoordinatesGenerator, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, offset2 = _this$props6.offset, chartWidth = _this$props6.chartWidth, chartHeight = _this$props6.chartHeight;
      if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0 || !isNumber(x2) || x2 !== +x2 || !isNumber(y2) || y2 !== +y2) {
        return null;
      }
      var _this$props7 = this.props, horizontalPoints = _this$props7.horizontalPoints, verticalPoints = _this$props7.verticalPoints;
      if ((!horizontalPoints || !horizontalPoints.length) && _isFunction(horizontalCoordinatesGenerator)) {
        horizontalPoints = horizontalCoordinatesGenerator({
          yAxis,
          width: chartWidth,
          height: chartHeight,
          offset: offset2
        });
      }
      if ((!verticalPoints || !verticalPoints.length) && _isFunction(verticalCoordinatesGenerator)) {
        verticalPoints = verticalCoordinatesGenerator({
          xAxis,
          width: chartWidth,
          height: chartHeight,
          offset: offset2
        });
      }
      return /* @__PURE__ */ React.createElement("g", {
        className: "recharts-cartesian-grid"
      }, this.renderBackground(), horizontal && this.renderHorizontal(horizontalPoints), vertical && this.renderVertical(verticalPoints), horizontal && this.renderHorizontalStripes(horizontalPoints), vertical && this.renderVerticalStripes(verticalPoints));
    }
  }], [{
    key: "renderLineItem",
    value: function renderLineItem(option, props3) {
      var lineItem;
      if (/* @__PURE__ */ React.isValidElement(option)) {
        lineItem = /* @__PURE__ */ React.cloneElement(option, props3);
      } else if (_isFunction(option)) {
        lineItem = option(props3);
      } else {
        var x1 = props3.x1, y1 = props3.y1, x2 = props3.x2, y2 = props3.y2, key = props3.key, others = _objectWithoutProperties$1(props3, _excluded$1);
        lineItem = /* @__PURE__ */ React.createElement("line", _extends$1({}, filterProps(others), {
          x1,
          y1,
          x2,
          y2,
          fill: "none",
          key
        }));
      }
      return lineItem;
    }
  }]);
  return CartesianGrid2;
}(reactExports.PureComponent);
_defineProperty$2(CartesianGrid, "displayName", "CartesianGrid");
_defineProperty$2(CartesianGrid, "defaultProps", {
  horizontal: true,
  vertical: true,
  // The ordinates of horizontal grid lines
  horizontalPoints: [],
  // The abscissas of vertical grid lines
  verticalPoints: [],
  stroke: "#ccc",
  fill: "none",
  // The fill of colors of grid lines
  verticalFill: [],
  horizontalFill: []
});
var XAxis = function XAxis2() {
  return null;
};
XAxis.displayName = "XAxis";
XAxis.defaultProps = {
  allowDecimals: true,
  hide: false,
  orientation: "bottom",
  width: 0,
  height: 30,
  mirror: false,
  xAxisId: 0,
  tickCount: 5,
  type: "category",
  padding: {
    left: 0,
    right: 0
  },
  allowDataOverflow: false,
  scale: "auto",
  reversed: false,
  allowDuplicatedCategory: true
};
var YAxis = function YAxis2() {
  return null;
};
YAxis.displayName = "YAxis";
YAxis.defaultProps = {
  allowDuplicatedCategory: true,
  allowDecimals: true,
  hide: false,
  orientation: "left",
  width: 60,
  height: 0,
  mirror: false,
  yAxisId: 0,
  tickCount: 5,
  type: "number",
  padding: {
    top: 0,
    bottom: 0
  },
  allowDataOverflow: false,
  scale: "auto",
  reversed: false
};
var baseIteratee$1 = _baseIteratee, isArrayLike2 = isArrayLike_1, keys3 = keys_1;
function createFind$1(findIndexFunc) {
  return function(collection, predicate3, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike2(collection)) {
      var iteratee = baseIteratee$1(predicate3);
      collection = keys3(collection);
      predicate3 = function(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index3 = findIndexFunc(collection, predicate3, fromIndex);
    return index3 > -1 ? iterable[iteratee ? collection[index3] : index3] : void 0;
  };
}
var _createFind = createFind$1;
var toFinite = toFinite_1;
function toInteger$1(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$1;
var baseFindIndex = _baseFindIndex, baseIteratee = _baseIteratee, toInteger = toInteger_1;
var nativeMax = Math.max;
function findIndex$1(array3, predicate3, fromIndex) {
  var length3 = array3 == null ? 0 : array3.length;
  if (!length3) {
    return -1;
  }
  var index3 = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index3 < 0) {
    index3 = nativeMax(length3 + index3, 0);
  }
  return baseFindIndex(array3, baseIteratee(predicate3), index3);
}
var findIndex_1 = findIndex$1;
var createFind = _createFind, findIndex2 = findIndex_1;
var find2 = createFind(findIndex2);
var find_1 = find2;
const _find = /* @__PURE__ */ getDefaultExportFromCjs(find_1);
var baseGetTag = _baseGetTag, isObjectLike = isObjectLike_1;
var boolTag = "[object Boolean]";
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
}
var isBoolean_1 = isBoolean;
const _isBoolean = /* @__PURE__ */ getDefaultExportFromCjs(isBoolean_1);
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray$1(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o3, minLen);
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var detectReferenceElementsDomain = function detectReferenceElementsDomain2(children, domain, axisId, axisType, specifiedTicks) {
  var lines = findAllByType(children, ReferenceLine);
  var dots = findAllByType(children, ReferenceDot);
  var elements = [].concat(_toConsumableArray$1(lines), _toConsumableArray$1(dots));
  var areas = findAllByType(children, ReferenceArea);
  var idKey = "".concat(axisType, "Id");
  var valueKey = axisType[0];
  var finalDomain = domain;
  if (elements.length) {
    finalDomain = elements.reduce(function(result, el2) {
      if (el2.props[idKey] === axisId && ifOverflowMatches(el2.props, "extendDomain") && isNumber(el2.props[valueKey])) {
        var value = el2.props[valueKey];
        return [Math.min(result[0], value), Math.max(result[1], value)];
      }
      return result;
    }, finalDomain);
  }
  if (areas.length) {
    var key1 = "".concat(valueKey, "1");
    var key2 = "".concat(valueKey, "2");
    finalDomain = areas.reduce(function(result, el2) {
      if (el2.props[idKey] === axisId && ifOverflowMatches(el2.props, "extendDomain") && isNumber(el2.props[key1]) && isNumber(el2.props[key2])) {
        var value1 = el2.props[key1];
        var value2 = el2.props[key2];
        return [Math.min(result[0], value1, value2), Math.max(result[1], value1, value2)];
      }
      return result;
    }, finalDomain);
  }
  if (specifiedTicks && specifiedTicks.length) {
    finalDomain = specifiedTicks.reduce(function(result, tick) {
      if (isNumber(tick)) {
        return [Math.min(result[0], tick), Math.max(result[1], tick)];
      }
      return result;
    }, finalDomain);
  }
  return finalDomain;
};
var eventemitter3 = { exports: {} };
(function(module2) {
  var has3 = Object.prototype.hasOwnProperty, prefix2 = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix2 = false;
  }
  function EE(fn2, context2, once4) {
    this.fn = fn2;
    this.context = context2;
    this.once = once4 || false;
  }
  function addListener2(emitter, event, fn2, context2, once4) {
    if (typeof fn2 !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn2, context2 || emitter, once4), evt = prefix2 ? prefix2 + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames2() {
    var names = [], events2, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events2 = this._events) {
      if (has3.call(events2, name))
        names.push(prefix2 ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events2));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l2 = handlers.length, ee2 = new Array(l2); i < l2; i++) {
      ee2[i] = handlers[i].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix2 ? prefix2 + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length3 = listeners2.length, j2;
      for (i = 0; i < length3; i++) {
        if (listeners2[i].once)
          this.removeListener(event, listeners2[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i].fn.call(listeners2[i].context);
            break;
          case 2:
            listeners2[i].fn.call(listeners2[i].context, a1);
            break;
          case 3:
            listeners2[i].fn.call(listeners2[i].context, a1, a2);
            break;
          case 4:
            listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners2[i].fn.apply(listeners2[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on3(event, fn2, context2) {
    return addListener2(this, event, fn2, context2, false);
  };
  EventEmitter2.prototype.once = function once4(event, fn2, context2) {
    return addListener2(this, event, fn2, context2, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener2(event, fn2, context2, once4) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return this;
    if (!fn2) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn2 && (!once4 || listeners2.once) && (!context2 || listeners2.context === context2)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events2 = [], length3 = listeners2.length; i < length3; i++) {
        if (listeners2[i].fn !== fn2 || once4 && !listeners2[i].once || context2 && listeners2[i].context !== context2) {
          events2.push(listeners2[i]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(event) {
    var evt;
    if (event) {
      evt = prefix2 ? prefix2 + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix2;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module2.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var eventCenter = new EventEmitter();
if (eventCenter.setMaxListeners) {
  eventCenter.setMaxListeners(10);
}
var SYNC_EVENT = "recharts.syncMouseEvents";
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$1(arg) {
  var key = _toPrimitive$1(arg, "string");
  return _typeof$1(key) === "symbol" ? key : String(key);
}
function _toPrimitive$1(input, hint) {
  if (_typeof$1(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$1(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var AccessibilityManager = /* @__PURE__ */ function() {
  function AccessibilityManager2() {
    _classCallCheck$1(this, AccessibilityManager2);
    _defineProperty$1(this, "activeIndex", 0);
    _defineProperty$1(this, "coordinateList", []);
    _defineProperty$1(this, "layout", "horizontal");
  }
  _createClass$1(AccessibilityManager2, [{
    key: "setDetails",
    value: function setDetails(_ref) {
      var _ref$coordinateList = _ref.coordinateList, coordinateList = _ref$coordinateList === void 0 ? [] : _ref$coordinateList, _ref$container = _ref.container, container = _ref$container === void 0 ? null : _ref$container, _ref$layout = _ref.layout, layout = _ref$layout === void 0 ? null : _ref$layout, _ref$offset = _ref.offset, offset2 = _ref$offset === void 0 ? null : _ref$offset, _ref$mouseHandlerCall = _ref.mouseHandlerCallback, mouseHandlerCallback = _ref$mouseHandlerCall === void 0 ? null : _ref$mouseHandlerCall;
      this.coordinateList = coordinateList !== null && coordinateList !== void 0 ? coordinateList : this.coordinateList;
      this.container = container !== null && container !== void 0 ? container : this.container;
      this.layout = layout !== null && layout !== void 0 ? layout : this.layout;
      this.offset = offset2 !== null && offset2 !== void 0 ? offset2 : this.offset;
      this.mouseHandlerCallback = mouseHandlerCallback !== null && mouseHandlerCallback !== void 0 ? mouseHandlerCallback : this.mouseHandlerCallback;
      if (this.activeIndex >= this.coordinateList.length) {
        this.activeIndex = this.coordinateList.length - 1;
      }
    }
  }, {
    key: "focus",
    value: function focus() {
      this.spoofMouse();
    }
  }, {
    key: "keyboardEvent",
    value: function keyboardEvent(e3) {
      switch (e3.key) {
        case "ArrowRight": {
          if (this.layout !== "horizontal") {
            return;
          }
          this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1);
          this.spoofMouse();
          break;
        }
        case "ArrowLeft": {
          if (this.layout !== "horizontal") {
            return;
          }
          this.activeIndex = Math.max(this.activeIndex - 1, 0);
          this.spoofMouse();
          break;
        }
      }
    }
  }, {
    key: "spoofMouse",
    value: function spoofMouse() {
      if (this.layout !== "horizontal") {
        return;
      }
      var _this$container$getBo = this.container.getBoundingClientRect(), x2 = _this$container$getBo.x, y2 = _this$container$getBo.y;
      var coordinate = this.coordinateList[this.activeIndex].coordinate;
      var pageX = x2 + coordinate;
      var pageY = y2 + this.offset.top;
      this.mouseHandlerCallback({
        pageX,
        pageY
      });
    }
  }]);
  return AccessibilityManager2;
}();
var _excluded = ["item"], _excluded2 = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(arr, i) {
  var _i2 = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i2) {
    var _s2, _e2, _x, _r, _arr = [], _n2 = true, _d = false;
    try {
      if (_x = (_i2 = _i2.call(arr)).next, 0 === i) {
        if (Object(_i2) !== _i2)
          return;
        _n2 = false;
      } else
        for (; !(_n2 = (_s2 = _x.call(_i2)).done) && (_arr.push(_s2.value), _arr.length !== i); _n2 = true)
          ;
    } catch (err) {
      _d = true, _e2 = err;
    } finally {
      try {
        if (!_n2 && null != _i2["return"] && (_r = _i2["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props3) {
  for (var i = 0; i < props3.length; i++) {
    var descriptor = props3[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o3, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf(o3, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call3) {
  if (call3 && (_typeof(call3) === "object" || typeof call3 === "function")) {
    return call3;
  } else if (call3 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf(o3) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf(o3);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o3, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function ownKeys(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var ORIENT_MAP = {
  xAxis: ["bottom", "top"],
  yAxis: ["left", "right"]
};
var originCoordinate = {
  x: 0,
  y: 0
};
var isFinit = Number.isFinite ? Number.isFinite : isFinite;
var defer = (
  // eslint-disable-next-line no-nested-ternary
  typeof requestAnimationFrame === "function" ? requestAnimationFrame : typeof setImmediate === "function" ? setImmediate : setTimeout
);
var deferClear = (
  // eslint-disable-next-line no-nested-ternary
  typeof cancelAnimationFrame === "function" ? cancelAnimationFrame : typeof clearImmediate === "function" ? clearImmediate : clearTimeout
);
var calculateTooltipPos = function calculateTooltipPos2(rangeObj, layout) {
  if (layout === "horizontal") {
    return rangeObj.x;
  }
  if (layout === "vertical") {
    return rangeObj.y;
  }
  if (layout === "centric") {
    return rangeObj.angle;
  }
  return rangeObj.radius;
};
var getActiveCoordinate = function getActiveCoordinate2(layout, tooltipTicks, activeIndex, rangeObj) {
  var entry = tooltipTicks.find(function(tick) {
    return tick && tick.index === activeIndex;
  });
  if (entry) {
    if (layout === "horizontal") {
      return {
        x: entry.coordinate,
        y: rangeObj.y
      };
    }
    if (layout === "vertical") {
      return {
        x: rangeObj.x,
        y: entry.coordinate
      };
    }
    if (layout === "centric") {
      var _angle = entry.coordinate;
      var _radius = rangeObj.radius;
      return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {
        angle: _angle,
        radius: _radius
      });
    }
    var radius = entry.coordinate;
    var angle = rangeObj.angle;
    return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {
      angle,
      radius
    });
  }
  return originCoordinate;
};
var getDisplayedData = function getDisplayedData2(data2, _ref, item) {
  var graphicalItems = _ref.graphicalItems, dataStartIndex = _ref.dataStartIndex, dataEndIndex = _ref.dataEndIndex;
  var itemsData = (graphicalItems || []).reduce(function(result, child) {
    var itemData = child.props.data;
    if (itemData && itemData.length) {
      return [].concat(_toConsumableArray(result), _toConsumableArray(itemData));
    }
    return result;
  }, []);
  if (itemsData && itemsData.length > 0) {
    return itemsData;
  }
  if (item && item.props && item.props.data && item.props.data.length > 0) {
    return item.props.data;
  }
  if (data2 && data2.length && isNumber(dataStartIndex) && isNumber(dataEndIndex)) {
    return data2.slice(dataStartIndex, dataEndIndex + 1);
  }
  return [];
};
function isDomainSpecifiedByUser(domain, allowDataOverflow, axisType) {
  if (axisType === "number" && allowDataOverflow === true && Array.isArray(domain)) {
    var domainStart = domain === null || domain === void 0 ? void 0 : domain[0];
    var domainEnd = domain === null || domain === void 0 ? void 0 : domain[1];
    if (!!domainStart && !!domainEnd && isNumber(domainStart) && isNumber(domainEnd)) {
      return true;
    }
  }
  return false;
}
function getDefaultDomainByAxisType(axisType) {
  return axisType === "number" ? [0, "auto"] : void 0;
}
var getTooltipContent = function getTooltipContent2(state, chartData, activeIndex, activeLabel) {
  var graphicalItems = state.graphicalItems, tooltipAxis = state.tooltipAxis;
  var displayedData = getDisplayedData(chartData, state);
  if (activeIndex < 0 || !graphicalItems || !graphicalItems.length || activeIndex >= displayedData.length) {
    return null;
  }
  return graphicalItems.reduce(function(result, child) {
    var hide = child.props.hide;
    if (hide) {
      return result;
    }
    var data2 = child.props.data;
    var payload;
    if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
      var entries = data2 === void 0 ? displayedData : data2;
      payload = findEntryInArray(entries, tooltipAxis.dataKey, activeLabel);
    } else {
      payload = data2 && data2[activeIndex] || displayedData[activeIndex];
    }
    if (!payload) {
      return result;
    }
    return [].concat(_toConsumableArray(result), [getTooltipItem(child, payload)]);
  }, []);
};
var getTooltipData = function getTooltipData2(state, chartData, layout, rangeObj) {
  var rangeData = rangeObj || {
    x: state.chartX,
    y: state.chartY
  };
  var pos = calculateTooltipPos(rangeData, layout);
  var ticks2 = state.orderedTooltipTicks, axis = state.tooltipAxis, tooltipTicks = state.tooltipTicks;
  var activeIndex = calculateActiveTickIndex(pos, ticks2, tooltipTicks, axis);
  if (activeIndex >= 0 && tooltipTicks) {
    var activeLabel = tooltipTicks[activeIndex] && tooltipTicks[activeIndex].value;
    var activePayload = getTooltipContent(state, chartData, activeIndex, activeLabel);
    var activeCoordinate = getActiveCoordinate(layout, ticks2, activeIndex, rangeData);
    return {
      activeTooltipIndex: activeIndex,
      activeLabel,
      activePayload,
      activeCoordinate
    };
  }
  return null;
};
var getAxisMapByAxes = function getAxisMapByAxes2(props3, _ref2) {
  var axes = _ref2.axes, graphicalItems = _ref2.graphicalItems, axisType = _ref2.axisType, axisIdKey = _ref2.axisIdKey, stackGroups = _ref2.stackGroups, dataStartIndex = _ref2.dataStartIndex, dataEndIndex = _ref2.dataEndIndex;
  var layout = props3.layout, children = props3.children, stackOffset = props3.stackOffset;
  var isCategorical = isCategoricalAxis(layout, axisType);
  var axisMap = axes.reduce(function(result, child) {
    var _child$props$domain2;
    var _child$props = child.props, type3 = _child$props.type, dataKey = _child$props.dataKey, allowDataOverflow = _child$props.allowDataOverflow, allowDuplicatedCategory = _child$props.allowDuplicatedCategory, scale = _child$props.scale, ticks2 = _child$props.ticks, includeHidden = _child$props.includeHidden;
    var axisId = child.props[axisIdKey];
    if (result[axisId]) {
      return result;
    }
    var displayedData = getDisplayedData(props3.data, {
      graphicalItems: graphicalItems.filter(function(item) {
        return item.props[axisIdKey] === axisId;
      }),
      dataStartIndex,
      dataEndIndex
    });
    var len = displayedData.length;
    var domain, duplicateDomain, categoricalDomain;
    if (isDomainSpecifiedByUser(child.props.domain, allowDataOverflow, type3)) {
      domain = parseSpecifiedDomain(child.props.domain, null, allowDataOverflow);
      if (isCategorical && (type3 === "number" || scale !== "auto")) {
        categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, "category");
      }
    }
    var defaultDomain = getDefaultDomainByAxisType(type3);
    if (!domain || domain.length === 0) {
      var _child$props$domain;
      var childDomain = (_child$props$domain = child.props.domain) !== null && _child$props$domain !== void 0 ? _child$props$domain : defaultDomain;
      if (dataKey) {
        domain = getDomainOfDataByKey(displayedData, dataKey, type3);
        if (type3 === "category" && isCategorical) {
          var duplicate = hasDuplicate(domain);
          if (allowDuplicatedCategory && duplicate) {
            duplicateDomain = domain;
            domain = _range(0, len);
          } else if (!allowDuplicatedCategory) {
            domain = parseDomainOfCategoryAxis(childDomain, domain, child).reduce(function(finalDomain, entry) {
              return finalDomain.indexOf(entry) >= 0 ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry]);
            }, []);
          }
        } else if (type3 === "category") {
          if (!allowDuplicatedCategory) {
            domain = parseDomainOfCategoryAxis(childDomain, domain, child).reduce(function(finalDomain, entry) {
              return finalDomain.indexOf(entry) >= 0 || entry === "" || _isNil(entry) ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry]);
            }, []);
          } else {
            domain = domain.filter(function(entry) {
              return entry !== "" && !_isNil(entry);
            });
          }
        } else if (type3 === "number") {
          var errorBarsDomain = parseErrorBarsOfAxis(displayedData, graphicalItems.filter(function(item) {
            return item.props[axisIdKey] === axisId && (includeHidden || !item.props.hide);
          }), dataKey, axisType, layout);
          if (errorBarsDomain) {
            domain = errorBarsDomain;
          }
        }
        if (isCategorical && (type3 === "number" || scale !== "auto")) {
          categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, "category");
        }
      } else if (isCategorical) {
        domain = _range(0, len);
      } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack && type3 === "number") {
        domain = stackOffset === "expand" ? [0, 1] : getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
      } else {
        domain = getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function(item) {
          return item.props[axisIdKey] === axisId && (includeHidden || !item.props.hide);
        }), type3, layout, true);
      }
      if (type3 === "number") {
        domain = detectReferenceElementsDomain(children, domain, axisId, axisType, ticks2);
        if (childDomain) {
          domain = parseSpecifiedDomain(childDomain, domain, allowDataOverflow);
        }
      } else if (type3 === "category" && childDomain) {
        var axisDomain = childDomain;
        var isDomainValid = domain.every(function(entry) {
          return axisDomain.indexOf(entry) >= 0;
        });
        if (isDomainValid) {
          domain = axisDomain;
        }
      }
    }
    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({}, child.props), {}, {
      axisType,
      domain,
      categoricalDomain,
      duplicateDomain,
      originalDomain: (_child$props$domain2 = child.props.domain) !== null && _child$props$domain2 !== void 0 ? _child$props$domain2 : defaultDomain,
      isCategorical,
      layout
    })));
  }, {});
  return axisMap;
};
var getAxisMapByItems = function getAxisMapByItems2(props3, _ref3) {
  var graphicalItems = _ref3.graphicalItems, Axis = _ref3.Axis, axisType = _ref3.axisType, axisIdKey = _ref3.axisIdKey, stackGroups = _ref3.stackGroups, dataStartIndex = _ref3.dataStartIndex, dataEndIndex = _ref3.dataEndIndex;
  var layout = props3.layout, children = props3.children;
  var displayedData = getDisplayedData(props3.data, {
    graphicalItems,
    dataStartIndex,
    dataEndIndex
  });
  var len = displayedData.length;
  var isCategorical = isCategoricalAxis(layout, axisType);
  var index3 = -1;
  var axisMap = graphicalItems.reduce(function(result, child) {
    var axisId = child.props[axisIdKey];
    var originalDomain = getDefaultDomainByAxisType("number");
    if (!result[axisId]) {
      index3++;
      var domain;
      if (isCategorical) {
        domain = _range(0, len);
      } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack) {
        domain = getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
        domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
      } else {
        domain = parseSpecifiedDomain(originalDomain, getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function(item) {
          return item.props[axisIdKey] === axisId && !item.props.hide;
        }), "number", layout), Axis.defaultProps.allowDataOverflow);
        domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
      }
      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({
        axisType
      }, Axis.defaultProps), {}, {
        hide: true,
        orientation: _get(ORIENT_MAP, "".concat(axisType, ".").concat(index3 % 2), null),
        domain,
        originalDomain,
        isCategorical,
        layout
        // specify scale when no Axis
        // scale: isCategorical ? 'band' : 'linear',
      })));
    }
    return result;
  }, {});
  return axisMap;
};
var getAxisMap = function getAxisMap2(props3, _ref4) {
  var _ref4$axisType = _ref4.axisType, axisType = _ref4$axisType === void 0 ? "xAxis" : _ref4$axisType, AxisComp = _ref4.AxisComp, graphicalItems = _ref4.graphicalItems, stackGroups = _ref4.stackGroups, dataStartIndex = _ref4.dataStartIndex, dataEndIndex = _ref4.dataEndIndex;
  var children = props3.children;
  var axisIdKey = "".concat(axisType, "Id");
  var axes = findAllByType(children, AxisComp);
  var axisMap = {};
  if (axes && axes.length) {
    axisMap = getAxisMapByAxes(props3, {
      axes,
      graphicalItems,
      axisType,
      axisIdKey,
      stackGroups,
      dataStartIndex,
      dataEndIndex
    });
  } else if (graphicalItems && graphicalItems.length) {
    axisMap = getAxisMapByItems(props3, {
      Axis: AxisComp,
      graphicalItems,
      axisType,
      axisIdKey,
      stackGroups,
      dataStartIndex,
      dataEndIndex
    });
  }
  return axisMap;
};
var tooltipTicksGenerator = function tooltipTicksGenerator2(axisMap) {
  var axis = getAnyElementOfObject(axisMap);
  var tooltipTicks = getTicksOfAxis(axis, false, true);
  return {
    tooltipTicks,
    orderedTooltipTicks: _sortBy(tooltipTicks, function(o3) {
      return o3.coordinate;
    }),
    tooltipAxis: axis,
    tooltipAxisBandSize: getBandSizeOfAxis(axis, tooltipTicks)
  };
};
var createDefaultState = function createDefaultState2(props3) {
  var _brushItem$props, _brushItem$props2;
  var children = props3.children, defaultShowTooltip = props3.defaultShowTooltip;
  var brushItem = findChildByType(children, Brush);
  var startIndex = brushItem && brushItem.props && brushItem.props.startIndex || 0;
  var endIndex = (brushItem === null || brushItem === void 0 ? void 0 : (_brushItem$props = brushItem.props) === null || _brushItem$props === void 0 ? void 0 : _brushItem$props.endIndex) !== void 0 ? brushItem === null || brushItem === void 0 ? void 0 : (_brushItem$props2 = brushItem.props) === null || _brushItem$props2 === void 0 ? void 0 : _brushItem$props2.endIndex : props3.data && props3.data.length - 1 || 0;
  return {
    chartX: 0,
    chartY: 0,
    dataStartIndex: startIndex,
    dataEndIndex: endIndex,
    activeTooltipIndex: -1,
    isTooltipActive: !_isNil(defaultShowTooltip) ? defaultShowTooltip : false
  };
};
var hasGraphicalBarItem = function hasGraphicalBarItem2(graphicalItems) {
  if (!graphicalItems || !graphicalItems.length) {
    return false;
  }
  return graphicalItems.some(function(item) {
    var name = getDisplayName(item && item.type);
    return name && name.indexOf("Bar") >= 0;
  });
};
var getAxisNameByLayout = function getAxisNameByLayout2(layout) {
  if (layout === "horizontal") {
    return {
      numericAxisName: "yAxis",
      cateAxisName: "xAxis"
    };
  }
  if (layout === "vertical") {
    return {
      numericAxisName: "xAxis",
      cateAxisName: "yAxis"
    };
  }
  if (layout === "centric") {
    return {
      numericAxisName: "radiusAxis",
      cateAxisName: "angleAxis"
    };
  }
  return {
    numericAxisName: "angleAxis",
    cateAxisName: "radiusAxis"
  };
};
var calculateOffset = function calculateOffset2(_ref5, prevLegendBBox) {
  var props3 = _ref5.props, graphicalItems = _ref5.graphicalItems, _ref5$xAxisMap = _ref5.xAxisMap, xAxisMap = _ref5$xAxisMap === void 0 ? {} : _ref5$xAxisMap, _ref5$yAxisMap = _ref5.yAxisMap, yAxisMap = _ref5$yAxisMap === void 0 ? {} : _ref5$yAxisMap;
  var width = props3.width, height = props3.height, children = props3.children;
  var margin = props3.margin || {};
  var brushItem = findChildByType(children, Brush);
  var legendItem = findChildByType(children, Legend);
  var offsetH = Object.keys(yAxisMap).reduce(function(result, id2) {
    var entry = yAxisMap[id2];
    var orientation = entry.orientation;
    if (!entry.mirror && !entry.hide) {
      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, result[orientation] + entry.width));
    }
    return result;
  }, {
    left: margin.left || 0,
    right: margin.right || 0
  });
  var offsetV = Object.keys(xAxisMap).reduce(function(result, id2) {
    var entry = xAxisMap[id2];
    var orientation = entry.orientation;
    if (!entry.mirror && !entry.hide) {
      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, _get(result, "".concat(orientation)) + entry.height));
    }
    return result;
  }, {
    top: margin.top || 0,
    bottom: margin.bottom || 0
  });
  var offset2 = _objectSpread(_objectSpread({}, offsetV), offsetH);
  var brushBottom = offset2.bottom;
  if (brushItem) {
    offset2.bottom += brushItem.props.height || Brush.defaultProps.height;
  }
  if (legendItem && prevLegendBBox) {
    offset2 = appendOffsetOfLegend(offset2, graphicalItems, props3, prevLegendBBox);
  }
  return _objectSpread(_objectSpread({
    brushBottom
  }, offset2), {}, {
    width: width - offset2.left - offset2.right,
    height: height - offset2.top - offset2.bottom
  });
};
var generateCategoricalChart = function generateCategoricalChart2(_ref6) {
  var _class;
  var chartName = _ref6.chartName, GraphicalChild = _ref6.GraphicalChild, _ref6$defaultTooltipE = _ref6.defaultTooltipEventType, defaultTooltipEventType = _ref6$defaultTooltipE === void 0 ? "axis" : _ref6$defaultTooltipE, _ref6$validateTooltip = _ref6.validateTooltipEventTypes, validateTooltipEventTypes = _ref6$validateTooltip === void 0 ? ["axis"] : _ref6$validateTooltip, axisComponents = _ref6.axisComponents, legendContent = _ref6.legendContent, formatAxisMap3 = _ref6.formatAxisMap, defaultProps2 = _ref6.defaultProps;
  var getFormatItems = function getFormatItems2(props3, currentState) {
    var graphicalItems = currentState.graphicalItems, stackGroups = currentState.stackGroups, offset2 = currentState.offset, updateId = currentState.updateId, dataStartIndex = currentState.dataStartIndex, dataEndIndex = currentState.dataEndIndex;
    var barSize = props3.barSize, layout = props3.layout, barGap = props3.barGap, barCategoryGap = props3.barCategoryGap, globalMaxBarSize = props3.maxBarSize;
    var _getAxisNameByLayout = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout.numericAxisName, cateAxisName = _getAxisNameByLayout.cateAxisName;
    var hasBar = hasGraphicalBarItem(graphicalItems);
    var sizeList = hasBar && getBarSizeList({
      barSize,
      stackGroups
    });
    var formattedItems = [];
    graphicalItems.forEach(function(item, index3) {
      var displayedData = getDisplayedData(props3.data, {
        dataStartIndex,
        dataEndIndex
      }, item);
      var _item$props = item.props, dataKey = _item$props.dataKey, childMaxBarSize = _item$props.maxBarSize;
      var numericAxisId = item.props["".concat(numericAxisName, "Id")];
      var cateAxisId = item.props["".concat(cateAxisName, "Id")];
      var axisObj = axisComponents.reduce(function(result, entry) {
        var _objectSpread6;
        var axisMap = currentState["".concat(entry.axisType, "Map")];
        var id2 = item.props["".concat(entry.axisType, "Id")];
        var axis = axisMap && axisMap[id2];
        return _objectSpread(_objectSpread({}, result), {}, (_objectSpread6 = {}, _defineProperty(_objectSpread6, entry.axisType, axis), _defineProperty(_objectSpread6, "".concat(entry.axisType, "Ticks"), getTicksOfAxis(axis)), _objectSpread6));
      }, {});
      var cateAxis = axisObj[cateAxisName];
      var cateTicks = axisObj["".concat(cateAxisName, "Ticks")];
      var stackedData = stackGroups && stackGroups[numericAxisId] && stackGroups[numericAxisId].hasStack && getStackedDataOfItem(item, stackGroups[numericAxisId].stackGroups);
      var itemIsBar = getDisplayName(item.type).indexOf("Bar") >= 0;
      var bandSize = getBandSizeOfAxis(cateAxis, cateTicks);
      var barPosition = [];
      if (itemIsBar) {
        var _ref7, _getBandSizeOfAxis;
        var maxBarSize = _isNil(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
        var barBandSize = (_ref7 = (_getBandSizeOfAxis = getBandSizeOfAxis(cateAxis, cateTicks, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref7 !== void 0 ? _ref7 : 0;
        barPosition = getBarPosition({
          barGap,
          barCategoryGap,
          bandSize: barBandSize !== bandSize ? barBandSize : bandSize,
          sizeList: sizeList[cateAxisId],
          maxBarSize
        });
        if (barBandSize !== bandSize) {
          barPosition = barPosition.map(function(pos) {
            return _objectSpread(_objectSpread({}, pos), {}, {
              position: _objectSpread(_objectSpread({}, pos.position), {}, {
                offset: pos.position.offset - barBandSize / 2
              })
            });
          });
        }
      }
      var composedFn = item && item.type && item.type.getComposedData;
      if (composedFn) {
        var _objectSpread7;
        formattedItems.push({
          props: _objectSpread(_objectSpread({}, composedFn(_objectSpread(_objectSpread({}, axisObj), {}, {
            displayedData,
            props: props3,
            dataKey,
            item,
            bandSize,
            barPosition,
            offset: offset2,
            stackedData,
            layout,
            dataStartIndex,
            dataEndIndex
          }))), {}, (_objectSpread7 = {
            key: item.key || "item-".concat(index3)
          }, _defineProperty(_objectSpread7, numericAxisName, axisObj[numericAxisName]), _defineProperty(_objectSpread7, cateAxisName, axisObj[cateAxisName]), _defineProperty(_objectSpread7, "animationId", updateId), _objectSpread7)),
          childIndex: parseChildIndex(item, props3.children),
          item
        });
      }
    });
    return formattedItems;
  };
  var updateStateOfAxisMapsOffsetAndStackGroups = function updateStateOfAxisMapsOffsetAndStackGroups2(_ref8, prevState) {
    var props3 = _ref8.props, dataStartIndex = _ref8.dataStartIndex, dataEndIndex = _ref8.dataEndIndex, updateId = _ref8.updateId;
    if (!validateWidthHeight({
      props: props3
    })) {
      return null;
    }
    var children = props3.children, layout = props3.layout, stackOffset = props3.stackOffset, data2 = props3.data, reverseStackOrder = props3.reverseStackOrder;
    var _getAxisNameByLayout2 = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout2.numericAxisName, cateAxisName = _getAxisNameByLayout2.cateAxisName;
    var graphicalItems = findAllByType(children, GraphicalChild);
    var stackGroups = getStackGroupsByAxisId(data2, graphicalItems, "".concat(numericAxisName, "Id"), "".concat(cateAxisName, "Id"), stackOffset, reverseStackOrder);
    var axisObj = axisComponents.reduce(function(result, entry) {
      var name = "".concat(entry.axisType, "Map");
      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, name, getAxisMap(props3, _objectSpread(_objectSpread({}, entry), {}, {
        graphicalItems,
        stackGroups: entry.axisType === numericAxisName && stackGroups,
        dataStartIndex,
        dataEndIndex
      }))));
    }, {});
    var offset2 = calculateOffset(_objectSpread(_objectSpread({}, axisObj), {}, {
      props: props3,
      graphicalItems
    }), prevState === null || prevState === void 0 ? void 0 : prevState.legendBBox);
    Object.keys(axisObj).forEach(function(key) {
      axisObj[key] = formatAxisMap3(props3, axisObj[key], offset2, key.replace("Map", ""), chartName);
    });
    var cateAxisMap = axisObj["".concat(cateAxisName, "Map")];
    var ticksObj = tooltipTicksGenerator(cateAxisMap);
    var formattedGraphicalItems = getFormatItems(props3, _objectSpread(_objectSpread({}, axisObj), {}, {
      dataStartIndex,
      dataEndIndex,
      updateId,
      graphicalItems,
      stackGroups,
      offset: offset2
    }));
    return _objectSpread(_objectSpread({
      formattedGraphicalItems,
      graphicalItems,
      offset: offset2,
      stackGroups
    }, ticksObj), axisObj);
  };
  return _class = /* @__PURE__ */ function(_Component) {
    _inherits(CategoricalChartWrapper, _Component);
    var _super = _createSuper(CategoricalChartWrapper);
    function CategoricalChartWrapper(_props) {
      var _this;
      _classCallCheck(this, CategoricalChartWrapper);
      _this = _super.call(this, _props);
      _defineProperty(_assertThisInitialized(_this), "accessibilityManager", new AccessibilityManager());
      _defineProperty(_assertThisInitialized(_this), "clearDeferId", function() {
        if (!_isNil(_this.deferId) && deferClear) {
          deferClear(_this.deferId);
        }
        _this.deferId = null;
      });
      _defineProperty(_assertThisInitialized(_this), "handleLegendBBoxUpdate", function(box) {
        if (box) {
          var _this$state = _this.state, dataStartIndex = _this$state.dataStartIndex, dataEndIndex = _this$state.dataEndIndex, updateId = _this$state.updateId;
          _this.setState(_objectSpread({
            legendBBox: box
          }, updateStateOfAxisMapsOffsetAndStackGroups({
            props: _this.props,
            dataStartIndex,
            dataEndIndex,
            updateId
          }, _objectSpread(_objectSpread({}, _this.state), {}, {
            legendBBox: box
          }))));
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleReceiveSyncEvent", function(cId, chartId, data2) {
        var syncId = _this.props.syncId;
        if (syncId === cId && chartId !== _this.uniqueChartId) {
          _this.clearDeferId();
          _this.deferId = defer && defer(_this.applySyncEvent.bind(_assertThisInitialized(_this), data2));
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleBrushChange", function(_ref9) {
        var startIndex = _ref9.startIndex, endIndex = _ref9.endIndex;
        if (startIndex !== _this.state.dataStartIndex || endIndex !== _this.state.dataEndIndex) {
          var updateId = _this.state.updateId;
          _this.setState(function() {
            return _objectSpread({
              dataStartIndex: startIndex,
              dataEndIndex: endIndex
            }, updateStateOfAxisMapsOffsetAndStackGroups({
              props: _this.props,
              dataStartIndex: startIndex,
              dataEndIndex: endIndex,
              updateId
            }, _this.state));
          });
          _this.triggerSyncEvent({
            dataStartIndex: startIndex,
            dataEndIndex: endIndex
          });
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleMouseEnter", function(e3) {
        var onMouseEnter = _this.props.onMouseEnter;
        var mouse = _this.getMouseInfo(e3);
        if (mouse) {
          var _nextState = _objectSpread(_objectSpread({}, mouse), {}, {
            isTooltipActive: true
          });
          _this.setState(_nextState);
          _this.triggerSyncEvent(_nextState);
          if (_isFunction(onMouseEnter)) {
            onMouseEnter(_nextState, e3);
          }
        }
      });
      _defineProperty(_assertThisInitialized(_this), "triggeredAfterMouseMove", function(e3) {
        var onMouseMove = _this.props.onMouseMove;
        var mouse = _this.getMouseInfo(e3);
        var nextState = mouse ? _objectSpread(_objectSpread({}, mouse), {}, {
          isTooltipActive: true
        }) : {
          isTooltipActive: false
        };
        _this.setState(nextState);
        _this.triggerSyncEvent(nextState);
        if (_isFunction(onMouseMove)) {
          onMouseMove(nextState, e3);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleItemMouseEnter", function(el2) {
        _this.setState(function() {
          return {
            isTooltipActive: true,
            activeItem: el2,
            activePayload: el2.tooltipPayload,
            activeCoordinate: el2.tooltipPosition || {
              x: el2.cx,
              y: el2.cy
            }
          };
        });
      });
      _defineProperty(_assertThisInitialized(_this), "handleItemMouseLeave", function() {
        _this.setState(function() {
          return {
            isTooltipActive: false
          };
        });
      });
      _defineProperty(_assertThisInitialized(_this), "handleMouseMove", function(e3) {
        if (e3 && _isFunction(e3.persist)) {
          e3.persist();
        }
        _this.triggeredAfterMouseMove(e3);
      });
      _defineProperty(_assertThisInitialized(_this), "handleMouseLeave", function(e3) {
        var onMouseLeave = _this.props.onMouseLeave;
        var nextState = {
          isTooltipActive: false
        };
        _this.setState(nextState);
        _this.triggerSyncEvent(nextState);
        if (_isFunction(onMouseLeave)) {
          onMouseLeave(nextState, e3);
        }
        _this.cancelThrottledTriggerAfterMouseMove();
      });
      _defineProperty(_assertThisInitialized(_this), "handleOuterEvent", function(e3) {
        var eventName = getReactEventByType(e3);
        var event = _get(_this.props, "".concat(eventName));
        if (eventName && _isFunction(event)) {
          var mouse;
          if (/.*touch.*/i.test(eventName)) {
            mouse = _this.getMouseInfo(e3.changedTouches[0]);
          } else {
            mouse = _this.getMouseInfo(e3);
          }
          var handler = event;
          handler(mouse, e3);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleClick", function(e3) {
        var onClick2 = _this.props.onClick;
        var mouse = _this.getMouseInfo(e3);
        if (mouse) {
          var _nextState2 = _objectSpread(_objectSpread({}, mouse), {}, {
            isTooltipActive: true
          });
          _this.setState(_nextState2);
          _this.triggerSyncEvent(_nextState2);
          if (_isFunction(onClick2)) {
            onClick2(_nextState2, e3);
          }
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleMouseDown", function(e3) {
        var onMouseDown = _this.props.onMouseDown;
        if (_isFunction(onMouseDown)) {
          var _nextState3 = _this.getMouseInfo(e3);
          onMouseDown(_nextState3, e3);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleMouseUp", function(e3) {
        var onMouseUp = _this.props.onMouseUp;
        if (_isFunction(onMouseUp)) {
          var _nextState4 = _this.getMouseInfo(e3);
          onMouseUp(_nextState4, e3);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleTouchMove", function(e3) {
        if (e3.changedTouches != null && e3.changedTouches.length > 0) {
          _this.handleMouseMove(e3.changedTouches[0]);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleTouchStart", function(e3) {
        if (e3.changedTouches != null && e3.changedTouches.length > 0) {
          _this.handleMouseDown(e3.changedTouches[0]);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleTouchEnd", function(e3) {
        if (e3.changedTouches != null && e3.changedTouches.length > 0) {
          _this.handleMouseUp(e3.changedTouches[0]);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "verticalCoordinatesGenerator", function(_ref10) {
        var xAxis = _ref10.xAxis, width = _ref10.width, height = _ref10.height, offset2 = _ref10.offset;
        return getCoordinatesOfGrid(getTicks(_objectSpread(_objectSpread(_objectSpread({}, CartesianAxis.defaultProps), xAxis), {}, {
          ticks: getTicksOfAxis(xAxis, true),
          viewBox: {
            x: 0,
            y: 0,
            width,
            height
          }
        })), offset2.left, offset2.left + offset2.width);
      });
      _defineProperty(_assertThisInitialized(_this), "horizontalCoordinatesGenerator", function(_ref11) {
        var yAxis = _ref11.yAxis, width = _ref11.width, height = _ref11.height, offset2 = _ref11.offset;
        return getCoordinatesOfGrid(getTicks(_objectSpread(_objectSpread(_objectSpread({}, CartesianAxis.defaultProps), yAxis), {}, {
          ticks: getTicksOfAxis(yAxis, true),
          viewBox: {
            x: 0,
            y: 0,
            width,
            height
          }
        })), offset2.top, offset2.top + offset2.height);
      });
      _defineProperty(_assertThisInitialized(_this), "axesTicksGenerator", function(axis) {
        return getTicksOfAxis(axis, true);
      });
      _defineProperty(_assertThisInitialized(_this), "renderCursor", function(element) {
        var _this$state2 = _this.state, isTooltipActive = _this$state2.isTooltipActive, activeCoordinate = _this$state2.activeCoordinate, activePayload = _this$state2.activePayload, offset2 = _this$state2.offset, activeTooltipIndex = _this$state2.activeTooltipIndex;
        var tooltipEventType = _this.getTooltipEventType();
        if (!element || !element.props.cursor || !isTooltipActive || !activeCoordinate || chartName !== "ScatterChart" && tooltipEventType !== "axis") {
          return null;
        }
        var layout = _this.props.layout;
        var restProps;
        var cursorComp = Curve;
        if (chartName === "ScatterChart") {
          restProps = activeCoordinate;
          cursorComp = Cross;
        } else if (chartName === "BarChart") {
          restProps = _this.getCursorRectangle();
          cursorComp = Rectangle;
        } else if (layout === "radial") {
          var _this$getCursorPoints = _this.getCursorPoints(), cx = _this$getCursorPoints.cx, cy = _this$getCursorPoints.cy, radius = _this$getCursorPoints.radius, startAngle = _this$getCursorPoints.startAngle, endAngle = _this$getCursorPoints.endAngle;
          restProps = {
            cx,
            cy,
            startAngle,
            endAngle,
            innerRadius: radius,
            outerRadius: radius
          };
          cursorComp = Sector;
        } else {
          restProps = {
            points: _this.getCursorPoints()
          };
          cursorComp = Curve;
        }
        var key = element.key || "_recharts-cursor";
        var cursorProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({
          stroke: "#ccc",
          pointerEvents: "none"
        }, offset2), restProps), filterProps(element.props.cursor)), {}, {
          payload: activePayload,
          payloadIndex: activeTooltipIndex,
          key,
          className: "recharts-tooltip-cursor"
        });
        return /* @__PURE__ */ reactExports.isValidElement(element.props.cursor) ? /* @__PURE__ */ reactExports.cloneElement(element.props.cursor, cursorProps) : /* @__PURE__ */ reactExports.createElement(cursorComp, cursorProps);
      });
      _defineProperty(_assertThisInitialized(_this), "renderPolarAxis", function(element, displayName, index3) {
        var axisType = _get(element, "type.axisType");
        var axisMap = _get(_this.state, "".concat(axisType, "Map"));
        var axisOption = axisMap && axisMap[element.props["".concat(axisType, "Id")]];
        return /* @__PURE__ */ reactExports.cloneElement(element, _objectSpread(_objectSpread({}, axisOption), {}, {
          className: axisType,
          key: element.key || "".concat(displayName, "-").concat(index3),
          ticks: getTicksOfAxis(axisOption, true)
        }));
      });
      _defineProperty(_assertThisInitialized(_this), "renderXAxis", function(element, displayName, index3) {
        var xAxisMap = _this.state.xAxisMap;
        var axisObj = xAxisMap[element.props.xAxisId];
        return _this.renderAxis(axisObj, element, displayName, index3);
      });
      _defineProperty(_assertThisInitialized(_this), "renderYAxis", function(element, displayName, index3) {
        var yAxisMap = _this.state.yAxisMap;
        var axisObj = yAxisMap[element.props.yAxisId];
        return _this.renderAxis(axisObj, element, displayName, index3);
      });
      _defineProperty(_assertThisInitialized(_this), "renderGrid", function(element) {
        var _this$state3 = _this.state, xAxisMap = _this$state3.xAxisMap, yAxisMap = _this$state3.yAxisMap, offset2 = _this$state3.offset;
        var _this$props = _this.props, width = _this$props.width, height = _this$props.height;
        var xAxis = getAnyElementOfObject(xAxisMap);
        var yAxisWithFiniteDomain = _find(yAxisMap, function(axis) {
          return _every(axis.domain, isFinit);
        });
        var yAxis = yAxisWithFiniteDomain || getAnyElementOfObject(yAxisMap);
        var props3 = element.props || {};
        return /* @__PURE__ */ reactExports.cloneElement(element, {
          key: element.key || "grid",
          x: isNumber(props3.x) ? props3.x : offset2.left,
          y: isNumber(props3.y) ? props3.y : offset2.top,
          width: isNumber(props3.width) ? props3.width : offset2.width,
          height: isNumber(props3.height) ? props3.height : offset2.height,
          xAxis,
          yAxis,
          offset: offset2,
          chartWidth: width,
          chartHeight: height,
          verticalCoordinatesGenerator: props3.verticalCoordinatesGenerator || _this.verticalCoordinatesGenerator,
          horizontalCoordinatesGenerator: props3.horizontalCoordinatesGenerator || _this.horizontalCoordinatesGenerator
        });
      });
      _defineProperty(_assertThisInitialized(_this), "renderPolarGrid", function(element) {
        var _element$props = element.props, radialLines = _element$props.radialLines, polarAngles = _element$props.polarAngles, polarRadius = _element$props.polarRadius;
        var _this$state4 = _this.state, radiusAxisMap = _this$state4.radiusAxisMap, angleAxisMap = _this$state4.angleAxisMap;
        var radiusAxis = getAnyElementOfObject(radiusAxisMap);
        var angleAxis = getAnyElementOfObject(angleAxisMap);
        var cx = angleAxis.cx, cy = angleAxis.cy, innerRadius = angleAxis.innerRadius, outerRadius = angleAxis.outerRadius;
        return /* @__PURE__ */ reactExports.cloneElement(element, {
          polarAngles: _isArray2(polarAngles) ? polarAngles : getTicksOfAxis(angleAxis, true).map(function(entry) {
            return entry.coordinate;
          }),
          polarRadius: _isArray2(polarRadius) ? polarRadius : getTicksOfAxis(radiusAxis, true).map(function(entry) {
            return entry.coordinate;
          }),
          cx,
          cy,
          innerRadius,
          outerRadius,
          key: element.key || "polar-grid",
          radialLines
        });
      });
      _defineProperty(_assertThisInitialized(_this), "renderLegend", function() {
        var formattedGraphicalItems = _this.state.formattedGraphicalItems;
        var _this$props2 = _this.props, children = _this$props2.children, width = _this$props2.width, height = _this$props2.height;
        var margin = _this.props.margin || {};
        var legendWidth = width - (margin.left || 0) - (margin.right || 0);
        var props3 = getLegendProps({
          children,
          formattedGraphicalItems,
          legendWidth,
          legendContent
        });
        if (!props3) {
          return null;
        }
        var item = props3.item, otherProps = _objectWithoutProperties(props3, _excluded);
        return /* @__PURE__ */ reactExports.cloneElement(item, _objectSpread(_objectSpread({}, otherProps), {}, {
          chartWidth: width,
          chartHeight: height,
          margin,
          ref: function ref(legend) {
            _this.legendInstance = legend;
          },
          onBBoxUpdate: _this.handleLegendBBoxUpdate
        }));
      });
      _defineProperty(_assertThisInitialized(_this), "renderTooltip", function() {
        var children = _this.props.children;
        var tooltipItem = findChildByType(children, Tooltip);
        if (!tooltipItem) {
          return null;
        }
        var _this$state5 = _this.state, isTooltipActive = _this$state5.isTooltipActive, activeCoordinate = _this$state5.activeCoordinate, activePayload = _this$state5.activePayload, activeLabel = _this$state5.activeLabel, offset2 = _this$state5.offset;
        return /* @__PURE__ */ reactExports.cloneElement(tooltipItem, {
          viewBox: _objectSpread(_objectSpread({}, offset2), {}, {
            x: offset2.left,
            y: offset2.top
          }),
          active: isTooltipActive,
          label: activeLabel,
          payload: isTooltipActive ? activePayload : [],
          coordinate: activeCoordinate
        });
      });
      _defineProperty(_assertThisInitialized(_this), "renderBrush", function(element) {
        var _this$props3 = _this.props, margin = _this$props3.margin, data2 = _this$props3.data;
        var _this$state6 = _this.state, offset2 = _this$state6.offset, dataStartIndex = _this$state6.dataStartIndex, dataEndIndex = _this$state6.dataEndIndex, updateId = _this$state6.updateId;
        return /* @__PURE__ */ reactExports.cloneElement(element, {
          key: element.key || "_recharts-brush",
          onChange: combineEventHandlers(_this.handleBrushChange, null, element.props.onChange),
          data: data2,
          x: isNumber(element.props.x) ? element.props.x : offset2.left,
          y: isNumber(element.props.y) ? element.props.y : offset2.top + offset2.height + offset2.brushBottom - (margin.bottom || 0),
          width: isNumber(element.props.width) ? element.props.width : offset2.width,
          startIndex: dataStartIndex,
          endIndex: dataEndIndex,
          updateId: "brush-".concat(updateId)
        });
      });
      _defineProperty(_assertThisInitialized(_this), "renderReferenceElement", function(element, displayName, index3) {
        if (!element) {
          return null;
        }
        var _assertThisInitialize = _assertThisInitialized(_this), clipPathId = _assertThisInitialize.clipPathId;
        var _this$state7 = _this.state, xAxisMap = _this$state7.xAxisMap, yAxisMap = _this$state7.yAxisMap, offset2 = _this$state7.offset;
        var _element$props2 = element.props, xAxisId = _element$props2.xAxisId, yAxisId = _element$props2.yAxisId;
        return /* @__PURE__ */ reactExports.cloneElement(element, {
          key: element.key || "".concat(displayName, "-").concat(index3),
          xAxis: xAxisMap[xAxisId],
          yAxis: yAxisMap[yAxisId],
          viewBox: {
            x: offset2.left,
            y: offset2.top,
            width: offset2.width,
            height: offset2.height
          },
          clipPathId
        });
      });
      _defineProperty(_assertThisInitialized(_this), "renderActivePoints", function(_ref12) {
        var item = _ref12.item, activePoint = _ref12.activePoint, basePoint = _ref12.basePoint, childIndex = _ref12.childIndex, isRange = _ref12.isRange;
        var result = [];
        var key = item.props.key;
        var _item$item$props = item.item.props, activeDot = _item$item$props.activeDot, dataKey = _item$item$props.dataKey;
        var dotProps = _objectSpread(_objectSpread({
          index: childIndex,
          dataKey,
          cx: activePoint.x,
          cy: activePoint.y,
          r: 4,
          fill: getMainColorOfGraphicItem(item.item),
          strokeWidth: 2,
          stroke: "#fff",
          payload: activePoint.payload,
          value: activePoint.value,
          key: "".concat(key, "-activePoint-").concat(childIndex)
        }, filterProps(activeDot)), adaptEventHandlers(activeDot));
        result.push(CategoricalChartWrapper.renderActiveDot(activeDot, dotProps));
        if (basePoint) {
          result.push(CategoricalChartWrapper.renderActiveDot(activeDot, _objectSpread(_objectSpread({}, dotProps), {}, {
            cx: basePoint.x,
            cy: basePoint.y,
            key: "".concat(key, "-basePoint-").concat(childIndex)
          })));
        } else if (isRange) {
          result.push(null);
        }
        return result;
      });
      _defineProperty(_assertThisInitialized(_this), "renderGraphicChild", function(element, displayName, index3) {
        var item = _this.filterFormatItem(element, displayName, index3);
        if (!item) {
          return null;
        }
        var tooltipEventType = _this.getTooltipEventType();
        var _this$state8 = _this.state, isTooltipActive = _this$state8.isTooltipActive, tooltipAxis = _this$state8.tooltipAxis, activeTooltipIndex = _this$state8.activeTooltipIndex, activeLabel = _this$state8.activeLabel;
        var children = _this.props.children;
        var tooltipItem = findChildByType(children, Tooltip);
        var _item$props2 = item.props, points = _item$props2.points, isRange = _item$props2.isRange, baseLine = _item$props2.baseLine;
        var _item$item$props2 = item.item.props, activeDot = _item$item$props2.activeDot, hide = _item$item$props2.hide;
        var hasActive = !hide && isTooltipActive && tooltipItem && activeDot && activeTooltipIndex >= 0;
        var itemEvents = {};
        if (tooltipEventType !== "axis" && tooltipItem && tooltipItem.props.trigger === "click") {
          itemEvents = {
            onClick: combineEventHandlers(_this.handleItemMouseEnter, null, element.props.onCLick)
          };
        } else if (tooltipEventType !== "axis") {
          itemEvents = {
            onMouseLeave: combineEventHandlers(_this.handleItemMouseLeave, null, element.props.onMouseLeave),
            onMouseEnter: combineEventHandlers(_this.handleItemMouseEnter, null, element.props.onMouseEnter)
          };
        }
        var graphicalItem = /* @__PURE__ */ reactExports.cloneElement(element, _objectSpread(_objectSpread({}, item.props), itemEvents));
        function findWithPayload(entry) {
          return typeof tooltipAxis.dataKey === "function" ? tooltipAxis.dataKey(entry.payload) : null;
        }
        if (hasActive) {
          var activePoint, basePoint;
          if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
            var specifiedKey = typeof tooltipAxis.dataKey === "function" ? findWithPayload : "payload.".concat(tooltipAxis.dataKey.toString());
            activePoint = findEntryInArray(points, specifiedKey, activeLabel);
            basePoint = isRange && baseLine && findEntryInArray(baseLine, specifiedKey, activeLabel);
          } else {
            activePoint = points[activeTooltipIndex];
            basePoint = isRange && baseLine && baseLine[activeTooltipIndex];
          }
          if (!_isNil(activePoint)) {
            return [graphicalItem].concat(_toConsumableArray(_this.renderActivePoints({
              item,
              activePoint,
              basePoint,
              childIndex: activeTooltipIndex,
              isRange
            })));
          }
        }
        if (isRange) {
          return [graphicalItem, null, null];
        }
        return [graphicalItem, null];
      });
      _defineProperty(_assertThisInitialized(_this), "renderCustomized", function(element, displayName, index3) {
        return /* @__PURE__ */ reactExports.cloneElement(element, _objectSpread(_objectSpread({
          key: "recharts-customized-".concat(index3)
        }, _this.props), _this.state));
      });
      _this.uniqueChartId = _isNil(_props.id) ? uniqueId("recharts") : _props.id;
      _this.clipPathId = "".concat(_this.uniqueChartId, "-clip");
      if (_props.throttleDelay) {
        _this.triggeredAfterMouseMove = _throttle(_this.triggeredAfterMouseMove, _props.throttleDelay);
      }
      _this.state = {};
      return _this;
    }
    _createClass(CategoricalChartWrapper, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$props$margin$le, _this$props$margin$to;
        if (!_isNil(this.props.syncId)) {
          this.addListener();
        }
        this.accessibilityManager.setDetails({
          container: this.container,
          offset: {
            left: (_this$props$margin$le = this.props.margin.left) !== null && _this$props$margin$le !== void 0 ? _this$props$margin$le : 0,
            top: (_this$props$margin$to = this.props.margin.top) !== null && _this$props$margin$to !== void 0 ? _this$props$margin$to : 0
          },
          coordinateList: this.state.tooltipTicks,
          mouseHandlerCallback: this.handleMouseMove,
          layout: this.props.layout
        });
      }
    }, {
      key: "getSnapshotBeforeUpdate",
      value: function getSnapshotBeforeUpdate(prevProps, prevState) {
        if (!this.props.accessibilityLayer) {
          return null;
        }
        if (this.state.tooltipTicks !== prevState.tooltipTicks) {
          this.accessibilityManager.setDetails({
            coordinateList: this.state.tooltipTicks
          });
        }
        if (this.props.layout !== prevProps.layout) {
          this.accessibilityManager.setDetails({
            layout: this.props.layout
          });
        }
        if (this.props.margin !== prevProps.margin) {
          var _this$props$margin$le2, _this$props$margin$to2;
          this.accessibilityManager.setDetails({
            offset: {
              left: (_this$props$margin$le2 = this.props.margin.left) !== null && _this$props$margin$le2 !== void 0 ? _this$props$margin$le2 : 0,
              top: (_this$props$margin$to2 = this.props.margin.top) !== null && _this$props$margin$to2 !== void 0 ? _this$props$margin$to2 : 0
            }
          });
        }
        return null;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (_isNil(prevProps.syncId) && !_isNil(this.props.syncId)) {
          this.addListener();
        }
        if (!_isNil(prevProps.syncId) && _isNil(this.props.syncId)) {
          this.removeListener();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearDeferId();
        if (!_isNil(this.props.syncId)) {
          this.removeListener();
        }
        this.cancelThrottledTriggerAfterMouseMove();
      }
    }, {
      key: "cancelThrottledTriggerAfterMouseMove",
      value: function cancelThrottledTriggerAfterMouseMove() {
        if (typeof this.triggeredAfterMouseMove.cancel === "function") {
          this.triggeredAfterMouseMove.cancel();
        }
      }
    }, {
      key: "getTooltipEventType",
      value: function getTooltipEventType() {
        var tooltipItem = findChildByType(this.props.children, Tooltip);
        if (tooltipItem && _isBoolean(tooltipItem.props.shared)) {
          var eventType = tooltipItem.props.shared ? "axis" : "item";
          return validateTooltipEventTypes.indexOf(eventType) >= 0 ? eventType : defaultTooltipEventType;
        }
        return defaultTooltipEventType;
      }
      /**
       * Get the information of mouse in chart, return null when the mouse is not in the chart
       * @param  {Object} event    The event object
       * @return {Object}          Mouse data
       */
    }, {
      key: "getMouseInfo",
      value: function getMouseInfo(event) {
        if (!this.container) {
          return null;
        }
        var containerOffset = getOffset(this.container);
        var e3 = calculateChartCoordinate(event, containerOffset);
        var rangeObj = this.inRange(e3.chartX, e3.chartY);
        if (!rangeObj) {
          return null;
        }
        var _this$state9 = this.state, xAxisMap = _this$state9.xAxisMap, yAxisMap = _this$state9.yAxisMap;
        var tooltipEventType = this.getTooltipEventType();
        if (tooltipEventType !== "axis" && xAxisMap && yAxisMap) {
          var xScale = getAnyElementOfObject(xAxisMap).scale;
          var yScale = getAnyElementOfObject(yAxisMap).scale;
          var xValue = xScale && xScale.invert ? xScale.invert(e3.chartX) : null;
          var yValue = yScale && yScale.invert ? yScale.invert(e3.chartY) : null;
          return _objectSpread(_objectSpread({}, e3), {}, {
            xValue,
            yValue
          });
        }
        var toolTipData = getTooltipData(this.state, this.props.data, this.props.layout, rangeObj);
        if (toolTipData) {
          return _objectSpread(_objectSpread({}, e3), toolTipData);
        }
        return null;
      }
    }, {
      key: "getCursorRectangle",
      value: function getCursorRectangle() {
        var layout = this.props.layout;
        var _this$state10 = this.state, activeCoordinate = _this$state10.activeCoordinate, offset2 = _this$state10.offset, tooltipAxisBandSize = _this$state10.tooltipAxisBandSize;
        var halfSize = tooltipAxisBandSize / 2;
        return {
          stroke: "none",
          fill: "#ccc",
          x: layout === "horizontal" ? activeCoordinate.x - halfSize : offset2.left + 0.5,
          y: layout === "horizontal" ? offset2.top + 0.5 : activeCoordinate.y - halfSize,
          width: layout === "horizontal" ? tooltipAxisBandSize : offset2.width - 1,
          height: layout === "horizontal" ? offset2.height - 1 : tooltipAxisBandSize
        };
      }
    }, {
      key: "getCursorPoints",
      value: function getCursorPoints() {
        var layout = this.props.layout;
        var _this$state11 = this.state, activeCoordinate = _this$state11.activeCoordinate, offset2 = _this$state11.offset;
        var x1, y1, x2, y2;
        if (layout === "horizontal") {
          x1 = activeCoordinate.x;
          x2 = x1;
          y1 = offset2.top;
          y2 = offset2.top + offset2.height;
        } else if (layout === "vertical") {
          y1 = activeCoordinate.y;
          y2 = y1;
          x1 = offset2.left;
          x2 = offset2.left + offset2.width;
        } else if (!_isNil(activeCoordinate.cx) || !_isNil(activeCoordinate.cy)) {
          if (layout === "centric") {
            var cx = activeCoordinate.cx, cy = activeCoordinate.cy, innerRadius = activeCoordinate.innerRadius, outerRadius = activeCoordinate.outerRadius, angle = activeCoordinate.angle;
            var innerPoint = polarToCartesian(cx, cy, innerRadius, angle);
            var outerPoint = polarToCartesian(cx, cy, outerRadius, angle);
            x1 = innerPoint.x;
            y1 = innerPoint.y;
            x2 = outerPoint.x;
            y2 = outerPoint.y;
          } else {
            var _cx = activeCoordinate.cx, _cy = activeCoordinate.cy, radius = activeCoordinate.radius, startAngle = activeCoordinate.startAngle, endAngle = activeCoordinate.endAngle;
            var startPoint = polarToCartesian(_cx, _cy, radius, startAngle);
            var endPoint = polarToCartesian(_cx, _cy, radius, endAngle);
            return {
              points: [startPoint, endPoint],
              cx: _cx,
              cy: _cy,
              radius,
              startAngle,
              endAngle
            };
          }
        }
        return [{
          x: x1,
          y: y1
        }, {
          x: x2,
          y: y2
        }];
      }
    }, {
      key: "inRange",
      value: function inRange(x2, y2) {
        var layout = this.props.layout;
        if (layout === "horizontal" || layout === "vertical") {
          var offset2 = this.state.offset;
          var isInRange = x2 >= offset2.left && x2 <= offset2.left + offset2.width && y2 >= offset2.top && y2 <= offset2.top + offset2.height;
          return isInRange ? {
            x: x2,
            y: y2
          } : null;
        }
        var _this$state12 = this.state, angleAxisMap = _this$state12.angleAxisMap, radiusAxisMap = _this$state12.radiusAxisMap;
        if (angleAxisMap && radiusAxisMap) {
          var angleAxis = getAnyElementOfObject(angleAxisMap);
          return inRangeOfSector({
            x: x2,
            y: y2
          }, angleAxis);
        }
        return null;
      }
    }, {
      key: "parseEventsOfWrapper",
      value: function parseEventsOfWrapper() {
        var children = this.props.children;
        var tooltipEventType = this.getTooltipEventType();
        var tooltipItem = findChildByType(children, Tooltip);
        var tooltipEvents = {};
        if (tooltipItem && tooltipEventType === "axis") {
          if (tooltipItem.props.trigger === "click") {
            tooltipEvents = {
              onClick: this.handleClick
            };
          } else {
            tooltipEvents = {
              onMouseEnter: this.handleMouseEnter,
              onMouseMove: this.handleMouseMove,
              onMouseLeave: this.handleMouseLeave,
              onTouchMove: this.handleTouchMove,
              onTouchStart: this.handleTouchStart,
              onTouchEnd: this.handleTouchEnd
            };
          }
        }
        var outerEvents = adaptEventHandlers(this.props, this.handleOuterEvent);
        return _objectSpread(_objectSpread({}, outerEvents), tooltipEvents);
      }
      /* eslint-disable  no-underscore-dangle */
    }, {
      key: "addListener",
      value: function addListener2() {
        eventCenter.on(SYNC_EVENT, this.handleReceiveSyncEvent);
        if (eventCenter.setMaxListeners && eventCenter._maxListeners) {
          eventCenter.setMaxListeners(eventCenter._maxListeners + 1);
        }
      }
    }, {
      key: "removeListener",
      value: function removeListener2() {
        eventCenter.removeListener(SYNC_EVENT, this.handleReceiveSyncEvent);
        if (eventCenter.setMaxListeners && eventCenter._maxListeners) {
          eventCenter.setMaxListeners(eventCenter._maxListeners - 1);
        }
      }
    }, {
      key: "triggerSyncEvent",
      value: function triggerSyncEvent(data2) {
        var syncId = this.props.syncId;
        if (!_isNil(syncId)) {
          eventCenter.emit(SYNC_EVENT, syncId, this.uniqueChartId, data2);
        }
      }
    }, {
      key: "applySyncEvent",
      value: function applySyncEvent(data2) {
        var _this$props4 = this.props, layout = _this$props4.layout, syncMethod = _this$props4.syncMethod;
        var updateId = this.state.updateId;
        var dataStartIndex = data2.dataStartIndex, dataEndIndex = data2.dataEndIndex;
        if (!_isNil(data2.dataStartIndex) || !_isNil(data2.dataEndIndex)) {
          this.setState(_objectSpread({
            dataStartIndex,
            dataEndIndex
          }, updateStateOfAxisMapsOffsetAndStackGroups({
            props: this.props,
            dataStartIndex,
            dataEndIndex,
            updateId
          }, this.state)));
        } else if (!_isNil(data2.activeTooltipIndex)) {
          var chartX = data2.chartX, chartY = data2.chartY;
          var activeTooltipIndex = data2.activeTooltipIndex;
          var _this$state13 = this.state, offset2 = _this$state13.offset, tooltipTicks = _this$state13.tooltipTicks;
          if (!offset2) {
            return;
          }
          if (typeof syncMethod === "function") {
            activeTooltipIndex = syncMethod(tooltipTicks, data2);
          } else if (syncMethod === "value") {
            activeTooltipIndex = -1;
            for (var i = 0; i < tooltipTicks.length; i++) {
              if (tooltipTicks[i].value === data2.activeLabel) {
                activeTooltipIndex = i;
                break;
              }
            }
          }
          var viewBox = _objectSpread(_objectSpread({}, offset2), {}, {
            x: offset2.left,
            y: offset2.top
          });
          var validateChartX = Math.min(chartX, viewBox.x + viewBox.width);
          var validateChartY = Math.min(chartY, viewBox.y + viewBox.height);
          var activeLabel = tooltipTicks[activeTooltipIndex] && tooltipTicks[activeTooltipIndex].value;
          var activePayload = getTooltipContent(this.state, this.props.data, activeTooltipIndex);
          var activeCoordinate = tooltipTicks[activeTooltipIndex] ? {
            x: layout === "horizontal" ? tooltipTicks[activeTooltipIndex].coordinate : validateChartX,
            y: layout === "horizontal" ? validateChartY : tooltipTicks[activeTooltipIndex].coordinate
          } : originCoordinate;
          this.setState(_objectSpread(_objectSpread({}, data2), {}, {
            activeLabel,
            activeCoordinate,
            activePayload,
            activeTooltipIndex
          }));
        } else {
          this.setState(data2);
        }
      }
    }, {
      key: "filterFormatItem",
      value: function filterFormatItem(item, displayName, childIndex) {
        var formattedGraphicalItems = this.state.formattedGraphicalItems;
        for (var i = 0, len = formattedGraphicalItems.length; i < len; i++) {
          var entry = formattedGraphicalItems[i];
          if (entry.item === item || entry.props.key === item.key || displayName === getDisplayName(entry.item.type) && childIndex === entry.childIndex) {
            return entry;
          }
        }
        return null;
      }
    }, {
      key: "renderAxis",
      value: (
        /**
         * Draw axis
         * @param {Object} axisOptions The options of axis
         * @param {Object} element      The axis element
         * @param {String} displayName  The display name of axis
         * @param {Number} index        The index of element
         * @return {ReactElement}       The instance of x-axes
         */
        function renderAxis(axisOptions, element, displayName, index3) {
          var _this$props5 = this.props, width = _this$props5.width, height = _this$props5.height;
          return /* @__PURE__ */ React.createElement(CartesianAxis, _extends({}, axisOptions, {
            className: "recharts-".concat(axisOptions.axisType, " ").concat(axisOptions.axisType),
            key: element.key || "".concat(displayName, "-").concat(index3),
            viewBox: {
              x: 0,
              y: 0,
              width,
              height
            },
            ticksGenerator: this.axesTicksGenerator
          }));
        }
      )
    }, {
      key: "renderClipPath",
      value: function renderClipPath() {
        var clipPathId = this.clipPathId;
        var _this$state$offset = this.state.offset, left = _this$state$offset.left, top = _this$state$offset.top, height = _this$state$offset.height, width = _this$state$offset.width;
        return /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", {
          id: clipPathId
        }, /* @__PURE__ */ React.createElement("rect", {
          x: left,
          y: top,
          height,
          width
        })));
      }
    }, {
      key: "getXScales",
      value: function getXScales() {
        var xAxisMap = this.state.xAxisMap;
        return xAxisMap ? Object.entries(xAxisMap).reduce(function(res, _ref13) {
          var _ref14 = _slicedToArray(_ref13, 2), axisId = _ref14[0], axisProps = _ref14[1];
          return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));
        }, {}) : null;
      }
    }, {
      key: "getYScales",
      value: function getYScales() {
        var yAxisMap = this.state.yAxisMap;
        return yAxisMap ? Object.entries(yAxisMap).reduce(function(res, _ref15) {
          var _ref16 = _slicedToArray(_ref15, 2), axisId = _ref16[0], axisProps = _ref16[1];
          return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));
        }, {}) : null;
      }
    }, {
      key: "getXScaleByAxisId",
      value: function getXScaleByAxisId(axisId) {
        var _this$state$xAxisMap, _this$state$xAxisMap$;
        return (_this$state$xAxisMap = this.state.xAxisMap) === null || _this$state$xAxisMap === void 0 ? void 0 : (_this$state$xAxisMap$ = _this$state$xAxisMap[axisId]) === null || _this$state$xAxisMap$ === void 0 ? void 0 : _this$state$xAxisMap$.scale;
      }
    }, {
      key: "getYScaleByAxisId",
      value: function getYScaleByAxisId(axisId) {
        var _this$state$yAxisMap, _this$state$yAxisMap$;
        return (_this$state$yAxisMap = this.state.yAxisMap) === null || _this$state$yAxisMap === void 0 ? void 0 : (_this$state$yAxisMap$ = _this$state$yAxisMap[axisId]) === null || _this$state$yAxisMap$ === void 0 ? void 0 : _this$state$yAxisMap$.scale;
      }
    }, {
      key: "getItemByXY",
      value: function getItemByXY(chartXY) {
        var formattedGraphicalItems = this.state.formattedGraphicalItems;
        if (formattedGraphicalItems && formattedGraphicalItems.length) {
          for (var i = 0, len = formattedGraphicalItems.length; i < len; i++) {
            var graphicalItem = formattedGraphicalItems[i];
            var props3 = graphicalItem.props, item = graphicalItem.item;
            var itemDisplayName = getDisplayName(item.type);
            if (itemDisplayName === "Bar") {
              var activeBarItem = (props3.data || []).find(function(entry) {
                return isInRectangle(chartXY, entry);
              });
              if (activeBarItem) {
                return {
                  graphicalItem,
                  payload: activeBarItem
                };
              }
            } else if (itemDisplayName === "RadialBar") {
              var _activeBarItem = (props3.data || []).find(function(entry) {
                return inRangeOfSector(chartXY, entry);
              });
              if (_activeBarItem) {
                return {
                  graphicalItem,
                  payload: _activeBarItem
                };
              }
            }
          }
        }
        return null;
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        if (!validateWidthHeight(this)) {
          return null;
        }
        var _this$props6 = this.props, children = _this$props6.children, className = _this$props6.className, width = _this$props6.width, height = _this$props6.height, style = _this$props6.style, compact = _this$props6.compact, title = _this$props6.title, desc = _this$props6.desc, others = _objectWithoutProperties(_this$props6, _excluded2);
        var attrs = filterProps(others);
        var map3 = {
          CartesianGrid: {
            handler: this.renderGrid,
            once: true
          },
          ReferenceArea: {
            handler: this.renderReferenceElement
          },
          ReferenceLine: {
            handler: this.renderReferenceElement
          },
          ReferenceDot: {
            handler: this.renderReferenceElement
          },
          XAxis: {
            handler: this.renderXAxis
          },
          YAxis: {
            handler: this.renderYAxis
          },
          Brush: {
            handler: this.renderBrush,
            once: true
          },
          Bar: {
            handler: this.renderGraphicChild
          },
          Line: {
            handler: this.renderGraphicChild
          },
          Area: {
            handler: this.renderGraphicChild
          },
          Radar: {
            handler: this.renderGraphicChild
          },
          RadialBar: {
            handler: this.renderGraphicChild
          },
          Scatter: {
            handler: this.renderGraphicChild
          },
          Pie: {
            handler: this.renderGraphicChild
          },
          Funnel: {
            handler: this.renderGraphicChild
          },
          Tooltip: {
            handler: this.renderCursor,
            once: true
          },
          PolarGrid: {
            handler: this.renderPolarGrid,
            once: true
          },
          PolarAngleAxis: {
            handler: this.renderPolarAxis
          },
          PolarRadiusAxis: {
            handler: this.renderPolarAxis
          },
          Customized: {
            handler: this.renderCustomized
          }
        };
        if (compact) {
          return /* @__PURE__ */ React.createElement(Surface, _extends({}, attrs, {
            width,
            height,
            title,
            desc
          }), this.renderClipPath(), renderByOrder(children, map3));
        }
        if (this.props.accessibilityLayer) {
          var _2, _img;
          attrs.tabIndex = (_2 = 0) !== null && _2 !== void 0 ? _2 : this.props.tabIndex;
          attrs.role = (_img = "img") !== null && _img !== void 0 ? _img : this.props.role;
          attrs.onKeyDown = function(e3) {
            _this2.accessibilityManager.keyboardEvent(e3);
          };
          attrs.onFocus = function() {
            _this2.accessibilityManager.focus();
          };
        }
        var events2 = this.parseEventsOfWrapper();
        return /* @__PURE__ */ React.createElement("div", _extends({
          className: classNames("recharts-wrapper", className),
          style: _objectSpread({
            position: "relative",
            cursor: "default",
            width,
            height
          }, style)
        }, events2, {
          ref: function ref(node) {
            _this2.container = node;
          },
          role: "region"
        }), /* @__PURE__ */ React.createElement(Surface, _extends({}, attrs, {
          width,
          height,
          title,
          desc
        }), this.renderClipPath(), renderByOrder(children, map3)), this.renderLegend(), this.renderTooltip());
      }
    }]);
    return CategoricalChartWrapper;
  }(reactExports.Component), _defineProperty(_class, "displayName", chartName), _defineProperty(_class, "defaultProps", _objectSpread({
    layout: "horizontal",
    stackOffset: "none",
    barCategoryGap: "10%",
    barGap: 4,
    margin: {
      top: 5,
      right: 5,
      bottom: 5,
      left: 5
    },
    reverseStackOrder: false,
    syncMethod: "index"
  }, defaultProps2)), _defineProperty(_class, "getDerivedStateFromProps", function(nextProps, prevState) {
    var data2 = nextProps.data, children = nextProps.children, width = nextProps.width, height = nextProps.height, layout = nextProps.layout, stackOffset = nextProps.stackOffset, margin = nextProps.margin;
    if (_isNil(prevState.updateId)) {
      var defaultState = createDefaultState(nextProps);
      return _objectSpread(_objectSpread(_objectSpread({}, defaultState), {}, {
        updateId: 0
      }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({
        props: nextProps
      }, defaultState), {}, {
        updateId: 0
      }), prevState)), {}, {
        prevData: data2,
        prevWidth: width,
        prevHeight: height,
        prevLayout: layout,
        prevStackOffset: stackOffset,
        prevMargin: margin,
        prevChildren: children
      });
    }
    if (data2 !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || layout !== prevState.prevLayout || stackOffset !== prevState.prevStackOffset || !shallowEqual(margin, prevState.prevMargin)) {
      var _defaultState = createDefaultState(nextProps);
      var keepFromPrevState = {
        // (chartX, chartY) are (0,0) in default state, but we want to keep the last mouse position to avoid
        // any flickering
        chartX: prevState.chartX,
        chartY: prevState.chartY,
        // The tooltip should stay active when it was active in the previous render. If this is not
        // the case, the tooltip disappears and immediately re-appears, causing a flickering effect
        isTooltipActive: prevState.isTooltipActive
      };
      var updatesToState = _objectSpread(_objectSpread({}, getTooltipData(prevState, data2, layout)), {}, {
        updateId: prevState.updateId + 1
      });
      var newState = _objectSpread(_objectSpread(_objectSpread({}, _defaultState), keepFromPrevState), updatesToState);
      return _objectSpread(_objectSpread(_objectSpread({}, newState), updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread({
        props: nextProps
      }, newState), prevState)), {}, {
        prevData: data2,
        prevWidth: width,
        prevHeight: height,
        prevLayout: layout,
        prevStackOffset: stackOffset,
        prevMargin: margin,
        prevChildren: children
      });
    }
    if (!isChildrenEqual(children, prevState.prevChildren)) {
      var hasGlobalData = !_isNil(data2);
      var newUpdateId = hasGlobalData ? prevState.updateId : prevState.updateId + 1;
      return _objectSpread(_objectSpread({
        updateId: newUpdateId
      }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({
        props: nextProps
      }, prevState), {}, {
        updateId: newUpdateId
      }), prevState)), {}, {
        prevChildren: children
      });
    }
    return null;
  }), _defineProperty(_class, "renderActiveDot", function(option, props3) {
    var dot;
    if (/* @__PURE__ */ reactExports.isValidElement(option)) {
      dot = /* @__PURE__ */ reactExports.cloneElement(option, props3);
    } else if (_isFunction(option)) {
      dot = option(props3);
    } else {
      dot = /* @__PURE__ */ React.createElement(Dot, props3);
    }
    return /* @__PURE__ */ React.createElement(Layer, {
      className: "recharts-active-dot",
      key: props3.key
    }, dot);
  }), _class;
};
var BarChart = generateCategoricalChart({
  chartName: "BarChart",
  GraphicalChild: Bar,
  defaultTooltipEventType: "axis",
  validateTooltipEventTypes: ["axis", "item"],
  axisComponents: [{
    axisType: "xAxis",
    AxisComp: XAxis
  }, {
    axisType: "yAxis",
    AxisComp: YAxis
  }],
  formatAxisMap
});
var client = {};
var m = reactDomExports;
{
  client.createRoot = m.createRoot;
  client.hydrateRoot = m.hydrateRoot;
}
var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
function getUniqueId() {
  var key = "__global_unique_id__";
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
}
function objectIs(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on3(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function(h2) {
        return h2 !== handler;
      });
    },
    get: function get3() {
      return value;
    },
    set: function set4(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function(handler) {
        return handler(value, changedBits);
      });
    }
  };
}
function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}
function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;
  var contextProp = "__create-react-context-" + getUniqueId() + "__";
  var Provider2 = /* @__PURE__ */ function(_Component) {
    _inheritsLoose$1(Provider3, _Component);
    function Provider3() {
      var _this;
      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }
    var _proto = Provider3.prototype;
    _proto.getChildContext = function getChildContext() {
      var _ref;
      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };
    _proto.componentWillReceiveProps = function componentWillReceiveProps2(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;
        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          changedBits |= 0;
          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };
    _proto.render = function render() {
      return this.props.children;
    };
    return Provider3;
  }(reactExports.Component);
  Provider2.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = PropTypes$1.object.isRequired, _Provider$childContex);
  var Consumer = /* @__PURE__ */ function(_Component2) {
    _inheritsLoose$1(Consumer2, _Component2);
    function Consumer2() {
      var _this2;
      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };
      _this2.onUpdate = function(newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };
      return _this2;
    }
    var _proto2 = Consumer2.prototype;
    _proto2.componentWillReceiveProps = function componentWillReceiveProps2(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };
    _proto2.getValue = function getValue2() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };
    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };
    return Consumer2;
  }(reactExports.Component);
  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = PropTypes$1.object, _Consumer$contextType);
  return {
    Provider: Provider2,
    Consumer
  };
}
var index = React.createContext || createReactContext;
var createNamedContext2 = function createNamedContext3(name) {
  var context2 = index();
  context2.displayName = name;
  return context2;
};
var historyContext = /* @__PURE__ */ createNamedContext2("Router-History");
var context = /* @__PURE__ */ createNamedContext2("Router");
var Router = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Router2, _React$Component);
  Router2.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };
  function Router2(props3) {
    var _this;
    _this = _React$Component.call(this, props3) || this;
    _this.state = {
      location: props3.history.location
    };
    _this._isMounted = false;
    _this._pendingLocation = null;
    if (!props3.staticContext) {
      _this.unlisten = props3.history.listen(function(location) {
        _this._pendingLocation = location;
      });
    }
    return _this;
  }
  var _proto = Router2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;
    this._isMounted = true;
    if (this.unlisten) {
      this.unlisten();
    }
    if (!this.props.staticContext) {
      this.unlisten = this.props.history.listen(function(location) {
        if (_this2._isMounted) {
          _this2.setState({
            location
          });
        }
      });
    }
    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) {
      this.unlisten();
      this._isMounted = false;
      this._pendingLocation = null;
    }
  };
  _proto.render = function render() {
    return /* @__PURE__ */ React.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router2.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, /* @__PURE__ */ React.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };
  return Router2;
}(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose$1(MemoryRouter, _React$Component);
  function MemoryRouter() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }
  var _proto = MemoryRouter.prototype;
  _proto.render = function render() {
    return /* @__PURE__ */ React.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return MemoryRouter;
})(React.Component);
var Lifecycle = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Lifecycle2, _React$Component);
  function Lifecycle2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Lifecycle2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount)
      this.props.onMount.call(this, this);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate)
      this.props.onUpdate.call(this, this, prevProps);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount)
      this.props.onUnmount.call(this, this);
  };
  _proto.render = function render() {
    return null;
  };
  return Lifecycle2;
}(React.Component);
var cache = {};
var cacheLimit = 1e4;
var cacheCount = 0;
function compilePath(path3) {
  if (cache[path3])
    return cache[path3];
  var generator = pathToRegexp$1.compile(path3);
  if (cacheCount < cacheLimit) {
    cache[path3] = generator;
    cacheCount++;
  }
  return generator;
}
function generatePath(path3, params) {
  if (path3 === void 0) {
    path3 = "/";
  }
  if (params === void 0) {
    params = {};
  }
  return path3 === "/" ? path3 : compilePath(path3)(params, {
    pretty: true
  });
}
function Redirect(_ref) {
  var computedMatch = _ref.computedMatch, to2 = _ref.to, _ref$push = _ref.push, push2 = _ref$push === void 0 ? false : _ref$push;
  return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context2) {
    !context2 ? invariant(false) : void 0;
    var history = context2.history, staticContext = context2.staticContext;
    var method = push2 ? history.push : history.replace;
    var location = createLocation(computedMatch ? typeof to2 === "string" ? generatePath(to2, computedMatch.params) : _extends$q({}, to2, {
      pathname: generatePath(to2.pathname, computedMatch.params)
    }) : to2);
    if (staticContext) {
      method(location);
      return null;
    }
    return /* @__PURE__ */ React.createElement(Lifecycle, {
      onMount: function onMount() {
        method(location);
      },
      onUpdate: function onUpdate(self2, prevProps) {
        var prevLocation = createLocation(prevProps.to);
        if (!locationsAreEqual(prevLocation, _extends$q({}, location, {
          key: prevLocation.key
        }))) {
          method(location);
        }
      },
      to: to2
    });
  });
}
var cache$1 = {};
var cacheLimit$1 = 1e4;
var cacheCount$1 = 0;
function compilePath$1(path3, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path3])
    return pathCache[path3];
  var keys4 = [];
  var regexp = pathToRegexp$1(path3, keys4, options);
  var result = {
    regexp,
    keys: keys4
  };
  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path3] = result;
    cacheCount$1++;
  }
  return result;
}
function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }
  var _options = options, path3 = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths3 = [].concat(path3);
  return paths3.reduce(function(matched, path4) {
    if (!path4 && path4 !== "")
      return null;
    if (matched)
      return matched;
    var _compilePath = compilePath$1(path4, {
      end: exact,
      strict,
      sensitive
    }), regexp = _compilePath.regexp, keys4 = _compilePath.keys;
    var match5 = regexp.exec(pathname);
    if (!match5)
      return null;
    var url = match5[0], values3 = match5.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact)
      return null;
    return {
      path: path4,
      // the path used to match
      url: path4 === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact,
      // whether or not we matched exactly
      params: keys4.reduce(function(memo, key, index3) {
        memo[key.name] = values3[index3];
        return memo;
      }, {})
    };
  }, null);
}
function isEmptyChildren(children) {
  return React.Children.count(children) === 0;
}
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose$1(Route2, _React$Component);
  function Route2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Route2.prototype;
  _proto.render = function render() {
    var _this = this;
    return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context$12) {
      !context$12 ? invariant(false) : void 0;
      var location = _this.props.location || context$12.location;
      var match5 = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath(location.pathname, _this.props) : context$12.match;
      var props3 = _extends$q({}, context$12, {
        location,
        match: match5
      });
      var _this$props = _this.props, children = _this$props.children, component = _this$props.component, render2 = _this$props.render;
      if (Array.isArray(children) && isEmptyChildren(children)) {
        children = null;
      }
      return /* @__PURE__ */ React.createElement(context.Provider, {
        value: props3
      }, props3.match ? children ? typeof children === "function" ? children(props3) : children : component ? /* @__PURE__ */ React.createElement(component, props3) : render2 ? render2(props3) : null : typeof children === "function" ? children(props3) : null);
    });
  };
  return Route2;
})(React.Component);
function addLeadingSlash(path3) {
  return path3.charAt(0) === "/" ? path3 : "/" + path3;
}
function addBasename(basename, location) {
  if (!basename)
    return location;
  return _extends$q({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
}
function stripBasename(basename, location) {
  if (!basename)
    return location;
  var base = addLeadingSlash(basename);
  if (location.pathname.indexOf(base) !== 0)
    return location;
  return _extends$q({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}
function createURL(location) {
  return typeof location === "string" ? location : createPath(location);
}
function staticHandler(methodName) {
  return function() {
    invariant(false);
  };
}
function noop2() {
}
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose$1(StaticRouter, _React$Component);
  function StaticRouter() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handlePush = function(location) {
      return _this.navigateTo(location, "PUSH");
    };
    _this.handleReplace = function(location) {
      return _this.navigateTo(location, "REPLACE");
    };
    _this.handleListen = function() {
      return noop2;
    };
    _this.handleBlock = function() {
      return noop2;
    };
    return _this;
  }
  var _proto = StaticRouter.prototype;
  _proto.navigateTo = function navigateTo(location, action) {
    var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
    context2.action = action;
    context2.location = addBasename(basename, createLocation(location));
    context2.url = createURL(context2.location);
  };
  _proto.render = function render() {
    var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose$e(_this$props2, ["basename", "context", "location"]);
    var history = {
      createHref: function createHref(path3) {
        return addLeadingSlash(basename + createURL(path3));
      },
      action: "POP",
      location: stripBasename(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler(),
      goBack: staticHandler(),
      goForward: staticHandler(),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return /* @__PURE__ */ React.createElement(Router, _extends$q({}, rest, {
      history,
      staticContext: context2
    }));
  };
  return StaticRouter;
})(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose$1(Switch, _React$Component);
  function Switch() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Switch.prototype;
  _proto.render = function render() {
    var _this = this;
    return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context2) {
      !context2 ? invariant(false) : void 0;
      var location = _this.props.location || context2.location;
      var element, match5;
      React.Children.forEach(_this.props.children, function(child) {
        if (match5 == null && /* @__PURE__ */ React.isValidElement(child)) {
          element = child;
          var path3 = child.props.path || child.props.from;
          match5 = path3 ? matchPath(location.pathname, _extends$q({}, child.props, {
            path: path3
          })) : context2.match;
        }
      });
      return match5 ? /* @__PURE__ */ React.cloneElement(element, {
        location,
        computedMatch: match5
      }) : null;
    });
  };
  return Switch;
})(React.Component);
function withRouter(Component) {
  var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";
  var C2 = function C3(props3) {
    var wrappedComponentRef = props3.wrappedComponentRef, remainingProps = _objectWithoutPropertiesLoose$e(props3, ["wrappedComponentRef"]);
    return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context2) {
      !context2 ? invariant(false) : void 0;
      return /* @__PURE__ */ React.createElement(Component, _extends$q({}, remainingProps, context2, {
        ref: wrappedComponentRef
      }));
    });
  };
  C2.displayName = displayName;
  C2.WrappedComponent = Component;
  return hoistStatics(C2, Component);
}
React.useContext;
class IonRouteInner extends React.PureComponent {
  render() {
    return React.createElement(Route, Object.assign({ path: this.props.path, exact: this.props.exact, render: this.props.render }, this.props.computedMatch !== void 0 ? {
      computedMatch: this.props.computedMatch
    } : {}));
  }
}
class ReactRouterViewStack extends ViewStacks {
  constructor() {
    super();
    this.createViewItem = this.createViewItem.bind(this);
    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);
    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);
    this.getChildrenToRender = this.getChildrenToRender.bind(this);
    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);
  }
  createViewItem(outletId, reactElement, routeInfo, page) {
    const viewItem = {
      id: generateId("viewItem"),
      outletId,
      ionPageElement: page,
      reactElement,
      mount: true,
      ionRoute: false
    };
    const matchProps = {
      exact: reactElement.props.exact,
      path: reactElement.props.path || reactElement.props.from,
      component: reactElement.props.component
    };
    const match5 = matchPath$1(routeInfo.pathname, matchProps);
    if (reactElement.type === IonRoute) {
      viewItem.ionRoute = true;
      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;
    }
    viewItem.routeData = {
      match: match5,
      childProps: reactElement.props
    };
    return viewItem;
  }
  getChildrenToRender(outletId, ionRouterOutlet, routeInfo) {
    const viewItems = this.getViewItemsForOutlet(outletId);
    React.Children.forEach(ionRouterOutlet.props.children, (child) => {
      const viewItem = viewItems.find((v2) => {
        return matchComponent$1(child, v2.routeData.childProps.path || v2.routeData.childProps.from);
      });
      if (viewItem) {
        viewItem.reactElement = child;
      }
    });
    const children = viewItems.map((viewItem) => {
      let clonedChild;
      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {
        clonedChild = React.createElement(ViewLifeCycleManager, { key: `view-${viewItem.id}`, mount: viewItem.mount, removeView: () => this.remove(viewItem) }, React.cloneElement(viewItem.reactElement, {
          computedMatch: viewItem.routeData.match
        }));
      } else {
        const match5 = matchComponent$1(viewItem.reactElement, routeInfo.pathname);
        clonedChild = React.createElement(ViewLifeCycleManager, { key: `view-${viewItem.id}`, mount: viewItem.mount, removeView: () => this.remove(viewItem) }, React.cloneElement(viewItem.reactElement, {
          computedMatch: viewItem.routeData.match
        }));
        if (!match5 && viewItem.routeData.match) {
          viewItem.routeData.match = void 0;
          viewItem.mount = false;
        }
      }
      return clonedChild;
    });
    return children;
  }
  findViewItemByRouteInfo(routeInfo, outletId, updateMatch) {
    const { viewItem, match: match5 } = this.findViewItemByPath(routeInfo.pathname, outletId);
    const shouldUpdateMatch = updateMatch === void 0 || updateMatch === true;
    if (shouldUpdateMatch && viewItem && match5) {
      viewItem.routeData.match = match5;
    }
    return viewItem;
  }
  findLeavingViewItemByRouteInfo(routeInfo, outletId, mustBeIonRoute = true) {
    const { viewItem } = this.findViewItemByPath(routeInfo.lastPathname, outletId, false, mustBeIonRoute);
    return viewItem;
  }
  findViewItemByPathname(pathname, outletId) {
    const { viewItem } = this.findViewItemByPath(pathname, outletId);
    return viewItem;
  }
  findViewItemByPath(pathname, outletId, forceExact, mustBeIonRoute) {
    let viewItem;
    let match5;
    let viewStack;
    if (outletId) {
      viewStack = this.getViewItemsForOutlet(outletId);
      viewStack.some(matchView);
      if (!viewItem) {
        viewStack.some(matchDefaultRoute);
      }
    } else {
      const viewItems = this.getAllViewItems();
      viewItems.some(matchView);
      if (!viewItem) {
        viewItems.some(matchDefaultRoute);
      }
    }
    return { viewItem, match: match5 };
    function matchView(v2) {
      if (mustBeIonRoute && !v2.ionRoute) {
        return false;
      }
      const matchProps = {
        exact: forceExact ? true : v2.routeData.childProps.exact,
        path: v2.routeData.childProps.path || v2.routeData.childProps.from,
        component: v2.routeData.childProps.component
      };
      const myMatch = matchPath$1(pathname, matchProps);
      if (myMatch) {
        viewItem = v2;
        match5 = myMatch;
        return true;
      }
      return false;
    }
    function matchDefaultRoute(v2) {
      if (!v2.routeData.childProps.path && !v2.routeData.childProps.from) {
        match5 = {
          path: pathname,
          url: pathname,
          isExact: true,
          params: {}
        };
        viewItem = v2;
        return true;
      }
      return false;
    }
  }
}
function matchComponent$1(node, pathname, forceExact) {
  const matchProps = {
    exact: forceExact ? true : node.props.exact,
    path: node.props.path || node.props.from,
    component: node.props.component
  };
  const match5 = matchPath$1(pathname, matchProps);
  return match5;
}
function clonePageElement(leavingViewHtml) {
  let html;
  if (typeof leavingViewHtml === "string") {
    html = leavingViewHtml;
  } else {
    html = leavingViewHtml.outerHTML;
  }
  if (document) {
    const newEl = document.createElement("div");
    newEl.innerHTML = html;
    newEl.style.zIndex = "";
    const ionBackButton = newEl.getElementsByTagName("ion-back-button");
    if (ionBackButton[0]) {
      ionBackButton[0].remove();
    }
    return newEl.firstChild;
  }
  return void 0;
}
const isViewVisible = (el2) => !el2.classList.contains("ion-page-invisible") && !el2.classList.contains("ion-page-hidden");
class StackManager extends React.PureComponent {
  constructor(props3) {
    super(props3);
    this.stackContextValue = {
      registerIonPage: this.registerIonPage.bind(this),
      isInOutlet: () => true
    };
    this.pendingPageTransition = false;
    this.registerIonPage = this.registerIonPage.bind(this);
    this.transitionPage = this.transitionPage.bind(this);
    this.handlePageTransition = this.handlePageTransition.bind(this);
    this.id = generateId("routerOutlet");
    this.prevProps = void 0;
    this.skipTransition = false;
  }
  componentDidMount() {
    if (this.clearOutletTimeout) {
      clearTimeout(this.clearOutletTimeout);
    }
    if (this.routerOutletElement) {
      this.setupRouterOutlet(this.routerOutletElement);
      this.handlePageTransition(this.props.routeInfo);
    }
  }
  componentDidUpdate(prevProps) {
    const { pathname } = this.props.routeInfo;
    const { pathname: prevPathname } = prevProps.routeInfo;
    if (pathname !== prevPathname) {
      this.prevProps = prevProps;
      this.handlePageTransition(this.props.routeInfo);
    } else if (this.pendingPageTransition) {
      this.handlePageTransition(this.props.routeInfo);
      this.pendingPageTransition = false;
    }
  }
  componentWillUnmount() {
    this.clearOutletTimeout = this.context.clearOutlet(this.id);
  }
  async handlePageTransition(routeInfo) {
    var _a2, _b;
    if (!this.routerOutletElement || !this.routerOutletElement.commit) {
      this.pendingPageTransition = true;
    } else {
      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);
      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);
      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {
        leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);
      }
      if (leavingViewItem) {
        if (routeInfo.routeAction === "replace") {
          leavingViewItem.mount = false;
        } else if (!(routeInfo.routeAction === "push" && routeInfo.routeDirection === "forward")) {
          if (routeInfo.routeDirection !== "none" && enteringViewItem !== leavingViewItem) {
            leavingViewItem.mount = false;
          }
        } else if ((_a2 = routeInfo.routeOptions) === null || _a2 === void 0 ? void 0 : _a2.unmount) {
          leavingViewItem.mount = false;
        }
      }
      const enteringRoute = matchRoute((_b = this.ionRouterOutlet) === null || _b === void 0 ? void 0 : _b.props.children, routeInfo);
      if (enteringViewItem) {
        enteringViewItem.reactElement = enteringRoute;
      } else if (enteringRoute) {
        enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);
        this.context.addViewItem(enteringViewItem);
      }
      if (enteringViewItem && enteringViewItem.ionPageElement) {
        if (enteringViewItem === leavingViewItem) {
          if (enteringViewItem.routeData.match.url !== routeInfo.pathname) {
            return;
          }
        }
        if (!leavingViewItem && this.props.routeInfo.prevRouteLastPathname) {
          leavingViewItem = this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname, this.id);
        }
        if (isViewVisible(enteringViewItem.ionPageElement) && leavingViewItem !== void 0 && !isViewVisible(leavingViewItem.ionPageElement)) {
          return;
        }
        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);
      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {
        if (leavingViewItem.ionPageElement) {
          leavingViewItem.ionPageElement.classList.add("ion-page-hidden");
          leavingViewItem.ionPageElement.setAttribute("aria-hidden", "true");
        }
      }
      this.forceUpdate();
    }
  }
  registerIonPage(page, routeInfo) {
    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);
    if (foundView) {
      const oldPageElement = foundView.ionPageElement;
      foundView.ionPageElement = page;
      foundView.ionRoute = true;
      if (oldPageElement === page) {
        return;
      }
    }
    this.handlePageTransition(routeInfo);
  }
  async setupRouterOutlet(routerOutlet) {
    const canStart = () => {
      const config2 = getConfig();
      const swipeEnabled = config2 && config2.get("swipeBackEnabled", routerOutlet.mode === "ios");
      if (!swipeEnabled) {
        return false;
      }
      const { routeInfo } = this.props;
      const propsToUse = this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? this.prevProps.routeInfo : { pathname: routeInfo.pushedByRoute || "" };
      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);
      return !!enteringViewItem && /**
       * The root url '/' is treated as
       * the first view item (but is never mounted),
       * so we do not want to swipe back to the
       * root url.
       */
      enteringViewItem.mount && /**
       * When on the first page (whatever view
       * you land on after the root url) it
       * is possible for findViewItemByRouteInfo to
       * return the exact same view you are currently on.
       * Make sure that we are not swiping back to the same
       * instances of a view.
       */
      enteringViewItem.routeData.match.path !== routeInfo.pathname;
    };
    const onStart = async () => {
      const { routeInfo } = this.props;
      const propsToUse = this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? this.prevProps.routeInfo : { pathname: routeInfo.pushedByRoute || "" };
      const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);
      const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);
      if (enteringViewItem && leavingViewItem) {
        await this.transitionPage(routeInfo, enteringViewItem, leavingViewItem, "back", true);
      }
      return Promise.resolve();
    };
    const onEnd = (shouldContinue) => {
      if (shouldContinue) {
        this.skipTransition = true;
        this.context.goBack();
      } else {
        const { routeInfo } = this.props;
        const propsToUse = this.prevProps && this.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? this.prevProps.routeInfo : { pathname: routeInfo.pushedByRoute || "" };
        const enteringViewItem = this.context.findViewItemByRouteInfo(propsToUse, this.id, false);
        const leavingViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id, false);
        if (enteringViewItem !== leavingViewItem && (enteringViewItem === null || enteringViewItem === void 0 ? void 0 : enteringViewItem.ionPageElement) !== void 0) {
          const { ionPageElement } = enteringViewItem;
          ionPageElement.setAttribute("aria-hidden", "true");
          ionPageElement.classList.add("ion-page-hidden");
        }
      }
    };
    routerOutlet.swipeHandler = {
      canStart,
      onStart,
      onEnd
    };
  }
  async transitionPage(routeInfo, enteringViewItem, leavingViewItem, direction, progressAnimation = false) {
    const runCommit = async (enteringEl, leavingEl) => {
      const skipTransition = this.skipTransition;
      if (skipTransition) {
        this.skipTransition = false;
      } else {
        enteringEl.classList.add("ion-page");
        enteringEl.classList.add("ion-page-invisible");
      }
      await routerOutlet.commit(enteringEl, leavingEl, {
        duration: skipTransition || directionToUse === void 0 ? 0 : void 0,
        direction: directionToUse,
        showGoBack: !!routeInfo.pushedByRoute,
        progressAnimation,
        animationBuilder: routeInfo.routeAnimation
      });
    };
    const routerOutlet = this.routerOutletElement;
    const routeInfoFallbackDirection = routeInfo.routeDirection === "none" || routeInfo.routeDirection === "root" ? void 0 : routeInfo.routeDirection;
    const directionToUse = direction !== null && direction !== void 0 ? direction : routeInfoFallbackDirection;
    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {
      if (leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem) {
        const match5 = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);
        if (match5) {
          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);
          if (newLeavingElement) {
            this.routerOutletElement.appendChild(newLeavingElement);
            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);
            this.routerOutletElement.removeChild(newLeavingElement);
          }
        } else {
          await runCommit(enteringViewItem.ionPageElement, void 0);
        }
      } else {
        await runCommit(enteringViewItem.ionPageElement, leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement);
        if (leavingViewItem && leavingViewItem.ionPageElement && !progressAnimation) {
          leavingViewItem.ionPageElement.classList.add("ion-page-hidden");
          leavingViewItem.ionPageElement.setAttribute("aria-hidden", "true");
        }
      }
    }
  }
  render() {
    const { children } = this.props;
    const ionRouterOutlet = React.Children.only(children);
    this.ionRouterOutlet = ionRouterOutlet;
    const components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, () => {
      this.forceUpdate();
    });
    return React.createElement(StackContext.Provider, { value: this.stackContextValue }, React.cloneElement(ionRouterOutlet, {
      ref: (node) => {
        if (ionRouterOutlet.props.setRef) {
          ionRouterOutlet.props.setRef(node);
        }
        if (ionRouterOutlet.props.forwardedRef) {
          ionRouterOutlet.props.forwardedRef.current = node;
        }
        this.routerOutletElement = node;
        const { ref } = ionRouterOutlet;
        if (typeof ref === "function") {
          ref(node);
        }
      }
    }, components));
  }
  static get contextType() {
    return RouteManagerContext;
  }
}
function matchRoute(node, routeInfo) {
  let matchedNode;
  React.Children.forEach(node, (child) => {
    const matchProps = {
      exact: child.props.exact,
      path: child.props.path || child.props.from,
      component: child.props.component
    };
    const match5 = matchPath(routeInfo.pathname, matchProps);
    if (match5) {
      matchedNode = child;
    }
  });
  if (matchedNode) {
    return matchedNode;
  }
  React.Children.forEach(node, (child) => {
    if (!(child.props.path || child.props.from)) {
      matchedNode = child;
    }
  });
  return matchedNode;
}
function matchComponent(node, pathname, forceExact) {
  const matchProps = {
    exact: forceExact ? true : node.props.exact,
    path: node.props.path || node.props.from,
    component: node.props.component
  };
  const match5 = matchPath(pathname, matchProps);
  return match5;
}
class IonRouterInner extends React.PureComponent {
  constructor(props3) {
    super(props3);
    this.exitViewFromOtherOutletHandlers = [];
    this.locationHistory = new LocationHistory();
    this.viewStack = new ReactRouterViewStack();
    this.routeMangerContextState = {
      canGoBack: () => this.locationHistory.canGoBack(),
      clearOutlet: this.viewStack.clear,
      findViewItemByPathname: this.viewStack.findViewItemByPathname,
      getChildrenToRender: this.viewStack.getChildrenToRender,
      goBack: () => this.handleNavigateBack(),
      createViewItem: this.viewStack.createViewItem,
      findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,
      findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,
      addViewItem: this.viewStack.add,
      unMountViewItem: this.viewStack.remove
    };
    const routeInfo = {
      id: generateId("routeInfo"),
      pathname: this.props.location.pathname,
      search: this.props.location.search
    };
    this.locationHistory.add(routeInfo);
    this.handleChangeTab = this.handleChangeTab.bind(this);
    this.handleResetTab = this.handleResetTab.bind(this);
    this.handleNativeBack = this.handleNativeBack.bind(this);
    this.handleNavigate = this.handleNavigate.bind(this);
    this.handleNavigateBack = this.handleNavigateBack.bind(this);
    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));
    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);
    this.state = {
      routeInfo
    };
  }
  handleChangeTab(tab, path3, routeOptions) {
    if (!path3) {
      return;
    }
    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);
    const [pathname, search2] = path3.split("?");
    if (routeInfo) {
      this.incomingRouteParams = Object.assign(Object.assign({}, routeInfo), { routeAction: "push", routeDirection: "none" });
      if (routeInfo.pathname === pathname) {
        this.incomingRouteParams.routeOptions = routeOptions;
        this.props.history.push(routeInfo.pathname + (routeInfo.search || ""));
      } else {
        this.incomingRouteParams.pathname = pathname;
        this.incomingRouteParams.search = search2 ? "?" + search2 : void 0;
        this.incomingRouteParams.routeOptions = routeOptions;
        this.props.history.push(pathname + (search2 ? "?" + search2 : ""));
      }
    } else {
      this.handleNavigate(pathname, "push", "none", void 0, routeOptions, tab);
    }
  }
  handleHistoryChange(location, action) {
    var _a2, _b, _c;
    let leavingLocationInfo;
    if (this.incomingRouteParams) {
      if (this.incomingRouteParams.routeAction === "replace") {
        leavingLocationInfo = this.locationHistory.previous();
      } else {
        leavingLocationInfo = this.locationHistory.current();
      }
    } else {
      leavingLocationInfo = this.locationHistory.current();
    }
    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;
    if (leavingUrl !== location.pathname) {
      if (!this.incomingRouteParams) {
        if (action === "REPLACE") {
          this.incomingRouteParams = {
            routeAction: "replace",
            routeDirection: "none",
            tab: this.currentTab
          };
        }
        if (action === "POP") {
          const currentRoute = this.locationHistory.current();
          if (currentRoute && currentRoute.pushedByRoute) {
            const prevInfo = this.locationHistory.findLastLocation(currentRoute);
            this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routeAction: "pop", routeDirection: "back" });
          } else {
            this.incomingRouteParams = {
              routeAction: "pop",
              routeDirection: "none",
              tab: this.currentTab
            };
          }
        }
        if (!this.incomingRouteParams) {
          this.incomingRouteParams = {
            routeAction: "push",
            routeDirection: ((_a2 = location.state) === null || _a2 === void 0 ? void 0 : _a2.direction) || "forward",
            routeOptions: (_b = location.state) === null || _b === void 0 ? void 0 : _b.routerOptions,
            tab: this.currentTab
          };
        }
      }
      let routeInfo;
      if ((_c = this.incomingRouteParams) === null || _c === void 0 ? void 0 : _c.id) {
        routeInfo = Object.assign(Object.assign({}, this.incomingRouteParams), { lastPathname: leavingLocationInfo.pathname });
        this.locationHistory.add(routeInfo);
      } else {
        const isPushed = this.incomingRouteParams.routeAction === "push" && this.incomingRouteParams.routeDirection === "forward";
        routeInfo = Object.assign(Object.assign({ id: generateId("routeInfo") }, this.incomingRouteParams), { lastPathname: leavingLocationInfo.pathname, pathname: location.pathname, search: location.search, params: this.props.match.params, prevRouteLastPathname: leavingLocationInfo.lastPathname });
        if (isPushed) {
          routeInfo.tab = leavingLocationInfo.tab;
          routeInfo.pushedByRoute = leavingLocationInfo.pathname;
        } else if (routeInfo.routeAction === "pop") {
          const r2 = this.locationHistory.findLastLocation(routeInfo);
          routeInfo.pushedByRoute = r2 === null || r2 === void 0 ? void 0 : r2.pushedByRoute;
        } else if (routeInfo.routeAction === "push" && routeInfo.tab !== leavingLocationInfo.tab) {
          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);
          routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;
        } else if (routeInfo.routeAction === "replace") {
          const currentRouteInfo = this.locationHistory.current();
          const currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;
          const pushedByRoute = currentPushedBy !== void 0 && currentPushedBy !== routeInfo.pathname ? currentPushedBy : routeInfo.pushedByRoute;
          routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;
          routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;
          routeInfo.pushedByRoute = pushedByRoute;
          routeInfo.routeDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeDirection) || routeInfo.routeDirection;
          routeInfo.routeAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeAnimation) || routeInfo.routeAnimation;
        }
        this.locationHistory.add(routeInfo);
      }
      this.setState({
        routeInfo
      });
    }
    this.incomingRouteParams = void 0;
  }
  /**
   * history@4.x uses goBack(), history@5.x uses back()
   * TODO: If support for React Router <=5 is dropped
   * this logic is no longer needed. We can just
   * assume back() is available.
   */
  handleNativeBack() {
    const history = this.props.history;
    const goBack2 = history.goBack || history.back;
    goBack2();
  }
  handleNavigate(path3, routeAction, routeDirection, routeAnimation, routeOptions, tab) {
    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {
      routeAction,
      routeDirection,
      routeOptions,
      routeAnimation,
      tab
    });
    if (routeAction === "push") {
      this.props.history.push(path3);
    } else {
      this.props.history.replace(path3);
    }
  }
  handleNavigateBack(defaultHref = "/", routeAnimation) {
    const config2 = getConfig();
    defaultHref = defaultHref ? defaultHref : config2 && config2.get("backButtonDefaultHref");
    const routeInfo = this.locationHistory.current();
    if (routeInfo && routeInfo.pushedByRoute) {
      const prevInfo = this.locationHistory.findLastLocation(routeInfo);
      if (prevInfo) {
        this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routeAction: "pop", routeDirection: "back", routeAnimation: routeAnimation || routeInfo.routeAnimation });
        if (routeInfo.lastPathname === routeInfo.pushedByRoute || /**
         * We need to exclude tab switches/tab
         * context changes here because tabbed
         * navigation is not linear, but router.back()
         * will go back in a linear fashion.
         */
        prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === "" && prevInfo.tab === "") {
          const history = this.props.history;
          const goBack2 = history.goBack || history.back;
          goBack2();
        } else {
          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ""), "pop", "back");
        }
      } else {
        this.handleNavigate(defaultHref, "pop", "back");
      }
    } else {
      this.handleNavigate(defaultHref, "pop", "back");
    }
  }
  handleResetTab(tab, originalHref, originalRouteOptions) {
    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);
    if (routeInfo) {
      const newRouteInfo = Object.assign({}, routeInfo);
      newRouteInfo.pathname = originalHref;
      newRouteInfo.routeOptions = originalRouteOptions;
      this.incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), { routeAction: "pop", routeDirection: "back" });
      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ""));
    }
  }
  handleSetCurrentTab(tab) {
    this.currentTab = tab;
    const ri2 = Object.assign({}, this.locationHistory.current());
    if (ri2.tab !== tab) {
      ri2.tab = tab;
      this.locationHistory.update(ri2);
    }
  }
  render() {
    return React.createElement(
      RouteManagerContext.Provider,
      { value: this.routeMangerContextState },
      React.createElement(NavManager, { ionRoute: IonRouteInner, ionRedirect: {}, stackManager: StackManager, routeInfo: this.state.routeInfo, onNativeBack: this.handleNativeBack, onNavigateBack: this.handleNavigateBack, onNavigate: this.handleNavigate, onSetCurrentTab: this.handleSetCurrentTab, onChangeTab: this.handleChangeTab, onResetTab: this.handleResetTab, locationHistory: this.locationHistory }, this.props.children)
    );
  }
}
const IonRouter = withRouter(IonRouterInner);
IonRouter.displayName = "IonRouter";
class IonReactRouter extends React.Component {
  constructor(props3) {
    super(props3);
    const { history } = props3, rest = __rest$1(props3, ["history"]);
    this.history = history || createBrowserHistory(rest);
    this.history.listen(this.handleHistoryChange.bind(this));
    this.registerHistoryListener = this.registerHistoryListener.bind(this);
  }
  /**
   * history@4.x passes separate location and action
   * params. history@5.x passes location and action
   * together as a single object.
   * TODO: If support for React Router <=5 is dropped
   * this logic is no longer needed. We can just assume
   * a single object with both location and action.
   */
  handleHistoryChange(location, action) {
    const locationValue = location.location || location;
    const actionValue = location.action || action;
    if (this.historyListenHandler) {
      this.historyListenHandler(locationValue, actionValue);
    }
  }
  registerHistoryListener(cb2) {
    this.historyListenHandler = cb2;
  }
  render() {
    const _a2 = this.props, { children } = _a2, props3 = __rest$1(_a2, ["children"]);
    return React.createElement(
      Router,
      Object.assign({ history: this.history }, props3),
      React.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children)
    );
  }
}
class IonReactMemoryRouter extends React.Component {
  constructor(props3) {
    super(props3);
    this.history = props3.history;
    this.history.listen(this.handleHistoryChange.bind(this));
    this.registerHistoryListener = this.registerHistoryListener.bind(this);
  }
  /**
   * history@4.x passes separate location and action
   * params. history@5.x passes location and action
   * together as a single object.
   * TODO: If support for React Router <=5 is dropped
   * this logic is no longer needed. We can just assume
   * a single object with both location and action.
   */
  handleHistoryChange(location, action) {
    const locationValue = location.location || location;
    const actionValue = location.action || action;
    if (this.historyListenHandler) {
      this.historyListenHandler(locationValue, actionValue);
    }
  }
  registerHistoryListener(cb2) {
    this.historyListenHandler = cb2;
  }
  render() {
    const _a2 = this.props, { children } = _a2, props3 = __rest$1(_a2, ["children"]);
    return React.createElement(
      Router$1,
      Object.assign({}, props3),
      React.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children)
    );
  }
}
class IonReactHashRouter extends React.Component {
  constructor(props3) {
    super(props3);
    const { history } = props3, rest = __rest$1(props3, ["history"]);
    this.history = history || createHashHistory(rest);
    this.history.listen(this.handleHistoryChange.bind(this));
    this.registerHistoryListener = this.registerHistoryListener.bind(this);
  }
  /**
   * history@4.x passes separate location and action
   * params. history@5.x passes location and action
   * together as a single object.
   * TODO: If support for React Router <=5 is dropped
   * this logic is no longer needed. We can just assume
   * a single object with both location and action.
   */
  handleHistoryChange(location, action) {
    const locationValue = location.location || location;
    const actionValue = location.action || action;
    if (this.historyListenHandler) {
      this.historyListenHandler(locationValue, actionValue);
    }
  }
  registerHistoryListener(cb2) {
    this.historyListenHandler = cb2;
  }
  render() {
    const _a2 = this.props, { children } = _a2, props3 = __rest$1(_a2, ["children"]);
    return React.createElement(
      Router,
      Object.assign({ history: this.history }, props3),
      React.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children)
    );
  }
}
var dist = {};
(function(exports) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof2(obj);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  var _react2 = _interopRequireWildcard2(reactExports);
  var _propTypes = _interopRequireDefault2(propTypesExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
      return { "default": obj };
    }
    var cache2 = _getRequireWildcardCache(nodeInterop);
    if (cache2 && cache2.has(obj)) {
      return cache2.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache2) {
      cache2.set(obj, newObj);
    }
    return newObj;
  }
  function ownKeys2(object2, enumerableOnly) {
    var keys4 = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys4.push.apply(keys4, symbols);
    }
    return keys4;
  }
  function _objectSpread3(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toConsumableArray2(arr) {
    return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
  }
  function _nonIterableSpread2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArray2(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _arrayWithoutHoles2(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray2(arr);
  }
  function _slicedToArray2(arr, i) {
    return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
  }
  function _nonIterableRest2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray2(o3, minLen) {
    if (!o3)
      return;
    if (typeof o3 === "string")
      return _arrayLikeToArray2(o3, minLen);
    var n2 = Object.prototype.toString.call(o3).slice(8, -1);
    if (n2 === "Object" && o3.constructor)
      n2 = o3.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o3);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray2(o3, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _iterableToArrayLimit2(arr, i) {
    var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i2 == null)
      return;
    var _arr = [];
    var _n2 = true;
    var _d = false;
    var _s2, _e2;
    try {
      for (_i2 = _i2.call(arr); !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
        _arr.push(_s2.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n2 && _i2["return"] != null)
          _i2["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  function _arrayWithHoles2(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function FPSStats2(_ref) {
    var _ref$top = _ref.top, top = _ref$top === void 0 ? 0 : _ref$top, _ref$right = _ref.right, right = _ref$right === void 0 ? "auto" : _ref$right, _ref$bottom = _ref.bottom, bottom = _ref$bottom === void 0 ? "auto" : _ref$bottom, _ref$left = _ref.left, left = _ref$left === void 0 ? 0 : _ref$left, _ref$graphHeight = _ref.graphHeight, graphHeight = _ref$graphHeight === void 0 ? 29 : _ref$graphHeight, _ref$graphWidth = _ref.graphWidth, graphWidth = _ref$graphWidth === void 0 ? 70 : _ref$graphWidth;
    var _useReducer = (0, _react2.useReducer)(function(state2) {
      var currentTime = Date.now();
      if (currentTime > state2.prevTime + 1e3) {
        var nextFPS = Math.round(state2.frames * 1e3 / (currentTime - state2.prevTime));
        return {
          max: Math.max(state2.max, nextFPS),
          len: Math.min(state2.len + 1, graphWidth),
          fps: [].concat(_toConsumableArray2(state2.fps), [nextFPS]).slice(-graphWidth),
          frames: 1,
          prevTime: currentTime
        };
      } else {
        return _objectSpread3(_objectSpread3({}, state2), {}, {
          frames: state2.frames + 1
        });
      }
    }, {
      len: 0,
      max: 0,
      frames: 0,
      prevTime: Date.now(),
      fps: []
    }), _useReducer2 = _slicedToArray2(_useReducer, 2), state = _useReducer2[0], dispatch = _useReducer2[1];
    var requestRef = (0, _react2.useRef)();
    var tick = function tick2() {
      dispatch();
      requestRef.current = requestAnimationFrame(tick2);
    };
    (0, _react2.useEffect)(function() {
      requestRef.current = requestAnimationFrame(tick);
      return function() {
        return cancelAnimationFrame(requestRef.current);
      };
    }, []);
    var fps = state.fps, max3 = state.max, len = state.len;
    return /* @__PURE__ */ _react2["default"].createElement("div", {
      style: {
        zIndex: 999999,
        position: "fixed",
        height: 46,
        width: graphWidth + 6,
        padding: 3,
        backgroundColor: "#000",
        color: "#00ffff",
        fontSize: "9px",
        lineHeight: "10px",
        fontFamily: "Helvetica, Arial, sans-serif",
        fontWeight: "bold",
        boxSizing: "border-box",
        pointerEvents: "none",
        top,
        right,
        bottom,
        left
      }
    }, /* @__PURE__ */ _react2["default"].createElement("span", null, fps[len - 1], " FPS"), /* @__PURE__ */ _react2["default"].createElement("div", {
      style: {
        position: "absolute",
        left: 3,
        right: 3,
        bottom: 3,
        height: graphHeight,
        background: "#282844",
        boxSizing: "border-box"
      }
    }, fps.map(function(frame, i) {
      return /* @__PURE__ */ _react2["default"].createElement("div", {
        key: "fps-".concat(i),
        style: {
          position: "absolute",
          bottom: 0,
          right: "".concat(len - 1 - i, "px"),
          height: "".concat(graphHeight * frame / max3, "px"),
          width: 1,
          background: "#00ffff",
          boxSizing: "border-box"
        }
      });
    })));
  }
  FPSStats2.propTypes = {
    top: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].number]),
    right: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].number]),
    bottom: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].number]),
    left: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].number]),
    graphHeight: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].number]),
    graphWidth: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].number])
  };
  var _default2 = FPSStats2;
  exports["default"] = _default2;
})(dist);
const FPSStats = /* @__PURE__ */ getDefaultExportFromCjs(dist);
export {
  lensPath$1 as $,
  tail$1 as A,
  createBrowserHistory as B,
  CALL_HISTORY_METHOD as C,
  createMemoryHistory as D,
  EventEmitter$2 as E,
  F,
  useSelector as G,
  matchPath$1 as H,
  chroma as I,
  over$1 as J,
  init$1 as K,
  L,
  combineReducers as M,
  uniq$1 as N,
  composeWithDevTools as O,
  axios$1 as P,
  fork as Q,
  RR as R,
  takeLatest as S,
  call2 as T,
  actionChannel as U,
  take2 as V,
  clone$5 as W,
  eventChannel as X,
  ReconnectingEventSource as Y,
  END as Z,
  LogRocket as _,
  pipe as a,
  trash as a$,
  takeLast$1 as a0,
  take$3 as a1,
  sagaMiddlewareFactory as a2,
  createStore as a3,
  applyMiddleware as a4,
  compose$2 as a5,
  jsxRuntimeExports as a6,
  useDispatch as a7,
  useHistory as a8,
  useStore as a9,
  IonAccordionGroup as aA,
  logOutOutline as aB,
  IonSelect as aC,
  IonSelectOption as aD,
  last$2 as aE,
  IonHeader as aF,
  IonToolbar as aG,
  IonButtons as aH,
  IonTitle as aI,
  IonText as aJ,
  IonFooter as aK,
  IonBackButton as aL,
  connect as aM,
  checkmark as aN,
  ellipseOutline as aO,
  IonBadge as aP,
  IonAvatar as aQ,
  hooks as aR,
  useIonRouter as aS,
  IonModal as aT,
  closeCircleOutline as aU,
  IonSpinner as aV,
  send as aW,
  IonTextarea as aX,
  IonItemSliding as aY,
  IonItemOptions as aZ,
  IonItemOption as a_,
  reactExports as aa,
  useIonAlert as ab,
  useIonLoading as ac,
  IonPage as ad,
  IonContent as ae,
  IonCard as af,
  IonCardHeader as ag,
  IonCardSubtitle as ah,
  IonCardTitle as ai,
  IonCardContent as aj,
  IonItem as ak,
  IonLabel as al,
  IonInput as am,
  IonCheckbox as an,
  IonButton as ao,
  context$1 as ap,
  useLocation as aq,
  useParams as ar,
  prop$1 as as,
  IonIcon as at,
  ellipse as au,
  IonList as av,
  arrowUndo as aw,
  arrowUp as ax,
  IonAccordion as ay,
  IonListHeader as az,
  buffer as b,
  Vi as b$,
  pencil as b0,
  IonNote as b1,
  useIonViewWillEnter as b2,
  Swiper2 as b3,
  SwiperSlide as b4,
  locateOutline as b5,
  appsOutline as b6,
  reloadCircle as b7,
  arrowForward as b8,
  moon as b9,
  IonFabButton as bA,
  close as bB,
  IonFabList as bC,
  timerOutline as bD,
  brush as bE,
  useRouteMatch as bF,
  menu as bG,
  business as bH,
  contract as bI,
  search as bJ,
  ReactDOM as bK,
  getDefaultExportFromCjs as bL,
  IonSearchbar as bM,
  flatten$1 as bN,
  sortBy$2 as bO,
  cancelled as bP,
  useIonViewDidEnter as bQ,
  useIonViewDidLeave as bR,
  IonPopover as bS,
  useIonToast as bT,
  link as bU,
  informationCircleOutline as bV,
  IonGrid as bW,
  IonRow as bX,
  IonCol as bY,
  flash as bZ,
  flashOff as b_,
  balloon as ba,
  flashlight as bb,
  radio as bc,
  skull as bd,
  IonToggle as be,
  pin as bf,
  wifi as bg,
  wine as bh,
  warning as bi,
  walk$2 as bj,
  IonMenu as bk,
  IonMenuToggle as bl,
  businessOutline as bm,
  chatbubblesOutline as bn,
  listCircle as bo,
  readerOutline as bp,
  pulseOutline as bq,
  calendarOutline as br,
  IonItemDivider as bs,
  settings as bt,
  help as bu,
  IonThumbnail as bv,
  IonRoute as bw,
  React as bx,
  CreateAnimation as by,
  IonFab as bz,
  curry$2 as c,
  head$1 as c0,
  videocamOff as c1,
  IonRouterOutlet as c2,
  IonItemGroup as c3,
  closeCircle as c4,
  home as c5,
  star$1 as c6,
  navigate as c7,
  informationCircle as c8,
  checkmarkCircle as c9,
  setupIonicReact as cA,
  R$2 as cB,
  client as cC,
  isRTL$1 as cD,
  createGesture as cE,
  clamp$1 as cF,
  now$5 as cG,
  pointerCoord as cH,
  readTask as cI,
  findClosestIonContent as cJ,
  componentOnReady as cK,
  writeTask$1 as cL,
  scrollToTop as cM,
  Keyboard as cN,
  addEventListener$1 as cO,
  removeEventListener as cP,
  KeyboardResize as cQ,
  raf as cR,
  getScrollElement as cS,
  scrollByPoint as cT,
  shuffle as ca,
  IonDatetime as cb,
  IonRange as cc,
  personCircle as cd,
  IonImg as ce,
  Ua as cf,
  ga as cg,
  ResponsiveContainer as ch,
  BarChart as ci,
  CartesianGrid as cj,
  XAxis as ck,
  YAxis as cl,
  Legend as cm,
  Bar as cn,
  LabelList as co,
  chevronBackOutline as cp,
  IonLoading as cq,
  delay as cr,
  cancel as cs,
  IonReactRouter as ct,
  Redirect as cu,
  IonToast as cv,
  IonAlert as cw,
  IonApp as cx,
  FPSStats as cy,
  Provider as cz,
  lensIndex$1 as d,
  equals$1 as e,
  append$2 as f,
  concat$1 as g,
  prepend$1 as h,
  identity$e as i,
  moize as j,
  filter$1 as k,
  luxon as l,
  mergeDeepRight$1 as m,
  where$1 as n,
  select as o,
  process$2 as p,
  put as q,
  reject$1 as r,
  set$3 as s,
  takeEvery as t,
  uuid as u,
  goBack as v,
  whereEq$1 as w,
  replace2 as x,
  push as y,
  LOCATION_CHANGE as z
};
//# sourceMappingURL=vendor-6932f6a6.js.map
